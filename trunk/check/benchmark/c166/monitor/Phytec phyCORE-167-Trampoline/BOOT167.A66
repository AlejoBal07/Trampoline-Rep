$MOD167					; Define 80C167 mode
$INCLUDE (REG167.INC)
;
;-----------------------------------------------------------------------------
;  This file is part of the C166 Compiler package
;  Copyright KEIL ELEKTRONIK GmbH 1993 - 1999
;-----------------------------------------------------------------------------
;  BOOT167.A66:  This code is executed after processor reset when the
;                bootstrap mode is enabled and provides the initialization
;                of the 80C167 processor and downloading of MONITOR167.
;
;-----------------------------------------------------------------------------
;
; Definitions for SYSCON and BUSCON0 Register:
; --------------------------------------------
$INCLUDE (CONFIG.INC)

%*DEFINE (ADDR (Val, Start, Range)) (
%SET (adr, %SUBSTR(%Start,1,(%LEN(%Start)- 3))%SUBSTR(%Start,%LEN(%Start),1))
%IF (%EQS (%Range,4K))     THEN (%SET (adr, (%adr AND 0FFF0H) + 0)) FI
%IF (%EQS (%Range,8K))     THEN (%SET (adr, (%adr AND 0FFE0H) + 1)) FI
%IF (%EQS (%Range,16K))    THEN (%SET (adr, (%adr AND 0FFC0H) + 2)) FI
%IF (%EQS (%Range,32K))    THEN (%SET (adr, (%adr AND 0FF80H) + 3)) FI
%IF (%EQS (%Range,64K))    THEN (%SET (adr, (%adr AND 0FF00H) + 4)) FI
%IF (%EQS (%Range,128K))   THEN (%SET (adr, (%adr AND 0FE00H) + 5)) FI
%IF (%EQS (%Range,256K))   THEN (%SET (adr, (%adr AND 0FC00H) + 6)) FI
%IF (%EQS (%Range,512K))   THEN (%SET (adr, (%adr AND 0F800H) + 7)) FI
%IF (%EQS (%Range,1024K))  THEN (%SET (adr, (%adr AND 0F000H) + 8)) FI
%IF (%EQS (%Range,1M))     THEN (%SET (adr, (%adr AND 0F000H) + 8)) FI
%IF (%EQS (%Range,2048K))  THEN (%SET (adr, (%adr AND 0E000H) + 9)) FI
%IF (%EQS (%Range,2M))     THEN (%SET (adr, (%adr AND 0E000H) + 9)) FI
%IF (%EQS (%Range,4096K))  THEN (%SET (adr, (%adr AND 0C000H) +10)) FI
%IF (%EQS (%Range,4M))     THEN (%SET (adr, (%adr AND 0C000H) +10)) FI
%IF (%EQS (%Range,8192K))  THEN (%SET (adr, (%adr AND 08000H) +11)) FI
%IF (%EQS (%Range,8M))     THEN (%SET (adr, (%adr AND 08000H) +11)) FI
%Val	EQU 	%adr
)

_STKSZ		SET	0
_STKSZ1		SET	0		; size is 512 Words
$IF (STK_SIZE = 0)
_STKSZ1		SET	1		; size is 256 Words
$ENDIF
$IF (STK_SIZE = 1)
_STKSZ		SET	1
_STKSZ1		SET	2		; size is 128 Words
$ENDIF
$IF (STK_SIZE = 2)
_STKSZ		SET	2
_STKSZ1		SET	3		; size is  64 Words
$ENDIF
$IF (STK_SIZE = 3)
_STKSZ		SET	3
_STKSZ1		SET	4		; size is  32 Words
$ENDIF
$IF (STK_SIZE = 4)
_STKSZ		SET	4
$ENDIF
$IF (STK_SIZE = 5)
_STKSZ		SET	5
$ENDIF
$IF (STK_SIZE = 6)
_STKSZ		SET	6
$ENDIF
$IF (STK_SIZE = 7)
_STKSZ		SET	7
$ENDIF



WR_MEM		EQU	1	; write memory
GO_COMMAND	EQU	6	; go command
GET_MON_SUM	EQU	16	; get monitor checksum

E_NOERROR	EQU	0	; no error                     ACK
E_UNKNOWN	EQU	1	; unknown command              len = 1
E_CHECKSUM	EQU	2	; checksum error               len = 1
E_NORAM		EQU	3	; no RAM at address            len = 4

STX		EQU	02H	; Start of TeXt
ENQ		EQU	05H	; ENQuiry
ACK		EQU	06H	; ACKnowledge
DC1		EQU	11H	; Ctrl+Q
NACK		EQU	15H	; Negative ACKnowledge

; Historic Parameter for old CPU's
; BOOT960 = 0: C167 CPU with 32 Byte Bootstrap loader is used
; BOOT960 = 1: C167 CPU with 960 Byte Bootstrap loader is used
$SET (BOOT960 = 0)


BOOTSTRAP  SECTION CODE AT 0FA40H

BOOT		PROC	NEAR
$IF NOT (BOOT960)
START:		MOV	R0,#0FA60H		; Start of bootstrap code
LAB1:		JNB	S0RIC.7,LAB1		; when CPU expects 32 Bytes
		MOVB	[R0],S0RBUF
		BCLR	S0RIC.7
		CMPI1	R0,#ENDBOOT-1
		JMPR	CC_NZ,LAB1
$ENDIF
		DISWDT  			; Start of bootstrap code
		MOV	STKOV,#0FA00H
		MOV	STKUN,#0FC00H
		MOV     SP,#0FC00H		; at address 0FA60H
		MOV	CP,#0FC00H
		MOV	TFR,ZEROS
		MOV	PSW,ZEROS

$IF (INIT_XPERCON = 1)
; Improtant XPERCON must be set before SYSCON.XPEN is enabled
XPERCON  DEFR 0F024H
_V_XPERCON       SET     _V_CAN1 OR (_V_CAN2 << 1) OR (_V_XRAM2 << 10)
_V_XPERCON	SET	_V_XPERCON OR (_V_XRAM6 << 11) OR (_V_XFLASH << 14)
		EXTR	#1
		MOV	XPERCON,#_V_XPERCON
$ENDIF

BCON0L		SET     (_MTTC0 << 5) OR (_RWDC0 << 4)
BCON0L		SET	BCON0L OR ((NOT _MCTC0) AND 0FH)
BCON0L		SET	BCON0L AND (NOT (_RDYEN0 << 3))
BCON0L		SET	BCON0L OR (_RDY_AS0 << 3)
BCON0H		SET	(_ALECTL0 << 1) OR (_RDYEN0 << 4)
BCON0H		SET	BCON0H OR (_CSREN0 << 6) OR (_CSWEN0 << 7)
$IF (BTYP_ENABLE == 1)
BCON0L		SET	BCON0L OR (_BTYP0 << 6)
BCON0H		SET	BCON0H OR (_BUSACT0 << 2)
$ENDIF

$IF (BTYP_ENABLE == 0)
		BFLDL	BUSCON0,#03FH,#BCON0L
		BFLDH	BUSCON0,#0D2H,#BCON0H
$ELSE
		BFLDL	BUSCON0,#0FFH,#BCON0L
		BFLDH	BUSCON0,#0D6H,#BCON0H
$ENDIF
SYS_BITS	SET	0FF6FH

SYS_H		SET	(_STKSZ << 5) OR (_ROMS1 << 4) OR (_SGTDIS << 3)
SYS_H		SET	SYS_H OR (_ROMEN << 2) OR (_BYTDIS << 1) OR _CLKEN
SYS_L		SET	_XPERSHARE OR (_VISIBLE << 1) OR (_XPEN << 2)
SYS_L           SET     SYS_L OR (_BDRSTEN << 3)
SYS_L           SET     SYS_L OR (_PWDCFG << 5) OR (_CSCFG << 6)
$IF (WRCFG_ENABLE == 1)
SYS_L		SET	SYS_L OR (_WRCFG << 7)
SYS_BITS	SET	SYS_BITS OR 00080H
$ENDIF
$IF (OWDDIS_ENABLE == 1)
SYS_L		SET	SYS_L OR (_OWDDIS << 4)
SYS_BITS	SET	SYS_BITS OR 00010H
$ENDIF
; Setup SYSCON Register

 		BFLDH	SYSCON,#HIGH SYS_BITS,#SYS_H
		BFLDL	SYSCON,#LOW  SYS_BITS,#SYS_L
;
$IF (ADVANCED_SYSCON = 1)
SYS_2           SET     (_PDCON << 4) OR (_RTS << 6) OR (_SCS << 7)
SYS_2           SET     SYS_2 OR (_CLKCON << 8) OR (_CLKREL << 10)

SYS_3           SET     _ADCDIS OR (_ASC0DIS << 1) OR (_SSCDIS << 2)
SYS_3           SET     SYS_3 OR (_GPTDIS << 3)
SYS_3           SET     SYS_3 OR (_FMDIS << 5) OR (_CC1DIS << 6) OR (_CC2DIS << 7)
SYS_3           SET     SYS_3 OR (_CC6DIS << 8) OR (_PWMDIS << 9)
SYS_3           SET     SYS_3 OR (_ASC1DIS << 10) OR (_I2CDIS << 11)
SYS_3           SET     SYS_3 OR (_CAN1DIS << 13) OR (_CAN2DIS << 14)
SYS_3           SET     SYS_3 OR (_PCDDIS << 15)

		EXTR	#2
		MOV	SYSCON2,#SYS_2
		MOV	SYSCON3,#SYS_3
$ENDIF
;

$IF (BUSCON1 = 1)
BCON1		SET     (_MTTC1 << 5) OR (_RWDC1 << 4)
BCON1		SET	BCON1 OR ((NOT _MCTC1) AND 0FH)
BCON1		SET	BCON1 AND (NOT (_RDYEN1 << 3))
BCON1 		SET	BCON1 OR (_RDY_AS1 << 3)  OR (_BTYP1 << 6)
BCON1 		SET	BCON1 OR (_ALECTL1 << 9) OR (_BUSACT1 << 10)
BCON1		SET	BCON1 OR (_RDYEN1 << 12) OR (_CSREN1 << 14)
BCON1           SET     BCON1 OR (_CSWEN1 << 15)

%ADDR (ADDR1,%ADDRESS1,%RANGE1)
		MOV	ADDRSEL1,#ADDR1 
		MOV	BUSCON1,#BCON1
$ENDIF

$IF (BUSCON2 = 1)
BCON2		SET     (_MTTC2 << 5) OR (_RWDC2 << 4)
BCON2		SET	BCON2 OR ((NOT _MCTC2) AND 0FH)
BCON2		SET	BCON2 AND (NOT (_RDYEN2 << 3))
BCON2 		SET	BCON2 OR (_RDY_AS2 << 3)  OR (_BTYP2 << 6)
BCON2 		SET	BCON2 OR (_ALECTL2 << 9) OR (_BUSACT2 << 10)
BCON2		SET	BCON2 OR (_RDYEN2 << 12) OR (_CSREN2 << 14)
BCON2           SET     BCON2 OR (_CSWEN2 << 15)

%ADDR (ADDR2,%ADDRESS2,%RANGE2)
		MOV	ADDRSEL2,#ADDR2 
		MOV	BUSCON2,#BCON2
$ENDIF

$IF (BUSCON3 = 1)
BCON3		SET     (_MTTC3 << 5) OR (_RWDC3 << 4)
BCON3		SET	BCON3 OR ((NOT _MCTC3) AND 0FH)
BCON3		SET	BCON3 AND (NOT (_RDYEN3 << 3))
BCON3 		SET	BCON3 OR (_RDY_AS3 << 3)  OR (_BTYP3 << 6)
BCON3 		SET	BCON3 OR (_ALECTL3 << 9) OR (_BUSACT3 << 10)
BCON3		SET	BCON3 OR (_RDYEN3 << 12) OR (_CSREN3 << 14)
BCON3           SET     BCON3 OR (_CSWEN3 << 15)

%ADDR (ADDR3,%ADDRESS3,%RANGE3)
		MOV	ADDRSEL3,#ADDR3 
		MOV	BUSCON3,#BCON3
$ENDIF

$IF (BUSCON4 = 1)
BCON4		SET     (_MTTC4 << 5) OR (_RWDC4 << 4)
BCON4		SET	BCON4 OR ((NOT _MCTC4) AND 0FH)
BCON4		SET	BCON4 AND (NOT (_RDYEN4 << 3))
BCON4 		SET	BCON4 OR (_RDY_AS4 << 3)  OR (_BTYP4 << 6)
BCON4 		SET	BCON4 OR (_ALECTL4 << 9) OR (_BUSACT4 << 10)
BCON4		SET	BCON4 OR (_RDYEN4 << 12) OR (_CSREN4 << 14)
BCON4           SET     BCON4 OR (_CSWEN4 << 15)

%ADDR (ADDR4,%ADDRESS4,%RANGE4)
		MOV	ADDRSEL4,#ADDR4 
		MOV	BUSCON4,#BCON4
$ENDIF
$IF (STK_SIZE = 7)
		MOV	STKUN,#0FFFEH		; AVOID STKUN TRAP
		MOV	STKOV,#0H		; AVOID STKOV TRAP
$ENDIF

		MOV	DPP0,#0000H
		MOV	DPP1,#0001H
		MOV	DPP2,#0002H
		MOV	DPP3,#0003H

		EINIT   

CMD_LOOP:	CALL	GETCHAR			; GETCHAR
		CMPB	RL4,#WR_MEM		; MEMORY WRITE
		JMPR	CC_EQ,WRITE_MEM
		CMPB	RL4,#GO_COMMAND		; START MONITOR
		JMPR	CC_EQ,START_MON
		CMPB	RL4,#GET_MON_SUM	; MONITOR LOADED?
		JMPR	CC_EQ,MON_CHECKSUM

		MOV	R4,#00AAH		; SEND A SYNC 'AA'
		CALL	PUTCHAR			; PUTCHAR
		JMPR	CC_UC,CMD_LOOP


START_MON:	MOV	R14,#GO_COMMAND	; START MONITOR
		CALL	GETCHAR
		MOVBZ	R5,RL4
		CALL	GETCHAR
		MOV	RH6,RL4
		CALL	GETCHAR
		MOV	RL6,RL4
		CALL	GETCHAR
		CALL	GETCHAR
		CALL	GETCHAR
		CALL	GETCHAR		; READ FOR CHECKSUM
		MOV	R15,#E_CHECKSUM
		AND	R14,#00FFH
		JMP	CC_NZ,STATUS_MSG
		MOV	R4,#ACK	; SEND STATUS OK
		CALL	PUTCHAR
		PUSH	R5	; INDIRECT JUMP SEGMENTED
		PUSH	R6
;		RETS
		DB	0DBH, 000H	; CODE FOR RETS TO AVOID WARNING



MON_CHECKSUM:	MOV	R14,#GET_MON_SUM	; check if monitor already
		CALL	GETCHAR			; present
		MOVBZ	R5,RL4
		CALL	GETCHAR
		MOV	RH1,RL4
		CALL	GETCHAR
		MOV	RL1,RL4
		CALL	GETCHAR
		MOV	RH7,RL4
		CALL	GETCHAR
		MOV	RL7,RL4
		CALL	GETCHAR
		MOV	R15,#E_CHECKSUM
		AND	R14,#00FFH
		JMP	CC_NZ,STATUS_MSG

		MOV	R3,#0

MC_1:		EXTS	R5,#1
		ADD	R3,[R1+]	; no overflow possible
		SUB	R7,#2
		JMP	CC_UGT,MC_1

		MOV	R14,ZEROS
		MOV	R4,#STX
		CALL	PUTCHAR
		MOV	RL4,#02		; length of error message
		CALL	PUTCHAR
		MOV	RL4,RH3
		CALL	PUTCHAR
		MOV	RL4,RL3
		CALL	PUTCHAR
		MOV	R4,ZEROS
		SUB	R4,R14		; CALCULATE CHECKSUM
		CALL	PUTCHAR
		JMP	CC_UC,CMD_LOOP



WRITE_MEM:	MOV	R14,#WR_MEM	; DELETE CHECKSUM
		CALL	GETCHAR
		MOVBZ	R5,RL4
		CALL	GETCHAR
		MOV	RH6,RL4
		CALL	GETCHAR
		MOV	RL6,RL4
		CALL	GETCHAR
		MOV	RL7,RL4
		MOV	R15,#E_NORAM	; ERROR: NO MEMORY AT ADDRESS

WM_1:		CALL	GETCHAR
		EXTS	R5,#2
		MOVB	[R6],RL4
		MOVB	RL3,[R6]
		CMP	RL3,RL4
		JMP	CC_NE,STATUS_MSG
		ADD	R6,#1
		ADDC	RL5,#0
		SUB	RL7,#1
		JMP	CC_NZ,WM_1

		CALL	GETCHAR		; READ FOR CHECKSUM
		AND	R14,#00FFH
		JMP	CC_Z,STATUS_OK
		MOV	R15,#E_CHECKSUM
;		JMP	CC_UC,STATUS_MSG

STATUS_MSG:	MOV	R14,ZEROS
		MOV	R4,#NACK
		CALL	PUTCHAR
		MOV	RL4,#01		; length of error message
		CALL	PUTCHAR
		MOV	R4,R15
		CALL	PUTCHAR
		MOV	R4,ZEROS
		SUB	R4,R14		; CALCULATE CHECKSUM
		CALL	PUTCHAR
		JMP	CC_UC,CMD_LOOP

STATUS_OK:	MOV	R4,#ACK
		CALL	PUTCHAR
		JMP	CC_UC,CMD_LOOP


; RETURN VALUE IN RL4
GETCHAR:	JNB     S0RIC.7,$
		BCLR    S0RIC.7
		MOVB    RL4,S0RBUF
		ADD     R14,R4		; R14 = CHECKSUM
		RET

; VALUE IN RL4
PUTCHAR:	JNB     S0TIC.7,$
		BCLR    S0TIC.7
		MOVBZ   R4,RL4
		MOV     S0TBUF,R4
		ADD     R14,R4		; R14 = CHECKSUM
		RET
ENDBOOT:

BOOT		ENDP

BOOTSTRAP	ENDS


		END
