semantics goil_semantic_types :

import semantics goil_basic_types in "goil_basic_types.ggs" ;
import semantics goil_routines in "goil_routines.ggs" ;

list @number_list {
    @luint64 number ;
}

abstract class @number_set {}

class @uint_range extends @number_set {
    @luint64 first ;
    @luint64 last ;
}

class @uint_list extends @number_set {
    @number_list numbers ;
}

map @implementationSpec {
    @lstring type ;
}

map @implementation {
    @implementationSpec spec ;
    insert insertSpec error message "%K is duplicated in %L";
}

#action generateHeader
#    ?@lstring version
#    ?@lstring description
#;
#
map @os_imp {
    @lstring type ;
    
}

abstract class @oil_obj {
    @lstring description ;
	method get_description !@lstring desc :
		desc := description ;
	end method ;
}

#
# Task classes
#
abstract class @task_autostart_obj {
}

class @task_autostart_void extends @task_autostart_obj {
}

class @task_autostart_false extends @task_autostart_obj {
}

class @task_autostart_true extends @task_autostart_obj {
	@stringset appmodes ;
}

class @task_obj extends @oil_obj {
    @luint64 priority ;
    @lstring schedule ;
    @luint64 activation ;
    @task_autostart_obj autostart ;
    @stringset resources ;
    @stringset events;
    @ident_map other_fields;

    method get_priority !@uint64 out_priority :
        out_priority := [priority uint64] ;
    end method ;

    method get_activation !@string out_act :
        out_act := [[activation uint64] string] ;
    end method ;

    method get_autostart !@task_autostart_obj out_auto :
        out_auto := autostart ;
    end method ;

    method get_resources !@stringset out_resources :
        out_resources := resources ;
    end method ;

    method get_events !@stringset out_events :
        out_events := events ;
    end method ;

    method get_other_fields !@ident_map out_others :
        out_others := other_fields ;
    end method ;
}

map @task_map {
    @task_obj task ;
    insert insertTask error message "Task %K is already defined in %L" ;
}

map @task_mask {
    @uint64 mask ;
    insert insert_mask error message "Task %K has already its mask" ;
    search get_mask error message "No mask for task %K" ;
}

#
# Resource classes
#

abstract class @resource_property_obj {
}

class @resource_property_standard_obj extends @resource_property_obj {
}

class @resource_property_linked_obj extends @resource_property_obj {
	@lstring linked_resource ;
}

class @resource_property_internal_obj extends @resource_property_obj {
}

class @resource_obj extends @oil_obj {
	@resource_property_obj resource_property ;
	
	method get_property !@resource_property_obj out :
		out := resource_property;
	end method ;
}

map @resource_map {
	@resource_obj resource ;
	insert insertResource error message "Resource %K is already defined in %L" ;
	search getResource error message "Resource %K is not defined" ;
}

map @linked_resources {
	@lstring linked_resource ;
	insert insertLinked error message "Resource %K (%L) is part of a cycle of linked resources" ;
}

#
# Event classes
#
abstract class @event_mask_obj {
}

class @event_mask_user_obj extends @event_mask_obj {
	@luint64 mask ;
}

class @event_mask_auto_obj extends @event_mask_obj {
}

class @event_obj extends @oil_obj {
	@event_mask_obj mask ;

	method get_mask !@event_mask_obj out_mask :
		out_mask := mask ;
	end method ;
}

map @event_map {
    @event_obj event ;
    insert insertEvent error message "Event %K is already defined in %L" ;
    search get_event error message "Event %K is not defined" ;
}

map @event_usage_map {
    @uint count ;
    insert insert_count error message "Key %K is already there" ;
    search get_count error message "Key %K is not there" ;
    remove delete error message "Key %K cannot be deleted" ;
}

list @events {
    @lstring event_name ;
}

#
# Alarm classes
#
abstract class @action_obj {
    abstract method generate
        ?@prefix_map unused p
        ?@lstring    unused name
        ?@string     unused err
        !@string     res ;
}

abstract class @autostart_obj {}

class @void_action extends @action_obj {
    override method generate
        ?@prefix_map unused p
        ?@lstring    unused name
        ?@string     unused err
        !@string     res :

        res := "" ;
    end method ;
}

class @setevent_action extends @action_obj {
    @lstring task_name ;
    @lstring event_name ;
    override method generate
        ?@prefix_map p
        ?@lstring    name
        ?@string     err
        !@string     res :

        template ?res !"notification_setevent" ;
        replace !p !err."notif_name"   ![name string] !?res ;
        replace !p !err."notification" ![name string] !?res ;
        replace !p !"task" ![task_name string] !?res ;
        replace !p !"event" ![event_name string] !?res ;
   end method ;
}

class @activatetask_action extends @action_obj {
    @lstring task_name ;
    override method generate
        ?@prefix_map p
        ?@lstring    name
        ?@string     err
        !@string     res :

        template ?res !"notification_activatetask" ;
        replace !p !err."notif_name"   ![name string]      !?res ;
        replace !p !err."notification" ![name string]      !?res ;
        replace !p !"task"         ![task_name string] !?res ;
   end method ;
}

class @callback_action extends @action_obj {
    @lstring function_name ;
    override method generate
        ?@prefix_map p
        ?@lstring    name
        ?@string     err
        !@string     res :

        template ?res !"notification_activatetask" ;
        replace !p !err."notif_name"   ![name string] !?res ;
        replace !p !err."notification" ![name string] !?res ;
        replace !p !"callback" ![function_name string] !?res ;
   end method ;
}

class @autostart_void extends @autostart_obj {
}

class @autostart_true_params extends @autostart_obj {
    @luint64   alarm_time ;
    @luint64   cycle_time ;
    @stringset app_modes ;
}

class @alarm_obj extends @oil_obj {
    @lstring        counter_name ;
    @action_obj     action_params ;
    @autostart_obj  autostart_params ;

    method get_action !@action_obj out_action :
        out_action := action_params ;
    end method ;

    method get_autostart !@autostart_obj out_autostart :
        out_autostart := autostart_params ;
    end method ;

    method get_counter !@lstring out_counter :
        out_counter := counter_name ;
    end method ;
}

map @alarm_map {
    @alarm_obj  alarm ;
    insert insertAlarm error message "Alarm %K is duplicated in %L";
}

#
# ISR classes
#

class @isr_obj extends @oil_obj {
    @luint64   category ;
    @luint64   priority ;
    @stringset resources ;
    @stringset messages ;
    @ident_map other_fields;

    method get_priority !@uint64 out_priority :
        out_priority := [priority uint64];
    end method ;

    method get_activation !@string out_act :
        out_act := "1" ;
    end method ;

    method get_resources !@stringset out_resources :
        out_resources := resources ;
    end method ;

    method get_other_fields !@ident_map out_others :
        out_others := other_fields ;
    end method ;
}

map @isr_map {
    @isr_obj isr ;
    insert insertISR error message "ISR %K is duplicated in %L" ;
}

#
# Counter classes
#

class @counter_obj extends @oil_obj {
    @luint64 max_allowed_value ;
    @luint64 ticks_per_base ;
    @luint64 min_cycle ;

    method get_ticks_per_base !@string out_tpb :
        out_tpb := [[ticks_per_base uint64] string] ;
    end method ;
}

map @counter_map {
    @counter_obj counter ;
    insert insertCounter error message "Counter %K is duplicated in %L" ;
}

#
# Message classes
#

abstract class @base_mess extends @oil_obj {
    @action_obj notification ;
    @action_obj notificationerror ;
    @ident_map other_fields;
}

map @message_map ;

abstract class @mess_prop_obj {
    abstract method s_mess !@lstring sd ;
    abstract method generate
        ?@prefix_map     p
        ?@lstring        name 
        ?@base_mess      mess
        ?@message_map    messages
        ?@ident_list_map dests
        !@string         h_res
        !@string         i_res ;
    method generate_notif
        ?@prefix_map p
        ?@lstring    name
        ?@base_mess  mess 
        ?!@string    res :

        @action_obj notif ;
        @string notif_res ;

        # get the notification
        notif := [mess notification] ;
        [notif generate !p !name !"" ?notif_res] ;

        if notif_res == "" then
            res := [res stringByReplacingStringByString !"$NOTIFICATION_PTR$" !"NULL"] ;
        else
            replace !p !"notif_ptr" ![name string] !?res ;
        end if ;

        res := notif_res."\n".res ;

        # get the error notification
        notif := [mess notificationerror] ;
        [notif generate !p !name !"error_" ?notif_res] ;

        if notif_res == "" then
            res := [res stringByReplacingStringByString !"$ERROR_NOTIFICATION_PTR$" !"NULL"] ;
        else
            replace !p !"error_notif_ptr" ![name string] !?res ;
        end if ;

        res := notif_res."\n".res ;
    end method ;

    method generate_dest_list
        ?@prefix_map     p
        ?@lstring        name
        ?@lstring        sendingmessage
        ?@ident_list_map dests
        ?!@string        res :
    
        @string next_mo ;
        @ident_list dest_list;
        @bool notfound := true ;
        @bool nextone := false ;
        [dests get !sendingmessage ?dest_list] ;

        foreach dest_list (@lstring obj) while notfound :
#            message [obj string]."\n" ;
            if nextone then
                replace !p !"target" ![obj string] !?res ;
                notfound := false ;
            end if ;
            if [obj string] == [name string] then
                nextone := true ;
            end if ; 
        end foreach ;
        if notfound then
            res := [res stringByReplacingStringByString !"$TARGET$" !"NULL"] ;
        end if ;
    end method ;
}

class @message_obj extends @base_mess {
    @mess_prop_obj messageproperty ;
}

map @message_map {
    @message_obj mess ;
    insert insert_message error message "Message %K is duplicated in %L" ;
    search get_message error message "Message %K does not exist" ;
}

abstract class @filter_prop_obj {
    abstract method generate
        ?@prefix_map p
        ?@lstring    name
        ?!@string    res ;
    method base_generate
        ?@prefix_map p
        ?@lstring    name
        ?!@string    res :

        replace !p !"msg_name"    ![name string]       !?res ;
        replace !p !"filter"      ![name string]       !?res ;
        replace !p !"filter_ptr"  ![name string]       !?res ;
    end method ;        
}

class @void_filter extends @filter_prop_obj {
    override method generate
        ?@prefix_map unused p
        ?@lstring    unused name
        ?!@string    res :

        res := [res stringByReplacingStringByString !"$FILTER_PTR$" !"NULL"] ;
    end method ;
}

class @always_filter extends @filter_prop_obj {
    override method generate
        ?@prefix_map p
        ?@lstring    name
        ?!@string    res :

        @string f_res ;
        template ?f_res !"filter_noparam" ;
        res := f_res . res ;
        [self base_generate !p !name !?res] ;
        replace !p !"filter_func" !"tpl_filter_always" !?res ;
        replace !p !"filter_kind" !"Always"            !?res ;
    end method ;
}

class @never_filter extends @filter_prop_obj {
    override method generate
        ?@prefix_map p
        ?@lstring    name
        ?!@string    res :

        @string f_res ;
        template ?f_res !"filter_noparam" ;
        res := f_res . res ;
        [self base_generate !p !name !?res] ;
        replace !p !"filter_func" !"tpl_filter_never" !?res ;
        replace !p !"filter_kind" !"Never"            !?res ;
    end method ;
}

class @maskednewequalsx_filter extends @filter_prop_obj {
    @luint64 mask ;
    @luint64 x ;
    override method generate
        ?@prefix_map unused p
        ?@lstring    unused name
        ?!@string    unused res :

    end method ;
}

class @maskednewdiffersx_filter extends @filter_prop_obj {
    @luint64 mask ;
    @luint64 x ;
    override method generate
        ?@prefix_map unused p
        ?@lstring    unused name
        ?!@string    unused res :

    end method ;
}

class @newisequal_filter extends @filter_prop_obj {
    override method generate
        ?@prefix_map p
        ?@lstring    name
        ?!@string    res :

        @string f_res ;
        template ?f_res !"filter_noparam" ;
        res := f_res . res ;
        [self base_generate !p !name !?res] ;
        replace !p !"filter_func" !"tpl_filter_new_is_equal" !?res ;
        replace !p !"filter_kind" !"New is Equal"            !?res ;
    end method ;
}

class @newisdifferent_filter extends @filter_prop_obj {
    override method generate
        ?@prefix_map p
        ?@lstring    name
        ?!@string    res :

        @string f_res ;
        template ?f_res !"filter_noparam" ;
        res := f_res . res ;
        [self base_generate !p !name !?res] ;
        replace !p !"filter_func" !"tpl_filter_new_is_different" !?res ;
        replace !p !"filter_kind" !"New is Different"            !?res ;
    end method ;
}

class @maskednewequalsmaskedold_filter extends @filter_prop_obj {
    @luint64 mask ;
    override method generate
        ?@prefix_map unused p
        ?@lstring    unused name
        ?!@string    unused res :

    end method ;
}

class @maskednewdiffersmaskedold_filter extends @filter_prop_obj {
    @luint64 mask ;
    override method generate
        ?@prefix_map unused p
        ?@lstring    unused name
        ?!@string    unused res :

    end method ;
}

class @newiswithin extends @filter_prop_obj {
    @luint64 min ;
    @luint64 max ;
    override method generate
        ?@prefix_map unused p
        ?@lstring    unused name
        ?!@string    unused res :

    end method ;
}

class @newisoutside extends @filter_prop_obj {
    @luint64 min ;
    @luint64 max ;
    override method generate
        ?@prefix_map unused p
        ?@lstring    unused name
        ?!@string    unused res :

    end method ;
}

class @newisgreater_filter extends @filter_prop_obj {
    override method generate
        ?@prefix_map p
        ?@lstring    name
        ?!@string    res :

        @string f_res ;
        template ?f_res !"filter_noparam" ;
        res := f_res . res ;
        [self base_generate !p !name !?res] ;
        replace !p !"filter_func" !"tpl_filter_new_is_greater" !?res ;
        replace !p !"filter_kind" !"New is Greater"            !?res ;
    end method ;
}

class @newislessorequal_filter extends @filter_prop_obj {
    override method generate
        ?@prefix_map p
        ?@lstring    name
        ?!@string    res :

        @string f_res ;
        template ?f_res !"filter_noparam" ;
        res := f_res . res ;
        [self base_generate !p !name !?res] ;
        replace !p !"filter_func" !"tpl_filter_new_is_less_or_equal" !?res ;
        replace !p !"filter_kind" !"New is Less or Equal"            !?res ;
    end method ;
}

class @newisless_filter extends @filter_prop_obj {
    override method generate
        ?@prefix_map p
        ?@lstring    name
        ?!@string    res :

        @string f_res ;
        template ?f_res !"filter_noparam" ;
        res := f_res . res ;
        [self base_generate !p !name !?res] ;
        replace !p !"filter_func" !"tpl_filter_new_is_less" !?res ;
        replace !p !"filter_kind" !"New is Less"            !?res ;
    end method ;
}

class @newisgreaterorequal_filter extends @filter_prop_obj {
    override method generate
        ?@prefix_map p
        ?@lstring    name
        ?!@string    res :

        @string f_res ;
        template ?f_res !"filter_noparam" ;
        res := f_res . res ;
        [self base_generate !p !name !?res] ;
        replace !p !"filter_func" !"tpl_filter_new_is_greater_or_equal" !?res ;
        replace !p !"filter_kind" !"New is Greater or Equal"            !?res ;
    end method ;
}

class @oneeveryn_filter extends @filter_prop_obj {
    @luint64 period ;
    @luint64 offset ;
    override method generate
        ?@prefix_map unused p
        ?@lstring    unused name
        ?!@string    unused res :

    end method ;
}

abstract class @link_obj {}

class @void_mess_prop extends @mess_prop_obj {
    override method s_mess !@lstring sd : sd := [@lstring new !"" !here] ; end method ;
    override method generate
        ?@prefix_map     unused p
        ?@lstring        unused name 
        ?@base_mess      unused mess
        ?@message_map    unused messages
        ?@ident_list_map unused dests
        !@string         h_res
        !@string         i_res :

        h_res := "" ;
        i_res := "" ;
    end method ;
}

class @ssi_mess_prop extends @mess_prop_obj {
    @lstring cdatatype ;
    override method s_mess !@lstring sd : sd := [@lstring new !"" !here] ; end method ;
    override method generate
        ?@prefix_map     p
        ?@lstring        name 
        ?@base_mess      unused mess
        ?@message_map    unused messages
        ?@ident_list_map dests
        !@string         h_res
        !@string         i_res :

        h_res := "" ;
        template ?i_res !"message_ssi" ;
        replace !p !"msg_name" ![name string] !?i_res ;
        replace !p !"msg" ![name string] !?i_res ;
        if [dests hasKey ![name string]] then
            @ident_list d_mess_list ;
            [dests get !name ?d_mess_list] ;
            @lstring target ;
            [d_mess_list first ?target] ;
            replace !p !"target" ![target string] !?i_res ;
        end if ;
    end method ;
}

class @sse_mess_prop extends @mess_prop_obj {
    @lstring cdatatype ;
    @lstring tranferproperty ;
    @filter_prop_obj filter ;
    @lstring networkordercallout ;
    @lstring cpuordercallout ;
    @luint64 initialvalue ;
    @lstring networkmessage ;
    override method s_mess !@lstring sd : sd := [@lstring new !"" !here] ; end method ;
    override method generate
        ?@prefix_map     unused p
        ?@lstring        unused name 
        ?@base_mess      unused mess
        ?@message_map    unused messages
        ?@ident_list_map unused dests
        !@string         h_res
        !@string         i_res :

        h_res := "" ;
        i_res := "" ;
    end method ;
}

class @sde_mess_prop extends @mess_prop_obj {
    @lstring tranferproperty ;
    @lstring networkordercallout ;
    @lstring cpuordercallout ;
    @luint64 initialvalue ;
    @lstring networkmessage ;
    override method s_mess !@lstring sd : sd := [@lstring new !"" !here] ; end method ;
    override method generate
        ?@prefix_map     unused p
        ?@lstring        unused name 
        ?@base_mess      unused mess
        ?@message_map    unused messages
        ?@ident_list_map unused dests
        !@string         h_res
        !@string         i_res :

        h_res := "" ;
        i_res := "" ;
    end method ;
}

class @szi_mess_prop extends @mess_prop_obj {
    override method s_mess !@lstring sd : sd := [@lstring new !"" !here] ; end method ;
    override method generate
        ?@prefix_map     p
        ?@lstring        name 
        ?@base_mess      unused mess
        ?@message_map    unused messages
        ?@ident_list_map dests
        !@string         h_res
        !@string         i_res :

        h_res := "" ;
        template ?i_res !"message_szi" ;
        replace !p !"msg_name" ![name string] !?i_res ;
        replace !p !"msg" ![name string] !?i_res ;
        if [dests hasKey ![name string]] then
            @ident_list d_mess_list ;
            [dests get !name ?d_mess_list] ;
            @lstring target ;
            [d_mess_list first ?target] ;
            replace !p !"target" ![target string] !?i_res ;
        end if ;
    end method ;
}

class @sze_mess_prop extends @mess_prop_obj {
    @lstring networkordercallout ;
    @lstring cpuordercallout ;
    @lstring networkmessage ;
    override method s_mess !@lstring sd : sd := [@lstring new !"" !here] ; end method ;
    override method generate
        ?@prefix_map     unused p
        ?@lstring        unused name 
        ?@base_mess      unused mess
        ?@message_map    unused messages
        ?@ident_list_map unused dests
        !@string         h_res
        !@string         i_res :

        h_res := "" ;
        i_res := "" ;
    end method ;
}

class @rzi_mess_prop extends @mess_prop_obj {
    @lstring sendingmessage ;
    override method s_mess !@lstring sd : sd := sendingmessage ; end method ;
    override method generate
        ?@prefix_map     p
        ?@lstring        name 
        ?@base_mess      mess
        ?@message_map    unused messages
        ?@ident_list_map dests
        !@string         h_res
        !@string         i_res :

        h_res := "" ;
        template ?i_res !"message_rzi" ;
        replace !p !"msg_name" ![name string] !?i_res ;
        replace !p !"msg" ![name string] !?i_res ;

        # Add the notification structures if any
        [self generate_notif !p !name !mess !?i_res] ;

        # Add the destination message chaining
        [self generate_dest_list !p !name !sendingmessage !dests !?i_res] ;

    end method ;
}

class @rze_mess_prop extends @mess_prop_obj {
    @lstring networkordercallout ;
    @lstring cpuordercallout ;
    @lstring networkmessage ;
    override method s_mess !@lstring sd : sd := [@lstring new !"" !here] ; end method ;
    override method generate
        ?@prefix_map unused p
        ?@lstring        unused name 
        ?@base_mess      unused mess
        ?@message_map    unused messages
        ?@ident_list_map unused dests
        !@string         h_res
        !@string         i_res :

        h_res := "" ;
        i_res := "" ;
    end method ;
}

class @rui_mess_prop extends @mess_prop_obj {
    @lstring sendingmessage ;
    @filter_prop_obj filter ;
    @luint64 initialvalue ;
    override method s_mess !@lstring sd : sd := sendingmessage ; end method ;
    override method generate
        ?@prefix_map     p
        ?@lstring        name 
        ?@base_mess      mess
        ?@message_map    messages
        ?@ident_list_map dests
        !@string         h_res
        !@string         i_res :

        h_res := "" ;
        template ?i_res !"message_rui" ;
        replace !p !"msg_name" ![name string] !?i_res ;
        replace !p !"msg"      ![name string] !?i_res ;
        replace !p !"msg_buf"  ![name string] !?i_res ;

        # Add the filter structures if any
        [filter generate !p !name !?i_res] ;

        # Add the notification structures if any
        [self generate_notif !p !name !mess !?i_res] ;

        # Add the destination message chaining
        [self generate_dest_list !p !name !sendingmessage !dests !?i_res] ;

        # Add the size of the source message object
        @message_obj sender ;
        [messages get_message !sendingmessage ?sender] ;
        @mess_prop_obj prop := [sender messageproperty] ;
        extract prop :
        when @ssi_mess_prop (@lstring cdatatype) ->
            replace !p !"size" !"sizeof(".[cdatatype string].")" !?i_res ;
        else
            error here : "Incompatible sending message object" ;
        end extract ;
    end method ;
}

class @rqi_mess_prop extends @mess_prop_obj {
    @lstring sendingmessage ;
    @filter_prop_obj filter ;
    @luint64 initialvalue ;
    @luint64 queuesize ;
    override method s_mess !@lstring sd : sd := sendingmessage ; end method ;
    override method generate
        ?@prefix_map     p
        ?@lstring        name 
        ?@base_mess      mess
        ?@message_map    messages
        ?@ident_list_map dests
        !@string         h_res
        !@string         i_res :

        h_res := "" ;
        template ?i_res !"message_rqi" ;
        replace !p !"msg_name" ![name string] !?i_res ;
        replace !p !"msg"      ![name string] !?i_res ;
        replace !p !"msg_buf"  ![name string] !?i_res ;

       # Add the filter structures if any
        [filter generate !p !name !?i_res] ;

        # Add the notification structures if any
        [self generate_notif !p !name !mess !?i_res] ;

        # Add the destination message chaining
        [self generate_dest_list !p !name !sendingmessage !dests !?i_res] ;

        # Add the size of the source message object
        @message_obj sender ;
        [messages get_message !sendingmessage ?sender] ;
        @mess_prop_obj prop := [sender messageproperty] ;
        extract prop :
        when @ssi_mess_prop (@lstring cdatatype) ->
            replace !p !"element_size" !"sizeof(".[cdatatype string].")" !?i_res ;
        else
            error here : "Incompatible sending message object" ;
        end extract ;

        # Add the size of the queue
        replace !p !"queue_size"  ![[queuesize uint64] string] !?i_res ;

        # Add the dynamic queue
        replace !p !"dyn_queue"  ![name string] !?i_res ;

    end method ;
}

class @rue_mess_prop extends @mess_prop_obj {
    @lstring cdatatype ;
    @filter_prop_obj filter ;
    @link_obj link ;
    @luint64 initialvalue ;
    override method s_mess !@lstring sd : sd := [@lstring new !"" !here] ; end method ;
    override method generate
        ?@prefix_map     unused p
        ?@lstring        unused name 
        ?@base_mess      unused mess
        ?@message_map    unused messages
        ?@ident_list_map unused dests
        !@string         h_res
        !@string         i_res :

        h_res := "" ;
        i_res := "" ;
    end method ;
}

class @rqe_mess_prop extends @mess_prop_obj {
    @lstring cdatatype ;
    @luint64 queuesize ;
    @filter_prop_obj filter ;
    @link_obj link ;
    @luint64 initialvalue ;
    override method s_mess !@lstring sd : sd := [@lstring new !"" !here] ; end method ;
    override method generate
        ?@prefix_map     unused p
        ?@lstring        unused name 
        ?@base_mess      unused mess
        ?@message_map    unused messages
        ?@ident_list_map unused dests
        !@string         h_res
        !@string         i_res :

        h_res := "" ;
        i_res := "" ;
    end method ;
}

class @rde_mess_prop extends @mess_prop_obj {
    @link_obj link ;
    @luint64 initialvalue ;
    override method s_mess !@lstring sd : sd := [@lstring new !"" !here] ; end method ;
    override method generate
        ?@prefix_map     unused p
        ?@lstring        unused name 
        ?@base_mess      unused mess
        ?@message_map    unused messages
        ?@ident_list_map unused dests
        !@string         h_res
        !@string         i_res :

        h_res := "" ;
        i_res := "" ;
    end method ;
}

class @rzs_mess_prop extends @mess_prop_obj {
    @lstring cdatatype ;
    @luint64 initialvalue ;
    override method s_mess !@lstring sd : sd := [@lstring new !"" !here] ; end method ;
    override method generate
        ?@prefix_map     unused p
        ?@lstring        unused name 
        ?@base_mess      unused mess
        ?@message_map    unused messages
        ?@ident_list_map unused dests
        !@string         h_res
        !@string         i_res :

        h_res := "" ;
        i_res := "" ;
    end method ;
}

#
# Link attribute management
#
class @void_link extends @link_obj {}

class @true_link extends @link_obj {
    @lstring receivemessage ;
}

class @false_link extends @link_obj {}

class @nmcallback_action extends @action_obj {
    @lstring function_name ;
    @luint64 ipdu ;
    override method generate
        ?@prefix_map unused p
        ?@lstring    unused name
        ?@string     unused err
        !@string     res :

        res := "" ;
    end method ;
}


end semantics ;
