semantics goil_semantic_types :

import semantics goil_basic_types in "goil_basic_types.ggs" ;
import semantics goil_types_action in "goil_types_action.ggs" ;
import semantics goil_routines in "goil_routines.ggs" ;
#import semantics goil_types_timing_prot in "goil_types_timing_prot.ggs" ;

map @implementation_spec {
    @imp_type type ;
    insert put error message "%K is duplicated in %L";
    search get error message "%K does not exists";
    remove del error message "%K does not exists";
}

map @implementation {
    @implementation_spec spec ;
    insert put error message "%K is duplicated in %L";
    search get error message "%K does not exists";
    remove del error message "%K does not exists";
}

#action generateHeader
#    ?@lstring version
#    ?@lstring desc
#;
#
map @os_imp {
    @lstring type ;
    
}

#
# Event classes
#
abstract class @event_mask_obj {
    @location location ;
}

class @event_mask_void_obj extends @event_mask_obj {
}

class @event_mask_user_obj extends @event_mask_obj {
	@luint64 mask ;
}

class @event_mask_auto_obj extends @event_mask_obj {
}

class @event_obj extends @oil_obj {
	@event_mask_obj mask ;
}

map @event_map {
    @event_obj event ;
    insert put error message "Event %K is already defined in %L" ;
    search get error message "Event %K is not defined" ;
    remove del error message "Event %K is not defined" ;
}

map @event_usage_map {
    @uint count ;
    insert insert_count error message "Key %K is already there" ;
    search get_count error message "Key %K is not there" ;
    remove delete error message "Key %K cannot be deleted" ;
}

list @events {
    @lstring event_name ;
}

#
# Alarm classes
#
class @alarm_autostart_true extends @autostart_obj {
    @luint64   alarm_time ;
    @luint64   cycle_time ;
    @stringset app_modes ;
}

class @alarm_obj extends @oil_obj {
    @lstring        counter_name ;
    @action_obj     action_params ;
    @autostart_obj  autostart_params ;
}

map @alarm_map {
    @alarm_obj  alarm ;
    insert put error message "Alarm %K is duplicated in %L";
    search get error message "Alarm %K is not defined" ;
    remove del error message "Alarm %K is not defined" ;
}

#
# Message classes
#

abstract class @base_mess extends @oil_obj {
    @action_obj notification ;
    @action_obj notificationerror ;
    @ident_map other_fields;
}

map @message_map ;

abstract class @mess_prop_obj {
    @location location ;
    abstract method s_mess !@lstring sd ;
    abstract method generate
        ?@prefix_map     p
        ?@lstring        name 
        ?@base_mess      mess
        ?@message_map    messages
        ?@ident_list_map dests
        !@string         h_res
        !@string         i_res ;
    method generate_notif
        ?@prefix_map p
        ?@lstring    name
        ?@base_mess  mess 
        ?!@string    h_res
        ?!@string    i_res :

        @action_obj notif ;

        # get the notification
        notif := [mess notification] ;
        [notif generate !p !name !"" !"notif_ptr" !?h_res !?i_res] ;

        # get the error notification
        notif := [mess notificationerror] ;
        [notif generate !p !name !"error_" !"error_notif_ptr" !?h_res !?i_res] ;
    end method ;

    method generate_dest_list
        ?@prefix_map     p
        ?@lstring        name
        ?@lstring        sendingmessage
        ?@ident_list_map dests
        ?!@string        res :
    
        @string next_mo ;
        @ident_list dest_list;
        @bool notfound := true ;
        @bool nextone := false ;
        [dests get !sendingmessage ?dest_list] ;

        foreach dest_list (@lstring obj) while notfound do
#            message [obj string]."\n" ;
            if nextone then
                performReplace !p !"target_ptr" ![obj string] !?res ;
                notfound := false ;
            end if ;
            if [obj string] == [name string] then
                nextone := true ;
            end if ; 
        end foreach ;
        if notfound then
            res := [res stringByReplacingStringByString !"$TARGET_PTR$" !"NULL"] ;
        end if ;
    end method ;
}

class @message_obj extends @base_mess {
    @mess_prop_obj messageproperty ;
}

map @message_map {
    @message_obj mess ;
    insert put error message "Message %K is duplicated in %L" ;
    search get error message "Message %K does not exist" ;
    remove del error message "Message %K does not exist" ;
}

abstract class @filter_prop_obj {
    abstract method generate
        ?@prefix_map p
        ?@lstring    name
        ?!@string    res ;
    method base_generate
        ?@prefix_map p
        ?@lstring    name
        ?!@string    res :

        performReplace !p !"msg_name"    ![name string]       !?res ;
        performReplace !p !"filter"      ![name string]       !?res ;
        performReplace !p !"filter_ptr"  ![name string]       !?res ;
    end method ;        
}

class @void_filter extends @filter_prop_obj {
    override method generate
        ?@prefix_map unused p
        ?@lstring    unused name
        ?!@string    res :

        res := [res stringByReplacingStringByString !"$FILTER_PTR$" !"NULL"] ;
    end method ;
}

class @always_filter extends @filter_prop_obj {
    override method generate
        ?@prefix_map p
        ?@lstring    name
        ?!@string    res :

        @string f_res ;
        retrieveTemplateString ?f_res !"filter_noparam" ;
        res := f_res . res ;
        [self base_generate !p !name !?res] ;
        performReplace !p !"filter_func" !"tpl_filter_always" !?res ;
        performReplace !p !"filter_kind" !"Always"            !?res ;
    end method ;
}

class @never_filter extends @filter_prop_obj {
    override method generate
        ?@prefix_map p
        ?@lstring    name
        ?!@string    res :

        @string f_res ;
        retrieveTemplateString ?f_res !"filter_noparam" ;
        res := f_res . res ;
        [self base_generate !p !name !?res] ;
        performReplace !p !"filter_func" !"tpl_filter_never" !?res ;
        performReplace !p !"filter_kind" !"Never"            !?res ;
    end method ;
}

class @maskednewequalsx_filter extends @filter_prop_obj {
    @luint64 mask ;
    @luint64 x ;
    override method generate
        ?@prefix_map unused p
        ?@lstring    unused name
        ?!@string    unused res :

    end method ;
}

class @maskednewdiffersx_filter extends @filter_prop_obj {
    @luint64 mask ;
    @luint64 x ;
    override method generate
        ?@prefix_map unused p
        ?@lstring    unused name
        ?!@string    unused res :

    end method ;
}

class @newisequal_filter extends @filter_prop_obj {
    override method generate
        ?@prefix_map p
        ?@lstring    name
        ?!@string    res :

        @string f_res ;
        retrieveTemplateString ?f_res !"filter_noparam" ;
        res := f_res . res ;
        [self base_generate !p !name !?res] ;
        performReplace !p !"filter_func" !"tpl_filter_new_is_equal" !?res ;
        performReplace !p !"filter_kind" !"New is Equal"            !?res ;
    end method ;
}

class @newisdifferent_filter extends @filter_prop_obj {
    override method generate
        ?@prefix_map p
        ?@lstring    name
        ?!@string    res :

        @string f_res ;
        retrieveTemplateString ?f_res !"filter_noparam" ;
        res := f_res . res ;
        [self base_generate !p !name !?res] ;
        performReplace !p !"filter_func" !"tpl_filter_new_is_different" !?res ;
        performReplace !p !"filter_kind" !"New is Different"            !?res ;
    end method ;
}

class @maskednewequalsmaskedold_filter extends @filter_prop_obj {
    @luint64 mask ;
    override method generate
        ?@prefix_map unused p
        ?@lstring    unused name
        ?!@string    unused res :

    end method ;
}

class @maskednewdiffersmaskedold_filter extends @filter_prop_obj {
    @luint64 mask ;
    override method generate
        ?@prefix_map unused p
        ?@lstring    unused name
        ?!@string    unused res :

    end method ;
}

class @newiswithin extends @filter_prop_obj {
    @luint64 min ;
    @luint64 max ;
    override method generate
        ?@prefix_map unused p
        ?@lstring    unused name
        ?!@string    unused res :

    end method ;
}

class @newisoutside extends @filter_prop_obj {
    @luint64 min ;
    @luint64 max ;
    override method generate
        ?@prefix_map unused p
        ?@lstring    unused name
        ?!@string    unused res :

    end method ;
}

class @newisgreater_filter extends @filter_prop_obj {
    override method generate
        ?@prefix_map p
        ?@lstring    name
        ?!@string    res :

        @string f_res ;
        retrieveTemplateString ?f_res !"filter_noparam" ;
        res := f_res . res ;
        [self base_generate !p !name !?res] ;
        performReplace !p !"filter_func" !"tpl_filter_new_is_greater" !?res ;
        performReplace !p !"filter_kind" !"New is Greater"            !?res ;
    end method ;
}

class @newislessorequal_filter extends @filter_prop_obj {
    override method generate
        ?@prefix_map p
        ?@lstring    name
        ?!@string    res :

        @string f_res ;
        retrieveTemplateString ?f_res !"filter_noparam" ;
        res := f_res . res ;
        [self base_generate !p !name !?res] ;
        performReplace !p !"filter_func" !"tpl_filter_new_is_less_or_equal" !?res ;
        performReplace !p !"filter_kind" !"New is Less or Equal"            !?res ;
    end method ;
}

class @newisless_filter extends @filter_prop_obj {
    override method generate
        ?@prefix_map p
        ?@lstring    name
        ?!@string    res :

        @string f_res ;
        retrieveTemplateString ?f_res !"filter_noparam" ;
        res := f_res . res ;
        [self base_generate !p !name !?res] ;
        performReplace !p !"filter_func" !"tpl_filter_new_is_less" !?res ;
        performReplace !p !"filter_kind" !"New is Less"            !?res ;
    end method ;
}

class @newisgreaterorequal_filter extends @filter_prop_obj {
    override method generate
        ?@prefix_map p
        ?@lstring    name
        ?!@string    res :

        @string f_res ;
        retrieveTemplateString ?f_res !"filter_noparam" ;
        res := f_res . res ;
        [self base_generate !p !name !?res] ;
        performReplace !p !"filter_func" !"tpl_filter_new_is_greater_or_equal" !?res ;
        performReplace !p !"filter_kind" !"New is Greater or Equal"            !?res ;
    end method ;
}

class @oneeveryn_filter extends @filter_prop_obj {
    @luint64 period ;
    @luint64 offset ;
    override method generate
        ?@prefix_map unused p
        ?@lstring    unused name
        ?!@string    unused res :

    end method ;
}

abstract class @link_obj {}

class @void_mess_prop extends @mess_prop_obj {
    override method s_mess !@lstring sd : sd := [@lstring new !"" !here] ; end method ;
    override method generate
        ?@prefix_map     unused p
        ?@lstring        unused name 
        ?@base_mess      unused mess
        ?@message_map    unused messages
        ?@ident_list_map unused dests
        !@string         h_res
        !@string         i_res :

        h_res := "" ;
        i_res := "" ;
    end method ;
}

class @ssi_mess_prop extends @mess_prop_obj {
    @lstring cdatatype ;
    override method s_mess !@lstring sd : sd := [@lstring new !"" !here] ; end method ;
    override method generate
        ?@prefix_map     p
        ?@lstring        name 
        ?@base_mess      unused mess
        ?@message_map    unused messages
        ?@ident_list_map dests
        !@string         h_res
        !@string         i_res :

        h_res := "" ;
        retrieveTemplateString ?i_res !"message_ssi" ;
        performReplace !p !"msg_name" ![name string] !?i_res ;
        performReplace !p !"msg" ![name string] !?i_res ;
        if [dests hasKey ![name string]] then
            @ident_list d_mess_list ;
            [dests get !name ?d_mess_list] ;
            @lstring target ;
            [d_mess_list first ?target] ;
            performReplace !p !"target" ![target string] !?i_res ;
        end if ;
    end method ;
}

class @sse_mess_prop extends @mess_prop_obj {
    @lstring cdatatype ;
    @lstring tranferproperty ;
    @filter_prop_obj filter ;
    @lstring networkordercallout ;
    @lstring cpuordercallout ;
    @luint64 initialvalue ;
    @lstring networkmessage ;
    override method s_mess !@lstring sd : sd := [@lstring new !"" !here] ; end method ;
    override method generate
        ?@prefix_map     unused p
        ?@lstring        unused name 
        ?@base_mess      unused mess
        ?@message_map    unused messages
        ?@ident_list_map unused dests
        !@string         h_res
        !@string         i_res :

        h_res := "" ;
        i_res := "" ;
    end method ;
}

class @sde_mess_prop extends @mess_prop_obj {
    @lstring tranferproperty ;
    @lstring networkordercallout ;
    @lstring cpuordercallout ;
    @luint64 initialvalue ;
    @lstring networkmessage ;
    override method s_mess !@lstring sd : sd := [@lstring new !"" !here] ; end method ;
    override method generate
        ?@prefix_map     unused p
        ?@lstring        unused name 
        ?@base_mess      unused mess
        ?@message_map    unused messages
        ?@ident_list_map unused dests
        !@string         h_res
        !@string         i_res :

        h_res := "" ;
        i_res := "" ;
    end method ;
}

class @szi_mess_prop extends @mess_prop_obj {
    override method s_mess !@lstring sd : sd := [@lstring new !"" !here] ; end method ;
    override method generate
        ?@prefix_map     p
        ?@lstring        name 
        ?@base_mess      unused mess
        ?@message_map    unused messages
        ?@ident_list_map dests
        !@string         h_res
        !@string         i_res :

        h_res := "" ;
        retrieveTemplateString ?i_res !"message_szi" ;
        performReplace !p !"msg_name" ![name string] !?i_res ;
        performReplace !p !"msg" ![name string] !?i_res ;
        if [dests hasKey ![name string]] then
            @ident_list d_mess_list ;
            [dests get !name ?d_mess_list] ;
            @lstring target ;
            [d_mess_list first ?target] ;
            performReplace !p !"target" ![target string] !?i_res ;
        end if ;
    end method ;
}

class @sze_mess_prop extends @mess_prop_obj {
    @lstring networkordercallout ;
    @lstring cpuordercallout ;
    @lstring networkmessage ;
    override method s_mess !@lstring sd : sd := [@lstring new !"" !here] ; end method ;
    override method generate
        ?@prefix_map     unused p
        ?@lstring        unused name 
        ?@base_mess      unused mess
        ?@message_map    unused messages
        ?@ident_list_map unused dests
        !@string         h_res
        !@string         i_res :

        h_res := "" ;
        i_res := "" ;
    end method ;
}

class @rzi_mess_prop extends @mess_prop_obj {
    @lstring sendingmessage ;
    override method s_mess !@lstring sd : sd := sendingmessage ; end method ;
    override method generate
        ?@prefix_map     p
        ?@lstring        name 
        ?@base_mess      mess
        ?@message_map    unused messages
        ?@ident_list_map dests
        !@string         h_res
        !@string         i_res :

        h_res := "" ;
        retrieveTemplateString ?i_res !"message_rzi" ;
        performReplace !p !"msg_name" ![name string] !?i_res ;
        performReplace !p !"msg" ![name string] !?i_res ;

        # Add the notification structures if any
        [self generate_notif !p !name !mess !?h_res !?i_res] ;

        # Add the destination message chaining
        [self generate_dest_list !p !name !sendingmessage !dests !?i_res] ;

    end method ;
}

class @rze_mess_prop extends @mess_prop_obj {
    @lstring networkordercallout ;
    @lstring cpuordercallout ;
    @lstring networkmessage ;
    override method s_mess !@lstring sd : sd := [@lstring new !"" !here] ; end method ;
    override method generate
        ?@prefix_map unused p
        ?@lstring        unused name 
        ?@base_mess      unused mess
        ?@message_map    unused messages
        ?@ident_list_map unused dests
        !@string         h_res
        !@string         i_res :

        h_res := "" ;
        i_res := "" ;
    end method ;
}

class @rui_mess_prop extends @mess_prop_obj {
    @lstring sendingmessage ;
    @filter_prop_obj filter ;
    @luint64 initialvalue ;
    override method s_mess !@lstring sd : sd := sendingmessage ; end method ;
    override method generate
        ?@prefix_map     p
        ?@lstring        name 
        ?@base_mess      mess
        ?@message_map    messages
        ?@ident_list_map dests
        !@string         h_res
        !@string         i_res :

        h_res := "" ;
        retrieveTemplateString ?i_res !"message_rui" ;
        performReplace !p !"msg_name" ![name string] !?i_res ;
        performReplace !p !"msg"      ![name string] !?i_res ;
        performReplace !p !"msg_buf"  ![name string] !?i_res ;

        # Add the filter structures if any
        [filter generate !p !name !?i_res] ;

        # Add the notification structures if any
        [self generate_notif !p !name !mess !?h_res !?i_res] ;

        # Add the destination message chaining
        [self generate_dest_list !p !name !sendingmessage !dests !?i_res] ;

        # Add the size of the source message object
        @message_obj sender ;
        [messages get !sendingmessage ?sender] ;
        @mess_prop_obj prop := [sender messageproperty] ;
        cast prop :
        when == @ssi_mess_prop ssi do
            performReplace !p !"size" !"sizeof(".[[ssi cdatatype] string].")" !?i_res ;
        else
            error here : "Incompatible sending message object" ;
        end cast ;
    end method ;
}

class @rqi_mess_prop extends @mess_prop_obj {
    @lstring sendingmessage ;
    @filter_prop_obj filter ;
    @luint64 initialvalue ;
    @luint64 queuesize ;
    override method s_mess !@lstring sd : sd := sendingmessage ; end method ;
    override method generate
        ?@prefix_map     p
        ?@lstring        name 
        ?@base_mess      mess
        ?@message_map    messages
        ?@ident_list_map dests
        !@string         h_res
        !@string         i_res :

        h_res := "" ;
        retrieveTemplateString ?i_res !"message_rqi" ;
        performReplace !p !"msg_name" ![name string] !?i_res ;
        performReplace !p !"msg"      ![name string] !?i_res ;
        performReplace !p !"msg_buf"  ![name string] !?i_res ;

       # Add the filter structures if any
        [filter generate !p !name !?i_res] ;

        # Add the notification structures if any
        [self generate_notif !p !name !mess !?h_res !?i_res] ;

        # Add the destination message chaining
        [self generate_dest_list !p !name !sendingmessage !dests !?i_res] ;

        # Add the size of the source message object
        @message_obj sender ;
        [messages get !sendingmessage ?sender] ;
        @mess_prop_obj prop := [sender messageproperty] ;
        cast prop :
        when == @ssi_mess_prop ssi do
            performReplace !p !"element_size" !"sizeof(".[[ssi cdatatype] string].")" !?i_res ;
        else
            error here : "Incompatible sending message object" ;
        end cast ;

        # Add the size of the queue
        performReplace !p !"queue_size"  ![[queuesize uint64] string] !?i_res ;

        # Add the dynamic queue
        performReplace !p !"dyn_queue"  ![name string] !?i_res ;

    end method ;
}

class @rue_mess_prop extends @mess_prop_obj {
    @lstring cdatatype ;
    @filter_prop_obj filter ;
    @link_obj link ;
    @luint64 initialvalue ;
    override method s_mess !@lstring sd : sd := [@lstring new !"" !here] ; end method ;
    override method generate
        ?@prefix_map     unused p
        ?@lstring        unused name 
        ?@base_mess      unused mess
        ?@message_map    unused messages
        ?@ident_list_map unused dests
        !@string         h_res
        !@string         i_res :

        h_res := "" ;
        i_res := "" ;
    end method ;
}

class @rqe_mess_prop extends @mess_prop_obj {
    @lstring cdatatype ;
    @luint64 queuesize ;
    @filter_prop_obj filter ;
    @link_obj link ;
    @luint64 initialvalue ;
    override method s_mess !@lstring sd : sd := [@lstring new !"" !here] ; end method ;
    override method generate
        ?@prefix_map     unused p
        ?@lstring        unused name 
        ?@base_mess      unused mess
        ?@message_map    unused messages
        ?@ident_list_map unused dests
        !@string         h_res
        !@string         i_res :

        h_res := "" ;
        i_res := "" ;
    end method ;
}

class @rde_mess_prop extends @mess_prop_obj {
    @link_obj link ;
    @luint64 initialvalue ;
    override method s_mess !@lstring sd : sd := [@lstring new !"" !here] ; end method ;
    override method generate
        ?@prefix_map     unused p
        ?@lstring        unused name 
        ?@base_mess      unused mess
        ?@message_map    unused messages
        ?@ident_list_map unused dests
        !@string         h_res
        !@string         i_res :

        h_res := "" ;
        i_res := "" ;
    end method ;
}

class @rzs_mess_prop extends @mess_prop_obj {
    @lstring cdatatype ;
    @luint64 initialvalue ;
    override method s_mess !@lstring sd : sd := [@lstring new !"" !here] ; end method ;
    override method generate
        ?@prefix_map     unused p
        ?@lstring        unused name 
        ?@base_mess      unused mess
        ?@message_map    unused messages
        ?@ident_list_map unused dests
        !@string         h_res
        !@string         i_res :

        h_res := "" ;
        i_res := "" ;
    end method ;
}

#
# Link attribute management
#
class @void_link extends @link_obj {}

class @true_link extends @link_obj {
    @lstring receivemessage ;
}

class @false_link extends @link_obj {}

class @nmcallback_action extends @action_obj {
    @lstring function_name ;
    @luint64 ipdu ;
    override method generate
        ?@prefix_map p
        ?@lstring    unused name
        ?@string     unused err
        ?@string     key
        ?!@string    unused h_res
        ?!@string    i_res :

        @lstring lkey := [@lstring new !key !here] ;
        @string prefix ;
        @string tag_to_rep ;
        [p prefix !lkey ?prefix ?tag_to_rep] ;
        i_res := [i_res stringByReplacingStringByString !tag_to_rep !"NULL"] ;
    end method ;
}

end semantics ;
# vim:ft=ggs:ts=4:sw=4
