#
# @file memory_mapping.gSemantics
#
# @section File description
#
# This file contains the functions for the generation of
# memory mapping related data structures. ie: memory protection
# linker script and MemMap file
#
# @section Copyright
#
# Goil OIL compiler for Trampoline
#
# Goil is copyright (c) IRCCyN 2005+
# Goil is protected by the french law of intellectual property
#
# This software is distributed under the GNU Public Licence V2
#
# @section File informations
#
# $Date$
# $Rev$
# $Author$
# $URL$
#

semantics memory_mapping :

import semantics goil_routines         in "goil_routines.ggs" ;
import semantics goil_types_root       in "goil_types_root.ggs" ;
import semantics goil_env_verification in "goil_env_verification.ggs" ;
import semantics template_routines     in "template_routines.ggs";

import option goil_options in "goil_options.gOption" ;

#
# generate_mp generates the descriptors used for memory protection
#
routine generate_mp
  ??@root_obj   cpu
  ??@string_map app_for_obj
  ?!@string     unused header
  ?!@string     implementation
  ?!@string     unused obj_header
:

  if memory_protection_on[![cpu os]] then 
    @string tpl_mp := template_string_if_exist[!"code" !"mp"];
    @string tpl_mp_desc := template_string_if_exist[!"code" !"mp_desc"];
    @string dec := "" ;
    @string ext := "" ;

    doReplace !?tpl_mp !"$TIMESTAMP$" ![@string stringWithCurrentDateTime];

    @stringset known_osapp [emptySet] ;

    foreach [cpu tasks] do
      @string desc := [tpl_mp_desc stringByReplacingStringByString !"$NAME$" ![key string]];
      if [option goil_options.autosar_on value] then
        if [app_for_obj count] > 0 then
          @string app_name ;
          [app_for_obj get !key ?app_name] ;
          if not [known_osapp hasKey !app_name] then
            ext .= "extern void *__SEG_START_APP_".app_name."_VAR_RGN;\n" ;
            ext .= "extern void *__SEG_END_APP_".app_name."_VAR_RGN;\n" ;
            doReplace !?desc !"$APP_NAME$" !app_name;
            known_osapp += !app_name ;
          end if ;
        end if ;
      end if ;
      dec .= desc;
    end foreach ;

    foreach [cpu isrs] do
      @string desc := [tpl_mp_desc stringByReplacingStringByString !"$NAME$" ![key string]];
      if [option goil_options.autosar_on value] then
        if [app_for_obj count] > 0 then
          @string app_name ;
          [app_for_obj get !key ?app_name] ;
          if not [known_osapp hasKey !app_name] then
            ext .= "extern void *__SEG_START_APP_".app_name."_VAR_RGN;\n" ;
            ext .= "extern void *__SEG_END_APP_".app_name."_VAR_RGN;\n" ;
            known_osapp += !app_name ;
          end if ;
        end if ;
      end if ;
      dec .= desc;
    end foreach ;

    @tasks_by_type stasks [emptySortedList];
    # sort tasks according to type (basic or extended)
    foreach [cpu tasks] do
      if [[task events] length] > 0 then
        stasks += !0 ![key string] ;
      else
        stasks += !1 ![key string] ;
      end if ;
    end foreach ;

    @string mp_table := "CONSTP2CONST(tpl_mem_prot_desc, AUTOMATIC, OS_VAR) tpl_mp_table[TASK_COUNT + ISR_COUNT + 1] = {\n" ;
    foreach stasks do
      # if the task belongs to a trusted OS Application, the corresponding
      # table entry is set to NULL
      if [option goil_options.autosar_on value] then
        if [app_for_obj count] > 0 then
          @string app_name ;
          [app_for_obj get ![@lstring new !name !here] ?app_name] ;
          @app_obj app ;
          [[cpu applis] get ![@lstring new !app_name !here] ?app] ;
          cast [app trusted] :
          when == @app_trusted_true do
            mp_table .= "  NULL,\n" ;
          else
            mp_table .= "  &".name."_mp_desc,\n" ;
          end cast ; 
        end if ;
      else
        mp_table .= "  &".name."_mp_desc,\n" ;
      end if ;
    end foreach;

    foreach [cpu isrs] do
      mp_table .= "  &".[key string]."_mp_desc,\n" ;
    end foreach;
    mp_table .= "  NULL\n};" ;

    @string directory := project_name[];

    doReplace !?tpl_mp !"$APPLICATION$" !directory ;
    doReplace !?tpl_mp !"$LINKER_SYM$"  !ext ;
    doReplace !?tpl_mp !"$REGION_DESC$" !dec ;
    doReplace !?tpl_mp !"$DESC_TABLE$"  !mp_table ;

    doReplace !?implementation !"$MEMORY_PROTECTION$" !tpl_mp;
  end if;
end routine ;

routine generate_link_script_new
  ??@root_obj cpu
  ??@goilTemplateVariableMap cfg
:
  @string linker := linker[![[cpu os] memmap]];
  if linker != "" then
    @string linkerScript := goil_template[!linker !cfg !"script"];
    @string scriptFile := project_name[]."/".link_script_name[![[cpu os] memmap]];
    @uint error_count := [@uint errorCount];
    if error_count == 0 then
      if [option .verbose_output value] then
          message "creating " . scriptFile . "\n";
      end if;
      [linkerScript makeDirectoryAndWriteToFile !scriptFile];
    end if;
  end if;  
end routine;

routine generate_link_script
  ??@root_obj cpu
:
  @string linker := linker[![[cpu os] memmap]];
  if linker != "" then
    @string task_vars := "";
    @string isr_vars := "";
    @string task_stack := "";
    @string isr_stack := "";
    @string app_vars := "";
    @string user_consts := "";
    @string user_code := "";
    
    # generate task related script
    @string var_tpl := template_string_if_exist[!linker !"task_var"];
    @string stack_tpl := template_string_if_exist[!linker !"task_stack"];
    @string const_tpl := template_string_if_exist[!linker !"task_const"];
    @string code_tpl := template_string_if_exist[!linker !"task_code"];
    foreach [cpu tasks] do
      task_vars   .= [var_tpl stringByReplacingStringByString   !"$TASK_NAME$" ![key string]];
      task_stack  .= [stack_tpl stringByReplacingStringByString !"$TASK_NAME$" ![key string]];
      user_consts .= [const_tpl stringByReplacingStringByString !"$TASK_NAME$" ![key string]];
      user_code   .= [code_tpl stringByReplacingStringByString  !"$TASK_NAME$" ![key string]];
    end foreach;

    # generate isr related script
    var_tpl := template_string_if_exist[!linker !"isr_var"];
    stack_tpl := template_string_if_exist[!linker !"isr_stack"];
    const_tpl := template_string_if_exist[!linker !"isr_const"];
    code_tpl := template_string_if_exist[!linker !"isr_code"];
    foreach [cpu isrs] do
      isr_vars    .= [var_tpl stringByReplacingStringByString   !"$ISR_NAME$" ![key string]];
      isr_stack   .= [stack_tpl stringByReplacingStringByString !"$TASK_NAME$" ![key string]];
      user_consts .= [const_tpl stringByReplacingStringByString !"$ISR_NAME$" ![key string]];
      user_code   .= [code_tpl stringByReplacingStringByString  !"$ISR_NAME$" ![key string]];
    end foreach;
    
    # generate application related script
    var_tpl := template_string_if_exist[!linker !"app_var"];
    const_tpl := template_string_if_exist[!linker !"app_const"];
    foreach [cpu applis] do
      app_vars    .= [var_tpl stringByReplacingStringByString   !"$APP_NAME$" ![key string]];
      user_consts .= [const_tpl stringByReplacingStringByString !"$APP_NAME$" ![key string]];
    end foreach;
    
    # generate the whole script
    @string script := template_string_if_exist[!linker !"script"];
    doReplace !?script !"$USER_CODE$"  !user_code;
    doReplace !?script !"$USER_CONST$" !user_consts;
    doReplace !?script !"$PROC_VAR$"   !task_vars.isr_vars;
    doReplace !?script !"$PROC_STACK$" !task_stack.isr_stack;
    doReplace !?script !"$APP_VAR$"    !app_vars;

    
    @string script_file := project_name[]."/".link_script_name[![[cpu os] memmap]];
    @uint error_count := [@uint errorCount];
    if error_count == 0 then
      if [option .verbose_output value] then
          message "creating " . script_file . "\n";
      end if;
      [script makeDirectoryAndWriteToFile !script_file];
    end if;
  end if;
end routine;

routine generate_memmap
  ??@root_obj   cpu
:
  @string cc := compiler[![[cpu os] memmap]];
  if cc != "" then
    @string mm := template_string_if_exist[!cc !"MemMap.h"];
    @string result := "";
    @string gen_tpl := template_string_if_exist[!cc !"generic_section"];
    @string section_tpl := [gen_tpl stringByReplacingStringByString !"$CONT$" !"SEC"];
    @string config_tpl := [gen_tpl stringByReplacingStringByString !"$CONT$" !"CONFIG"];
    @stringlist data_size [emptyList];
    data_size += !"_32BIT";
    data_size += !"_16BIT";
    data_size += !"_8BIT";
    data_size += !"_BOOLEAN";
    data_size += !"_UNSPECIFIED";
    @stringlist sub_kind [emptyList];
    sub_kind += !"_NOINIT";
    sub_kind += !"_POWER_ON_INIT";
    sub_kind += !"_FAST";
    sub_kind += !"";

    @string obj_tpl := [section_tpl stringByReplacingStringByString !"$OBJ$" !"Task"];
    foreach [cpu tasks] do
      @string named_sec := [obj_tpl stringByReplacingStringByString !"$NAME$" ![key string]];
      # generate the code section
      @string code_sec_tpl := [named_sec stringByReplacingStringByString !"$KIND$" !"CODE"];
      doReplace !?code_sec_tpl !"$SUBKIND$" !"";
      doReplace !?code_sec_tpl !"$SIZE$" !"";
      doReplace !?code_sec_tpl !"$TYPE$" !"CODE";
      doReplace !?code_sec_tpl !"$SECTION_KIND$" !"code";
      result .= code_sec_tpl;
      # generate the variables sections
      @string var_sec_tpl := [named_sec stringByReplacingStringByString !"$KIND$" !"VAR"];
      doReplace !?var_sec_tpl !"$TYPE$" !"DATA";
      doReplace !?var_sec_tpl !"$SECTION_KIND$" !"data";
      foreach sub_kind (@string sk) do
        @string var_sec_sk_tpl := [var_sec_tpl stringByReplacingStringByString !"$SUBKIND$" !sk];
        foreach data_size (@string size) do
          @string partial_result := [var_sec_sk_tpl stringByReplacingStringByString !"$SIZE$" !size];
          result .= partial_result;
        end foreach;
      end foreach;
      # generate the constants sections
      @string const_sec_tpl := [named_sec stringByReplacingStringByString !"$KIND$" !"CONST"];
      doReplace !?const_sec_tpl !"$TYPE$" !"DATA";
      doReplace !?const_sec_tpl !"$SECTION_KIND$" !"const";
      const_sec_tpl := [const_sec_tpl stringByReplacingStringByString !"$SUBKIND$" !""];
      foreach data_size (@string size) do
        @string partial_result := [const_sec_tpl stringByReplacingStringByString !"$SIZE$" !size];
        result .= partial_result;
      end foreach;
      const_sec_tpl := [named_sec stringByReplacingStringByString !"$KIND$" !"CALIB"];
      doReplace !?const_sec_tpl !"$TYPE$" !"DATA";
      const_sec_tpl := [const_sec_tpl stringByReplacingStringByString !"$SUBKIND$" !""];
      foreach data_size (@string size) do
        @string partial_result := [const_sec_tpl stringByReplacingStringByString !"$SIZE$" !size];
        result .= partial_result;
      end foreach;
      const_sec_tpl := [named_sec stringByReplacingStringByString !"$KIND$" !"CARTO"];
      doReplace !?const_sec_tpl !"$TYPE$" !"DATA";
      const_sec_tpl := [const_sec_tpl stringByReplacingStringByString !"$SUBKIND$" !""];
      foreach data_size (@string size) do
        @string partial_result := [const_sec_tpl stringByReplacingStringByString !"$SIZE$" !size];
        result .= partial_result;
      end foreach;
      # generate configuration data section
      @string cfg_data := [config_tpl stringByReplacingStringByString !"$KIND$" !"DATA"];
      doReplace !?cfg_data !"$TYPE$" !"DATA";
      doReplace !?cfg_data !"$SECTION_KIND$" !"data";
      cfg_data := [cfg_data stringByReplacingStringByString !"$SUBKIND$" !""];
      cfg_data := [cfg_data stringByReplacingStringByString !"$OBJ$" !"Task"];
      cfg_data := [cfg_data stringByReplacingStringByString !"$NAME$" ![key string]];
      foreach data_size (@string size) do
        @string partial_result := [cfg_data stringByReplacingStringByString !"$SIZE$" !size];
        result .= partial_result;
      end foreach;
      # generate the stack section
      @string stack_data := [named_sec stringByReplacingStringByString !"$KIND$" !"STACK"];
      doReplace !?stack_data !"$TYPE$" !"DATA";
      doReplace !?stack_data !"$SECTION_KIND$" !"data";
      doReplace !?stack_data !"$SUBKIND$" !"";
      doReplace !?stack_data !"$SIZE$" !"";
      result .= stack_data;
    end foreach;
    
    obj_tpl := [section_tpl stringByReplacingStringByString !"$OBJ$" !"ISR"];
    foreach [cpu isrs] do
      @string named_sec := [obj_tpl stringByReplacingStringByString !"$NAME$" ![key string]];
      # generate the code section
      @string code_sec_tpl := [named_sec stringByReplacingStringByString !"$KIND$" !"CODE"];
      doReplace !?code_sec_tpl !"$SUBKIND$" !"";
      doReplace !?code_sec_tpl !"$SIZE$" !"";
      doReplace !?code_sec_tpl !"$TYPE$" !"CODE";
      doReplace !?code_sec_tpl !"$SECTION_KIND$" !"text";
      result .= code_sec_tpl;
      # generate the variables sections
      @string var_sec_tpl := [named_sec stringByReplacingStringByString !"$KIND$" !"VAR"];
      doReplace !?var_sec_tpl !"$TYPE$" !"DATA";
      doReplace !?var_sec_tpl !"$SECTION_KIND$" !"data";
      foreach sub_kind (@string sk) do
        @string var_sec_sk_tpl := [var_sec_tpl stringByReplacingStringByString !"$SUBKIND$" !sk];
        foreach data_size (@string size) do
          @string partial_result := [var_sec_sk_tpl stringByReplacingStringByString !"$SIZE$" !size];
          result .= partial_result;
        end foreach;
      end foreach;
      # generate the constants sections
      @string const_sec_tpl := [named_sec stringByReplacingStringByString !"$KIND$" !"CONST"];
      doReplace !?const_sec_tpl !"$TYPE$" !"DATA";
      doReplace !?const_sec_tpl !"$SECTION_KIND$" !"rodata";
      const_sec_tpl := [const_sec_tpl stringByReplacingStringByString !"$SUBKIND$" !""];
      foreach data_size (@string size) do
        @string partial_result := [const_sec_tpl stringByReplacingStringByString !"$SIZE$" !size];
        result .= partial_result;
      end foreach;
      const_sec_tpl := [named_sec stringByReplacingStringByString !"$KIND$" !"CALIB"];
      doReplace !?const_sec_tpl !"$TYPE$" !"DATA";
      const_sec_tpl := [const_sec_tpl stringByReplacingStringByString !"$SUBKIND$" !""];
      foreach data_size (@string size) do
        @string partial_result := [const_sec_tpl stringByReplacingStringByString !"$SIZE$" !size];
        result .= partial_result;
      end foreach;
      const_sec_tpl := [named_sec stringByReplacingStringByString !"$KIND$" !"CARTO"];
      doReplace !?const_sec_tpl !"$TYPE$" !"DATA";
      const_sec_tpl := [const_sec_tpl stringByReplacingStringByString !"$SUBKIND$" !""];
      foreach data_size (@string size) do
        @string partial_result := [const_sec_tpl stringByReplacingStringByString !"$SIZE$" !size];
        result .= partial_result;
      end foreach;
      # generate configuration data section
      @string cfg_data := [config_tpl stringByReplacingStringByString !"$KIND$" !"DATA"];
      doReplace !?cfg_data !"$TYPE$" !"DATA";
      doReplace !?cfg_data !"$SECTION_KIND$" !"data";
      cfg_data := [cfg_data stringByReplacingStringByString !"$SUBKIND$" !""];
      cfg_data := [cfg_data stringByReplacingStringByString !"$OBJ$" !"ISR"];
      cfg_data := [cfg_data stringByReplacingStringByString !"$NAME$" ![key string]];
      foreach data_size (@string size) do
        @string partial_result := [cfg_data stringByReplacingStringByString !"$SIZE$" !size];
        result .= partial_result;
      end foreach;
    end foreach;

    doReplace !?mm !"$APP_MEMMAP$" !result;

    # OS MemMap
    @string os_secs := "";
    @string os_tpl := template_string_if_exist[!cc !"os_section"];
    @string code_section := [os_tpl stringByReplacingStringByString !"$KIND$" !"CODE"];
    doReplace !?code_section !"$TYPE$" !"CODE";
    doReplace !?code_section !"$SECTION_KIND$" !"text";
    doReplace !?code_section !"$CONT$" !"SEC";
    doReplace !?code_section !"$SUBKIND$" !"";
    doReplace !?code_section !"$SIZE$" !"";
    doReplace !?code_section !"$SECTION$" !".osCode";
    os_secs .= code_section;
    
    @string var_section := [os_tpl stringByReplacingStringByString !"$KIND$" !"VAR"];
    doReplace !?var_section !"$TYPE$" !"DATA";
    doReplace !?var_section !"$SECTION_KIND$" !"data";
    doReplace !?var_section !"$CONT$" !"SEC";
    doReplace !?var_section !"$SECTION$" !".osVar";
    @string no_init := [var_section stringByReplacingStringByString !"$SUBKIND$" !"_NOINIT"];
    foreach data_size (@string size) do
      os_secs .= [no_init stringByReplacingStringByString !"$SIZE$" !size];
    end foreach;
    @string power_on := [var_section stringByReplacingStringByString !"$SUBKIND$" !"_POWER_ON_INIT"];
    foreach data_size (@string size) do
      os_secs .= [power_on stringByReplacingStringByString !"$SIZE$" !size];
    end foreach;
    @string fast := [var_section stringByReplacingStringByString !"$SUBKIND$" !"_POWER_ON_INIT"];
    foreach data_size (@string size) do
      os_secs .= [fast stringByReplacingStringByString !"$SIZE$" !size];
    end foreach;
    @string var := [var_section stringByReplacingStringByString !"$SUBKIND$" !""];
    foreach data_size (@string size) do
      os_secs .= [var stringByReplacingStringByString !"$SIZE$" !size];
    end foreach;

    @string const_section := [os_tpl stringByReplacingStringByString !"$KIND$" !"CONST"];
    doReplace !?const_section !"$TYPE$" !"DATA";
    doReplace !?const_section !"$SECTION_KIND$" !"rodata";
    doReplace !?const_section !"$CONT$" !"SEC";
    doReplace !?const_section !"$SECTION$" !".osConst";
    @string os_const := [const_section stringByReplacingStringByString !"$SUBKIND$" !""];
    foreach data_size (@string size) do
      os_secs .= [os_const stringByReplacingStringByString !"$SIZE$" !size];
    end foreach;

    doReplace !?mm !"$OS_MEMMAP$" !os_secs;

    # API MemMap
    @string api_tpl := template_string_if_exist[!cc !"api_section"];
    doReplace !?mm !"$API_MEMMAP$" !api_tpl;
    
    @string mm_file := project_name[]."/MemMap.h";
    if [@uint errorCount] == 0 then
      if [option .verbose_output value] then
          message "creating " . mm_file . "\n";
      end if;
      [mm makeDirectoryAndWriteToFile !mm_file];
    end if;

  else
  end if ;
end routine;

routine generate_memmap_new
  ??@root_obj cpu
  ??@goilTemplateVariableMap cfg
:
#  @lstring cc := [cfg compilerKind];
  @string cc := compiler[![[cpu os] memmap]];
  if cc != "" then
    @string mm := goil_template[!cc !cfg !"MemMap.h"];
#    message mm;
    @string mm_file := project_name[]."/MemMap.h";
    if [@uint errorCount] == 0 then
      if [option .verbose_output value] then
          message "creating " . mm_file . "\n";
      end if;
      [mm makeDirectoryAndWriteToFile !mm_file];
    end if;
  else
#    warning here: "no compiler specified. MemMap.h will not be generated";
  end if;
end routine;

routine generate_compiler
  ??@root_obj   cpu
:
  @string cc := compiler[![[cpu os] memmap]];
  if cc != "" then
    @string comp := template_string_if_exist[!cc !"Compiler.h"];
    @string comp_cfg := template_string_if_exist[!cc !"Compiler_Cfg.h"];
    @string comp_file := project_name[]."/Compiler.h";
    @string comp_cfg_file := project_name[]."/Compiler_Cfg.h";

    if [@uint errorCount] == 0 then
      if [option .verbose_output value] then
          message "creating " . comp_file . "\n";
      end if;
      [comp makeDirectoryAndWriteToFile !comp_file];
      if [option .verbose_output value] then
          message "creating " . comp_cfg_file . "\n";
      end if;
      [comp_cfg makeDirectoryAndWriteToFile !comp_cfg_file];
    end if;
  end if;
end routine;

end semantics ;