#---------------------------------------------------------------------------*
#                                                                           *
#  GOIL template expression parser definition                               *
#                                                                           *
#  Copyright (C) 2009, ..., 2009 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax goil_template_expression_parser :
with "goil_template_scanner.gLexique" ;

import lexique goil_template_scanner in "goil_template_scanner.gLexique" ;

import semantics goil_template_semantics in "goil_template_semantics.ggs" ;
import semantics system_config in "system_config.ggs" ;

#------------------------------------------------------------------------------*
#                                                                              *
#          Rules prototypes                                                    *
#                                                                              *
#------------------------------------------------------------------------------*

nonterminal <expression>
  ??@string inPrefix
  ??@string inPath
  ??@systemConfig inCfg
  ??@goilTemplateVariableMap inVariableMap
  !@goilTemplateValue outValue
  !@goilTemplateType outResultType
label parse
;

nonterminal <relation_term>
  ??@string inPrefix
  ??@string inPath
  ??@systemConfig inCfg
  ??@goilTemplateVariableMap inVariableMap
  !@goilTemplateValue outValue
  !@goilTemplateType outResultType
label parse
;

nonterminal <relation_factor>
  ??@string inPrefix
  ??@string inPath
  ??@systemConfig inCfg
  ??@goilTemplateVariableMap inVariableMap
  !@goilTemplateValue outValue
  !@goilTemplateType outResultType
label parse
;

nonterminal <simple_expression>
  ??@string inPrefix
  ??@string inPath
  ??@systemConfig inCfg
  ??@goilTemplateVariableMap inVariableMap
  !@goilTemplateValue outValue
  !@goilTemplateType outResultType
label parse
;

nonterminal <term>
  ??@string inPrefix
  ??@string inPath
  ??@systemConfig inCfg
  ??@goilTemplateVariableMap inVariableMap
  !@goilTemplateValue outValue
  !@goilTemplateType outResultType
label parse
;

nonterminal <factor>
  ??@string inPrefix
  ??@string inPath
  ??@systemConfig inCfg
  ??@goilTemplateVariableMap inVariableMap
  !@goilTemplateValue outValue
  !@goilTemplateType outResultType
label parse
;

#---------------------------------------------------------------------------*
#                                                                           *
#   M A T C H    &    O P E R A T O R                                       *
#                                                                           *
#---------------------------------------------------------------------------*

routine matchAndOperatorForTemplate
  ??@goilTemplateType inLeftExpressionType
  ??@goilTemplateType inRightExpressionType
  !@goilTemplateType outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when boolType :: boolType :
    outResultType := inLeftExpressionType ;
  when unsignedType :: unsignedType :
    outResultType := inLeftExpressionType ;
  else
    error here : "operand type error : (" . [inLeftExpressionType messageGoilTemplateType] .
           " & " . [inRightExpressionType messageGoilTemplateType] . ") is not valid" 
           -> outResultType ;
  end match ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   M A T C H    |    O P E R A T O R                                       *
#                                                                           *
#---------------------------------------------------------------------------*

routine matchOrOperatorForTemplate
  ??@goilTemplateType inLeftExpressionType
  ??@goilTemplateType inRightExpressionType
  !@goilTemplateType outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when boolType :: boolType :
    outResultType := inLeftExpressionType ;
  when unsignedType :: unsignedType :
    outResultType := inLeftExpressionType ;
  else
    error here : "operand type error : (" . [inLeftExpressionType messageGoilTemplateType] .
           " | " . [inRightExpressionType messageGoilTemplateType] . ") is not valid" 
           -> outResultType ;
  end match ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   M A T C H    ^    O P E R A T O R                                       *
#                                                                           *
#---------------------------------------------------------------------------*

routine matchXorOperatorForTemplate
  ??@goilTemplateType inLeftExpressionType
  ??@goilTemplateType inRightExpressionType
  !@goilTemplateType outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when boolType :: boolType :
    outResultType := inLeftExpressionType ;
  when unsignedType :: unsignedType :
    outResultType := inLeftExpressionType ;
  else
    error here : "operand type error : (" . [inLeftExpressionType messageGoilTemplateType] .
           " | " . [inRightExpressionType messageGoilTemplateType] . ") is not valid" 
           -> outResultType ;
  end match ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    N O T    O P E R A T O R                                   *
#                                                                           *
#---------------------------------------------------------------------------*

routine checkNotOperatorForTemplate
  ??@goilTemplateType inOperandType
  !@goilTemplateType outResultType
:
  if inOperandType != [@goilTemplateType boolType] then
    error here : "the 'not' operator is not defined for an "
    . [inOperandType messageGoilTemplateType] . " type" ;
  end if ;
  outResultType := inOperandType ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    ~    O P E R A T O R                                       *
#                                                                           *
#---------------------------------------------------------------------------*

routine checkBitComplementOperatorForTemplate
  ??@goilTemplateType inOperandType
  !@goilTemplateType outResultType
:
  outResultType := inOperandType ;
  if inOperandType != [@goilTemplateType unsignedType] then
    error here : "the ~ operator is not defined for an "
    . [inOperandType messageGoilTemplateType] . " type" ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    ==    !=    C O M P A R I S O N S                          *
#                                                                           *
#---------------------------------------------------------------------------*

routine comparison_types_checkForTemplate
  ??@goilTemplateType inLeftExpressionType
  ??@goilTemplateType inRightExpressionType
:
  match inLeftExpressionType :: inRightExpressionType :
  when boolType     :: boolType :
  when unsignedType :: unsignedType :
  when stringType   :: stringType :
  else
    error here : "comparison between " . [inLeftExpressionType messageGoilTemplateType] .
           " and " . [inRightExpressionType messageGoilTemplateType] . " is not valid"  ;
  end match ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    ==    !=    <    <=    >    >=   C O M P A R I S O N S     *
#                                                                           *
#---------------------------------------------------------------------------*

routine magnitude_comparison_types_checkForTemplate
  ??@goilTemplateType inLeftExpressionType
  ??@goilTemplateType inRightExpressionType
:
  match inLeftExpressionType :: inRightExpressionType :
  when boolType      :: boolType :
  when unsignedType      :: unsignedType :
  when stringType    :: stringType :
  else
    error here : "comparison between " . [inLeftExpressionType messageGoilTemplateType] .
           " and " . [inRightExpressionType messageGoilTemplateType] . " is not valid"  ;
  end match ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    S H I F T    O P E R A T O R                               *
#                                                                           *
#---------------------------------------------------------------------------*

routine left_shift_types_checkForTemplate
  ??@goilTemplateType inLeftExpressionType
  ??@goilTemplateType inRightExpressionType
  !@goilTemplateType outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when unsignedType    :: unsignedType :
    outResultType := inLeftExpressionType ;
  else
    error here : "shift between " . [inLeftExpressionType messageGoilTemplateType]
      ." and " . [inRightExpressionType messageGoilTemplateType] . " is not valid"
      -> outResultType
    ;
  end match ;
end routine ;

#---------------------------------------------------------------------------*

routine right_shift_types_checkForTemplate
  ??@goilTemplateType inLeftExpressionType
  ??@goilTemplateType inRightExpressionType
  !@goilTemplateType outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when unsignedType    :: unsignedType :
    outResultType := inLeftExpressionType ;
  else
    error here : "shift between " . [inLeftExpressionType messageGoilTemplateType]
      ." and " . [inRightExpressionType messageGoilTemplateType] . " is not valid"
      -> outResultType
    ;
  end match ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    A D D I T I O N    O P E R A T O R                         *
#                                                                           *
#---------------------------------------------------------------------------*

routine addition_types_checkForTemplate
  ??@goilTemplateType inLeftExpressionType
  ??@goilTemplateType inRightExpressionType
  !@goilTemplateType outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when unsignedType      :: unsignedType :
    outResultType := inLeftExpressionType ;
  else
    error here : "addition between " . [inLeftExpressionType messageGoilTemplateType]
      ." and " . [inRightExpressionType messageGoilTemplateType] . " is not valid"
      -> outResultType
    ;
  end match ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    S U B S T R A C T I O N    O P E R A T O R                 *
#                                                                           *
#---------------------------------------------------------------------------*

routine substraction_types_checkForTemplate
  ??@goilTemplateType inLeftExpressionType
  ??@goilTemplateType inRightExpressionType
  !@goilTemplateType outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when unsignedType      :: unsignedType :
    outResultType := inLeftExpressionType ;
  else
    error here : "substraction between " . [inLeftExpressionType messageGoilTemplateType]
      ." and " . [inRightExpressionType messageGoilTemplateType] . " is not valid"
      -> outResultType
    ;
  end match ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    M U L T I P L Y    O P E R A T O R                         *
#                                                                           *
#---------------------------------------------------------------------------*

routine multiply_types_checkForTemplate
  ??@goilTemplateType inLeftExpressionType
  ??@goilTemplateType inRightExpressionType
  !@goilTemplateType outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when unsignedType      :: unsignedType :
    outResultType := inLeftExpressionType ;
  else
    error here : "multiplication between " . [inLeftExpressionType messageGoilTemplateType]
      ." and " . [inRightExpressionType messageGoilTemplateType] . " is not valid"
      -> outResultType
    ;
  end match ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    D I V I D E    O P E R A T O R                             *
#                                                                           *
#---------------------------------------------------------------------------*

routine divide_types_checkForTemplate
  ??@goilTemplateType inLeftExpressionType
  ??@goilTemplateType inRightExpressionType
  !@goilTemplateType outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when unsignedType      :: unsignedType :
    outResultType := inLeftExpressionType ;
  else
    error here : "division between " . [inLeftExpressionType messageGoilTemplateType]
      ." and " . [inRightExpressionType messageGoilTemplateType] . " is not valid"
      -> outResultType
    ;
  end match ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    M O D U L O    O P E R A T O R                             *
#                                                                           *
#---------------------------------------------------------------------------*

routine modulo_types_checkForTemplate
  ??@goilTemplateType inLeftExpressionType
  ??@goilTemplateType inRightExpressionType
  !@goilTemplateType outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when unsignedType      :: unsignedType :
    outResultType := inLeftExpressionType ;
  else
    error here : "modulo between " . [inLeftExpressionType messageGoilTemplateType]
      ." and " . [inRightExpressionType messageGoilTemplateType] . " is not valid"
      -> outResultType
    ;
  end match ;
end routine ;

#------------------------------------------------------------------------------*
#                                                                              *
#  A R G U M E N T    L I S T    S I G N A T U R E                             *
#                                                                              *
#------------------------------------------------------------------------------*

function argumentListSignature
  ??@goilTemplateExpressionList inParameterTypeList
  -> @string outResult
:
  outResult := " this method call has " ;
  outResult .= [[inParameterTypeList length] string] . " argument" ;
  outResult .= if [inParameterTypeList length] > 0 then "s" else "" end ;
  foreach inParameterTypeList
  before outResult .= ": " ;
  do outResult .= [mType messageGoilTemplateType] ;
  between outResult .= ", " ;
  end foreach ;
end function ;

#------------------------------------------------------------------------------*
#                                                                              *
#  C H E C K    I N V O C A T I O N    H A S   N O    A R G U M E N T          *
#                                                                              *
#------------------------------------------------------------------------------*

routine checkInvocationHasNoArgument
  ??@goilTemplateType inType
  ??@lstring inMethodName
  ??@goilTemplateExpressionList inParameterTypeList
:
  if [inParameterTypeList length] > 0 then
    error inMethodName:"calling '" . inMethodName . "' on a "
    . [inType messageGoilTemplateType] . " type requires no argument; "
    . argumentListSignature [!inParameterTypeList] ;
  end if ;
end routine ;

#------------------------------------------------------------------------------*
#                                                                              *
#  M E T H O D    I N V O C A T I O N                                          *
#                                                                              *
#------------------------------------------------------------------------------*

routine templateMethodInvocation
  ??@goilTemplateType inType
  ??@goilTemplateValue inValue
  ??@lstring inMethodName
  ??@goilTemplateExpressionList inParameterTypeList
  !@goilTemplateType outResultType
  !@goilTemplateValue outResultValue
:
  switch inType
  when boolType :
    if [inMethodName string] == "string" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList ;
      outResultType := [@goilTemplateType stringType] ;
      outResultValue := valueWithString [
        ! if [inValue mUnsigned64Value] > 0L then "true" else "false" end
      ] ;
    elsif [inMethodName string] == "unsigned" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList ;
      outResultType := [@goilTemplateType unsignedType] ;
      outResultValue := inValue ;
    else
      error inMethodName: "this template method is not defined" ->outResultValue, outResultType ;
    end if ;
  when unsignedType :
    if [inMethodName string] == "string" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList ;
      outResultType := [@goilTemplateType stringType] ;
      outResultValue := valueWithString [![[inValue mUnsigned64Value] string]] ;
    elsif [inMethodName string] == "hexString" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList ;
      outResultType := [@goilTemplateType stringType] ;
      outResultValue := valueWithString [![[inValue mUnsigned64Value] hexString]] ;
    else
      error inMethodName: "this template method is not defined" ->outResultValue, outResultType ;
    end if ;
  when stringType :
    if [inMethodName string] == "HTMLRepresentation" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList ;
      outResultType := [@goilTemplateType stringType] ;
      outResultValue := valueWithString [![[inValue mStringValue] HTMLRepresentation]] ;
    elsif [inMethodName string] == "identifierRepresentation" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList ;
      outResultType := [@goilTemplateType stringType] ;
      outResultValue := valueWithString [![[inValue mStringValue] identifierRepresentation]] ;
    elsif [inMethodName string] == "lowercaseString" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList ;
      outResultType := [@goilTemplateType stringType] ;
      outResultValue := valueWithString [![[inValue mStringValue] lowercaseString]] ;
    elsif [inMethodName string] == "length" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList ;
      outResultType := [@goilTemplateType unsignedType] ;
      outResultValue := valueWithUnsigned [![[[inValue mStringValue] length] uint64]] ;
    elsif [inMethodName string] == "stringByCapitalizingFirstCharacter" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList ;
      outResultType := [@goilTemplateType stringType] ;
      outResultValue := valueWithString [![[inValue mStringValue] stringByCapitalizingFirstCharacter]] ;
    elsif [inMethodName string] == "uppercaseString" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList ;
      outResultType := [@goilTemplateType stringType] ;
      outResultValue := valueWithString [![[inValue mStringValue] uppercaseString]] ;
    else
      error inMethodName: "this template method is not defined" ->outResultValue, outResultType ;
    end if ;
  when listType :
    if [inMethodName string] == "length" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList ;
      outResultType := [@goilTemplateType unsignedType] ;
      outResultValue := valueWithUnsigned [![[[inValue mMapListValue] length] uint64]] ;
    else
      error inMethodName: "this template method is not defined" ->outResultValue, outResultType ;
    end if ;
  end switch ;
end routine ;

#------------------------------------------------------------------------------*
#                                                                              *
#   E X P R E S S I O N                                                        *
#                                                                              *
#------------------------------------------------------------------------------*

rule <expression>
  ??@string inPrefix
  ??@string inPath
  ??@systemConfig inCfg
  ??@goilTemplateVariableMap inVariableMap
  !@goilTemplateValue outValue
  !@goilTemplateType outResultType
:
  <relation_term>
    !inPrefix
    !inPath
    !inCfg
    !inVariableMap
    ?outValue
    ?outResultType
  ;
  repeat
  while
    $|$ ;
    @goilTemplateValue leftOperand := outValue ;
    @goilTemplateValue rightOperand ;
    @goilTemplateType firstOperandType := outResultType ;
    @goilTemplateType secondOperandType ;
    <relation_term>
      !inPrefix
      !inPath
      !inCfg
      !inVariableMap
      ?rightOperand
      ?secondOperandType
    ;
    outValue.mUnsigned64Value := [leftOperand mUnsigned64Value] | [rightOperand mUnsigned64Value] ;
    matchOrOperatorForTemplate
      !firstOperandType
      !secondOperandType
      ?outResultType
     ;
  while
    $^$ ;
    @goilTemplateValue leftOperand := outValue ;
    @goilTemplateValue rightOperand ;
    @goilTemplateType firstOperandType := outResultType ;
    @goilTemplateType secondOperandType ;
    <relation_term>
      !inPrefix
      !inPath
      !inCfg
      !inVariableMap
      ?rightOperand
      ?secondOperandType
    ;
    outValue.mUnsigned64Value := [leftOperand mUnsigned64Value] ^ [rightOperand mUnsigned64Value] ;
    matchXorOperatorForTemplate
      !firstOperandType
      !secondOperandType
      ?outResultType
     ;
  end repeat ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   R E L A T I O N    T E R M                                                 *
#                                                                              *
#------------------------------------------------------------------------------*

rule <relation_term>
  ??@string inPrefix
  ??@string inPath
  ??@systemConfig inCfg
  ??@goilTemplateVariableMap inVariableMap
  !@goilTemplateValue outValue
  !@goilTemplateType outResultType
:
  <relation_factor>
    !inPrefix
    !inPath
    !inCfg
    !inVariableMap
    ?outValue
    ?outResultType
  ;
  repeat
  while
    $&$ ;
    @goilTemplateValue leftOperand := outValue ;
    @goilTemplateValue rightOperand ;
    @goilTemplateType firstOperandType := outResultType ;
    @goilTemplateType secondOperandType ;
    <relation_factor>
      !inPrefix
      !inPath
      !inCfg
      !inVariableMap
      ?rightOperand
      ?secondOperandType
    ;
    outValue.mUnsigned64Value := [leftOperand mUnsigned64Value] & [rightOperand mUnsigned64Value] ;
    matchAndOperatorForTemplate
      !firstOperandType
      !secondOperandType
      ?outResultType
    ;
  end repeat ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   R E L A T I O N    F A C T O R                                             *
#                                                                              *
#------------------------------------------------------------------------------*

rule <relation_factor>
  ??@string inPrefix
  ??@string inPath
  ??@systemConfig inCfg
  ??@goilTemplateVariableMap inVariableMap
  !@goilTemplateValue outValue
  !@goilTemplateType outResultType
:
  <simple_expression>
    !inPrefix
    !inPath
    !inCfg
    !inVariableMap
    ?outValue
    ?outResultType
  ;
  select
  or
    $==$ ;
    @goilTemplateValue leftExpression := outValue ;
    @goilTemplateType leftType := outResultType ;
    @goilTemplateValue rightExpression ;
    @goilTemplateType rightType ;
    <simple_expression>
      !inPrefix
      !inPath
      !inCfg
      !inVariableMap
      ?rightExpression
      ?rightType ;
    comparison_types_checkForTemplate !leftType !rightType ;
    @bool result ;
    switch leftType
    when boolType :
      result := [leftExpression mUnsigned64Value] == [rightExpression mUnsigned64Value] ;
    when unsignedType :
      result := [leftExpression mUnsigned64Value] == [rightExpression mUnsigned64Value] ;
    when stringType, listType :
      result := [leftExpression mStringValue] == [rightExpression mStringValue] ;
    end switch ;
    outResultType := [@goilTemplateType boolType] ;
    outValue.mUnsigned64Value := if result then 1L else 0L end ;
  or
    $!=$ ;
    @goilTemplateValue leftExpression := outValue ;
    @goilTemplateType leftType := outResultType ;
    @goilTemplateValue rightExpression ;
    @goilTemplateType rightType ;
    <simple_expression>
      !inPrefix
      !inPath
      !inCfg
      !inVariableMap
      ?rightExpression
      ?rightType
    ;
    comparison_types_checkForTemplate !leftType !rightType ;
    @bool result ;
    switch leftType
    when boolType :
      result := [leftExpression mUnsigned64Value] != [rightExpression mUnsigned64Value] ;
    when unsignedType :
      result := [leftExpression mUnsigned64Value] != [rightExpression mUnsigned64Value] ;
    when stringType, listType :
      result := [leftExpression mStringValue] != [rightExpression mStringValue] ;
    end switch ;
    outResultType := [@goilTemplateType boolType] ;
    outValue.mUnsigned64Value := if result then 1L else 0L end ;
  or
    $<=$ ;
    @goilTemplateValue leftExpression := outValue ;
    @goilTemplateType leftType := outResultType ;
    @goilTemplateValue rightExpression ;
    @goilTemplateType rightType ;
    <simple_expression>
      !inPrefix
      !inPath
      !inCfg
      !inVariableMap
      ?rightExpression
      ?rightType
    ;
    magnitude_comparison_types_checkForTemplate !leftType !rightType ;
    @bool result ;
    switch leftType
    when boolType :
      result := [leftExpression mUnsigned64Value] <= [rightExpression mUnsigned64Value] ;
    when unsignedType :
      result := [leftExpression mUnsigned64Value] <= [rightExpression mUnsigned64Value] ;
    when stringType, listType :
      result := false ;
    end switch ;
    outResultType := [@goilTemplateType boolType] ;
    outValue.mUnsigned64Value := if result then 1L else 0L end ;
  or
    $>=$ ;
    @goilTemplateValue leftExpression := outValue ;
    @goilTemplateType leftType := outResultType ;
    @goilTemplateValue rightExpression ;
    @goilTemplateType rightType ;
    <simple_expression>
      !inPrefix
      !inPath
      !inCfg
      !inVariableMap
      ?rightExpression
      ?rightType
    ;
    magnitude_comparison_types_checkForTemplate !leftType !rightType ;
    @bool result ;
    switch leftType
    when boolType :
      result := [leftExpression mUnsigned64Value] >= [rightExpression mUnsigned64Value] ;
    when unsignedType :
      result := [leftExpression mUnsigned64Value] >= [rightExpression mUnsigned64Value] ;
    when stringType, listType :
      result := false ;
    end switch ;
    outResultType := [@goilTemplateType boolType] ;
    outValue.mUnsigned64Value := if result then 1L else 0L end ;
  or
    $>$ ;
    @goilTemplateValue leftExpression := outValue ;
    @goilTemplateType leftType := outResultType ;
    @goilTemplateValue rightExpression ;
    @goilTemplateType rightType ;
    <simple_expression>
      !inPrefix
      !inPath
      !inCfg
      !inVariableMap
      ?rightExpression
      ?rightType
    ;
    magnitude_comparison_types_checkForTemplate !leftType !rightType ;
    @bool result ;
    switch leftType
    when boolType :
      result := [leftExpression mUnsigned64Value] > [rightExpression mUnsigned64Value] ;
    when unsignedType :
      result := [leftExpression mUnsigned64Value] > [rightExpression mUnsigned64Value] ;
    when stringType, listType :
      result := false ;
    end switch ;
    outResultType := [@goilTemplateType boolType] ;
    outValue.mUnsigned64Value := if result then 1L else 0L end ;
  or
    $<$ ;
    @goilTemplateValue leftExpression := outValue ;
    @goilTemplateType leftType := outResultType ;
    @goilTemplateValue rightExpression ;
    @goilTemplateType rightType ;
    <simple_expression>
      !inPrefix
      !inPath
      !inCfg
      !inVariableMap
      ?rightExpression
      ?rightType
    ;
    magnitude_comparison_types_checkForTemplate !leftType !rightType ;
    @bool result ;
    switch leftType
    when boolType :
      result := [leftExpression mUnsigned64Value] < [rightExpression mUnsigned64Value] ;
    when unsignedType :
      result := [leftExpression mUnsigned64Value] < [rightExpression mUnsigned64Value] ;
    when stringType, listType :
      result := false ;
    end switch ;
    outResultType := [@goilTemplateType boolType] ;
    outValue.mUnsigned64Value := if result then 1L else 0L end ;
  end select ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   S I M P L E    E X P R E S S I O N                                         *
#                                                                              *
#------------------------------------------------------------------------------*

rule <simple_expression>
  ??@string inPrefix
  ??@string inPath
  ??@systemConfig inCfg
  ??@goilTemplateVariableMap inVariableMap
  !@goilTemplateValue outValue
  !@goilTemplateType outResultType
:
  <term>
    !inPrefix
    !inPath
    !inCfg
    !inVariableMap
    ?outValue
    ?outResultType
  ;
  repeat
  while 
    $<<$ ;
    @goilTemplateValue leftExpression := outValue ;
    @goilTemplateType leftType := outResultType ;
    @goilTemplateValue rightExpression ;
    @goilTemplateType rightType ;
    <term>
      !inPrefix
      !inPath
      !inCfg
      !inVariableMap
      ?rightExpression
      ?rightType
    ;
    left_shift_types_checkForTemplate !leftType !rightType ?outResultType ;
    outValue.mUnsigned64Value := [leftExpression mUnsigned64Value] << [[rightExpression mUnsigned64Value] uint] ;
  while 
    $>>$ ;
    @goilTemplateValue leftExpression := outValue ;
    @goilTemplateType leftType := outResultType ;
    @goilTemplateValue rightExpression ;
    @goilTemplateType rightType ;
    <term>
      !inPrefix
      !inPath
      !inCfg
      !inVariableMap
      ?rightExpression
      ?rightType
    ;
    right_shift_types_checkForTemplate !leftType !rightType ?outResultType ;
    outValue.mUnsigned64Value := [leftExpression mUnsigned64Value] >> [[rightExpression mUnsigned64Value] uint] ;
  while 
    $+$ ;
    @goilTemplateValue leftExpression := outValue ;
    @goilTemplateType leftType := outResultType ;
    @goilTemplateValue rightExpression ;
    @goilTemplateType rightType ;
    <term>
      !inPrefix
      !inPath
      !inCfg
      !inVariableMap
      ?rightExpression
      ?rightType
    ;
    addition_types_checkForTemplate !leftType !rightType ?outResultType ;
    outValue.mUnsigned64Value := [leftExpression mUnsigned64Value] + [rightExpression mUnsigned64Value] ;
  while 
    $-$ ;
    @goilTemplateValue leftExpression := outValue ;
    @goilTemplateType leftType := outResultType ;
    @goilTemplateValue rightExpression ;
    @goilTemplateType rightType ;
    <term>
      !inPrefix
      !inPath
      !inCfg
      !inVariableMap
      ?rightExpression
      ?rightType
    ;
    addition_types_checkForTemplate !leftType !rightType ?outResultType ;
    outValue.mUnsigned64Value := [leftExpression mUnsigned64Value] - [rightExpression mUnsigned64Value] ;
  end repeat ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   T E R M                                                                    *
#                                                                              *
#------------------------------------------------------------------------------*

rule <term>
  ??@string inPrefix
  ??@string inPath
  ??@systemConfig inCfg
  ??@goilTemplateVariableMap inVariableMap
  !@goilTemplateValue outValue
  !@goilTemplateType outResultType
:
  <factor>
    !inPrefix
    !inPath
    !inCfg
    !inVariableMap
    ?outValue
    ?outResultType
  ;
  repeat
  while 
    $*$ ;
    @goilTemplateValue leftExpression := outValue ;
    @goilTemplateType leftType := outResultType ;
    @goilTemplateValue rightExpression ;
    @goilTemplateType rightType ;
    <factor>
      !inPrefix
      !inPath
      !inCfg
      !inVariableMap
      ?rightExpression
      ?rightType
    ;
    multiply_types_checkForTemplate !leftType !rightType ?outResultType ;
    outValue.mUnsigned64Value := [leftExpression mUnsigned64Value] * [rightExpression mUnsigned64Value] ;
  while 
    $/$ ;
    @goilTemplateValue leftExpression := outValue ;
    @goilTemplateType leftType := outResultType ;
    @goilTemplateValue rightExpression ;
    @goilTemplateType rightType ;
    <factor>
      !inPrefix
      !inPath
      !inCfg
      !inVariableMap
      ?rightExpression
      ?rightType
    ;
    divide_types_checkForTemplate !leftType !rightType ?outResultType ;
    outValue.mUnsigned64Value := [leftExpression mUnsigned64Value] / [rightExpression mUnsigned64Value] ;
  while 
    $mod$ ;
    @goilTemplateValue leftExpression := outValue ;
    @goilTemplateType leftType := outResultType ;
    @goilTemplateValue rightExpression ;
    @goilTemplateType rightType ;
    <factor>
      !inPrefix
      !inPath
      !inCfg
      !inVariableMap
      ?rightExpression
      ?rightType
    ;
    modulo_types_checkForTemplate !leftType !rightType ?outResultType ;
    outValue.mUnsigned64Value := [leftExpression mUnsigned64Value] mod [rightExpression mUnsigned64Value] ;
  end repeat ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    ( EXPRESSION )                                         *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@string inPrefix
  ??@string inPath
  ??@systemConfig inCfg
  ??@goilTemplateVariableMap inVariableMap
  !@goilTemplateValue outValue
  !@goilTemplateType outResultType
:
  $($ ;
  <expression>
    !inPrefix
    !inPath
    !inCfg
    !inVariableMap
    ?outValue
    ?outResultType
  ;
  $)$ ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    not FACTOR                                             *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@string inPrefix
  ??@string inPath
  ??@systemConfig inCfg
  ??@goilTemplateVariableMap inVariableMap
  !@goilTemplateValue outValue
  !@goilTemplateType outResultType
:
  $not$ ;
  @goilTemplateValue expression ;
  @goilTemplateType operandType ;
  <factor>
    !inPrefix
    !inPath
    !inCfg
    !inVariableMap
    ?expression
    ?operandType
  ;
  outValue := [@goilTemplateValue new
    !1L - [expression mUnsigned64Value]
    !""
    ![@goilTemplateFieldMapList emptyList]
  ] ;
  checkNotOperatorForTemplate !operandType ?outResultType ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    ~ FACTOR                                               *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@string inPrefix
  ??@string inPath
  ??@systemConfig inCfg
  ??@goilTemplateVariableMap inVariableMap
  !@goilTemplateValue outValue
  !@goilTemplateType outResultType
:
  $~$ ;
  @goilTemplateValue value ;
  @goilTemplateType operandType ;
  <factor>
    !inPrefix
    !inPath
    !inCfg
    !inVariableMap
    ?value
    ?operandType
  ;
  outValue := [@goilTemplateValue new
    !~ [value mUnsigned64Value]
    !""
    ![@goilTemplateFieldMapList emptyList]
  ] ;
  checkBitComplementOperatorForTemplate !operandType ?outResultType ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    true                                                   *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@string unused inPrefix
  ??@string unused inPath
  ??@systemConfig unused inCfg
  ??@goilTemplateVariableMap unused inVariableMap
  !@goilTemplateValue outValue
  !@goilTemplateType outResultType
:
  $yes$ ;
  outValue := [@goilTemplateValue new
    !1L
    !""
    ![@goilTemplateFieldMapList emptyList]
  ] ;
  outResultType := [@goilTemplateType boolType] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    false                                                  *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@string unused inPrefix
  ??@string unused inPath
  ??@systemConfig unused inCfg
  ??@goilTemplateVariableMap unused inVariableMap
  !@goilTemplateValue outValue
  !@goilTemplateType outResultType
:
  $no$ ;
  outValue := [@goilTemplateValue new
    !0L
    !""
    ![@goilTemplateFieldMapList emptyList]
  ] ;
  outResultType := [@goilTemplateType boolType] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    a 64-bit unsigned literal integer value                *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@string unused inPrefix
  ??@string unused inPath
  ??@systemConfig unused inCfg
  ??@goilTemplateVariableMap unused inVariableMap
  !@goilTemplateValue outValue
  !@goilTemplateType outResultType
:
  @luint64 literalInt ;
  $unsigned_literal_integer64$ ?literalInt ;
  outValue := [@goilTemplateValue new
    ![literalInt uint64]
    !""
    ![@goilTemplateFieldMapList emptyList]
  ] ;
  outResultType := [@goilTemplateType unsignedType] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    a literal string value                                 *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@string unused inPrefix
  ??@string unused inPath
  ??@systemConfig unused inCfg
  ??@goilTemplateVariableMap unused inVariableMap
  !@goilTemplateValue outValue
  !@goilTemplateType outResultType
:
  $string$ ?@lstring literalString ;
  outValue := [@goilTemplateValue new
    !0L
    ![literalString string]
    ![@goilTemplateFieldMapList emptyList]
  ] ;
  outResultType := [@goilTemplateType stringType] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#                         F A C T O R                                          *
#   template method call :   [expression method !... ]                         *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@string inPrefix
  ??@string inPath
  ??@systemConfig inCfg
  ??@goilTemplateVariableMap inVariableMap
  !@goilTemplateValue outValue
  !@goilTemplateType outResultType
:
  $[$ ;

  @goilTemplateValue expressionValue ;
  @goilTemplateType expressionType ;
  <expression>
    !inPrefix
    !inPath
    !inCfg
    !inVariableMap
    ?expressionValue
    ?expressionType
  ;

  $identifier$ ? @lstring templateMethodName ;

  @goilTemplateExpressionList expressionList [emptyList] ;
  select
  or
    $:$ ;
    repeat
      @goilTemplateValue expression ;
      @goilTemplateType resultType ;
      <expression>
        !inPrefix
        !inPath
        !inCfg
        !inVariableMap
        ?expression
        ?resultType
      ;
      expressionList += !expression !resultType ;
    while
      $,$ ;
    end repeat ;
  end select ;

  $]$ ;

  templateMethodInvocation
    !expressionType
    !expressionValue
    !templateMethodName
    !expressionList
    ?outResultType
    ?outValue
  ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#                         F A C T O R                                          *
#   function call        :   function_name (..., ...)                          *
#   variable             :   variable_name                                     *
#                                                                              *
#------------------------------------------------------------------------------*

routine typeError
  ??@lstring inFunctionName
  ??@type inActualType
  ??@string inExpectedTypeName
  ??@uint inParameterIndex
:
  @string m := "the function requires the parameter " . [inParameterIndex string]
  . " to be " . inExpectedTypeName . "; its type is "
  ;
  if inActualType == `@bool then
    m .= "boolean" ;
  elsif inActualType == `@uint64 then
    m .= "unsigned" ;
  elsif inActualType == `@string then
    m .= "string" ;
  else
    m .= "a not allowed type" ;
  end if ;
  error inFunctionName : m ;
end routine ;

#------------------------------------------------------------------------------*

rule <factor>
  ??@string inPrefix
  ??@string inPath
  ??@systemConfig inCfg
  ??@goilTemplateVariableMap inVariableMap
  !@goilTemplateValue outValue
  !@goilTemplateType outResultType
:
#--- Function call
  $identifier$ ?@lstring functionOrVariableName ;
  select
    [inVariableMap searchKey !functionOrVariableName ?outResultType ?outValue] ;
  or
  #--- Search for function name
    @function f ;
    if not [@function isFunctionDefined ![functionOrVariableName string]] then
      error functionOrVariableName : "there is no '" . functionOrVariableName . "' function defined in GOIL run time" ->f ;
    else
      f := [@function functionWithName ![functionOrVariableName string]] ;
    end if ;
  #--- Parse actual arguments
    @goilTemplateExpressionList actualArgumentList [emptyList] ;
    $($ ;
    repeat
      @goilTemplateValue expression ;
      @goilTemplateType resultType ;
      <expression>
        !inPrefix
        !inPath
        !inCfg
        !inVariableMap
        ?expression
        ?resultType
      ;
      actualArgumentList += !expression !resultType ;
    while
      $,$ ;
    end repeat ;
    $)$ ;
  #--- Check arguments
    @objectlist actualArgumentObjectList [emptyList] ;
    # The functions a template may call have an implicit first argument which is
    # the inCfg (ie an object embedding all the system configuration and allow the
    # function to retrieve the informations. So it is remove from the parameter
    # list before checking the actual parameter list against the formal parameter list.
    @typelist completeFormalParameterList := [f formalParameterTypeList];
    @type firstParamType;
    [!?completeFormalParameterList popFirst ?firstParamType];
    if firstParamType != `@systemConfig then
      error functionOrVariableName:"Internal error, this function does not have a @systemConfig as first argument";
    end if ;
    const @typelist formalParameterList := completeFormalParameterList ;
    if [formalParameterList length] != [actualArgumentList length] then
      error functionOrVariableName: "this function is invoked with "
      . [[actualArgumentList length] string]
      . " parameter" . if [actualArgumentList length] > 1 then "s" else "" end
      . ", but requires " 
      . [[formalParameterList length] string]
      . " parameter" . if [formalParameterList length] > 1 then "s" else "" end
      -> outValue, outResultType ;
    else
      @uint idx := 1 ;
      foreach formalParameterList prefixedby formal_, actualArgumentList prefixedby actual_ do
        switch actual_mType
        when boolType :
          if formal_mValue != `@bool then
            typeError !functionOrVariableName !formal_mValue !"boolean" !idx ;
          end if ;
          actualArgumentObjectList += ![if [actual_mValue mUnsigned64Value] == 0L then false else true end object] ;
        when unsignedType :
          if formal_mValue != `@uint64 then
            typeError !functionOrVariableName !formal_mValue !"unsigned" !idx ;
          end if ;
          actualArgumentObjectList += ![[actual_mValue mUnsigned64Value] object] ;
        when stringType :
          if formal_mValue != `@string then
            typeError !functionOrVariableName !formal_mValue !"string" !idx ;
          end if ;
          actualArgumentObjectList += ![[actual_mValue mStringValue] object] ;
        when listType :
          typeError !functionOrVariableName !formal_mValue !"string" !idx ;
        end switch ;
        idx ++ ;     
      end foreach ;
      outResultType := [@goilTemplateType unsignedType] ;
      outValue := [@goilTemplateValue new !0L !"" ![@goilTemplateFieldMapList emptyList]] ;
      if [@uint errorCount] == 0 then
        const @object result := [f invoke ![@objectlist listWithValue ![inCfg object]] . actualArgumentObjectList ![functionOrVariableName location]] ;
        if [result objectStaticType] == `@uint64 then
          outResultType := [@goilTemplateType unsignedType] ;
          outValue.mUnsigned64Value := (cast result if == @uint64 else error functionOrVariableName) ;
        elsif [result objectStaticType] == `@bool then
          outResultType := [@goilTemplateType boolType] ;
          outValue.mUnsigned64Value := [(cast result if == @bool else error functionOrVariableName) uint64] ;
        elsif [result objectStaticType] == `@string then
          outResultType := [@goilTemplateType stringType] ;
          outValue.mStringValue := (cast result if == @string else error functionOrVariableName) ;
        else
          error functionOrVariableName : "this function does not return an unsigned, boolean or string value" ;
        end if ;
      end if ;
    end if ;
  end select ;
end rule ;

#------------------------------------------------------------------------------*

end syntax ;
