semantics goil_semantics :

import option goil_options in "goil_options.ggs" ;

list @number_list {
    @luint64 number ;
}

abstract class @number_set {}

class @uint_range extends @number_set {
    @luint64 first ;
    @luint64 last ;
}

class @uint_list extends @number_set {
    @number_list numbers ;
}

map @implementationSpec {
    @lstring type ;
}

map @implementation {
    @implementationSpec spec ;
    insert insertSpec error message "%K is duplicated in %L";
}

action generateHeader
    ?@lstring version
    ?@lstring description
;

map @os_imp {
    @lstring type ;
    
}

abstract class @oil_obj {
    @lstring description ;
	reader get_description !@lstring desc :
		desc := description ;
	end reader ;
}

#
# Map to store string constants used
# for code generation
#
map @prefix_map {
    @string prefix ;
    @string tag_to_rep ;
    insert insert_prefix error message "prefix %K duplicated %L" ;
    search prefix error message "prefix %K is not defined" ;
}

#
# Task classes
#
abstract class @task_autostart_obj {
}

class @task_autostart_void extends @task_autostart_obj {
}

class @task_autostart_false extends @task_autostart_obj {
}

class @task_autostart_true extends @task_autostart_obj {
	@stringset appmodes ;
}

class @task_obj extends @oil_obj {
	@luint64 priority ;
	@lstring schedule ;
	@luint64 activation ;
	@task_autostart_obj autostart ;
	@stringset resources ;
	@stringset events;
	
	reader get_resources !@stringset out_resources :
		out_resources := resources ;
	end reader ;

	reader get_events !@stringset out_events :
		out_events := events ;
	end reader ;

}

map @task_map {
	@task_obj task ;
    insert insertTask error message "Task %K is already defined in %L" ;
} 

#
# Resource classes
#

abstract class @resource_property_obj {
}

class @resource_property_standard_obj extends @resource_property_obj {
}

class @resource_property_linked_obj extends @resource_property_obj {
	@lstring linked_resource ;
}

class @resource_property_internal_obj extends @resource_property_obj {
}

class @resource_obj extends @oil_obj {
	@resource_property_obj resource_property ;
	
	reader get_property !@resource_property_obj out :
		out := resource_property;
	end reader ;
}

map @resource_map {
	@resource_obj resource ;
	insert insertResource error message "Resource %K is already defined in %L" ;
	search getResource error message "Resource %K is not defined" ;
}

map @linked_resources {
	@lstring linked_resource ;
	insert insertLinked error message "Resource %K (%L) is part of a cycle of linked resources" ;
}

#
# Event classes
#
abstract class @event_mask_obj {
}

class @event_mask_user_obj extends @event_mask_obj {
	@luint64 mask ;
}

class @event_mask_auto_obj extends @event_mask_obj {
}

class @event_obj extends @oil_obj {
	@event_mask_obj mask ;

	reader get_mask !@event_mask_obj out_mask :
		out_mask := mask ;
	end reader ;
}

map @event_map {
	@event_obj event ;
	insert insertEvent error message "Event %K is already defined in %L" ;
}

#
# Alarm classes
#
abstract class @action_obj {}
abstract class @autostart_obj {}

class @void_action extends @action_obj {
}

class @setevent_action extends @action_obj {
    @lstring task_name ;
    @lstring event_name ;
}

class @activatetask_action extends @action_obj {
    @lstring task_name ;
}

class @callback_action extends @action_obj {
    @lstring function_name ;
}

class @autostart_void extends @autostart_obj {
}

class @autostart_true_params extends @autostart_obj {
    @luint64   alarm_time ;
    @luint64   cycle_time ;
    @stringset app_modes ;
}

class @alarm_obj extends @oil_obj {
    @lstring        counter_name ;
    @action_obj     action_params ;
    @autostart_obj  autostart_params ;

    reader get_action !@action_obj out_action :
        out_action := action_params ;
    end reader ;

    reader get_autostart !@autostart_obj out_autostart :
        out_autostart := autostart_params ;
    end reader ;

    reader get_counter !@lstring out_counter :
        out_counter := counter_name ;
    end reader ;
}

map @alarm_map {
    @alarm_obj  alarm ;
    insert insertAlarm error message "Alarm %K is duplicated in %L";
}

action generateAlarms ?@alarm_map alarms ;
#
# ISR classes
#

class @isr_obj extends @oil_obj {
    @luint64   category ;
    @stringset resources ;
    @stringset messages ;
}

map @isr_map {
    @isr_obj isr ;
    insert insertISR error message "ISR %K is duplicated in %L" ;
}

#
# Counter classes
#

class @counter_obj extends @oil_obj {
    @luint64 max_allowed_value ;
    @luint64 ticks_per_base ;
    @luint64 min_cycle ;
}

map @counter_map {
    @counter_obj counter ;
    insert insertCounter error message "Counter %K is duplicated in %L" ;
}

#
# Semantics routine
#

# Each linked resource chain must finish with a STANDARD resource
# Buggy ? : the "Cycle detected" error is printed many times (expected: one)
routine resolve_linked_resources 
	?!@resource_map resources
:
	@resource_map resolved [emptyMap] ;
	@resource_map unresolved := resources ;
	@resource_map unresolved_next [emptyMap] ;
	@bool first_loop := true ;

	loop [unresolved count] - [unresolved_next count] :
		if (first_loop) then first_loop := false ;
		else 
			unresolved := unresolved_next ;
			unresolved_next := [@resource_map emptyMap] ;
		end if ;
	while ([unresolved count] > 0) do 
		foreach unresolved (@lstring res_key @resource_obj res) :

			@resource_property_obj res_prop ;
			[res get_property ?res_prop] ;
			extract res_prop :

				#current resource is a linked resource : we try to resolve it
				when @resource_property_linked_obj (@lstring linked_key) ->

					#target is in resolved : we (try to) resolve
					if( [resolved hasKey ![linked_key string]] ) then
						@resource_obj target_resource ;
						@resource_property_obj target_property ;
						[resolved getResource !linked_key ?target_resource] ;
						[target_resource get_property ?target_property] ;
						extract target_property :

							#linked to a standard resource : ok
							when @resource_property_standard_obj ( ) -> [!?resolved insertResource !res_key !res] ;

							#linked to an internal resource : error
							when @resource_property_internal_obj ( ) -> 
								error here : "RESOURCE " . [res_key string] . " is linked to INTERNAL RESOURCE " . [linked_key string];

							#linked to a resolved linked resource : we resolve current resource, with a direct link to the standard resource
							when @resource_property_linked_obj (@lstring standard_key) ->
								@resource_property_linked_obj resolved_prop := [@resource_property_linked_obj new !standard_key] ;
								@lstring resolved_desc ;
								[res get_description ?resolved_desc] ;
								@resource_obj resolved_res := [@resource_obj new !resolved_desc !resolved_prop] ;
								[!?resolved insertResource !res_key !resolved_res] ;
							else
						end extract ;

					#target not in resolved : we put current resource in unresolved
					else
						[!?unresolved_next insertResource !res_key !res] ;
					end if ;

				#standard or internal resource : resolved
				else [!?resolved insertResource !res_key !res] ;
			end extract ;
		end foreach ;
		if ([unresolved count] == [unresolved_next count])
		then
			error here : "Cycle detected in linked resource" ;
			foreach unresolved_next (@lstring unresolved_key *) :
				error unresolved_key : "Involved in cycle" ;
			end foreach ;
		end if;
	end loop ;

	resources := resolved ;
end routine ;

routine all_events_and_resources_defined_and_used 
	?@task_map tasks
	?@event_map events
	?@resource_map resources
:
	@stringset used_events [emptySet] ;
	@stringset used_resources [emptySet] ;

	#Events and resources referenced in a task are defined
	foreach tasks (@lstring task_name @task_obj task) :

		#all referenced events must be defined
		@stringset task_events ;
		[task get_events ?task_events] ;
		foreach task_events (@string event_name) :
			used_events += !event_name ;
			if (not [events hasKey !event_name])
			then error task_name : "EVENT " . event_name . " is not defined" ;
			end if ;
		end foreach ;

		#all referenced resources must be defined
		@stringset task_resources ;
		[task get_resources ?task_resources] ;
		foreach task_resources (@string res_name) :
			used_resources += !res_name ;
			if (not [resources hasKey !res_name])
			then error task_name : "RESOURCE " . res_name . " is not defined" ;
			end if ;
		end foreach ;

	end foreach ;

	#all defined events should be referenced in a task
	foreach events (@lstring event_key *) :
		if (not [used_events hasKey ![event_key string]])
		then warning event_key : "EVENT " . [event_key string] . " is defined but never used" ;
		end if ;
	end foreach ;

	#all defined resources should be referenced in a task
	foreach resources (@lstring res_key *) :
		if (not [used_resources hasKey ![res_key string]])
		then warning res_key : "RESOURCE " . [res_key string] . " is defined but never used" ;
		end if ;
	end foreach ;

end routine ;

routine all_event_masks_different
	?@event_map events 
:
	@stringset defined_masks [emptySet] ;
	foreach events (@lstring event_name @event_obj event) :
		@event_mask_obj mask ;
		[event get_mask ?mask] ;
		extract mask :
			when @event_mask_user_obj (@luint64 mask_value) -> 
				@string mask_in_string := [[mask_value uint64] string] ;
				if [defined_masks hasKey !mask_in_string]
				then warning event_name : "Mask " . mask_in_string . " already used" ;
				else defined_masks += !mask_in_string ;
				end if ;
			else
		end extract ;
	end foreach ;
end routine ;

#--------------------------------------------------------------------
# Code generation routines
#--------------------------------------------------------------------
#routine target !@string target_platform :
#    target_platform := [option goil_options.target_platform] ;
#end routine ;

routine template !@string template ?@string obj :
    @string target_platform := "ppc" ;
    @string targ_tpl := "" ;

# Get the platform
#    target ?target_platform ;

# Look for a template in target plateform path
    targ_tpl := "../templates/".target_platform."/".obj.".tpl" ;
    if [targ_tpl fileExists]
    then template := [@string stringWithContentsOfFile !targ_tpl] ;
    else

# then in the all_targets path
        targ_tpl := "../templates/all_targets/".obj.".tpl" ;
        if [targ_tpl fileExists]
        then template := [@string stringWithContentsOfFile !targ_tpl] ;
             message "found template in all_targets\n" ;
        else template := "" ;
             error here: "No template found" ;
        end if ;
    end if;
end routine ;

routine prefix ?@prefix_map p ?@string key !@string val :
    @lstring lkey := [@lstring new !key !here] ;
    [p prefix !lkey ?val ?*] ;
end routine ;

routine replace ?@prefix_map p ?@string key ?@string name ?!@string res :
    @lstring lkey := [@lstring new !key !here] ;
    @string prefix ;
    @string tag_to_rep ;
    [p prefix !lkey ?prefix ?tag_to_rep] ;
    res := [res stringByReplacingStringByString !tag_to_rep !prefix.name] ;
end routine ;

routine generate_alarms ?@alarm_map alarms ?@prefix_map p ?!@string header ?!@string implementation :
    @string tpl_alarm_setevent ;
    @string tpl_alarm_activatetask ;
    @string tpl_alarm_callback ;

    @string alarms_result := "" ;

    template ?tpl_alarm_setevent     !"alarm_event_set" ;
    template ?tpl_alarm_activatetask !"alarm_task_act" ;
    template ?tpl_alarm_callback     !"alarm_callback" ;

    foreach alarms (@lstring alarm_name @alarm_obj alarm) :
        @string result := "" ;

# sets up the kind of alarm and its action
        @action_obj alarm_action ;
        [alarm get_action ?alarm_action] ;
        extract alarm_action :
        when @setevent_action (@lstring task_name @lstring event_name) ->
            result := tpl_alarm_setevent ;
            replace !p !"task"  ![task_name string] !?result ;
            replace !p !"event" ![event_name string] !?result ;
        when @activatetask_action (@lstring task_name) ->
            result := tpl_alarm_activatetask ;
            replace !p !"task" ![task_name string] !?result ;
        when @callback_action (@lstring function_name) ->
            result := tpl_alarm_callback ;
            replace !p !"callback" ![function_name string] !?result ;
        else error alarm_name : "Unknown action found" ;
        end extract ;

# sets up the autostart params
        @autostart_obj autostart ;
        [alarm get_autostart ?autostart] ;
        extract autostart :
        when @autostart_void () ->
            result := [result stringByReplacingStringByString !"$ALARM_STATE$" !"ALARM_SLEEP"] ;
            result := [result stringByReplacingStringByString !"$ALARM_CYCLE$" !"0"] ;
            result := [result stringByReplacingStringByString !"$ALARM_DATE$" !"0"] ;
        when @autostart_true_params (@luint64 alarm_time @luint64 cycle_time *) ->
            result := [result stringByReplacingStringByString !"$ALARM_STATE$" !"ALARM_AUTOSTART"] ;
            result := [result stringByReplacingStringByString !"$ALARM_CYCLE$" ![[cycle_time uint64] string]] ;
            result := [result stringByReplacingStringByString !"$ALARM_DATE$" ![[alarm_time uint64] string]] ;
        else error alarm_name : "Unknown autostart found" ;
        end extract ;

# sets up the remaining params
        @lstring counter_name ;
        [alarm get_counter ?counter_name] ;
        replace !p !"alarm"   ![alarm_name string]  !?result ;
        replace !p !"counter" ![counter_name string] !?result ;
        alarms_result := alarms_result . "\n" . result ;
    end foreach ;

# build the alarm table
    alarms_result := alarms_result . "\n" . "tpl_alarm *tpl_alarm_table[ALARM_COUNT] = {\n" ;
    @uint n := 0 ;
    @string alarm_prefix ;
    @string alarm_ids := "" ;
    prefix !p !"alarm" ?alarm_prefix ;
    foreach alarms (@lstring alarm_name *) :
        alarm_ids := alarm_ids . "#define alarm_id_of_" . [alarm_name string] . "  " . [n string] . "\n" ;
        alarms_result := alarms_result . "    &" . alarm_prefix  . [alarm_name string] ;
        n++ ;
        if n != [alarms count]
        then alarms_result := alarms_result . ",\n" ;
        else alarms_result := alarms_result . "\n" ;
        end if ;
   end foreach ;
    alarms_result := alarms_result . "};\n" ;

    header := [header stringByReplacingStringByString !"$ALARMS$" !alarm_ids. "\n#define ALARM_COUNT ".[[alarms count] string]] ;
    implementation := [implementation stringByReplacingStringByString !"$ALARMS$" !alarms_result] ;
end routine ;

end semantics ;
