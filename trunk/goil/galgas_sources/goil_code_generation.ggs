semantics goil_code_generation :

import semantics goil_routines in "goil_routines.ggs" ;
import semantics goil_semantic_types in "goil_semantic_types.ggs" ;
import semantics goil_targets in "goil_targets.ggs" ;

import semantics goil_code_msg_gen in "goil_code_msg_gen.ggs" ;

#--------------------------------------------------------------------
# Initialisation of token found in templates
#--------------------------------------------------------------------
routine init_prefixes ?!@prefix_map prefix :
    [!?prefix insert_prefix ![@lstring new !"task" !here]
              !"descriptor_of_task_" !"$TASK$"] ;
    [!?prefix insert_prefix ![@lstring new !"task_name" !here]
              !"" !"$EXEC_NAME$"] ;
    [!?prefix insert_prefix ![@lstring new !"task_static" !here]
              !"static_descriptor_of_task_" !"$EXEC_STATIC$"] ;

    [!?prefix insert_prefix ![@lstring new !"isr" !here]
              !"descriptor_of_isr_" !"$ISR$"] ;
    [!?prefix insert_prefix ![@lstring new !"isr_name" !here]
              !"" !"$EXEC_NAME$"] ;
    [!?prefix insert_prefix ![@lstring new !"isr_static" !here]
              !"static_descriptor_of_isr_" !"$EXEC_STATIC$"] ;
    [!?prefix insert_prefix ![@lstring new !"isr_helper" !here]
              !"static_helper_of_isr_" !"$ISR_HELPER$"] ;

    [!?prefix insert_prefix ![@lstring new !"alarm" !here]
              !"descriptor_of_alarm_" !"$ALARM$"] ;
    [!?prefix insert_prefix ![@lstring new !"alarm_name" !here]
              !"" !"$ALARM_NAME$"] ;

    [!?prefix insert_prefix ![@lstring new !"counter" !here]
              !"descriptor_of_counter_" !"$COUNTER$"] ;
    [!?prefix insert_prefix ![@lstring new !"counter_name" !here]
              !"" !"$COUNTER_NAME$"] ;

    [!?prefix insert_prefix ![@lstring new !"event" !here]
              !"mask_of_" !"$EVENT$"] ;
    [!?prefix insert_prefix ![@lstring new !"event_name" !here]
              !"" !"$EVENT_NAME$"] ;
    [!?prefix insert_prefix ![@lstring new !"event_mask" !here]
              !"" !"$EVENT_MASK$"] ;

    [!?prefix insert_prefix ![@lstring new !"resource" !here]
              !"descriptor_of_resource_" !"$RESOURCE$"] ;
    [!?prefix insert_prefix ![@lstring new !"resource_name" !here]
              !"" !"$RESOURCE_NAME$"] ;

    [!?prefix insert_prefix ![@lstring new !"callback" !here]
              !"alarm_callback_" !"$ALARM_CALLBACK$"] ;
    [!?prefix insert_prefix ![@lstring new !"task_function" !here]
              !"function_of_task_" !"$EXEC_FUNCTION$"] ;
    [!?prefix insert_prefix ![@lstring new !"task_context" !here]
              !"CONTEXT_OF_TASK_" !"$EXEC_CONTEXT$"] ;
    [!?prefix insert_prefix ![@lstring new !"task_stack" !here]
              !"STACK_OF_TASK_" !"$EXEC_STACK$"] ;
    [!?prefix insert_prefix ![@lstring new !"task_id" !here]
              !"task_id_of_" !"$TASK_ID$"] ;
    [!?prefix insert_prefix ![@lstring new !"isr_function" !here]
              !"function_of_isr_" !"$EXEC_FUNCTION$"] ;
    [!?prefix insert_prefix ![@lstring new !"isr_context" !here]
              !"CONTEXT_OF_ISR_" !"$EXEC_CONTEXT$"] ;
    [!?prefix insert_prefix ![@lstring new !"isr_stack" !here]
              !"STACK_OF_ISR_" !"$EXEC_STACK$"] ;
    
    init_targets_prefixes !?prefix ;

end routine ;

#--------------------------------------------------------------------
# Code generation routines
#--------------------------------------------------------------------
# Alarms generation
#--------------------------------------------------------------------
routine generate_alarms ?@alarm_map alarms ?@prefix_map p ?!@string header ?!@string implementation :
    @string tpl_alarm_setevent ;
    @string tpl_alarm_activatetask ;
    @string tpl_alarm_callback ;

    @string alarms_result := "" ;

    template ?tpl_alarm_setevent     !"alarm_event_set" ;
    template ?tpl_alarm_activatetask !"alarm_task_act" ;
    template ?tpl_alarm_callback     !"alarm_callback" ;

    foreach alarms (@lstring alarm_name @alarm_obj alarm) :
        @string result := "" ;

# sets up the kind of alarm and its action
        @action_obj alarm_action ;
        [alarm get_action ?alarm_action] ;
        extract alarm_action :
        when @setevent_action (@lstring task_name @lstring event_name) ->
            result := tpl_alarm_setevent ;
            replace !p !"task"  ![task_name string] !?result ;
            replace !p !"event" ![event_name string] !?result ;
        when @activatetask_action (@lstring task_name) ->
            result := tpl_alarm_activatetask ;
            replace !p !"task" ![task_name string] !?result ;
        when @callback_action (@lstring function_name) ->
            result := tpl_alarm_callback ;
            replace !p !"callback" ![function_name string] !?result ;
        else error alarm_name : "Unknown action found" ;
        end extract ;

# sets up the autostart params
        @autostart_obj autostart ;
        [alarm get_autostart ?autostart] ;
        extract autostart :
        when @autostart_void () ->
            result := [result stringByReplacingStringByString !"$ALARM_STATE$" !"ALARM_SLEEP"] ;
            result := [result stringByReplacingStringByString !"$ALARM_CYCLE$" !"0"] ;
            result := [result stringByReplacingStringByString !"$ALARM_DATE$" !"0"] ;
        when @autostart_true_params (@luint64 alarm_time @luint64 cycle_time *) ->
            result := [result stringByReplacingStringByString !"$ALARM_STATE$" !"ALARM_AUTOSTART"] ;
            result := [result stringByReplacingStringByString !"$ALARM_CYCLE$" ![[cycle_time uint64] string]] ;
            result := [result stringByReplacingStringByString !"$ALARM_DATE$" ![[alarm_time uint64] string]] ;
        else error alarm_name : "Unknown autostart found" ;
        end extract ;

# sets up the remaining params
        @lstring counter_name ;
        [alarm get_counter ?counter_name] ;
        replace !p !"alarm_name"   ![alarm_name string]  !?result ;
        replace !p !"alarm"   ![alarm_name string]  !?result ;
        replace !p !"counter" ![counter_name string] !?result ;
        alarms_result := alarms_result . "\n" . result ;
    end foreach ;

# build the alarm table
    @string alarm_head ;
    @string alarm_imp ;
    obj_table !"alarm" !p ![alarms allKeys] ?alarm_head ?alarm_imp ;
    alarms_result := alarms_result."\n".alarm_imp ;

    header := [header stringByReplacingStringByString !"$ALARMS$" !alarm_head] ;
    implementation := [implementation stringByReplacingStringByString !"$ALARMS$" !alarms_result] ;
end routine ;

#--------------------------------------------------------------------
# Tasks generation
#--------------------------------------------------------------------
routine generate_tasks ?@task_map tasks ?@prefix_map p ?!@string header ?!@string implementation :
    @string tpl_task ;

    @string tasks_result := "" ;

    template ?tpl_task !"task" ;

    foreach tasks (@lstring task_name @task_obj task) :
        @string tmp ;
        @string result := "" ;

        generate_context_and_stack !task_name !task !p !?result ;

        result := result . tpl_task ;

        replace !p !"task_name"     ![task_name string] !?result ;
        replace !p !"task_function" ![task_name string] !?result ;
        replace !p !"task"          ![task_name string] !?result ;
        replace !p !"task_static"   ![task_name string] !?result ;
        replace !p !"task_context"  ![task_name string] !?result ;
        replace !p !"task_stack"    ![task_name string] !?result ;
        replace !p !"task_id"       ![task_name string] !?result ;
        
        @uint64 prio ;
        [task get_priority ?prio] ;
        tmp := [prio string] ;
        result := [result stringByReplacingStringByString !"$TASK_PRIORITY$" !tmp] ;
        [task get_activation ?tmp] ;
        result := [result stringByReplacingStringByString !"$TASK_MAX_ACT_COUNT$" !tmp] ;

        @task_autostart_obj autostart;
        [task get_autostart ?autostart];
        extract autostart :
        when @task_autostart_true (*) ->
            result := [result stringByReplacingStringByString !"$TASK_STATE$" !"AUTOSTART"] ;
        when @task_autostart_false () ->
            result := [result stringByReplacingStringByString !"$TASK_STATE$" !"SUSPENDED"] ;
        else error task_name : "Unknown autostart found" ;
        end extract ;

        tasks_result := tasks_result . "\n" . result ;
    end foreach ;

# build the task table
    @string task_head ;
    @string task_imp ;
    obj_table !"task" !p ![tasks allKeys] ?task_head ?task_imp ;
    tasks_result := tasks_result."\n".task_imp ;

    header := [header stringByReplacingStringByString !"$TASKS$" !task_head] ; 
    implementation := [implementation stringByReplacingStringByString !"$TASKS$" !tasks_result] ; 
end routine ;

#--------------------------------------------------------------------
# ISRs generation
#--------------------------------------------------------------------
routine generate_isrs ?@isr_map isrs ?@prefix_map p ?!@string header ?!@string implementation :
    @string tpl_isr ;

    @string isrs_result := "" ;

    template ?tpl_isr !"isr" ;

    foreach isrs (@lstring isr_name @isr_obj isr) :
        @string tmp ;
        @string result := "" ;

        generate_context_and_stack !isr_name !isr !p !?result ;

        result := result . tpl_isr ;

        replace !p !"isr_name"     ![isr_name string] !?result ;
        replace !p !"isr_function" ![isr_name string] !?result ;
        replace !p !"isr"          ![isr_name string] !?result ;
        replace !p !"isr_static"   ![isr_name string] !?result ;
        replace !p !"isr_context"  ![isr_name string] !?result ;
        replace !p !"isr_stack"    ![isr_name string] !?result ;
        replace !p !"isr_helper"   ![isr_name string] !?result ;
        
        @uint64 prio ;
        [isr get_priority ?prio] ;
        tmp := [prio string] ;
        result := [result stringByReplacingStringByString !"$ISR_PRIORITY$" !tmp] ;
        [isr get_activation ?tmp] ;
        result := [result stringByReplacingStringByString !"$ISR_MAX_ACT_COUNT$" !tmp] ;

        isrs_result := isrs_result . "\n" . result ;
    end foreach ;

    header := [header stringByReplacingStringByString !"$ISRS$" !""] ; 
    implementation := [implementation stringByReplacingStringByString !"$ISRS$" !isrs_result] ; 
end routine ;

#--------------------------------------------------------------------
# Counters generation
#--------------------------------------------------------------------
routine generate_counters
    ?@counter_map counters
    ?@prefix_map p
    ?!@string header
    ?!@string implementation :

    @string tpl_counter ;
    @string counters_result := "" ;

    template ?tpl_counter !"counter" ;

    foreach counters (@lstring counter_name @counter_obj counter) :
        @string tmp ;
        @string result := tpl_counter ;

        replace !p !"counter_name" ![counter_name string] !?result ;
        replace !p !"counter" ![counter_name string] !?result ;
        [counter get_ticks_per_base ?tmp] ;
        result := [result stringByReplacingStringByString !"$TICKS_PER_BASE$" !tmp] ;

        counters_result := counters_result . "\n" . result ;
    end foreach ;
 
    header := [header stringByReplacingStringByString !"$COUNTERS$" !""] ; 
    implementation := [implementation stringByReplacingStringByString !"$COUNTERS$" !counters_result] ; 
end routine ;

#--------------------------------------------------------------------
# Resources generation
#--------------------------------------------------------------------
routine max_task_prio_for_rez
    ?@task_map tasks
    ?@string rez_name
    !@string task_use
    ?!@uint64 rez_prio
:
    task_use := "" ;
    foreach tasks (@lstring task_name @task_obj task) :
        @stringset rez ;
        [task get_resources ?rez] ;
        if [rez hasKey !rez_name]
        then 
            @uint64 prio ;
            [task get_priority ?prio] ;
            if prio > rez_prio
            then rez_prio := prio ;
            end if ;
            task_use := task_use.task_name."(".[prio string].") " ;
        end if ;
    end foreach ;
    if task_use == ""
    then task_use := "none" ;
    end if ;
end routine ;

routine max_isr_prio_for_rez
    ?@isr_map isrs
    ?@string rez_name
    !@string isr_use
    ?!@uint64 rez_prio
:
    isr_use := "" ;
    foreach isrs (@lstring isr_name @isr_obj isr) :
        @stringset rez ;
        [isr get_resources ?rez] ;
        if [rez hasKey !rez_name]
        then
            @uint64 prio ;
            [isr get_priority ?prio] ;
            if prio > rez_prio
            then rez_prio := prio ;
            end if ;
            isr_use := isr_use.isr_name."(".[prio string].") " ;
        end if ;
    end foreach ;
    if isr_use == ""
    then isr_use := "none" ;
    end if ;
end routine ;

routine generate_resources
    ?@resource_map resources
    ?@task_map tasks
    ?@isr_map isrs
    ?@prefix_map p
    ?!@string header
    ?!@string implementation :

    @string tpl_resource ;
    @string tpl_internal_resource ;
    @string resources_result := "" ;
    @stringset regular_rez [emptySet] ;

    template ?tpl_resource !"resource" ;
    template ? tpl_internal_resource !"internal_resource" ;

    foreach resources (@lstring resource_name @resource_obj resource) :
        
        @string result ;
        @string name := [resource_name string] ;
        @uint64 rez_prio := 0L ;
        @string task_use := "none" ;
        @string isr_use := "none" ;

        @resource_property_obj rez_prop ;
        [resource get_property ?rez_prop] ;

        extract rez_prop :
        when @resource_property_standard_obj () ->
            result := tpl_resource ;
            max_task_prio_for_rez !tasks !name ?task_use !?rez_prio ;
            max_isr_prio_for_rez !isrs !name ?isr_use !?rez_prio ;
            regular_rez += !name ;
        when @resource_property_linked_obj (*) ->
            result := tpl_resource ;
            max_task_prio_for_rez !tasks !name ?task_use !?rez_prio ;
            max_isr_prio_for_rez !isrs !name ?isr_use !?rez_prio ;
            regular_rez += !name ;
        when @resource_property_internal_obj () ->
            result := tpl_internal_resource ;
            max_task_prio_for_rez !tasks !name ?task_use !?rez_prio ;
        else
            result := "" ;
            error resource_name : "Unknown property found" ;
        end extract ;

        replace !p !"resource_name" ![resource_name string] !?result ;
        replace !p !"resource"      ![resource_name string] !?result ;

        
        result := [result stringByReplacingStringByString !"$PRIORITY$" ![rez_prio string]] ;
        result := [result stringByReplacingStringByString !"$TASKS$" !task_use] ;
        result := [result stringByReplacingStringByString !"$ISRS$" !isr_use] ;

        resources_result := resources_result . "\n" . result ;
    end foreach ;

# build the resource table
    @string rez_head ;
    @string rez_imp ;
    obj_table !"resource" !p !regular_rez ?rez_head ?rez_imp ;
    resources_result := resources_result."\n".rez_imp ;
 
    header := [header stringByReplacingStringByString !"$RESOURCES$" !rez_head] ; 
    implementation := [implementation stringByReplacingStringByString !"$RESOURCES$" !resources_result] ; 
end routine ;

#--------------------------------------------------------------------
# Events generation
#--------------------------------------------------------------------
routine generate_events
    ?@event_map events
    ?@task_map tasks
    ?@prefix_map p
    ?!@string header
    ?!@string implementation
:
    @string tpl_event ;
    @string header_result := "" ;
    @string implementation_result := "" ;

    template ?tpl_event !"event" ;

    #
    # Iterate through the tasks to get the events used
    # a Or is done with the user masks of user events
    # and the result is stored in the task_mask map.
    # event conflicts are detected when building this Or
    # Auto events are looked up and for each auto event
    # the number of referencing tasks is computed and
    # stored in the evt_usage map.
    # In addition, a reverse mapping allowing to get all
    # the task referencing an event is built and stored
    # in the tasks_for_event map.
    #
    @event_usage_map evt_usage [emptyMap] ;
    @task_mask task_mask [emptyMap] ;
    @tasks_for_event tasks_for_event [emptyMap] ; 

    foreach tasks (@lstring task_name @task_obj task) :
        @stringset events_used ;
        [task get_events ?events_used] ;
        @uint64 event_mask := 0L ;
        foreach events_used (@string evt_name) :
            @event_obj event ;
            [events get_event ![@lstring new !evt_name !here] ?event] ;
            @event_mask_obj mask_obj ;
            [event get_mask ?mask_obj] ;
            extract mask_obj :
            when @event_mask_user_obj (@luint64 mask) ->
                if (event_mask & [mask uint64]) == 0L
                then
                    event_mask := event_mask | [mask uint64] ;
                else
                    error mask : "Mask %K conflicts with previous declarations" ;
                end if ;
            when @event_mask_auto_obj () ->
                @uint count ;
                if [evt_usage hasKey !evt_name]
                then
                    [!?evt_usage delete ![@lstring new !evt_name !here] ?count] ;
                    count++ ;
                else
                    count := 1 ;
                end if ;
                [!?evt_usage insert_count ![@lstring new !evt_name !here] !count] ;
            else
            end extract ;

            @stringset ref_tasks [emptySet] ;
            if [tasks_for_event hasKey !evt_name] 
            then
                [!?tasks_for_event delete ![@lstring new !evt_name !here] ?ref_tasks] ;
            end if ;
            ref_tasks += ![task_name string] ;
            [!?tasks_for_event insert_tasks ![@lstring new !evt_name !here] !ref_tasks] ;

        end foreach ;
        [!?task_mask insert_mask !task_name !event_mask] ;
    end foreach ;

    #
    # Output the user events
    #
    foreach events (@lstring evt_name @event_obj evt) :
        @event_mask_obj evt_mask ;
        [evt get_mask ?evt_mask] ;
        extract evt_mask :
        when @event_mask_user_obj (@luint64 mask) ->
            @string result := tpl_event ;
            replace !p !"event" ![evt_name string] !?result ;
            replace !p !"event_name" ![evt_name string] !?result ;
            replace !p !"event_mask" ![[mask uint64] string] !?result ;
            header_result .= result."\n" ;
        else
        end extract ;
    end foreach ;

    #
    # Sort the auto events by reference count
    # and build a list by ref count
    #
    @events ordered_evt [emptyList] ;
    @uint max := 0 ;
    @events to_delete [emptyList];
    @uint evt_count := [evt_usage count] ;

    loop evt_count + 1 :
    while [evt_usage count] > 0 do
        max := 0 ;
        foreach evt_usage (@lstring key @uint count) :
#            message [key string]." : ".[count string]."\n" ;
            if count > max
            then
                max := count ;
            end if ;
        end foreach ;

#        message "max = ".[max string]."\n" ;

        to_delete := [@events emptyList] ;
        foreach evt_usage (@lstring key @uint count) :
            if count == max
            then
                ordered_evt += !key ;
                to_delete += !key ;
#                message "A detruire : ".[key string]."\n" ;
            end if ;
        end foreach ;

        foreach to_delete (@lstring key) :
#            message "destruction de : ".[key string]."\n" ;
            [!?evt_usage delete !key ?*] ;
        end foreach ;

#        message "taille de la map = ".[[evt_usage count] string]."\n" ;
#        foreach evt_usage (@lstring key @uint count) :
#            message "Il reste : ".[key string].", ".[count string]."\n" ;
#        end foreach ;
    end loop ;

#    message "FIN\n" ; 
    #
    # Compute the mask for auto events
    #
    foreach ordered_evt (@lstring evt) :
#        message [evt string]."\n" ;
        # build the user mask
        @stringset ref_tasks ;
        [tasks_for_event get_tasks !evt ?ref_tasks] ;
        @uint64 common_mask := 0L ;
        foreach ref_tasks (@string task_name) :
            @uint64 mask ;
            [task_mask get_mask ![@lstring new !task_name !here] ?mask] ;
            common_mask := common_mask | mask ;
        end foreach ;
#        message "mask = ".[common_mask string]."\n" ;
        # find the first unused bit in the mask
        @uint64 needle := 1L ;
        loop 64:
        while (needle & common_mask) != 0L do
            needle := needle << 1 ;
        end loop ;
#        message "found ".[needle string]."\n" ;
        
        @string result := tpl_event ;
        replace !p !"event" ![evt string] !?result ;
        replace !p !"event_name" ![evt string] !?result ;
        replace !p !"event_mask" ![needle string] !?result ;
        header_result .= result."\n" ;
    end foreach ;

    header := [header stringByReplacingStringByString !"$EVENTS$" !header_result] ; 
    implementation := [implementation stringByReplacingStringByString !"$EVENTS$" !implementation_result] ; 

end routine ;


end semantics ;