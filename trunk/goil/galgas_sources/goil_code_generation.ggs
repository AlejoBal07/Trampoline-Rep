semantics goil_code_generation :

import option goil_options in "goil_options.ggs" ;
import semantics goil_routines in "goil_routines.ggs" ;
import semantics goil_semantic_types in "goil_semantic_types.ggs" ;
import semantics goil_targets in "goil_targets.ggs" ;

#--------------------------------------------------------------------
# Initialisation of token found in templates
#--------------------------------------------------------------------
routine init_prefixes ?!@prefix_map prefix :
    [!?prefix insert_prefix ![@lstring new !"task" !here]
              !"descriptor_of_task_" !"$TASK$"] ;
    [!?prefix insert_prefix ![@lstring new !"task_name" !here]
              !"" !"$TASK_NAME$"] ;
    [!?prefix insert_prefix ![@lstring new !"task_static" !here]
              !"static_descriptor_of_task_" !"$TASK_STATIC$"] ;
    [!?prefix insert_prefix ![@lstring new !"alarm" !here]
              !"descriptor_of_alarm_" !"$ALARM$"] ;
    [!?prefix insert_prefix ![@lstring new !"alarm_name" !here]
              !"" !"$ALARM_NAME$"] ;
    [!?prefix insert_prefix ![@lstring new !"counter" !here]
              !"descriptor_of_counter_" !"$COUNTER$"] ;
    [!?prefix insert_prefix ![@lstring new !"counter_name" !here]
              !"" !"$COUNTER_NAME$"] ;
    [!?prefix insert_prefix ![@lstring new !"event" !here]
              !"value_of_" !"$EVENT$"] ;
    [!?prefix insert_prefix ![@lstring new !"event_name" !here]
              !"" !"$EVENT_NAME$"] ;

    [!?prefix insert_prefix ![@lstring new !"resource" !here]
              !"descriptor_of_resource_" !"$RESOURCE$"] ;
    [!?prefix insert_prefix ![@lstring new !"resource_name" !here]
              !"" !"$RESOURCE_NAME$"] ;

    [!?prefix insert_prefix ![@lstring new !"callback" !here]
              !"alarm_callback_" !"$ALARM_CALLBACK$"] ;
    [!?prefix insert_prefix ![@lstring new !"task_function" !here]
              !"function_of_task_" !"$TASK_FUNCTION$"] ;
    [!?prefix insert_prefix ![@lstring new !"task_context" !here]
              !"CONTEXT_OF_TASK_" !"$TASK_CONTEXT$"] ;
    [!?prefix insert_prefix ![@lstring new !"task_stack" !here]
              !"STACK_OF_TASK_" !"$TASK_STACK$"] ;
    [!?prefix insert_prefix ![@lstring new !"task_id" !here]
              !"id_of_task_" !"$TASK_ID$"] ;
    
    init_targets_prefixes !?prefix ;

end routine ;

#--------------------------------------------------------------------
# Code generation routines
#--------------------------------------------------------------------
# Alarms generation
#--------------------------------------------------------------------
routine generate_alarms ?@alarm_map alarms ?@prefix_map p ?!@string header ?!@string implementation :
    @string tpl_alarm_setevent ;
    @string tpl_alarm_activatetask ;
    @string tpl_alarm_callback ;

    @string alarms_result := "" ;

    template ?tpl_alarm_setevent     !"alarm_event_set" ;
    template ?tpl_alarm_activatetask !"alarm_task_act" ;
    template ?tpl_alarm_callback     !"alarm_callback" ;

    foreach alarms (@lstring alarm_name @alarm_obj alarm) :
        @string result := "" ;

# sets up the kind of alarm and its action
        @action_obj alarm_action ;
        [alarm get_action ?alarm_action] ;
        extract alarm_action :
        when @setevent_action (@lstring task_name @lstring event_name) ->
            result := tpl_alarm_setevent ;
            replace !p !"task"  ![task_name string] !?result ;
            replace !p !"event" ![event_name string] !?result ;
        when @activatetask_action (@lstring task_name) ->
            result := tpl_alarm_activatetask ;
            replace !p !"task" ![task_name string] !?result ;
        when @callback_action (@lstring function_name) ->
            result := tpl_alarm_callback ;
            replace !p !"callback" ![function_name string] !?result ;
        else error alarm_name : "Unknown action found" ;
        end extract ;

# sets up the autostart params
        @autostart_obj autostart ;
        [alarm get_autostart ?autostart] ;
        extract autostart :
        when @autostart_void () ->
            result := [result stringByReplacingStringByString !"$ALARM_STATE$" !"ALARM_SLEEP"] ;
            result := [result stringByReplacingStringByString !"$ALARM_CYCLE$" !"0"] ;
            result := [result stringByReplacingStringByString !"$ALARM_DATE$" !"0"] ;
        when @autostart_true_params (@luint64 alarm_time @luint64 cycle_time *) ->
            result := [result stringByReplacingStringByString !"$ALARM_STATE$" !"ALARM_AUTOSTART"] ;
            result := [result stringByReplacingStringByString !"$ALARM_CYCLE$" ![[cycle_time uint64] string]] ;
            result := [result stringByReplacingStringByString !"$ALARM_DATE$" ![[alarm_time uint64] string]] ;
        else error alarm_name : "Unknown autostart found" ;
        end extract ;

# sets up the remaining params
        @lstring counter_name ;
        [alarm get_counter ?counter_name] ;
        replace !p !"alarm_name"   ![alarm_name string]  !?result ;
        replace !p !"alarm"   ![alarm_name string]  !?result ;
        replace !p !"counter" ![counter_name string] !?result ;
        alarms_result := alarms_result . "\n" . result ;
    end foreach ;

# build the alarm table
    @string alarm_head ;
    @string alarm_imp ;
    obj_table !"alarm" !p ![alarms allKeys] ?alarm_head ?alarm_imp ;
    alarms_result := alarms_result."\n".alarm_imp ;

    header := [header stringByReplacingStringByString !"$ALARMS$" !alarm_head] ;
    implementation := [implementation stringByReplacingStringByString !"$ALARMS$" !alarms_result] ;
end routine ;

#--------------------------------------------------------------------
# Tasks generation
#--------------------------------------------------------------------
routine generate_tasks ?@task_map tasks ?@prefix_map p ?!@string header ?!@string implementation :
    @string tpl_task ;

    @string tasks_result := "" ;

    template ?tpl_task !"task" ;

    foreach tasks (@lstring task_name @task_obj task) :
        @string tmp ;
        @string result := "" ;

        generate_context_and_stack !task_name !task !p !?result ;

        result := result . tpl_task ;

        replace !p !"task_name"     ![task_name string] !?result ;
        replace !p !"task_function" ![task_name string] !?result ;
        replace !p !"task"          ![task_name string] !?result ;
        replace !p !"task_static"   ![task_name string] !?result ;
        replace !p !"task_context"  ![task_name string] !?result ;
        replace !p !"task_stack"    ![task_name string] !?result ;
        replace !p !"task_id"       ![task_name string] !?result ;
        
        @uint64 prio ;
        [task get_priority ?prio] ;
        tmp := [prio string] ;
        result := [result stringByReplacingStringByString !"$TASK_PRIORITY$" !tmp] ;
        [task get_activation ?tmp] ;
        result := [result stringByReplacingStringByString !"$TASK_MAX_ACT_COUNT$" !tmp] ;

        @task_autostart_obj autostart;
        [task get_autostart ?autostart];
        extract autostart :
        when @task_autostart_true (*) ->
            result := [result stringByReplacingStringByString !"$TASK_STATE$" !"AUTOSTART"] ;
        when @task_autostart_false () ->
            result := [result stringByReplacingStringByString !"$TASK_STATE$" !"SUSPENDED"] ;
        else error task_name : "Unknown autostart found" ;
        end extract ;

        tasks_result := tasks_result . "\n" . result ;
    end foreach ;

# build the task table
    @string task_head ;
    @string task_imp ;
    obj_table !"task" !p ![tasks allKeys] ?task_head ?task_imp ;
    tasks_result := tasks_result."\n".task_imp ;

    header := [header stringByReplacingStringByString !"$TASKS$" !task_head] ; 
    implementation := [implementation stringByReplacingStringByString !"$TASKS$" !tasks_result] ; 
end routine ;

#--------------------------------------------------------------------
# Counters generation
#--------------------------------------------------------------------
routine generate_counters
    ?@counter_map counters
    ?@prefix_map p
    ?!@string header
    ?!@string implementation :

    @string tpl_counter ;
    @string counters_result := "" ;

    template ?tpl_counter !"counter" ;

    foreach counters (@lstring counter_name @counter_obj counter) :
        @string tmp ;
        @string result := tpl_counter ;

        replace !p !"counter_name" ![counter_name string] !?result ;
        replace !p !"counter" ![counter_name string] !?result ;
        [counter get_ticks_per_base ?tmp] ;
        result := [result stringByReplacingStringByString !"$TICKS_PER_BASE$" !tmp] ;

        counters_result := counters_result . "\n" . result ;
    end foreach ;
 
    header := [header stringByReplacingStringByString !"$COUNTERS$" !""] ; 
    implementation := [implementation stringByReplacingStringByString !"$COUNTERS$" !counters_result] ; 
end routine ;

#--------------------------------------------------------------------
# Resources generation
#--------------------------------------------------------------------
routine max_task_prio_for_rez
    ?@task_map tasks
    ?@string rez_name
    !@string task_use
    ?!@uint64 rez_prio
:
    task_use := "" ;
    foreach tasks (@lstring task_name @task_obj task) :
        @stringset rez ;
        [task get_resources ?rez] ;
        if [rez hasKey !rez_name]
        then 
            @uint64 prio ;
            [task get_priority ?prio] ;
            if prio > rez_prio
            then rez_prio := prio ;
            end if ;
            task_use := task_use.task_name."(".[prio string].") " ;
        end if ;
    end foreach ;
    if task_use == ""
    then task_use := "none" ;
    end if ;
end routine ;

routine max_isr_prio_for_rez
    ?@isr_map isrs
    ?@string rez_name
    !@string isr_use
    ?!@uint64 rez_prio
:
    isr_use := "" ;
    foreach isrs (@lstring isr_name @isr_obj isr) :
        @stringset rez ;
        [isr get_resources ?rez] ;
        if [rez hasKey !rez_name]
        then
            @uint64 prio ;
            [isr get_priority ?prio] ;
            if prio > rez_prio
            then rez_prio := prio ;
            end if ;
            isr_use := isr_use.isr_name."(".[prio string].") " ;
        end if ;
    end foreach ;
    if isr_use == ""
    then isr_use := "none" ;
    end if ;
end routine ;

routine generate_resources
    ?@resource_map resources
    ?@task_map tasks
    ?@isr_map isrs
    ?@prefix_map p
    ?!@string header
    ?!@string implementation :

    @string tpl_resource ;
    @string tpl_internal_resource ;
    @string resources_result := "" ;
    @stringset regular_rez [emptySet] ;

    template ?tpl_resource !"resource" ;
    template ? tpl_internal_resource !"internal_resource" ;

    foreach resources (@lstring resource_name @resource_obj resource) :
        
        @string result ;
        @string name := [resource_name string] ;
        @uint64 rez_prio := 0L ;
        @string task_use := "none" ;
        @string isr_use := "none" ;

        @resource_property_obj rez_prop ;
        [resource get_property ?rez_prop] ;

        extract rez_prop :
        when @resource_property_standard_obj () ->
            result := tpl_resource ;
            max_task_prio_for_rez !tasks !name ?task_use !?rez_prio ;
            max_isr_prio_for_rez !isrs !name ?isr_use !?rez_prio ;
            regular_rez += !name ;
        when @resource_property_linked_obj (*) ->
            result := tpl_resource ;
            max_task_prio_for_rez !tasks !name ?task_use !?rez_prio ;
            max_isr_prio_for_rez !isrs !name ?isr_use !?rez_prio ;
            regular_rez += !name ;
        when @resource_property_internal_obj () ->
            result := tpl_internal_resource ;
            max_task_prio_for_rez !tasks !name ?task_use !?rez_prio ;
        else
            result := "" ;
            error resource_name : "Unknown property found" ;
        end extract ;

        replace !p !"resource_name" ![resource_name string] !?result ;
        replace !p !"resource"      ![resource_name string] !?result ;

        
        result := [result stringByReplacingStringByString !"$PRIORITY$" ![rez_prio string]] ;
        result := [result stringByReplacingStringByString !"$TASKS$" !task_use] ;
        result := [result stringByReplacingStringByString !"$ISRS$" !isr_use] ;

        resources_result := resources_result . "\n" . result ;
    end foreach ;

# build the resource table
    @string rez_head ;
    @string rez_imp ;
    obj_table !"resource" !p !regular_rez ?rez_head ?rez_imp ;
    resources_result := resources_result."\n".rez_imp ;
 
    header := [header stringByReplacingStringByString !"$RESOURCES$" !rez_head] ; 
    implementation := [implementation stringByReplacingStringByString !"$RESOURCES$" !resources_result] ; 
end routine ;

end semantics ;