semantics goil_code_generation :

import option goil_options in "goil_options.ggs" ;
import semantics goil_routines in "goil_routines.ggs" ;
import semantics goil_semantic_types in "goil_semantic_types.ggs" ;
import semantics goil_targets in "goil_targets.ggs" ;

#--------------------------------------------------------------------
# Initialisation of token found in templates
#--------------------------------------------------------------------
routine init_prefixes ?!@prefix_map prefix :
    [!?prefix insert_prefix ![@lstring new !"task" !here]
              !"descriptor_of_task_" !"$TASK_NAME$"] ;
    [!?prefix insert_prefix ![@lstring new !"task_static" !here]
              !"static_descriptor_of_task_" !"$TASK_STATIC$"] ;
    [!?prefix insert_prefix ![@lstring new !"alarm" !here]
              !"descriptor_of_alarm_" !"$ALARM_NAME$"] ;
    [!?prefix insert_prefix ![@lstring new !"counter" !here]
              !"descriptor_of_counter_" !"$COUNTER_NAME$"] ;
    [!?prefix insert_prefix ![@lstring new !"event" !here]
              !"value_of_" !"$EVENT_NAME$"] ;

    [!?prefix insert_prefix ![@lstring new !"callback" !here]
              !"alarm_callback_" !"$ALARM_CALLBACK$"] ;
    [!?prefix insert_prefix ![@lstring new !"task_function" !here]
              !"function_of_task_" !"$TASK_FUNCTION$"] ;
    [!?prefix insert_prefix ![@lstring new !"task_context" !here]
              !"CONTEXT_OF_TASK_" !"$TASK_CONTEXT$"] ;
    [!?prefix insert_prefix ![@lstring new !"task_stack" !here]
              !"STACK_OF_TASK_" !"$TASK_STACK$"] ;
    [!?prefix insert_prefix ![@lstring new !"task_id" !here]
              !"id_of_task_" !"$TASK_ID$"] ;
    
    init_targets_prefixes !?prefix ;

end routine ;

#--------------------------------------------------------------------
# Code generation routines
#--------------------------------------------------------------------
# Alarms generation
#--------------------------------------------------------------------
routine generate_alarms ?@alarm_map alarms ?@prefix_map p ?!@string header ?!@string implementation :
    @string tpl_alarm_setevent ;
    @string tpl_alarm_activatetask ;
    @string tpl_alarm_callback ;

    @string alarms_result := "" ;

    template ?tpl_alarm_setevent     !"alarm_event_set" ;
    template ?tpl_alarm_activatetask !"alarm_task_act" ;
    template ?tpl_alarm_callback     !"alarm_callback" ;

    foreach alarms (@lstring alarm_name @alarm_obj alarm) :
        @string result := "" ;

# sets up the kind of alarm and its action
        @action_obj alarm_action ;
        [alarm get_action ?alarm_action] ;
        extract alarm_action :
        when @setevent_action (@lstring task_name @lstring event_name) ->
            result := tpl_alarm_setevent ;
            replace !p !"task"  ![task_name string] !?result ;
            replace !p !"event" ![event_name string] !?result ;
        when @activatetask_action (@lstring task_name) ->
            result := tpl_alarm_activatetask ;
            replace !p !"task" ![task_name string] !?result ;
        when @callback_action (@lstring function_name) ->
            result := tpl_alarm_callback ;
            replace !p !"callback" ![function_name string] !?result ;
        else error alarm_name : "Unknown action found" ;
        end extract ;

# sets up the autostart params
        @autostart_obj autostart ;
        [alarm get_autostart ?autostart] ;
        extract autostart :
        when @autostart_void () ->
            result := [result stringByReplacingStringByString !"$ALARM_STATE$" !"ALARM_SLEEP"] ;
            result := [result stringByReplacingStringByString !"$ALARM_CYCLE$" !"0"] ;
            result := [result stringByReplacingStringByString !"$ALARM_DATE$" !"0"] ;
        when @autostart_true_params (@luint64 alarm_time @luint64 cycle_time *) ->
            result := [result stringByReplacingStringByString !"$ALARM_STATE$" !"ALARM_AUTOSTART"] ;
            result := [result stringByReplacingStringByString !"$ALARM_CYCLE$" ![[cycle_time uint64] string]] ;
            result := [result stringByReplacingStringByString !"$ALARM_DATE$" ![[alarm_time uint64] string]] ;
        else error alarm_name : "Unknown autostart found" ;
        end extract ;

# sets up the remaining params
        @lstring counter_name ;
        [alarm get_counter ?counter_name] ;
        replace !p !"alarm"   ![alarm_name string]  !?result ;
        replace !p !"counter" ![counter_name string] !?result ;
        alarms_result := alarms_result . "\n" . result ;
    end foreach ;

# build the alarm table
    @string alarm_head ;
    @string alarm_imp ;
    obj_table !"alarm" !p ![alarms allKeys] ?alarm_head ?alarm_imp ;
    alarms_result := alarms_result."\n".alarm_imp ;

    header := [header stringByReplacingStringByString !"$ALARMS$" !alarm_head] ;
    implementation := [implementation stringByReplacingStringByString !"$ALARMS$" !alarms_result] ;
end routine ;

#--------------------------------------------------------------------
# Tasks generation
#--------------------------------------------------------------------
routine generate_tasks ?@task_map tasks ?@prefix_map p ?!@string header ?!@string implementation :
    @string tpl_task ;

    @string tasks_result := "" ;

    template ?tpl_task !"task" ;

    foreach tasks (@lstring task_name @task_obj task) :
        @string tmp ;
        @string result := "" ;

        generate_context_and_stack !task_name !task !p !?result ;

        result := result . tpl_task ;

        replace !p !"task_function" ![task_name string] !?result ;
        replace !p !"task"          ![task_name string] !?result ;
        replace !p !"task_static"   ![task_name string] !?result ;
        replace !p !"task_context"  ![task_name string] !?result ;
        replace !p !"task_stack"    ![task_name string] !?result ;
        replace !p !"task_id"       ![task_name string] !?result ;
        [task get_priority ?tmp] ;
        result := [result stringByReplacingStringByString !"$TASK_PRIORITY$" !tmp] ;
        [task get_activation ?tmp] ;
        result := [result stringByReplacingStringByString !"$TASK_MAX_ACT_COUNT$" !tmp] ;

        @task_autostart_obj autostart;
        [task get_autostart ?autostart];
        extract autostart :
        when @task_autostart_true (*) ->
            result := [result stringByReplacingStringByString !"$TASK_STATE$" !"AUTOSTART"] ;
        when @task_autostart_false () ->
            result := [result stringByReplacingStringByString !"$TASK_STATE$" !"SUSPENDED"] ;
        else error task_name : "Unknown autostart found" ;
        end extract ;

        tasks_result := tasks_result . "\n" . result ;
    end foreach ;

# build the task table
    @string task_head ;
    @string task_imp ;
    obj_table !"task" !p ![tasks allKeys] ?task_head ?task_imp ;
    tasks_result := tasks_result."\n".task_imp ;

    header := [header stringByReplacingStringByString !"$TASKS$" !task_head] ; 
    implementation := [implementation stringByReplacingStringByString !"$TASKS$" !tasks_result] ; 
end routine ;

#--------------------------------------------------------------------
# Counters generation
#--------------------------------------------------------------------
routine generate_counters
    ?@counter_map counters
    ?@prefix_map p
    ?!@string header
    ?!@string implementation :

    @string tpl_counter ;
    @string counters_result := "" ;

    template ?tpl_counter !"counter" ;

    foreach counters (@lstring counter_name @counter_obj counter) :
        @string tmp ;
        @string result := tpl_counter ;

        replace !p !"counter" ![counter_name string] !?result ;
        [counter get_ticks_per_base ?tmp] ;
        result := [result stringByReplacingStringByString !"$TICKS_PER_BASE$" !tmp] ;

        counters_result := counters_result . "\n" . result ;
    end foreach ;

# build the task table
 
    header := [header stringByReplacingStringByString !"$COUNTERS$" !""] ; 
    implementation := [implementation stringByReplacingStringByString !"$COUNTERS$" !counters_result] ; 
end routine ;


end semantics ;