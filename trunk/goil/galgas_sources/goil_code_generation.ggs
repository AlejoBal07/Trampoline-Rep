#
# @file goil_code_generation.ggs
#
# @section File description
#
# This file wraps user application configuration header.
# This wrapped file is typically
# generated from an OIL source.
#
# @section Copyright
#
# Trampoline OS
#
# Trampoline is copyright (c) IRCCyN 2005+
# Trampoline is protected by the french intellectual property law.
#
# This software is distributed under the GNU Public Licence V2
#
# @section File informations
#
# $Date$
# $Rev$
# $Author$
# $URL$
#

semantics goil_code_generation :

import semantics goil_routines in "goil_routines.ggs";
import semantics goil_semantic_types in "goil_semantic_types.ggs";
import semantics goil_targets in "goil_targets.ggs";
import semantics goil_types_os in "goil_types_os.ggs";
import semantics goil_types_task in "goil_types_task.ggs";
import semantics goil_types_app in "goil_types_app.ggs";
#import semantics goil_code_msg_gen in "goil_code_msg_gen.ggs";
#import semantics goil_code_schedtable_gen in "goil_code_schedtable_gen.ggs";
#import semantics goil_proc_generation in "goil_proc_generation.ggs";
import semantics memory_mapping in "memory_mapping.ggs";
#import semantics goil_app_generation in "goil_app_generation.ggs";
import semantics it_table_generation in "it_table_generation.ggs";
import semantics trace_description in "trace_description.ggs";
import semantics goil_env_verification in "goil_env_verification.ggs";
import semantics config_type in "config_type.ggs";
import semantics system_config in "system_config.ggs";
import semantics tasks_config in "tasks_config.ggs";
import semantics template_routines in "template_routines.ggs";

import semantics cfg_types in "cfg_types.ggs";
import grammar cfg_grammar in "cfg_grammar.gGrammar";

import option goil_options in "goil_options.gOption";

#--------------------------------------------------------------------
# Initialisation of token found in templates
#--------------------------------------------------------------------
#routine init_prefixes ?!@prefix_map prefix :
#    [!?prefix add ![@lstring new !"task" !here]
#              !"descriptor_of_task_" !"$TASK$"];
#    [!?prefix add ![@lstring new !"task_name" !here]
#              !"" !"$EXEC_NAME$"];
#    [!?prefix add ![@lstring new !"task_static" !here]
#              !"static_descriptor_of_task_" !"$EXEC_STATIC$"];
#
#    [!?prefix add ![@lstring new !"isr" !here]
#              !"descriptor_of_isr_" !"$ISR$"];
#    [!?prefix add ![@lstring new !"isr_name" !here]
#              !"" !"$EXEC_NAME$"];
#    [!?prefix add ![@lstring new !"isr_static" !here]
#              !"static_descriptor_of_isr_" !"$EXEC_STATIC$"];
#    [!?prefix add ![@lstring new !"isr_helper" !here]
#              !"static_helper_of_isr_" !"$ISR_HELPER$"];

#    [!?prefix add ![@lstring new !"proc" !here]
#              !"_descriptor" !""];

#    [!?prefix add ![@lstring new !"alarm" !here]
#              !"descriptor_of_alarm_" !"$ALARM$"];
#    [!?prefix add ![@lstring new !"alarm_name" !here]
#              !"" !"$ALARM_NAME$"];

#    [!?prefix add ![@lstring new !"counter" !here]
#              !"descriptor_of_counter_" !"$COUNTER$"];
#    [!?prefix add ![@lstring new !"counter_name" !here]
#              !"" !"$COUNTER_NAME$"];
#    [!?prefix add ![@lstring new !"counter_kind" !here]
#              !"" !"$COUNTER_KIND$"];
#
#    [!?prefix add ![@lstring new !"event" !here]
#              !"mask_of_" !"$EVENT$"];
#    [!?prefix add ![@lstring new !"event_name" !here]
#              !"" !"$EVENT_NAME$"];
#    [!?prefix add ![@lstring new !"event_mask" !here]
#              !"" !"$EVENT_MASK$"];

#    [!?prefix add ![@lstring new !"resource" !here]
#             !"descriptor_of_resource_" !"$RESOURCE$"];
#    [!?prefix add ![@lstring new !"resource_ptr" !here]
#              !"&descriptor_of_resource_" !"$RESOURCE_PTR$"];
#    [!?prefix add ![@lstring new !"resource_name" !here]
#              !"" !"$RESOURCE_NAME$"];

#    [!?prefix add ![@lstring new !"callback" !here]
#              !"alarm_callback_" !"$ALARM_CALLBACK$"];
#    [!?prefix add ![@lstring new !"task_function" !here]
#              !"function_of_task_" !"$EXEC_FUNCTION$"];
#    [!?prefix add ![@lstring new !"task_context" !here]
#              !"CONTEXT_OF_TASK_" !"$EXEC_CONTEXT$"];
#    [!?prefix add ![@lstring new !"task_stack" !here]
#             !"STACK_OF_TASK_" !"$EXEC_STACK$"];
#    [!?prefix add ![@lstring new !"task_id" !here]
#              !"task_id_of_" !"$TASK_ID$"];
#    [!?prefix add ![@lstring new !"isr_function" !here]
#              !"function_of_isr_" !"$EXEC_FUNCTION$"];
#    [!?prefix add ![@lstring new !"isr_context" !here]
#              !"CONTEXT_OF_ISR_" !"$EXEC_CONTEXT$"];
#    [!?prefix add ![@lstring new !"isr_stack" !here]
#              !"STACK_OF_ISR_" !"$EXEC_STACK$"];
#    
#    [!?prefix add ![@lstring new !"msg_name" !here] !"" !"$MESSAGE_NAME$"];
#    [!?prefix add ![@lstring new !"msg" !here] !"message_object_of_" !"$MESSAGE$"];
#    [!?prefix add ![@lstring new !"target" !here] !"message_object_of_" !"$TARGET$"];
#    [!?prefix add ![@lstring new !"target_ptr" !here] !"&message_object_of_" !"$TARGET_PTR$"];
#    [!?prefix add ![@lstring new !"size" !here] !"" !"$SIZE$"];
#    [!?prefix add ![@lstring new !"element_size" !here] !"" !"$ELEMENT_SIZE$"];
#    [!?prefix add ![@lstring new !"queue_size" !here] !"" !"$QUEUE_SIZE$"];
#    [!?prefix add ![@lstring new !"dyn_queue" !here] !"dynamic_queue_of_message_" !"$DYN_QUEUE$"];
#
#    [!?prefix add ![@lstring new !"notif_name" !here]
#              !"of message " !"$NOTIFICATION_NAME$"];
#    [!?prefix add ![@lstring new !"error_notif_name" !here]
#              !"error of message " !"$NOTIFICATION_NAME$"];
#    [!?prefix add ![@lstring new !"notification" !here]
#              !"notification_of_message_" !"$NOTIFICATION$"];
#    [!?prefix add ![@lstring new !"notif_ptr" !here]
#              !"&notification_of_message_" !"$NOTIFICATION_PTR$"];
#    [!?prefix add ![@lstring new !"error_notification" !here]
#              !"error_notification_of_message_" !"$NOTIFICATION$"];
#    [!?prefix add ![@lstring new !"flag_fct" !here]
#              !"tpl_set_flag_" !"$FLAGFUNCTION$"];
#    [!?prefix add ![@lstring new !"error_notif_ptr" !here]
#              !"&error_notification_of_message_" !"$NOTIFICATION_PTR$"];
#    [!?prefix add ![@lstring new !"msg_buf" !here]
#              !"buffer_of_message_" !"$BUFFER$"];
#    [!?prefix add ![@lstring new !"filter" !here]
#              !"filter_of_message_" !"$FILTER$"];
#    [!?prefix add ![@lstring new !"filter_ptr" !here]
#              !"&filter_of_message_" !"$FILTER_PTR$"];
#    [!?prefix add ![@lstring new !"filter_func" !here]
#              !"" !"$FILTERING_FUNC$"];
#    [!?prefix add ![@lstring new !"filter_kind" !here]
#              !"" !"$FILTER_KIND$"];
#
#    init_targets_prefixes !?prefix;

#end routine;

#--------------------------------------------------------------------
# Code generation routines
#--------------------------------------------------------------------
#routine generate_flags
#    ??@os_config os_gen_cfg
#    ??@root_obj   cpu
#    ?!@string    obj_header
#:
#    @string flags := "";
# 
#    # Output the ARCH
#    flags .= "#define    TARGET_ARCH    ARCH_".[arch[] uppercaseString]."\n";
#
#    # Check the STATUS field
#    if [[[cpu os] status] string] == "extended" then
#        flags .= "#define    OS_EXTENDED\n";
#    end if;
#
#    # Check the STARTUPHOOK field
#    @basic_type startuphook := [[cpu os] startuphook];
#    cast startuphook :
#    when == @bool_class b do
#        if [b value] then flags .= "#define    WITH_STARTUP_HOOK\n"; end if;
#    else end cast;
#    
#    # Check the SHUTDOWNHOOK field
#    @basic_type shutdownhook := [[cpu os] shutdownhook];
#    cast shutdownhook :
#    when == @bool_class b do
#        if [b value] then flags .= "#define    WITH_SHUTDOWN_HOOK\n"; end if;
#    else end cast;
#    
#    # Check the ERRORHOOK field
#    @basic_type errorhook := [[cpu os] errorhook];
#    cast errorhook :
#    when == @bool_class b do
#        if [b value] then flags .= "#define    WITH_ERROR_HOOK\n"; end if;
#    else end cast;
#    
#    # Check the PRETASKHOOK field
#    @basic_type pretaskhook := [[cpu os] pretaskhook];
#    cast pretaskhook :
#    when == @bool_class b do
#        if [b value] then flags .= "#define    WITH_PRE_TASK_HOOK\n"; end if;
#    else end cast;
#    
#    # Check the POSTTASKHOOK field
#    @basic_type posttaskhook := [[cpu os] posttaskhook];
#    cast posttaskhook :
#    when == @bool_class b do
#        if [b value] then flags .= "#define    WITH_POST_TASK_HOOK\n"; end if;
#    else end cast;
#    
#    # Check the USEGETSERVICEID field
#    @basic_type usegetserviceid := [[cpu os] usegetserviceid];
#    cast usegetserviceid :
#    when == @bool_class b do
#        if [b value] then flags .= "#define    WITH_USEGETSERVICEID\n"; end if;
#    else end cast;
#    
#    # Check the USEPARAMETERACCESS field
#    @basic_type useparameteraccess := [[cpu os] useparameteraccess];
#    cast useparameteraccess :
#    when == @bool_class b do
#        if [b value] then flags .= "#define    WITH_USEPARAMETERACCESS\n"; end if;
#    else end cast;
#    
#    # Check the USERESSCHEDULER field
#    @basic_type useresscheduler := [[cpu os] useresscheduler];
#    cast useresscheduler :
#    when == @bool_class b do
#        if [b value] then flags .= "#define    WITH_USERESSCHEDULER\n"; end if;
#    else end cast;
#    
#    # Generate the WITH_COM flag
#    @bool usecom := false;
#    if [[cpu com] usecom] then
#      usecom := true;
#    else
#      usecom := [[cpu messages] count] > 0    |
#                [[cpu net_messages] count] > 0;
#    end if;
#    flags .= bool_define[!"WITH_COM" !usecom];
#
#
#    # Check the SYSTEM_CALL field
#    cast [[cpu os] systemcall] :
#    when == @bool_class b do
#        if [b value] then flags .= "#define    WITH_SYSTEM_CALL\n"; end if;
#    else end cast;
#
#    # Check the MEMORY_PROTECTION field
#    flags .= bool_class_define[!"WITH_MEMORY_PROTECTION" !memory_protection[![cpu os]] !false];
#
#    # WITH_MEMMAP flag
#    flags .= bool_define[!"WITH_MEMMAP" !memory_mapping[![cpu os]]];
#    flags .= bool_define[!"WITH_COMPILER_SETTINGS" !(compiler[![[cpu os] memmap]] != "")];
#
#    # Output the TRAMPOLINE_BASE_PATH if it has been set in the OIL file
#    @lstring tpl_base_path := [[cpu os] tpl_base_path];
#    if [tpl_base_path string] != "" then
#      flags .= "#define    TRAMPOLINE_BASE_PATH \"".[tpl_base_path string]."\"\n";
#    else
#      flags .= "#define    TRAMPOLINE_BASE_PATH \"..\"\n";
#    end if;
#    
#    if [option goil_options.autosar_on value] then
#        # the autosar flag is turned on. so additional symbols are processed
#
#        flags .= "#define    WITH_AUTOSAR\n";
#
#        cast [[cpu os] protectionhook] :
#        when == @bool_class b do
#            if [b value] then flags .= "#define    WITH_PROTECTION_HOOK\n"; end if;
#        else end cast;
#
#        cast [[cpu os] stackmonitoring] :
#        when == @bool_class b do
#            if [b value] then flags .= "#define    WITH_STACK_MONITORING\n"; end if;
#        else end cast;
#
#        # check if timing protection must be turned on. This is done
#        # by scanning tasks and isrs. If at least one task or one isr
#        # uses timing protection, WITH_AUTOSAR_TIMING_PROTECTION is
#        # set. Otherwise, it is not set
#        @bool use_tp := false;
#
#        foreach [cpu tasks] (* @task_obj task) do
#            cast [task timing_prot] :
#            when == @void_timing_prot do
#            else
#                if use_tp == false then use_tp := true; end if;
#            end cast;
#        end foreach;
#
#        foreach [cpu isrs] (* @isr_obj isr) do
#            cast [isr timing_prot] :
#            when == @void_timing_prot do
#            else
#                if use_tp == false then use_tp := true; end if;
#            end cast;
#        end foreach;
#
#        if use_tp == true then
#            flags .= "#define    WITH_AUTOSAR_TIMING_PROTECTION\n";
#        end if;
#        flags .= "#define    AUTOSAR_SC    4\n";
#    end if;
#
#    # trace flags
#    @string tr;
#    [[[cpu os] trace] generate_c ?tr];
#    flags .= tr;
#
#    # with_it_table
#    flags .= bool_define[!"WITH_IT_TABLE"![os_gen_cfg with_it_table]];
#
#    # Output the boolean free flags
#    foreach [[cpu os] others] (@lstring key @basic_type f_obj) do
#        cast f_obj :
#        when == @bool_class b do
#            if [b value] then
#                flags .= "#define    WITH_".[key string]."\n";
#            end if;
#        else
#        end cast;
#    end foreach;
#
##    flags .= "#define    CRC_LEVEL " . [[option goil_options.corrected_bits value] string] . "\n";
#
#    obj_header := [obj_header stringByReplacingStringByString !"$CONFIG_FLAGS$" !flags];
#end routine;

#--------------------------------------------------------------------
# Makefile generation
#--------------------------------------------------------------------

#routine updateTemplateWithStringList
#  ?? @lstringlist strList
#  ?? @string templateKey
#  ?! @string templateStringToUpdate
#:
#    @string fullStr := "";
#    @bool first := true;
#    foreach strList (@lstring str) do 
#        if not first then fullStr .= " "; end if;
#        fullStr .= [str string]; 
#        first := false;
#    end foreach;
#    templateStringToUpdate := [templateStringToUpdate stringByReplacingStringByString !templateKey !fullStr];
#end routine;

#routine generate_makefile
#    ?@os_obj os
#    ?@string directory
#    ?@string app
#:
#    @string makefileSpecStr := template_string_if_exist[!"code" !"Makefile_specific"];
#    @string makefileStr := template_string[!"code" !"Makefile"];
#    
#    makefileStr := [makefileStr stringByReplacingStringByString !"$MAKEFILE_SPEC$" !makefileSpecStr];
#    updateTemplateWithStringList ![os app_src] !"$APP_SRC$" !?makefileStr;
#    updateTemplateWithStringList ![os cflags]  !"$CFLAGS$"  !?makefileStr;
#    updateTemplateWithStringList ![os ldflags] !"$LDFLAGS$" !?makefileStr;
#    updateTemplateWithStringList ![os asflags] !"$ASFLAGS$" !?makefileStr;
#
#    #executable name.
#    @string app_name_str := [[os app_name] string];
#    if app_name_str == "" then app_name_str := "trampoline"; end if;
#    checkFileDoesNotExists ![@lstring new !app_name_str ![[os app_name] location]];
#    makefileStr := [makefileStr stringByReplacingStringByString !"$APP_NAME$" !app_name_str];
#
#    #trampoline base path.
#    @string tpl_base_path_str := [[os tpl_base_path] string];
#    if tpl_base_path_str == "" then tpl_base_path_str := ".."; end if;
#    checkTrampolinePath ![@lstring new !tpl_base_path_str ![[os tpl_base_path] location]];
#    makefileStr := [makefileStr stringByReplacingStringByString !"$TRAMPOLINE_BASE_PATH$" !tpl_base_path_str];
#    
#    #oil file
#    makefileStr := [makefileStr stringByReplacingStringByString !"$OIL_FILE$" !app.".oil"];
#    #autosar flag
#    @string autosarStr;
#    if [option goil_options.autosar_on value] then autosarStr := "true";
#    else autosarStr := "false"; end if;
#    makefileStr := [makefileStr stringByReplacingStringByString !"$AUTOSAR_ON$" !autosarStr];
#    # trace flags
#    @string flags := "";
#    @string tr;
#    [[os trace] generate_make ?tr];
#    flags .= tr;
#    # memmap flag
#    flags .= bool_make_define[!"WITH_MEMMAP" !memory_mapping[!os]];
#    flags .= bool_make_define[!"WITH_LINKSCRIPT" !(link_script_name[![os memmap]] != "")];
#    # memory protection flag
#    flags .= bool_class_make_define[!"WITH_MEMORY_PROTECTION" !memory_protection[!os] !false];
#    doReplace !?makefileStr !"$FLAGS$" !flags;
#    # ld script file name
#    doReplace !?makefileStr !"$SCRIPT_FILE$" !link_script_name[![os memmap]];
#    
#    # -i option
#    @string i_option := "";
#    @string target_cfg_dep := "";
#    if [option goil_options.posix_it value] then 
#        i_option := "-i"; 
#        target_cfg_dep := "target.cfg";
#    end if;
#    doReplace !?makefileStr !"$GENITVEC$" !i_option;
#    doReplace !?makefileStr !"$OIL_FILE_DEP$" !target_cfg_dep;
#
#    makefileStr := [makefileStr stringByReplacingStringByString !"$TRAMPOLINE_TARGET$"![option goil_options.target_platform value]];
# 
#    do_replace_default !?makefileStr !"$COMPILER$" ![[os compiler] string] !"gcc";
#    do_replace_default !?makefileStr !"$ASSEMBLER$" ![[os assembler] string] !"as";
#    do_replace_default !?makefileStr !"$LINKER$" ![[os compiler] string] !"gcc";
# 
#    #target
#    check_target !tpl_base_path_str;
#    @string arch_chip_board := "";
#    add_makefile_flag_if_not_empty !?arch_chip_board !"ARCH" !arch[];
#    add_makefile_flag_if_not_empty !?arch_chip_board !"CHIP" !chip[];
#    add_makefile_flag_if_not_empty !?arch_chip_board !"BOARD" !board[];
#   
#    doReplace !?makefileStr !"$ARCH_CHIP_BOARD$" ! arch_chip_board;
#
#    doReplace !?makefileStr !"$WSC$" !true_false[!getBool[![os systemcall] !false]];
#    doReplace !?makefileStr !"$WMP$" !true_false[!getBool[!memory_protection[!os] !false]];
#    
#    #template
#    @string templatePathStr := [option goil_options.template_dir value];
#    @string templateStr;
#    if templatePathStr != "" then
#        templateStr := "GOIL_TEMPLATE_PATH = ".templatePathStr;
#    else
#        templateStr := "#GOIL_TEMPLATE_PATH = ";
#    end if;
#    makefileStr := [makefileStr stringByReplacingStringByString !"$GOIL_TEMPLATE_PATH$"!templateStr];
#    [makefileStr writeToFile ! directory."/Makefile"];
#end routine;

#--------------------------------------------------------------------
# Custom type generation
# This function generates the appropriate type according
# to the number of objects
#--------------------------------------------------------------------
routine generate_signed_type
  ?@uint64 count
  ?@string err
  !@string type
:
  # compute the max for each size
  @uint64 max_s8  := 1L << 7;
  @uint64 max_s16 := 1L << 15;
  @uint64 max_s32 := 1L << 31;
  
  if count < max_s8 then
    type := "s8";
  else
    if count < max_s16 then
      type := "s16";
    else
      if count < max_s32 then
        type := "s32";
      else
        type := "";
        error here : err;
      end if;
    end if;
  end if;
end routine;

routine generate_unsigned_type
  ?@uint64 count
  ?@string err
  !@string type
:
  # compute the max for each size
  @uint64 max_u8  := 1L << 8;
  @uint64 max_u16 := 1L << 16;
  @uint64 max_u32 := 1L << 32;

  if count < max_u8 then
    type := "u8";
  else
    if count < max_u16 then
      type := "u16";
    else
      if count < max_u32 then
        type := "u32";
      else
        type := "";
        error here : err;
      end if;
    end if;
  end if;
end routine;

routine generate_mask_type
  ?@uint64 count
  ?@string err
  !@string type
:
  # compute the max for each size
  @uint64 max_u8  := 8L;
  @uint64 max_u16 := 16L;
  @uint64 max_u32 := 32L;

  if count <= max_u8 then
    type := "u8";
  else
    if count <= max_u16 then
      type := "u16";
    else
      if count <= max_u32 then
        type := "u32";
      else
        type := "";
        error here : err;
      end if;
    end if;
  end if;
end routine;

routine generate_types
  ?@task_map          tasks
  ?@isr_map           isrs
  ?@alarm_map         alarms
  ?@counter_map       counters
  ?@resource_map      resources
  ?@scheduletable_map schedtables
  ?@app_map           apps
  ?@uint              max_priority
  ?!@string           types
:
  @string type;
  @uint64 max := 0L;
  @uint64 c;

  # compute the type for tpl_proc_id
  c := [[tasks count] uint64]+[[isrs count] uint64];
  if c > max then max := c; end if;
  generate_signed_type !c !"Too many processes (tasks and ISRs)" ?type;
  types := [types stringByReplacingStringByString !"$PROC_ID_T$" !type];

  # compute the type for tpl_priority
  generate_signed_type ![max_priority uint64] !"Maximum priority too high" ?type;
  #message "tpl_priority:         ".type."\n";
  types := [types stringByReplacingStringByString !"$PRIORITY_T$" !type];

  # compute the type for the activation count
  # iterate through the tasks to get the max
  @uint max_act := 0;
  foreach tasks (@lstring key @task_obj task) do
    cast [task activation] :
    when == @uint32_class ui do if [ui value] > max_act then max_act := [ui value]; end if;
    else error key : "Internal error, task ".[key string]." has wrong type for the ACTIVATION attribute";
    end cast;
  end foreach;
  generate_unsigned_type ![max_act uint64] !"Maximum ACTIVATION too high" ?type;
  #message "tpl_activate_counter: ".type."\n";
  types := [types stringByReplacingStringByString !"$ACTIVATION_T$" !type];

  # compute the type for the event mask
  # iterate through the tasks to get the maximum number of events
  @uint max_ev := 0;
  foreach tasks (@lstring key @task_obj task) do
    @lstringlist evts := [task events];
    if [evts length] > max_ev then max_ev := [evts length]; end if;
  end foreach;
  generate_mask_type ![max_ev uint64] !"Too much events" ?type;
  types := [types stringByReplacingStringByString !"$EVENTMASK_T$" !type];

  # compute the type for tpl_alarm_id
  c := [[alarms count] uint64];
  if c > max then max := c; end if;
  generate_unsigned_type !c !"too many alarms" ?type;
  #message "tpl_alarm_id:         ".type."\n";
  types := [types stringByReplacingStringByString !"$ALARM_ID_T$" !type];

  # compute the type for tpl_resource_id
  c := [[resources count] uint64];
  if c > max then max := c; end if;
  generate_unsigned_type !c !"too many resources" ?type;
  #message "tpl_resource_id:      ".type."\n";
  types := [types stringByReplacingStringByString !"$RESOURCE_ID_T$" !type];

  # compute the type for tpl_counter_id
  c := [[counters count] uint64];
  if c > max then max := c; end if;
  generate_unsigned_type !c !"too many counters" ?type;
  #message "tpl_counter_id:       ".type."\n";
  types := [types stringByReplacingStringByString !"$COUNTER_ID_T$" !type];

  # compute the type for tpl_schedtable_id
  c := [[schedtables count] uint64];
  if c > max then max := c; end if;
  generate_unsigned_type !c !"too many schedule tables" ?type;
  #message "tpl_schedtable_id:           ".type."\n";
  types := [types stringByReplacingStringByString !"$SCHEDTABLE_ID_T$" !type];

  # compute the type for tpl_timeobj_id as the max of the number of
  # alarms and schedule tables
  if [alarms count] > [schedtables count] then
    c := [[alarms count] uint64];
  else
    c := [[schedtables count] uint64];
  end if;
  if c > max then max := c; end if;
  generate_unsigned_type !c !"too many time objects" ?type;
  types := [types stringByReplacingStringByString !"$TIMEOBJ_ID_T$" !type];

  # compute the type for tpl_app_id
  generate_unsigned_type ![[apps count] uint64]+1L !"too many OS applications" ?type;
  #message "tpl_app_id:           ".type."\n";
  doReplace !?types !"$OSAPPLICATION_ID_T$" !type;

  # compute the type for tpl_tf_id (trusted function index)
  @stringset tfs [emptySet];

  foreach apps do
    cast [app trusted] :
    when == @app_trusted_true t do
      foreach [t trusted_fcts] (@string s) do
        tfs += !s;
      end foreach;
    else end cast;
  end foreach;

  generate_unsigned_type ![[tfs count] uint64] !"Too many Trusted Functions" ?type;
  doReplace !?types !"$TRUSTED_FCT_ID_T$" !type;

  # compute the type for tpl_generic_id
  generate_unsigned_type !max !"too many objects" ?type;
  #message "tpl_generic_id:           ".type."\n";
  doReplace !?types !"$GENERIC_ID_T$" !type;

end routine;

#--------------------------------------------------------------------
routine generate_timing_prot
    ?@task_map     tasks
    ?@resource_map rez
    ?!@string obj_header
:
    @uint max_sched_wd := [rez count] + 4 * [tasks count];

    obj_header := [obj_header stringByReplacingStringByString !"$MAX_WATCH_DOG$" ![max_sched_wd string]];
end routine;

#--------------------------------------------------------------------
# Alarms generation
#--------------------------------------------------------------------
#routine generate_alarms
#    ?@alarm_map  alarms
#    ?@stringMap app_for_obj
#    ?!@string    unused header
#    ?!@string    obj_header
#    ?!@string    implementation :
#
#    @string tpl_alarm_setevent         := template_string[!"code" !"alarm_event_set"];
#    @string tpl_alarm_activatetask     := template_string[!"code" !"alarm_task_act"];
#    @string tpl_alarm_callback         := template_string[!"code" !"alarm_callback"];
#    @string tpl_alarm_incrementcounter := template_string[!"code" !"alarm_inc_counter"];
#
#    @string alarms_result := "";
#
#    foreach alarms (@lstring alarm_name @alarm_obj alarm) do
#        @string result := "";
#
## sets up the kind of alarm and its action
#        @action_obj alarm_action;
#        alarm_action := [alarm action_params];
#        cast alarm_action :
#        when == @setevent_action sea do
#            result := tpl_alarm_setevent;
#            doReplace !?result !"$TASK$"  ![[sea task_name] string]."_id";
#            doReplace !?result !"$EVENT$" ![[sea event_name] string]."_mask";
#        when == @activatetask_action ata do
#            result := tpl_alarm_activatetask;
#            doReplace !?result !"$TASK$" ![[ata task_name] string]."_id";
#        when == @callback_action cba do
#            result := tpl_alarm_callback;
#            doReplace !?result !"$ALARM_CALLBACK$" ![[cba function_name] string]."_callback";
#        when == @incrementcounter_action ica do
#            result := tpl_alarm_incrementcounter;
#            doReplace !?result !"$TARGET_COUNTER$" ![[ica counter_name] string]."_counter_desc";
#        else error alarm_name : "Unknown action found";
#        end cast;
#
## sets up the autostart params
#        @autostart_obj autostart;
#        autostart := [alarm autostart_params];
#        cast autostart :
#        when == @autostart_void do
#            doReplace !?result !"$ALARM_STATE$" !"ALARM_SLEEP";
#            doReplace !?result !"$ALARM_CYCLE$" !"0";
#            doReplace !?result !"$ALARM_DATE$" !"0";
#        when == @autostart_false do
#            doReplace !?result !"$ALARM_STATE$" !"ALARM_SLEEP";
#            doReplace !?result !"$ALARM_CYCLE$" !"0";
#            doReplace !?result !"$ALARM_DATE$" !"0";
#        when == @alarm_autostart_true aat do
#            doReplace !?result !"$ALARM_STATE$" !"ALARM_AUTOSTART";
#            doReplace !?result !"$ALARM_CYCLE$" ![[[aat cycle_time] uint64] string];
#            doReplace !?result !"$ALARM_DATE$" ![[[aat alarm_time] uint64] string];
#        else error alarm_name : "Unknown autostart found";
#        end cast;
#
## sets up the remaining params
#        @lstring counter_name;
#        counter_name := [alarm counter_name];
#        doReplace !?result !"$ALARM_NAME$" ![alarm_name string];
#        doReplace !?result !"$ALARM$"   ![alarm_name string]."_alarm_desc";
#        doReplace !?result !"$COUNTER$" ![counter_name string]."_counter_desc";
#
## OS application which owns the alarm
#        if [option goil_options.autosar_on value] then
#          if [app_for_obj count] > 0 then
#            @string app_name;
#            [app_for_obj get !alarm_name ?app_name];
#            doReplace !?result !"$APP_ID$" ! app_name."_id";
#          end if;
#        end if;
#
#        alarms_result := alarms_result . "\n" . result;
#    end foreach;
#
## build the alarm table
#    @string alarm_ids := "";
#    @string alarm_imp := "";
#    foreach [alarms allKeys] (@string name) index n
#    before
#      alarm_imp := "CONSTP2VAR(tpl_time_obj, AUTOMATIC, OS_APPL_DATA)\n";
#      alarm_imp .= "  tpl_alarm_table[ALARM_COUNT] = {\n";
#    do
#      alarm_imp .= "  &".name."_alarm_desc";
#      alarm_ids .= "#define ".name."_id ".[n string]."\n";
#      alarm_ids .= "CONST(AlarmType, AUTOMATIC) ".name." = ".name."_id;\n";
#    between
#      alarm_imp .= ",\n";
#    after
#      alarm_imp .= "\n};\n";
#    end  foreach;
#
#    alarms_result := alarms_result."\n".alarm_imp;
#
#    doReplace !?implementation !"$ALARMIDS$" !alarm_ids;
#    doReplace !?implementation !"$ALARMS$" !alarms_result;
#    doReplace !?obj_header !"$ALARM_COUNT$" ![[alarms count] string];
#end routine;
#
#--------------------------------------------------------------------
# Actual Task priority computation
#--------------------------------------------------------------------
routine compute_actual_task_priority
    ?@task_map  tasks
    ?!@prio_map  prio_for_task
    !@uint      max_prio
:
    @objs_by_prio tl [emptySortedList];

    #
    # fill the sorted list
    # This list is sorted from the lower priority task
    # to the higher priority task
    #
    foreach tasks (@lstring task_name @task_obj task) do
        @basic_type prio_as_basic;
        @basic_type act_as_basic;
        @uint prio := 0;
        @uint act := 0;
        prio_as_basic := [task priority];
        act_as_basic := [task activation];

        cast prio_as_basic :
        when == @uint32_class ui do prio := [ui value];
        else error [prio_as_basic location] : "TASK PRIORITY attribute undefined";
        end cast;

        cast act_as_basic :
        when == @uint32_class ui do act := [ui value];
        else error [act_as_basic location] : "TASK ACTIVATION attribute undefined";
        end cast;

        tl += !prio !act !task_name;
    end foreach;

    #
    # Get the minimum priority
    #
    @uint actual_prio := 1;
    @uint cur_rel_prio := 0;
    if [tl length] > 0 then
        [tl smallest ?cur_rel_prio ?* ?*];
    end if;

    #
    # Compute the actual priority of the tasks starting from 1
    #
    foreach tl (@uint relative_prio @uint act @lstring tn) do
#        message "Prio = ".[relative_prio string].", nom = ".[tn string]."\n";
        if (relative_prio > cur_rel_prio) then
            cur_rel_prio := relative_prio;
            actual_prio ++;
        end if;
#        message "Actual prio = ".[actual_prio string].", nom = ".[tn string]."\n";
        [!?prio_for_task put !tn !actual_prio !act];
    end foreach;

    max_prio := actual_prio;

end routine;

#--------------------------------------------------------------------
# Actual ISR2 priority computation
#--------------------------------------------------------------------
routine compute_actual_isr_priority
    ?@isr_map   isrs
    ?!@prio_map  prio_for_isr
    ?@uint      floor
    !@uint      max_prio
:
    @objs_by_prio il [emptySortedList];

    if [isrs count] != 0 then
        #
        # fill the sorted list
        # This list is sorted from the lower priority isr
        # to the higher priority isr
        #
        foreach isrs (@lstring isr_name @isr_obj isr) do
            @basic_type prio_as_basic;
            @basic_type act_as_basic;
            @uint prio := 0;
            @uint act := 0;

            prio_as_basic := [isr priority];
            [isr get_activation ?act];

            cast prio_as_basic :
            when == @uint32_class ui do prio := [ui value];
            else error [prio_as_basic location] : "ISR PRIORITY attribute undefined";
            end cast;

    #        cast act_as_basic :
    #        when == @uint32_class ui do act := [ui value];
    #        else error [act_as_basic location] : "ISR ACTIVATION attribute undefined";
    #        end cast;

            il += !prio !act !isr_name;
        end foreach;

        #
        # Get the minimum priority
        #
        @uint actual_prio := floor + 1;
        @uint cur_rel_prio := 0;
        if [il length] > 0 then
            [il smallest ?cur_rel_prio ?* ?*];
        end if;

        #
        # Compute the actual priority of the isrs starting from floor + 1
        #
        foreach il (@uint relative_prio @uint a @lstring isn) do
#            message "Prio = ".[relative_prio string].", nom = ".[isn string]."\n";
            if (relative_prio > cur_rel_prio) then
                cur_rel_prio := relative_prio;
                actual_prio ++;
            end if;
#            message "Actual prio = ".[actual_prio string].", nom = ".[isn string]."\n";
            [!?prio_for_isr put !isn !actual_prio !a];
        end foreach;

        max_prio := actual_prio;
    else
        max_prio := floor;
    end if;
end routine;

#--------------------------------------------------------------------
# Resource priority computation
#--------------------------------------------------------------------
routine compute_rez_priority
    ?@resource_map rez
    ?@task_map     tasks
    ?@isr_map      isrs
    ?@prio_map     prio_for_process
    !@prio_map     prio_for_rez
    !@stringMap   comments
    
:
    prio_for_rez := [@prio_map emptyMap];
    comments := [@stringMap emptyMap];

    #
    # for each resource, start at a 0 priority.
    # iterate through the tasks and the isrs.
    # if the current task or isr may own the resource, and if
    # the priority of the current task/isr is greater than the
    # current computed priority for the resource, set the current
    # computed priority to that priority
    #

    foreach rez (@lstring rez_name ...) do
        @uint rez_prio := 0;
        @uint rez_act := 0;
        @string rez_comment := "";
        foreach tasks (@lstring tn @task_obj t) do
            @lstringlist owned_rez := [t resources];
            @bool owned;
            is_in_lstringlist !owned_rez !rez_name ?* ?owned;
            if owned then
                @uint prio;
                @uint act;
                [prio_for_process get !tn ?prio ?act];
                if prio > rez_prio then
                    rez_prio := prio;
                end if;
                rez_act := rez_act + act;
                rez_comment .= " used by task ".[tn string]." (".[prio string].")\n";
            end if;
        end foreach;
        foreach isrs (@lstring isn @isr_obj i) do
            @lstringlist owned_rez := [i resources];
            @bool owned;
            is_in_lstringlist !owned_rez !rez_name ?* ?owned;
            if owned then
                @uint prio;
                @uint act;
                [prio_for_process get !isn ?prio ?act];
                if prio > rez_prio then
                    rez_prio := prio;
                end if;
                rez_act := rez_act + act;
                rez_comment .= " used by isr ".[isn string]." (".[prio string].")\n";
            end if;
        end foreach;

        if rez_comment == "" then
            rez_comment := " none\n";
        end if;

        #
        # The higher priority task/isr that may own a resource had its activation
        # count added but it should not be. So substract it
        #
        foreach tasks (@lstring tn @task_obj t) do
            @lstringlist owned_rez := [t resources];
            @bool owned;
            is_in_lstringlist !owned_rez !rez_name ?* ?owned;
            if owned then
                @uint prio;
                @uint act;
                [prio_for_process get !tn ?prio ?act];
                if prio == rez_prio then
                    rez_act := rez_act - act;
                end if;
            end if;
        end foreach;
        foreach isrs (@lstring isn @isr_obj i) do
            @lstringlist owned_rez := [i resources];
            @bool owned;
            is_in_lstringlist !owned_rez !rez_name ?* ?owned;
            if owned then
                @uint prio;
                @uint act;
                [prio_for_process get !isn ?prio ?act];
                if prio == rez_prio then
                    rez_act := rez_act - act;
                end if;
            end if;
        end foreach;

        [!?prio_for_rez put !rez_name !rez_prio !rez_act];
        [!?comments put !rez_name !rez_comment];
#        message "Rez = ".[rez_name string]." prio = ".[rez_prio string]."\n";
#        message rez_comment;
    end foreach;
end routine;

#--------------------------------------------------------------------
# Compute the number of entry in the fifo for each priority level
#--------------------------------------------------------------------
routine compute_ready_list
    ?@prio_map  prio_for_process
    ?@prio_map  prio_for_rez
    ?@uint      max_task_prio
    ?@uint      max_prio
    !@prio_list ready_list
:
    ready_list := [@prio_list emptyList];

    # put in the list the fifo for the idle task
    ready_list += !1;

    # begin at priority 1
    @uint prio := 1;

    loop max_prio :
    while prio <= max_prio do
        # look for objects with the same priority
        @uint fifosize := 0;
        foreach prio_for_process (@lstring n @uint p @uint a) do
            if p == prio then fifosize := fifosize + a; end if;
        end foreach;
        foreach prio_for_rez (@lstring n @uint p @uint a) do
            if p == prio then fifosize := fifosize + a; end if;
        end foreach;

        # Since any task can get the RES_SCHEDULE resource,
        # This priority level should have one more entry
        if prio == max_task_prio then fifosize++; end if;

        ready_list += !fifosize;
        prio++;
    end loop;

#    log ready_list;
end routine;

routine compute_app_for_obj
  ?@app_map    apps
  !@stringMap app_for_obj
:
  app_for_obj := [@stringMap emptyMap];

  foreach apps do
    @string app_name := [key string];
    foreach [app tasks] do
      if not [app_for_obj hasKey ![key string]] then
        [!?app_for_obj put !key !app_name];
      end if;
    end foreach;
    foreach [app isrs] do
      if not [app_for_obj hasKey ![key string]] then
        [!?app_for_obj put !key !app_name];
      end if;
    end foreach;
    foreach [app alarms] do
      if not [app_for_obj hasKey ![key string]] then
        [!?app_for_obj put !key !app_name];
      end if;
    end foreach;
    foreach [app scheduletables] do
      if not [app_for_obj hasKey ![key string]] then
        [!?app_for_obj put !key !app_name];
      end if;
    end foreach;
    foreach [app counters] do
      if not [app_for_obj hasKey ![key string]] then
        [!?app_for_obj put !key !app_name];
      end if;
    end foreach;
    foreach [app resources] do
      if not [app_for_obj hasKey ![key string]] then
        [!?app_for_obj put !key !app_name];
      end if;
    end foreach;
  end foreach;
#  [!?app_for_obj put ![@lstring new !"SystemCounter" !here] !"INVALID_OSAPPLICATION"];

end routine;

#-------------------------------------------------------------------------------
# Tasks generation
#-------------------------------------------------------------------------------
#routine generate_tasks
#  ?@config          cfg
#  ?@task_map        tasks
#  ?@app_map         apps
#  ?@resource_map    resources
#  ?@prio_map        actual_priorities
#  ?@stringMap      app_for_obj
#  ?!@string         unused header
#  ?!@string         obj_header
#  ?!@string         implementation :
#
#    @string tpl_task := template_string[!"code" !"task"];
#    @string tasks_result := "";
#
#    @uint max_prio := 0;
#    @bool non_preemptable_exists := false;
#
#    foreach tasks (@lstring task_name @task_obj task) do
#        @string tmp;
#        @string result := "";
#
#        generate_context_and_stack !cfg !task_name !task !?result;
#
#        result := result . tpl_task;
#
#        doReplace !?result !"$EXEC_NAME$"     ![task_name string];
#        doReplace !?result !"$EXEC_FUNCTION$" ![task_name string]."_function";
#        doReplace !?result !"$TASK$"          ![task_name string]."_task_desc";
#        doReplace !?result !"$EXEC_STATIC$"   ![task_name string]."_task_stat_desc";
#        doReplace !?result !"$EXEC_CONTEXT$"  ![task_name string]."_CONTEXT";
#        doReplace !?result !"$EXEC_STACK$"    ![task_name string]."_STACK";
#        doReplace !?result !"$TASK_ID$"       ![task_name string]."_id";
#
#        # compute the type of the task (basic or extended) according to
#        # the events the task uses. If the task does not use any event,
#        # it is a basic task. It the task uses at least one event it is
#        # an extended task.
#        @string tpl_evt := "";
#        if [[task events] length] == 0 then
#            # basic task
#            result := [result stringByReplacingStringByString !"$TASK_TYPE$" !"TASK_BASIC"];
#        else
#            result := [result stringByReplacingStringByString !"$TASK_TYPE$" !"TASK_EXTENDED"];
#            # setup the event structure
#            tpl_evt := template_string[!"code" !"event_masks"];
#            doReplace !?tpl_evt !"$EXEC_NAME$" ![task_name string];
#            doReplace !?tpl_evt !"$TASK_EVENT_STRUCT$" ![task_name string]."_task_evts";
#        end if;
#
#        doReplace !?result !"$TASK_EVTS$" !tpl_evt;
#
#        @uint actual_prio;
#        [actual_priorities get !task_name ?actual_prio ?*];
#        
#        # Compute the maximum priority of tasks. This maximum priority
#        # is used as priority of RES_SCHEDULER and INTERNAL_RES_SCHEDULER
#        if actual_prio > max_prio then
#            max_prio := actual_prio;
#        end if;
#
#        if [[task schedule] string] == "NON" then
#            non_preemptable_exists := true;
#            doReplace !?result !"$RESOURCE_PTR$" !"&INTERNAL_RES_SCHEDULER";
#        else
#            # Schedule is FULL. Look for the usage of an internal resource
#            @lstringlist used_rez := [task resources];
#            @bool no_internal_rez_found := true;
#            foreach used_rez (@lstring rez_name) do
#                if no_internal_rez_found then
#                    @resource_obj rez;
#                    [resources get !rez_name ?rez];
#                    @resource_property_obj rez_prop := [rez property];
#                    cast rez_prop :
#                    when == @resource_property_internal_obj do
#                         doReplace !?result !"$RESOURCE_PTR$" !"&".[rez_name string]."_rez_desc";
#                         no_internal_rez_found := false;
#                    else
#                    end cast;
#               end if;
#            end foreach;
#            if no_internal_rez_found then
#                doReplace !?result !"$RESOURCE_PTR$" !"NULL";
#            end if;
#        end if;
#
#        tmp := [actual_prio string];
#        result := [result stringByReplacingStringByString !"$TASK_PRIORITY$" !tmp];
#        
#        @basic_type activation_as_basic;
#        activation_as_basic := [task activation];
#        cast activation_as_basic :
#        when == @uint32_class ui do tmp := [[ui value] string];
#        else error [activation_as_basic location] : "Unknown activation value";
#        end cast;
#        result := [result stringByReplacingStringByString !"$TASK_MAX_ACT_COUNT$" !tmp];
#
#        @task_autostart_obj autostart;
#        autostart := [task autostart];
#        cast autostart :
#        when == @task_autostart_true do
#            result := [result stringByReplacingStringByString !"$TASK_STATE$" !"AUTOSTART"];
#        when == @task_autostart_false do
#            result := [result stringByReplacingStringByString !"$TASK_STATE$" !"SUSPENDED"];
#        else error task_name : "Unknown autostart found";
#        end cast;
#
#        # AUTOSAR timing protection part
#        @timing_prot timing_prot := [task timing_prot];
#        @string tp;
#        @string tp_ref;
#        [timing_prot generate !cfg ?tp ?tp_ref ![task_name string] !resources];
#        result := [result stringByReplacingStringByString !"$TIMING_PROT_STRUCT$" !tp];
#        result := [result stringByReplacingStringByString !"$TIMING_PROT_REF$" !tp_ref];
#
#        # AUTOSAR OS Application part
#        if [option goil_options.autosar_on value] then
#          if [app_for_obj count] > 0 then
#            @string app_name;
#            [app_for_obj get !task_name ?app_name];
#            doReplace !?result !"$APP_ID$" ! app_name."_id";
#            # look if the OS Application is trusted
#            @uint trust := 0;
#            @app_obj app;
#            [apps get ![@lstring new !app_name !here] ?app];
#            cast [app trusted] :
#            when == @app_trusted_true do trust++;
#            else end cast;
#            doReplace !?result !"$TRUSTED_COUNT$" ![trust string];
#          else
#            doReplace !?result !"$TRUSTED_COUNT$" !"0";
#          end if;
#        else
#          doReplace !?result !"$TRUSTED_COUNT$" !"0";
#        end if;
#
#        tasks_result := tasks_result . "\n" . result;
#    end foreach;
#
## build the task table
##    @string task_head;
##    @string task_imp;
##    obj_table !"task" !"task" !"task" !p ![tasks allKeys] ?task_head ?task_imp;
##    tasks_result := tasks_result."\n".task_imp;
#
#    if non_preemptable_exists then
#        tasks_result := "extern tpl_internal_resource INTERNAL_RES_SCHEDULER;\n\n".tasks_result;
#    end if;
#
##    header := [header stringByReplacingStringByString !"$TASKS$" !task_head]; 
#    implementation := [implementation stringByReplacingStringByString !"$TASKS$" !tasks_result]; 
#    obj_header := [obj_header stringByReplacingStringByString !"$TASK_COUNT$" ![[tasks count] string]];
#    obj_header := [obj_header stringByReplacingStringByString !"$RES_SCHEDULER_PRIORITY$" ![max_prio string]];
#end routine;

#--------------------------------------------------------------------
# ISRs generation
#--------------------------------------------------------------------
#routine generate_isrs
#  ?@config          cfg
#  ?@isr_map         isrs
#  ?@app_map         apps
#  ?@resource_map    resources
#  ?@prio_map        actual_priorities
#  ?@stringMap      app_for_obj
#  ?!@string         unused header
#  ?!@string         obj_header
#  ?!@string         implementation :
#
#    @string tpl_isr := template_string[!"code" !"isr"];
#    @string tpl_isr_spec;
#
#    @string isrs_result := "";
#
#
#    foreach isrs (@lstring isr_name @isr_obj isr) do
#        @string tmp := "";
#        @string result := "";
#
#        generate_context_and_stack !cfg !isr_name !isr !?result;
#
#        result := result . tpl_isr;
#
#    doReplace !?result !"$EXEC_NAME$" ![isr_name string];
#    doReplace !?result !"$EXEC_FUNCTION$" ![isr_name string]."_function";
#    doReplace !?result !"$ISR$" ![isr_name string]."_isr_desc";
#    doReplace !?result !"$EXEC_STATIC$" ![isr_name string]."_isr_stat_desc";
#    doReplace !?result !"$EXEC_CONTEXT$" ![isr_name string]."_CONTEXT";
#    doReplace !?result !"$EXEC_STACK$" ![isr_name string]."_STACK";
#    doReplace !?result !"$ISR_HELPER$" ![isr_name string]."_isr_helper";
#    
#    doReplace !?result !"$ISR_ID$"       ![isr_name string]."_id";
#        
#        @uint actual_prio;
#        [actual_priorities get !isr_name ?actual_prio ?*];
#        tmp := [actual_prio string];
#        doReplace !?result !"$ISR_PRIORITY$" !tmp;
#        @uint act;
#        [isr get_activation ?act];
#        doReplace !?result !"$ISR_MAX_ACT_COUNT$" ![act string];
#
#        # AUTOSAR timing protection part
#        @timing_prot timing_prot := [isr timing_prot];
#        @string tp;
#        @string tp_ref;
#        [timing_prot generate !cfg ?tp ?tp_ref ![isr_name string] !resources];
#        doReplace !?result !"$TIMING_PROT_STRUCT$" !tp;
#        doReplace !?result !"$TIMING_PROT_REF$" !tp_ref;
#
#        # AUTOSAR OS Application part
#        if [option goil_options.autosar_on value] then
#          if [app_for_obj count] > 0 then
#            @string app_name;
#            [app_for_obj get !isr_name ?app_name];
#            doReplace !?result !"$APP_ID$" ! app_name."_id";
#            # look if the OS Application is trusted
#            @uint trust := 0;
#            @app_obj app;
#            [apps get ![@lstring new !app_name !here] ?app];
#            cast [app trusted] :
#            when == @app_trusted_true do trust++;
#            else end cast;
#            doReplace !?result !"$TRUSTED_COUNT$" ![trust string];
#          end if;
#        end if;
#
#        isrs_result := isrs_result . "\n" . result;
#
#    end foreach;
#
## build the isr table
##    @string isr_head;
##    @string isr_imp;
##    obj_table !"isr" !"isr" !"isr" !p ![isrs allKeys] ?isr_head ?isr_imp;
##    isrs_result := isrs_result."\n".isr_imp;
#
#    @string specific_code;
#    generate_isr_specific !isrs ?specific_code;
#    isrs_result .=  specific_code;
#
# #   header := [header stringByReplacingStringByString !"$ISRS$" !isr_head]; 
#    doReplace !?obj_header !"$ISR_COUNT$" ![[isrs count] string];
#    doReplace !?implementation !"$ISRS$" !isrs_result; 
#end routine;

#--------------------------------------------------------------------
# Counters generation
#--------------------------------------------------------------------
#routine generate_counters
#    ?@counter_map counters
#    ?@stringMap  app_for_obj
#    ?!@string     header
#    ?!@string     obj_header
#    ?!@string     implementation :
#
#    @string tpl_counter := template_string[!"code" !"counter"];
#    @string counters_result := "";
#    @string counters_cst := "";
#
#    foreach counters (@lstring counter_name @counter_obj counter) do
#        @string tmp := "";
#        @string result := tpl_counter;
#
#        doReplace !?result !"$COUNTER_NAME$" ![counter_name string];
#        doReplace !?result !"$COUNTER$" ![counter_name string]."_counter_desc";
#
#        @string name := "_" . [counter_name string];
#        if name == "_SystemCounter" then
#           name := "";
#        end if;
#
#        doReplace !?result !"$COUNTER_SUFF$" !name;
#
#        @basic_type ticks_as_basic;
#        ticks_as_basic := [counter ticks_per_base];
#        cast ticks_as_basic :
#        when == @uint32_class ui do tmp := [[ui value] string];
#        else error [ticks_as_basic location] : "Unknown COUNTER TICKSPERBASE value";
#        end cast;
#        doReplace !?result !"$TICKS_PER_BASE$" !tmp;
#        counters_cst .= "extern CONST(tpl_tick, OS_CONST) OSTICKSPERBASE".name.";\n";
#
#        @basic_type max_as_basic := [counter max_allowed_value];
#        cast max_as_basic :
#        when == @uint32_class ui do tmp := [[ui value] string];
#        else error [max_as_basic location] : "Unknown COUNTER MAXALLOWEDVALUE value";
#        end cast;
#        doReplace !?result !"$MAX_ALLOWED_VALUE$" !tmp;
#        counters_cst .= "extern CONST(tpl_tick, OS_CONST) OSMAXALLOWEDVALUE".name.";\n";
#
#        @basic_type min_as_basic := [counter min_cycle];
#        cast min_as_basic :
#        when == @uint32_class ui do tmp := [[ui value] string];
#        else error [min_as_basic location] : "Unknown COUNTER MINCYCLE value";
#        end cast;
#        doReplace !?result !"$MIN_CYCLE$" !tmp;
#        counters_cst .= "extern CONST(tpl_tick, OS_CONST) OSMINCYCLE".name.";\n\n";
#
#        #
#        # The COUNTER TYPE is specific to the AUTOSAR extension.
#        # There is no software counter in OSEK.
#        #
#        if [option goil_options.autosar_on value] then
#            @counter_type type := [counter type];
#            cast type :
#            when == @software_counter do tmp := "SOFTWARE_COUNTER";
#            when == @hardware_counter do tmp := "HARDWARE_COUNTER";
#            else error [type location] : "Unknown COUNTER TYPE value";
#            end cast;
#            doReplace !?result !"$COUNTER_KIND$" !tmp;
#
#            if [counter_name string] == "SystemCounter" then
#              doReplace !?result !"$APP_ID$" ! "INVALID_OSAPPLICATION";
#            else
#              if [app_for_obj count] > 0 then
#                @string app_name;
#                [app_for_obj get !counter_name ?app_name];
#                doReplace !?result !"$APP_ID$" ! app_name."_id";
#              end if;
#            end if;
#        end if;
#
#        counters_result := counters_result . "\n" . result;
#    end foreach;
# 
#    @string specific_code;
#    generate_counter_specific !counters ?specific_code;
#    counters_result .=  specific_code;
#
#    @string counter_ids := "";
#
#    # For AUTOSAR extension, generate a counter table
#    # of counters to allow access by API functions
#    # IncrementCounter, GetCounterValue and GetElapsedCounterValue
#    if [option goil_options.autosar_on value] then
#       @string counter_table := "";
#        foreach counters (@lstring counter_name @counter_obj counter) index n
#        before
#          counter_table := "#ifdef WITH_AUTOSAR\n";
#          counter_table .= "CONSTP2VAR(tpl_counter, OS_VAR, OS_APPL_DATA)\n";
#          counter_table .= "  tpl_counter_table[COUNTER_COUNT] = {\n";
#        do
#            counter_table .= "    &".[counter_name string]."_counter_desc";
#            counter_ids .= "#define ".[counter_name string]."_id ".[n string]."\n";
#            counter_ids .= "CONST(CounterType, AUTOMATIC) ".[counter_name string]." = ".[counter_name string]."_id;";
#        between counter_table .= ",\n"; counter_ids .= "\n";
#        after counter_table .= "\n};\n#endif\n";    
#        end foreach;
#        counters_result .= counter_table;
#    end if;
#
#
#    doReplace !?obj_header !"$COUNTER_COUNT$" ![[counters count] string];
#    doReplace !?header !"$COUNTERS$" !counters_cst; 
#    doReplace !?implementation !"$COUNTERIDS$" !counter_ids; 
#    doReplace !?implementation !"$COUNTERS$" !counters_result; 
#end routine;

#--------------------------------------------------------------------
# Resources generation
#--------------------------------------------------------------------
#routine generate_resources
#    ?@resource_map resources
#    ?@prio_map     rez_prio
#    ?@stringMap   rez_comments
#    ?@stringMap   app_for_obj
#    ?!@string      unused header
#    ?!@string      obj_header
#    ?!@string      implementation :
#
#    @string tpl_resource := template_string[!"code" !"resource"];
#    @string tpl_internal_resource := template_string[!"code" !"internal_resource"];
#    @string resources_result := "";
#    @stringlist regular_rez [emptyList];
#
#    foreach resources (@lstring resource_name @resource_obj resource) do
#        
#        @string result;
#        @string name := [resource_name string];
#
#        @resource_property_obj rez_prop;
#        rez_prop := [resource property];
#
#        @uint prio;
#        @string usage;
#        [rez_prio get !resource_name ?prio ?*];
#        [rez_comments get !resource_name ?usage];
#
#        cast rez_prop :
#        when == @resource_property_standard_obj do
#            result := tpl_resource;
#            regular_rez += !name;
#        when == @resource_property_linked_obj do
#            result := tpl_resource;
#            regular_rez += !name;
#        when == @resource_property_internal_obj do
#            result := tpl_internal_resource;
#        else
#            result := "";
#            error resource_name : "Unknown property found";
#        end cast;
#
#        doReplace !?result !"$RESOURCE_NAME$" ![resource_name string];
#        doReplace !?result !"$RESOURCE$"      ![resource_name string]."_rez_desc";
#
#        doReplace !?result !"$PRIORITY$" ![prio string];
#        doReplace !?result !"$USAGE$" !usage;
#
#        if [option goil_options.autosar_on value] then
#          if [app_for_obj count] > 0 then
#            @string app_name;
#            [app_for_obj get !resource_name ?app_name];
#            doReplace !?result !"$APP_ID$" ! app_name."_id";
#          end if;
#        end if;
#
#        resources_result := resources_result . "\n" . result;
#    end foreach;
#
## build the resource table
#    @string rez_ids := "";
#    @string rez_imp := "";
#
#    foreach regular_rez (@string name) index n do
#      rez_ids .= "#define ".name."_id ".[n string]."\n";
#      rez_ids .= "CONST(ResourceType, AUTOMATIC) ".name." = ".name."_id;\n";
#    end foreach;
#
#    regular_rez += !"res_sched";
#
#    foreach regular_rez (@string name) index n
#    before
#      rez_imp := "#define OS_START_SEC_CONST_UNSPECIFIED\n";
#      rez_imp .= "#include \"tpl_memmap.h\"\n";
#      rez_imp .= "CONSTP2VAR(tpl_resource, AUTOMATIC, OS_APPL_DATA)\n  tpl_resource_table[RESOURCE_COUNT] = {\n";
#    do
#       rez_imp .= "  &".name."_rez_desc";
#    between
#      rez_imp .= ",\n";
#    after
#      rez_imp .= "\n};\n";
#      rez_imp .= "#define OS_STOP_SEC_CONST_UNSPECIFIED\n";
#      rez_imp .= "#include \"tpl_memmap.h\"\n\n";
#    end foreach;
##    desc_table !"tpl_resource" !"resource" !"_rez_desc" !regular_rez ?rez_head ?rez_imp;
#    resources_result := resources_result."\n".rez_imp;
# 
#    doReplace !?implementation !"$REZIDS$" !rez_ids;
#    doReplace !?obj_header !"$RESOURCE_COUNT$" ![[regular_rez length] string];
#    doReplace !?implementation !"$RESOURCES$" !resources_result; 
#end routine;

routine computeEvents
  ??@root_obj cpu
  !@eventMaskMap eventMasks
:
  eventMasks := [@eventMaskMap emptyMap];
  @task_mask maskForTask := [@task_mask emptyMap];
  #
  # Iterate through the tasks to get the events used.
  # A or is done with the user masks of user events
  # and the result is stored in the task_mask map.
  # event conflicts are detected when building this Or
  # Auto events are looked up and for each auto event
  # the number of referencing tasks is computed and
  # stored in the evt_usage map.
  # In addition, a reverse mapping allowing to get all
  # the task referencing an event is built and stored
  # in the tasks_for_event map.
  #
  @event_usage_map evt_usage [emptyMap];
  @stringset_map tasksForEvent [emptyMap]; 

  foreach [cpu tasks] (@lstring taskName @task_obj task) do
    @lstringlist events_used;
    events_used := [task events];
    @uint64 event_mask := 0L;
    foreach events_used (@lstring evt_name) do
      @event_obj event;
      [[cpu events] get !evt_name ?event];
      @event_mask_obj mask_obj;
      mask_obj := [event mask];
      cast mask_obj :
      when == @event_mask_user_obj emu do
        if (event_mask & [[emu mask] uint64]) == 0L then
          event_mask := event_mask | [[emu mask] uint64];
        else
          error [emu mask] : "MASK of event ".[evt_name string]." conflicts with previous declarations";
        end if;
      when == @event_mask_auto_obj do
        @uint count;
        if [evt_usage hasKey ![evt_name string]] then
          [!?evt_usage delete !evt_name ?count];
          count++;
        else
          count := 1;
        end if;
        [!?evt_usage insert_count !evt_name !count];
      else
      end cast;
      @stringset refTasks [emptySet];
      if [tasksForEvent hasKey ![evt_name string]] then
        [!?tasksForEvent delete !evt_name ?refTasks];
      end if;
      refTasks += ![taskName string];
      [!?tasksForEvent add !evt_name !refTasks];
    end foreach;
    [!?maskForTask insert_mask !taskName !event_mask];
  end foreach;

  #
  # Output the user events
  #
  foreach [cpu events] (@lstring eventName @event_obj event) do
    @event_mask_obj eventMask := [event mask];
    cast eventMask :
    when == @event_mask_user_obj emu do
      [!?eventMasks put !eventName ![[emu mask] uint64]];
    else end cast;
  end foreach;

  #
  # Sort the auto events by reference count
  # in a sorted list
  #
  @sorted_events sortedEvents [emptySortedList];
  foreach evt_usage do
    sortedEvents += !key !count;
  end foreach;

  #
  # Compute the mask for auto events
  #
  # iterate through the events to compute the mask
  #

  foreach sortedEvents do
    if [tasksForEvent hasKey ![event_name string]] then
      @stringset tasks;
      [tasksForEvent get !event_name ?tasks];
      @uint64 mask := 0L;
      foreach tasks (@string t) do
        @uint64 tm;
        [maskForTask get_mask ![@lstring new !t !here] ?tm];
        mask := mask | tm;
      end foreach;
      # 0 are available slots in the mask.
      # look for the first available slot starting from bit 0
      @uint64 bit := 1L;
      loop 32 :
      while (bit < [[@uint max] uint64]) & ((bit & ~mask) == 0L) do
        bit := bit << 1; 
      end loop;
      if bit > [[@uint max] uint64] then
        error event_name : "All event mask bits are already use, event ".[event_name string]." can't be created";
      end if;
      # message "found ".[bit string]."\n";
      # update the task mask of the corresponding tasks
      foreach tasks (@string t) do
        @uint64 tm;
        [!?maskForTask del_mask ![@lstring new !t !here] ?tm];
        tm := bit | tm;
        [!?maskForTask insert_mask ![@lstring new !t !here] !tm];
      end foreach;
     
      [!?eventMasks put !event_name !bit];
#      @string result := tpl_event;
#      doReplace !?result !"$EVENT$" ![event_name string]."_mask";
#      doReplace !?result !"$EVENT_NAME$" ![event_name string];
#      doReplace !?result !"$EVENT_MASK$" ![bit string];
#      imp_result .= result."\n";

    end if;
  end foreach;
end routine;

#--------------------------------------------------------------------
# Events generation
#--------------------------------------------------------------------
#routine generate_events
#    ?@event_map events
#    ?@task_map tasks
#    ?!@string unused header
#    ?!@string implementation
#:
#    @string tpl_event := template_string[!"code" !"event"];
#    @string imp_result := "";
##    @string implementation_result := "";
#
#
#    #
#    # Iterate through the tasks to get the events used.
#    # A or is done with the user masks of user events
#    # and the result is stored in the task_mask map.
#    # event conflicts are detected when building this Or
#    # Auto events are looked up and for each auto event
#    # the number of referencing tasks is computed and
#    # stored in the evt_usage map.
#    # In addition, a reverse mapping allowing to get all
#    # the task referencing an event is built and stored
#    # in the tasks_for_event map.
#    #
#    @event_usage_map evt_usage [emptyMap];
#    @task_mask task_mask [emptyMap];
#    @stringset_map tasks_for_event [emptyMap]; 
#
#    foreach tasks (@lstring task_name @task_obj task) do
#        @lstringlist events_used;
#        events_used := [task events];
#        @uint64 event_mask := 0L;
#        foreach events_used (@lstring evt_name) do
#            @event_obj event;
#            [events get !evt_name ?event];
#            @event_mask_obj mask_obj;
#            mask_obj := [event mask];
#            cast mask_obj :
#            when == @event_mask_user_obj emu do
#                if (event_mask & [[emu mask] uint64]) == 0L
#                then
#                    event_mask := event_mask | [[emu mask] uint64];
#                else
#                    error [emu mask] : "MASK of event ".[evt_name string]." conflicts with previous declarations";
#                end if;
#            when == @event_mask_auto_obj do
#                @uint count;
#                if [evt_usage hasKey ![evt_name string]]
#                then
#                    [!?evt_usage delete !evt_name ?count];
#                    count++;
#                else
#                    count := 1;
#                end if;
#                [!?evt_usage insert_count !evt_name !count];
#            else
#            end cast;
#
#            @stringset ref_tasks [emptySet];
#            if [tasks_for_event hasKey ![evt_name string]] 
#            then
#                [!?tasks_for_event delete !evt_name ?ref_tasks];
#            end if;
#            ref_tasks += ![task_name string];
#            [!?tasks_for_event add !evt_name !ref_tasks];
#
#        end foreach;
#        [!?task_mask insert_mask !task_name !event_mask];
#    end foreach;
#
#  #
#  # Output the user events
#  #
#  foreach events (@lstring evt_name @event_obj evt) do
#    @event_mask_obj evt_mask;
#    evt_mask := [evt mask];
#    cast evt_mask :
#    when == @event_mask_user_obj emu do
#      @string result := tpl_event;
#      doReplace !?result !"$EVENT$" ![evt_name string]."_mask";
#      doReplace !?result !"$EVENT_NAME$" ![evt_name string];
#      doReplace !?result !"$EVENT_MASK$" ![[[emu mask] uint64] string];
#      imp_result .= result."\n";
#    else
#    end cast;
#  end foreach;
#
#  #
#  # Sort the auto events by reference count
#  # in a sorted list
#  #
#  @sorted_events sort_evts [emptySortedList];
#  foreach evt_usage do
#    sort_evts += !key !count;
#  end foreach;
#
#  #
#  # Compute the mask for auto events
#  #
#  # iterate through the events to compute the mask
#  #
#
#  foreach sort_evts do
#    if [tasks_for_event hasKey ![event_name string]] then
#      @stringset tasks;
#      [tasks_for_event get !event_name ?tasks];
#      @uint64 mask := 0L;
#      foreach tasks (@string t) do
#        @uint64 tm;
#        [task_mask get_mask ![@lstring new !t !here] ?tm];
#        mask := mask | tm;
#      end foreach;
#      # 0 are available slots in the mask.
#      # look for the first available slot starting from bit 0
#      @uint64 bit := 1L;
#      loop 32 :
#      while (bit < [[@uint max] uint64]) & ((bit & ~mask) == 0L) do
#        bit := bit << 1; 
#      end loop;
#      if bit > [[@uint max] uint64] then
#        error event_name : "All event mask bits are already use, event ".[event_name string]." can't be created";
#      end if;
#      # message "found ".[bit string]."\n";
#      # update the task mask of the corresponding tasks
#      foreach tasks (@string t) do
#        @uint64 tm;
#        [!?task_mask del_mask ![@lstring new !t !here] ?tm];
#        tm := bit | tm;
#        [!?task_mask insert_mask ![@lstring new !t !here] !tm];
#      end foreach;
#     
#      @string result := tpl_event;
#      doReplace !?result !"$EVENT$" ![event_name string]."_mask";
#      doReplace !?result !"$EVENT_NAME$" ![event_name string];
#      doReplace !?result !"$EVENT_MASK$" ![bit string];
#      imp_result .= result."\n";
#
#    end if;
#  end foreach;
#
##    @events ordered_evt [emptyList];
##    @uint max := 0;
##    @events to_delete [emptyList];
##   @uint evt_count := [evt_usage count];
#
##    loop evt_count + 1 :
##    while [evt_usage count] > 0 do
##        max := 0;
##        foreach evt_usage (@lstring key @uint count) do
##            message [key string]." : ".[count string]."\n";
##            if count > max
##            then
##                max := count;
##            end if;
##        end foreach;
#
##        message "max = ".[max string]."\n";
#
##        to_delete := [@events emptyList];
##        foreach evt_usage (@lstring key @uint count) do
##            if count == max
##            then
##                ordered_evt += !key;
##                to_delete += !key;
##                message "A detruire : ".[key string]."\n";
##            end if;
##        end foreach;
#
##        foreach to_delete (@lstring key) do
##            message "destruction de : ".[key string]."\n";
##            [!?evt_usage delete !key ?*];
##        end foreach;
#
##        message "taille de la map = ".[[evt_usage count] string]."\n";
##        foreach evt_usage (@lstring key @uint count) do
##            message "Il reste : ".[key string].", ".[count string]."\n";
##        end foreach;
##    end loop;
#
##    message "FIN\n"; 
#    #
#    # Compute the mask for auto events
#    #
#
##    log task_mask;
##    @uint64 common_mask := 0L;
##    foreach ordered_evt (@lstring evt) do
##        message [evt string]."\n";
#        # build the user mask
# #       @stringset ref_tasks;
# #       [tasks_for_event get !evt ?ref_tasks];
# #       foreach ref_tasks (@string task_name) do
# #           @uint64 mask;
# #           [task_mask get_mask ![@lstring new !task_name !here] ?mask];
# #           common_mask := common_mask | mask;
# #       end foreach;
##        message "mask = ".[common_mask string]."\n";
#        # find the first unused bit in the mask
# #       @uint64 needle := 1L;
# #       loop 64:
# #       while (needle & common_mask) != 0L do
# #           needle := needle << 1;
# #       end loop;
##        message "found ".[needle string]."\n";
# #       common_mask := common_mask | needle;
# #       @string result := tpl_event;
# #       doReplace !?result !"$EVENT$" ![evt string]."_mask";
# #       doReplace !?result !"$EVENT_NAME$" ![evt string];
# #       doReplace !?result !"$EVENT_MASK$" ![needle string];
# #       imp_result .= result."\n";
# #   end foreach;
#
##    header := [header stringByReplacingStringByString !"$EVENTS$" !imp_result]; 
#    doReplace !?implementation !"$EVENTS$" !imp_result; 
#
#end routine;

#--------------------------------------------------------------------
# Ready list structure generation
#--------------------------------------------------------------------
#routine generate_ready_list
#    ?@os_obj    os
#    ?@uint      max_prio
#    ?@prio_list ready_list
#    ?!@string   obj_header
#    ?!@string   implementation
#:
#
#    @string fifo := "";
#    @uint prio := 0;
#
#    @bool powerof2 := false;
#    @ident_map config := [os others];
#    # check if the POWER_OF_2_PRIORITY_QUEUE bool is declared
#    if [config hasKey !"POWEROF2QUEUE"] then
#        @basic_type pw;
#        [config get ![@lstring new !"POWEROF2QUEUE" !here] ?pw];
#        cast pw :
#        when == @bool_class b do
#            powerof2 := [b value];
#        else
#            error [pw location] : "POWEROF2QUEUE should be a boolean";
#        end cast;
#    end if;
#
#    fifo .= "#define OS_START_SEC_VAR_UNSPECIFIED\n#include \"tpl_memmap.h\"\n";
#
#    foreach ready_list (@uint size) do
#        @uint max_size;
#        if powerof2 then
#            max_size := 1;
#            loop 32 :
#            while size > max_size do
#                max_size := max_size << 1;
#            end loop;
#        else
#            max_size := size;
#        end if;
#        fifo .= "VAR(tpl_proc_id, OS_VAR) tpl_priority_".[prio string]."_fifo[".[max_size string]."];\n";
#        prio++;
#    end foreach;
#
#    fifo .= "\n";
#
#    prio := 0;
#    fifo .= "VAR(tpl_fifo_state, OS_VAR) tpl_fifo_rw[".[(max_prio + 1) string]."] = {\n";
#    loop max_prio + 1 :
#    while prio <= max_prio do
#        fifo .= "    { 0 , 0 }";
#        if prio < max_prio then fifo .= ","; end if;
#        fifo .= "\n";
#        prio++;
#    end loop;
#    fifo .= "};\n\n";
#
#    fifo .= "#define OS_STOP_SEC_VAR_UNSPECIFIED\n#include \"tpl_memmap.h\"\n";
#
#    fifo .= "#define OS_START_SEC_CONST_UNSPECIFIED\n#include \"tpl_memmap.h\"\n";
#
#    prio := 0;
#    fifo .= "CONST(tpl_priority_level, OS_CONST) tpl_ready_list[".[(max_prio + 1) string]."] = {\n";
#    foreach ready_list (@uint size) do
#        @uint max_size;
#        if powerof2 then
#            max_size := 1;
#            loop 32 :
#            while size > max_size do
#                max_size := max_size << 1;
#            end loop;
#            max_size--;
#        else
#            max_size := size;
#        end if;
#        fifo .= "    { tpl_priority_".[prio string]."_fifo , ".[max_size string]." }";
#        if prio < max_prio then fifo .= ","; end if;
#        fifo .= "\n";
#        prio++;
#    end foreach;
#    fifo .= "};\n\n";
#
#    fifo .= "#define OS_STOP_SEC_CONST_UNSPECIFIED\n#include \"tpl_memmap.h\"\n";
#
#    implementation := [implementation stringByReplacingStringByString !"$READY_LIST$" !fifo];
#    obj_header := [obj_header stringByReplacingStringByString !"$PRIO_LEVEL_COUNT$" ![(max_prio + 1) string]];
#end routine;

#routine loadTemplateConfig
#  !@templateConfig cfg
#  ?@root_obj cpu
#:
#  @lstringMap codeCfg [emptyMap];
#  @lstringMap linkerCfg [emptyMap];
#  @lstringMap compilerCfg [emptyMap];
#  @lstringMap buildCfg [emptyMap];
#  @stringlist searchedPaths;
#  @stringlist paths;
#  @stringlist codePathList [emptyList];
#  codePathList += !"templates/code";
#  codePathList += !rootTemplatesDirectory[] . "/code";
#  @stringlist linkerPathList [emptyList];
#  linkerPathList += !"templates/linker";
#  linkerPathList += !rootTemplatesDirectory[] . "/linker";
#  @stringlist compilerPathList [emptyList];
#  compilerPathList += !"templates/compiler";
#  compilerPathList += !rootTemplatesDirectory[] . "/compiler";
#  @stringlist buildPathList [emptyList];
#  buildPathList += !"templates/build";
#  buildPathList += !rootTemplatesDirectory[] . "/build";
#  
#  findAllFilesInPathList
#    !"templates.cfg"
#    !codePathList
#    ![option goil_options.target_platform value]
#    ?searchedPaths
#    ?paths;
#  
#  if [paths length] == 0 then
#    errorNoFileFound !searchedPaths !"code template configuration" !lstringWith[!"template.cfg"];
#  else
#    foreach paths (@string configFile) do
#      grammar template_cfg_grammar in lstringWith[!configFile] !?codeCfg;
#    end foreach;
#  end if;
#  
#  if linker[![[cpu os] memmap]] != "" then
#    findAllFilesInPathList
#      !"templates.cfg"
#      !linkerPathList
#      ![option goil_options.target_platform value]
#      ?searchedPaths
#      ?paths;
#  
#    if [paths length] == 0 then
#      errorNoFileFound !searchedPaths !"linker template configuration" !lstringWith[!"template.cfg"];
#    else
#      foreach paths (@string configFile) do
#        grammar template_cfg_grammar in lstringWith[!configFile] !?linkerCfg;
#      end foreach;
#    end if;
#  end if;
#  
#  if compiler[![[cpu os] memmap]] != "" then
#    findAllFilesInPathList
#      !"templates.cfg"
#      !compilerPathList
#      ![option goil_options.target_platform value]
#      ?searchedPaths
#      ?paths;
#  
#    if [paths length] == 0 then
#      errorNoFileFound !searchedPaths !"compiler template configuration" !lstringWith[!"template.cfg"];
#    else
#      foreach paths (@string configFile) do
#        grammar template_cfg_grammar in lstringWith[!configFile] !?compilerCfg;
#      end foreach;
#    end if;
#  end if;
#  
#  findAllFilesInPathList
#    !"templates.cfg"
#    !buildPathList
#    ![option goil_options.target_platform value]
#    ?searchedPaths
#    ?paths;
#  
#  if [paths length] == 0 then
#    errorNoFileFound !searchedPaths !"build template configuration" !lstringWith[!"template.cfg"];
#  else
#    foreach paths (@string configFile) do
#      grammar template_cfg_grammar in lstringWith[!configFile] !?buildCfg;
#    end foreach;
#  end if;
#  
#  cfg := [@templateConfig new
#    !codeCfg
#    !linkerCfg
#    !compilerCfg
#    !buildCfg
#  ];
#end routine;
#
##
# @fn generate_all
#
# routine generate_all does the generation of all the system.
# 
# @param cpu the root object got from the parsing
# 
routine generate_all
  ??@root_obj cpu
:
  # code generation
#  @string timestamp := [@string stringWithCurrentDateTime];

  @string temp_dir := templates_directory[!"code"];

  if temp_dir != "" then
      @string target := [option goil_options.target_platform value];
      if target != "" then
#          @string header := template_string[!"code" !"app_header"];
#          @string obj_header := template_string[!"code" !"obj_header"];
#          @string implementation := template_string[!"code" !"app_implementation"];
          @string types := template_string[!"code" !"types"];

          @config cfg [emptyMap];
          @lstring cfg_file := config_file[];
          if [cfg_file string] != "" then
              grammar cfg_grammar in cfg_file ?cfg;
          end if;

          @lstring extra_cfg_file := extra_config_file[];
          if [extra_cfg_file string] != "" then
              grammar cfg_grammar in extra_cfg_file ?cfg;
          end if;

          # Get all the 
#          @templateConfig templateConfig;
#          loadTemplateConfig ?templateConfig !cpu;

          @os_config generated_conf := os_cfg[!cpu];
#          @prefix_map prefix := [@prefix_map emptyMap];

#          init_prefixes !?prefix;

          @uint max_task_prio;
          @uint max_prio;
          @prio_map actual_prio [emptyMap];
          compute_actual_task_priority
              ![cpu tasks]
              !?actual_prio
              ?max_task_prio;

          compute_actual_isr_priority
              ![cpu isrs]
              !?actual_prio
              !max_task_prio
              ?max_prio;

          @prio_map rez_actual_prio;
          @stringMap rez_comments;
          compute_rez_priority 
              ![cpu resources]
              ![cpu tasks]
              ![cpu isrs] 
              !actual_prio
              ?rez_actual_prio
              ?rez_comments;

          @prio_list ready_list;
          compute_ready_list
              !actual_prio
              !rez_actual_prio
              !max_task_prio
              !max_prio
              ?ready_list;

          @stringMap app_for_obj;
          compute_app_for_obj
              ![cpu applis]
              ?app_for_obj;

#          generate_flags
#              !generated_conf
#              !cpu
#              !?obj_header;

#          [[cpu com] generate !?obj_header];

#          generate_events
#              ![cpu events]
#              ![cpu tasks]
#              !?header
#              !?implementation;

#          generate_counters
#              ![cpu counters]
#              !app_for_obj
#              !?header
#              !?obj_header
#              !?implementation;

#          generate_alarms
#              ![cpu alarms]
#              !app_for_obj
#              !?header
#              !?obj_header
#              !?implementation;

#          generate_tasks
#              !cfg
#              ![cpu tasks]
#              ![cpu applis]
#              ![cpu resources]
#              !actual_prio
#              !app_for_obj
#              !?header
#              !?obj_header
#              !?implementation;

#          generate_isrs
#              !cfg
#              ![cpu isrs]
#              ![cpu applis]
#              ![cpu resources]
#              !actual_prio
#              !app_for_obj
#              !?header
#              !?obj_header
#              !?implementation;

# Generate the process ids and table

#          generate_proc_table
#              ![cpu tasks]
#              ![cpu isrs]
#              !?header
#              !?implementation
#              !?obj_header;

#          generate_mp
#            !cpu
#            !app_for_obj
#            !?header
#            !?implementation
#            !?obj_header;

#          generate_resources
#              ![cpu resources]
#              !rez_actual_prio
#              !rez_comments
#              !app_for_obj
#              !?header
#              !?obj_header
#              !?implementation;

#          generate_messages
#              ![cpu messages]
#              !prefix
#              !?header
#              !?obj_header
#              !?implementation;

#          generate_network_messages
#            ![cpu net_messages]
#            ![cpu messages]
#            !?header
#            !?obj_header
#            !?implementation;

#          if [option goil_options.autosar_on value] then
#              generate_schedule_tables
#                  ![cpu scheduletables]
#                  !app_for_obj
#                  !?header
#                  !?obj_header
#                  !?implementation;
#              generate_timing_prot
#                  ![cpu tasks]
#                  ![cpu resources]
#                  !?obj_header;
#              generate_apps
#                  ![cpu applis]
#                  ![cpu tasks]
#                  ![cpu isrs]
#                  ![cpu alarms]
#                  ![cpu resources]
#                  ![cpu scheduletables]
#                  ![cpu counters]
#                  !?header
#                  !?obj_header
#                  !?implementation;
#              generate_trusted_functions
#                  ![cpu applis]
#                  !?header
#                  !?obj_header
#                  !?implementation;
#          end if;

#          generate_ready_list
#              ![cpu os]
#              !max_prio
#              !ready_list
#              !?obj_header
#              !?implementation;

          generate_types
              ![cpu tasks]
              ![cpu isrs]
              ![cpu alarms]
              ![cpu counters]
              ![cpu resources]
              ![cpu scheduletables]
              ![cpu applis]
              !max_prio
              !?types;
            
#          generate_it_table
#              !cfg
#              !generated_conf
#              !cpu
#              !?implementation;
              
          @eventMaskMap eventMasks;
          computeEvents !cpu ?eventMasks;

          @goilTemplateVariableMap sysCfg [emptyMap];
          #setCompilerKind !cpu !?sysCfg;
          
          setEnvData !cpu !?sysCfg;
          setProcessesList !cpu !actual_prio !app_for_obj !?sysCfg;
          setBasicTasksList !cpu !actual_prio !app_for_obj !?sysCfg;
          setExtendedTasksList !cpu !actual_prio !app_for_obj !?sysCfg;
          setTasksList !cpu !actual_prio !app_for_obj !?sysCfg;
          setISRs1List !cpu !actual_prio !app_for_obj !?sysCfg;
          setISRs2List !cpu !actual_prio !app_for_obj !?sysCfg;
          setCountersList !cpu !app_for_obj !?sysCfg;
          setEventsList !cpu !eventMasks !?sysCfg;
          setAlarmsList !cpu !app_for_obj !?sysCfg;
          setResourcesList !cpu !rez_actual_prio  !app_for_obj !?sysCfg;
          setMessagesList !cpu !app_for_obj !?sysCfg;
          setScheduletablesList !cpu !app_for_obj !?sysCfg;
          setOsapplicationsList !cpu !app_for_obj !?sysCfg;
          setProcessCount !cpu !?sysCfg;
          setBuildConfig !cpu !?sysCfg;
          setReadyList !cpu !ready_list !?sysCfg;         
          addBoolValue !?sysCfg ![@lstring new !"AUTOSAR" !here] ![option goil_options.autosar_on value];
          addUnsignedValue !?sysCfg !lstringWith[!"MAXTASKPRIORITY"] ![max_task_prio uint64];
          setOsConfig !cpu !?sysCfg;
          setInterruptSources !cfg !?sysCfg;
          
          #log sysCfg;
          
          @string goilLog := computeTemplate[!"" !sysCfg !"root"];
          [goilLog writeToFile !"goil.log"];
#          @string appConfigCFile := "tpl_app_config.c";
#          @string appConfigC := computeTemplate[!"code" !sysCfg !appConfigCFile];
#          @string appConfigHFile := "tpl_app_config.h";
#          @string appConfigH := computeTemplate[!"code" !sysCfg !appConfigHFile];
#          @string appDefineFile := "tpl_app_define.h";
#          @string appDefine := computeTemplate[!"code" !sysCfg !appDefineFile];          
#          @string appBuildFile := "Makefile";
#          @string appBuild := computeTemplate[!"build" !sysCfg !"Makefile"];
          
#          message appConfigH;
#          message appConfigC;

#          message appBuild;
                    
#          generate_memmap_new
#            !cpu
#            !sysCfg;
#
#          generate_link_script_new
#            !cpu
#            !sysCfg;
#
#          generate_compiler
#            !cpu;
#                generate_crc
#                    !tasks
#                    !?implementation;

          # write the result to files
          @string directory := projectName[];
          
#          @string header_file := "tpl_os_generated_configuration.h";
#          @string obj_header_file  := "tpl_app_objects.h";
#          @string implementation_file  := "tpl_os_generated_configuration.c";
          @string types_file := "tpl_app_custom_types.h";

#          header := [header stringByReplacingStringByString !"$HEADER$" !header_file];
#          header := [header stringByReplacingStringByString !"$IMPLEMENTATION$" !implementation_file];
#          header := [header stringByReplacingStringByString !"$TIMESTAMP$" !timestamp];
#          obj_header := [obj_header stringByReplacingStringByString !"$OBJ_HEADER$" !obj_header_file];
#          obj_header := [obj_header stringByReplacingStringByString !"$TIMESTAMP$" !timestamp];
#          implementation := [implementation stringByReplacingStringByString !"$HEADER$" !header_file];
#          implementation := [implementation stringByReplacingStringByString !"$OBJ_HEADER$" !obj_header_file];
#          implementation := [implementation stringByReplacingStringByString !"$IMPLEMENTATION$" !implementation_file];
#          implementation := [implementation stringByReplacingStringByString !"$TIMESTAMP$" !timestamp];

          @uint error_count := [@uint errorCount];

#          header_file := directory . "/" . header_file;
#          obj_header_file := directory . "/" . obj_header_file;
#          implementation_file := directory . "/" . implementation_file;
          types_file := directory . "/" . types_file;
#          appConfigHFile := directory . "/" . appConfigHFile;
#          appConfigCFile := directory . "/" . appConfigCFile;
#          appDefineFile := directory . "/" . appDefineFile;

          if error_count == 0 then
#              if [option .verbose_output value] then
#                  message "creating " . header_file . "\n";
#              end if;
#              [header makeDirectoryAndWriteToFile !header_file];
#              if [option .verbose_output value] then
#                  message "creating " . obj_header_file . "\n";
#              end if;
#              [obj_header makeDirectoryAndWriteToFile !obj_header_file];
#              if [option .verbose_output value] then
#                  message "creating " . implementation_file . "\n";
#              end if;
#              [implementation makeDirectoryAndWriteToFile !implementation_file];
              if [option .verbose_output value] then
                  message "creating " . types_file . "\n";
              end if;
              [types makeDirectoryAndWriteToFile !types_file];

#              if [option .verbose_output value] then
#                  message "creating " . appConfigHFile . "\n";
#              end if;
#              [appConfigH makeDirectoryAndWriteToFile !appConfigHFile];
#              if [option .verbose_output value] then
#                  message "creating " . appConfigCFile . "\n";
#              end if;
#              [appConfigC makeDirectoryAndWriteToFile !appConfigCFile];
#              if [option .verbose_output value] then
#                  message "creating " . appDefineFile . "\n";
#              end if;
#              [appDefine makeDirectoryAndWriteToFile !appDefineFile];
#          
#              if [option goil_options.generate_makefile value] then
#                  @string makefile_dir := [directory stringByDeletingLastPathComponent];
#                  if makefile_dir == "" then
#                      makefile_dir := ".";
#                  end if; 
##                  if [option .verbose_output value] then
##                      message "creating ".makefile_dir."/makefile\n";
##                  end if;
##                  generate_makefile
##                      ![cpu os]
##                      !makefile_dir
##                      ![[[@string stringWithSourceFilePath]
##                                 stringByDeletingPathExtension] lastPathComponent];
#                if [option .verbose_output value] then
#                  message "creating " . appBuildFile . "\n";
#                end if;
#                [appBuild makeDirectoryAndWriteToFile !appBuildFile];
          
#              end if;

              generate_description !cpu;
          end if;
      else
          message "No target platform given, compiling aborted\n";
      end if;
  else
      message "No template directory defined, compiling aborted\n";
  end if;
end routine;

end semantics;
# vim:ft=ggs:ts=4:sw=4
