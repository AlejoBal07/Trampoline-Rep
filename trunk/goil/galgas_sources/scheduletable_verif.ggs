semantics scheduletable_verif:

#import semantics goil_semantic_types in "goil_semantic_types.ggs";
#import semantics goil_types_scheduletable in "goil_types_scheduletable.ggs";
#import semantics goil_types_counter in "goil_types_counter.ggs";
#import semantics goil_types_task in "goil_types_task.ggs";
import semantics goil_types_root in "goil_types_root.ggs";

#
# Autosar schedule tables verification
#
routine schedule_tables_well_formed
  ??@scheduletable_map sts
  ??@root_obj cpu
:
  foreach sts (@lstring stname @scheduletable_obj st) do
	#check signgle-shot or repeating
	@string perio := "" ;
	cast [st periodic] :
  	 	when == @bool_class b do
        	if [b value] == true then 
              perio := "TRUE";
          	else
          	    perio := "FALSE";                       cast [st ltgt_sync]:      
                when == @ltgt_sync_true do                   error stname: "An implicit schedule table shall be repeating otherwise, synchronisation can't be done. See ".[stname string];
              else end cast;           		end if ;
   	else error stname : "Internal error, unexpected type for PERIODIC attribute of schedule table ".[stname string] ;
   	end cast ;

	# Check LENGTH is a number
	@uint64 len:= 0L;
   	cast [st length]:
      when == @uint64_class ui do
        len:= [ui value];
      else
        error stname: "Internal error, incorrect datatype for LENGTH attribute of Schedule Table ".[stname string];
   	end cast;
    
    # Check the schedule table has not a length equal to 0
    if len == 0L then
      error [[st length] location]: "The LENGTH attribute should not be 0";
    end if;

  	@action_list actions:= [st actions];
	# Check if at least one action exist in the schedule table 
	if ([actions length] == 0) then
	  	error stname: "OS401-OS407 - ACTION attribute not defined for SCHEDULETABLE ".[stname string];
	end if;

	#save counter values
  	@counter_map counters := [cpu counters];
	@uint64 mc := 0L;
	@uint64 mav := 0L;
	if [counters hasKey ![[st counter] string]] then
		@counter_obj cnt;
		[counters getCounter ![st counter] ?cnt];
		cast [cnt min_cycle] :
			when == @uint32_class a do
				mc := [[a value] uint64];
		else end cast;
		cast [cnt max_allowed_value] :
			when == @uint32_class b do
				mav := [[b value] uint64];
		else end cast;
	end if;

  	@uint64 cur_offset := 0L ;
   	@uint64 diff_offset := 0L ;
	@bool first_time := true;
 	foreach actions (@uint64 offset @uint order @action_obj action) do
  		# check there is no expiry point with an offset greater than the LENGTH of the schedule table
     	if offset > len then
         error [action location]: "Offset of action is greater than the LENGTH attribute of Schedule Table ".[stname string];
      	end if;

		diff_offset := offset - cur_offset;
		#message "offset = ".[offset string]." cur_offset = ".[cur_offset string]." diff_offset = ".[diff_offset string]."\n";
		
		# check the first offset is either 0 or in the range [OsMinCycle .. OsMaxaAllowedValue]
		# check the delay between expiry points is in the range [OsMinCycle .. OsMaxaAllowedValue]
		@string OS;
		if (cur_offset == 0L) then
			OS := "OS443";
		else
			OS := "OS408";
		end if;
		if (diff_offset != 0L) then
			if (diff_offset < mc) then
          		error stname : OS." - Delay between offset(".[cur_offset string].") and offset(".[offset string].") is less than mincyle(".[mc string].") of the counter of ".[stname string];
			end if;
			if (diff_offset > mav) then
          		error stname : OS." - Delay between offset(".[cur_offset string].") and offset(".[offset string].") is greater than maxallowedvalue(".[mav string].") of the counter of ".[stname string];
			end if;
		end if;

		# check the final delay  :
		#		- single-shot ST : 0 or in the range [OsMinCycle .. OsMaxaAllowedValue]
		#		- repeating ST : in the range [OsMinCycle .. OsMaxaAllowedValue]
		if ((offset == len) & (first_time == true) & (perio == "TRUE")) then
			error stname : "OS444 - Final delay (final offset) can be equal to LENGTH only for single-shot schedule table and ".[stname string]." isn't one";
		end if;		
		cur_offset := offset;
  	end foreach;
	
	#If Implicit Synchronisation, LENGTH should be equal to OSMAXALLOWEDVALUE + 1 (OS429)
	#@ltgt_sync_obj synchro := [st ltgt_sync];
	cast [st ltgt_sync] :
       when == @ltgt_sync_true sst do
		if ([[sst strategy] string] == "IMPLICIT") then         cast [st autostart] :
           when == @sd_autostart_relative do             error stname : "OS430 - ".[stname string]." should be started in Absolute mode only";           when == @sd_autostart_synchron do             error stname : "OS430 - ".[stname string]." should be started in Absolute mode only";         else end cast;                  if (len != (mav + 1L)) then
				error stname : "OS429 - LENGTH of ".[stname string]." should be equal to OSMAXALLOWEDVALUE + 1 (".[mav string].")";
			end if; 
		end if;
  	else end cast ;
     #Check good offset/start of autostart schedule table (because if out of range, API service call StartScheduleTableRel/StartScheduleTableRel   # can't return value in autostart)   cast [st autostart]:     when == @sd_autostart_relative relative_data do         if (([[relative_data offset] uint64] == 0L) | ([[relative_data offset] uint64] > mav) | ([[relative_data offset] uint64] < mc)) then            error stname: [stname string]." autostart's offset out of range [".[mc string]." ".[mav string]."] and not 0";         end if;     when == @sd_autostart_absolute absolute_data do         if (([[absolute_data value] uint64] > mav) | ([[absolute_data value] uint64] < mc)) then            error stname: [stname string]." autostart's offset out of range [".[mc string]." ".[mav string]."]";         end if;   else end cast;
  end foreach;
end routine;

routine schedule_tables_counters_exist_and_compatible
  ??@scheduletable_map sts
  ??@counter_map       cnts
:
  foreach sts (@lstring stname @scheduletable_obj st) do
    @lstring cnt:= [st counter];

    if not ([cnts hasKey ![cnt string]]) & ([cnt string] != "SystemCounter") then
      error cnt: "counter ".[cnt string]." is not defined !";
    else
      @uint64 len:= 0L;
      @location loc:= here;
      cast [st length]:
      when == @uint64_class ui do len:= [ui value]; loc:= [ui location];
      else error here: "Internal error, incorrect datatype for LENGTH attribute of schedule table ".[stname string];
      end cast;

      # check the length of te schedule table is not
      # greater than the max allowed value of the counter
      @counter_obj cpt;
      [cnts getCounter !cnt ?cpt];
      @uint64 max:= 0L;

      cast [cpt max_allowed_value]:
        when == @uint32_class ui do
          max:= [[ui value] uint64];
        else
          error here: "Internal error, incorrect datatype for MAXALLOWEDVALUE attribute of counter ".[cnt string];
      end cast;

      if (len > ( max + 1L)) then
        error loc: "LENGTH of schedule table ".[stname string]." is greater than MAXALLOWEDVALUE of counter ".[cnt string];
      end if;
    end if;
  end foreach;
end routine;

routine schedule_tables_tasks_and_events_exist
  ??@root_obj cpu

#scheduletable_map sts
#  ??@task_map          tasks
#  ??@event_map         events
:
  foreach [cpu scheduletables] (@lstring stname @scheduletable_obj st) do
    foreach [st actions] (@uint64 offset @uint order @action_obj action) do
        cast action:
        when == @activatetask_action ata do
		   if not [[cpu tasks] hasKey ![[ata task_name] string]] then
            error [action location]: "TASK attribute of action does not reference an existing task";
          end if;
      	 when == @setevent_action sea do
        	if not [[cpu tasks] hasKey ![[sea task_name] string]] then
          		error [action location]: "TASK attribute of action does not reference an existing task";
       	end if;
       	if not [[cpu events] hasKey ![[sea event_name] string]] then
        		error [action location]: "EVENT attribute of action does not reference an existing event";
        	end if;
		 when == @incrementcounter_action ica do
          if not [[cpu counters] hasKey ![[ica counter_name] string]] then
            error [action location]: "COUNTER attribute of action does not reference an existing counter";
          end if;
        else
          error stname: "Internal error, incorrect datatype for ACTION attribute at offset ".[offset string]." of schedule table ".[stname string];
      end cast;
    end foreach;
  end foreach;
end routine;

end semantics;