#---------------------------------------------------------------------------*
#                                                                           *
#  GOIL template invocation                                                 *
#                                                                           *
#  Copyright (C) 2009, ..., 2009 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics goil_template_invocation :
import semantics system_config in "system_config.ggs";
import semantics goil_template_semantics in "goil_template_semantics.ggs" ;
import grammar goil_template_grammar in "goil_template_grammar.gGrammar" ;
import option goil_options in "goil_options.gOption" ;

#------------------------------------------------------------------------------*

once allowedFunctions -> @stringset outAllowedFunctionSet :
  outAllowedFunctionSet := [@stringset emptySet] ;
  outAllowedFunctionSet += !"testFunction" ;
  outAllowedFunctionSet += !"tasks" ;
end once ;

#------------------------------------------------------------------------------*

routine addBoolValue
  ?!@goilTemplateVariableMap ioTemplateVariableMap
  ??@lstring inVariableName
  ??@bool inValue
:
  [!?ioTemplateVariableMap insertKey
    !inVariableName
    ![@goilTemplateType boolType]
    ![@goilTemplateValue new !if inValue then 1L else 0L end !"" ![@goilTemplateFieldMapList emptyList]]
  ] ;
end routine ;

#------------------------------------------------------------------------------*

routine addUnsignedValue
  ?!@goilTemplateVariableMap ioTemplateVariableMap
  ??@lstring inVariableName
  ??@uint64 inValue
:
  [!?ioTemplateVariableMap insertKey
    !inVariableName
    ![@goilTemplateType unsignedType]
    ![@goilTemplateValue new !inValue !"" ![@goilTemplateFieldMapList emptyList]]
  ] ;
end routine ;

#------------------------------------------------------------------------------*

routine addStringValue
  ?!@goilTemplateVariableMap ioTemplateVariableMap
  ??@lstring inVariableName
  ??@string inValue
:
  [!?ioTemplateVariableMap insertKey
    !inVariableName
    ![@goilTemplateType stringType]
    ![@goilTemplateValue new !0L !inValue ![@goilTemplateFieldMapList emptyList]]
  ] ;
end routine ;

#------------------------------------------------------------------------------*

routine addListValue
  ?!@goilTemplateVariableMap ioTemplateVariableMap
  ??@lstring inVariableName
  ??@goilTemplateFieldMapList inValue
:
  [!?ioTemplateVariableMap insertKey
    !inVariableName
    ![@goilTemplateType listType]
    ![@goilTemplateValue new !0L !"" !inValue]
  ] ;
end routine ;

#------------------------------------------------------------------------------*
#                                                                              *
#  A D D    A    F I E L D    V A L U E                                        *
#                                                                              *
#------------------------------------------------------------------------------*

routine addBoolFieldValue
  ?!@goilTemplateFieldMap ioTemplateFieldMap
  ??@lstring inVariableName
  ??@bool inValue
:
  [!?ioTemplateFieldMap insertKey
    !inVariableName
    ![@goilTemplateType boolType]
    !if inValue then 1L else 0L end
    !""
    ![@goilTemplateFieldMapList emptyList]
  ] ;
end routine ;

#------------------------------------------------------------------------------*

routine addUnsignedFieldValue
  ?!@goilTemplateFieldMap ioTemplateFieldMap
  ??@lstring inVariableName
  ??@uint64 inValue
:
  [!?ioTemplateFieldMap insertKey
    !inVariableName
    ![@goilTemplateType unsignedType]
    !inValue
    !""
    ![@goilTemplateFieldMapList emptyList]
  ] ;
end routine ;

#------------------------------------------------------------------------------*

routine addStringFieldValue
  ?!@goilTemplateFieldMap ioTemplateFieldMap
  ??@lstring inVariableName
  ??@string inValue
:
  [!?ioTemplateFieldMap insertKey
    !inVariableName
    ![@goilTemplateType stringType]
    !0L
    !inValue
    ![@goilTemplateFieldMapList emptyList]
  ] ;
end routine ;

#------------------------------------------------------------------------------*

routine addListFieldValue
  ?!@goilTemplateFieldMap ioTemplateFieldMap
  ??@lstring inVariableName
  ??@goilTemplateFieldMapList inValue
:
  [!?ioTemplateFieldMap insertKey
    !inVariableName
    ![@goilTemplateType listType]
    !0L
    !""
    !inValue
  ] ;
end routine ;

#------------------------------------------------------------------------------*
#                                                                              *
#  D I S P L A Y    T Y P E    A N D    V A L U E                              *
#                                                                              *
#------------------------------------------------------------------------------*

function displayTypeAndValue
  ??@goilTemplateType inType
  ??@goilTemplateValue inValue
  -> @string outResult
:
  switch inType
  when boolType :
    outResult := "bool: " . if [inValue mUnsigned64Value] == 1L then "yes" else "no" end ;
  when unsignedType :
    outResult := "unsigned: " . [[inValue mUnsigned64Value] string] ;
  when stringType :
    outResult := "string: '" . [inValue mStringValue] . "'" ;
  when listType :
    outResult := "list, " . [[[inValue mMapListValue] length] string] . " element" . if [[inValue mMapListValue] length] > 1 then "s" else "" end . ":" ;
    foreach [inValue mMapListValue] index idx do
      outResult .= "\n  #" . [idx string] . ":" ;
      foreach mMap do
        outResult .= "'" . key . "' " ;
        switch mType
        when boolType :
          outResult .= "bool: " . if mUnsigned64Value == 1L then "yes" else "no" end ;
        when unsignedType :
          outResult .= "unsigned: " . [mUnsigned64Value string] ;
        when stringType :
          outResult .= "string: '" . mStringValue . "'" ;
        when listType :
        end switch ;
      between outResult .= ", " ;
      end foreach ;
    end foreach ;
  end switch ;
end function ;

#------------------------------------------------------------------------------*

routine displayTemplateVariableMap
  ??@goilTemplateVariableMap inTemplateVariableMap
:
  foreach inTemplateVariableMap do
    message "'" . key . "' " . displayTypeAndValue [!mType !mValue] . "\n" ;
  end foreach ;
end routine ;

routine displayPathList
  ??@stringlist pathList
:
  message " -----------------------------------------\n";
  foreach pathList do
    message " - '" . mValue . "'\n" ;
  end foreach ;
  message " -----------------------------------------\n";
end routine;
#------------------------------------------------------------------------------*

routine goilTemplateInvocation
  ??@lstring                 inTemplateName
  ??@string                  inPrefix
  ??@string                  inPath
  ??@systemConfig            inCfg
  ??@goilTemplateVariableMap inTemplateVariableMap
  ?!@string                  ioResultingString
:
  if [@uint errorCount] == 0 then
    const @string templateDir := root_templates_directory[] ;
    if [templateDir length] == 0 then
      error inTemplateName:"the '--goil-templates' option or the environment variable GOIL_TEMPLATES is required for generating code" ;
    elsif not [templateDir directoryExists] then
      error inTemplateName:"the template path '" . templateDir . "' exists but is not a valid directory path" ;
    else
      const @string targetDir := [option goil_options.target_platform value] ;
      if [targetDir length] == 0 then
        error inTemplateName:"the '--target' (or '-t') option is required for generating code" ;
      elsif not [templateDir . "/" . inPrefix directoryExists] then
        error inTemplateName: "internal. no '". templateDir . "/" . inPrefix . "' template found";
#      elsif not [templateDir . "/" . targetDir directoryExists] then
#        error inTemplateName:"the '--target' (or '-t') option value is '" . templateDir
#        . "', so the path formed with '--goil-templates' option is '"
#        . templateDir . "/" . targetDir
#        . "', but it is not a valid directory path" ;
      else
        @stringlist pathList [emptyList] ;
        @bool found := false ;
        if inPath != "" then
          const @string fullTemplatePath := inPath . "/" . inPrefix . "/" . inTemplateName . ".goilTemplate" ;
          pathList += !fullTemplatePath ;
          found := [fullTemplatePath fileExists] ;
          if found then
            #displayPathList !pathList;
            grammar goil_template_grammar in [@lstring new !fullTemplatePath !here] !inPrefix !inPath !inCfg !inTemplateVariableMap !?ioResultingString ;
          end if ;
        end if ;
        @string targetTemplatePartialPath := targetDir ;
        loop [targetDir length] :
        while ([targetTemplatePartialPath length] > 0) & not found
        do
          const @string fullTemplatePath := templateDir . "/" . inPrefix . "/" . targetTemplatePartialPath . "/" . inTemplateName . ".goilTemplate" ;
          pathList += !fullTemplatePath ;
          found := [fullTemplatePath fileExists] ;
          if found then
            #displayPathList !pathList;
            grammar goil_template_grammar in [@lstring new !fullTemplatePath !here] !inPrefix !inPath !inCfg !inTemplateVariableMap !?ioResultingString ;
          else
            targetTemplatePartialPath := [targetTemplatePartialPath stringByDeletingLastPathComponent] ;
          end if ;
        end loop ;
        if not found then
          const @string fullTemplatePath := templateDir . "/" . inPrefix . "/" . inTemplateName . ".goilTemplate" ;
          pathList += !fullTemplatePath ;
          found := [fullTemplatePath fileExists] ;
          if found then
            #displayPathList !pathList;
            grammar goil_template_grammar in [@lstring new !fullTemplatePath !here] !inPrefix !inPath !inCfg !inTemplateVariableMap !?ioResultingString ;
          end if;
        end if;
        if not found then
          @string m := "cannot find a valid path for the '" . inTemplateName . "' template; I have tried:" ;
          foreach pathList do
            m .= "\n  - '" . mValue . "';" ;
          end foreach ;
          error inTemplateName :m ;
        end if ;
      end if ;
    end if ;
  end if ;
end routine ;

#------------------------------------------------------------------------------*

end semantics ;
