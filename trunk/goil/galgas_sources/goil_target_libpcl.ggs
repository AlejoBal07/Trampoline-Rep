semantics goil_target_libpcl :

import semantics goil_semantic_types in "goil_semantic_types.ggs" ;
import semantics goil_routines in "goil_routines.ggs" ;

routine init_libpcl_prefixes ?!@prefix_map prefix :
    [!?prefix insert_prefix ![@lstring new !"libpcl_stack" !here]
              !"stack_zone_of_" !"$STACK_ZONE$"] ;
    [!?prefix insert_prefix ![@lstring new !"libpcl_context" !here]
              !"integer_context_of_" !"$EXEC_ALL_CONTEXT$"] ;
end routine ;

routine generate_target_libpcl
    ?@lstring name
    ?@ident_map others
    ?@prefix_map p
    ?@oil_obj exe
    ?!@string result :

    replace !p !"libpcl_stack" ![name string] !?result ;
    replace !p !"libpcl_context" ![name string] !?result ;
    
    @uint64 stack_size;
    additional_int_key_required !"STACKSIZE" !others !name ?stack_size;
    result := [result stringByReplacingStringByString !"$STACK_SIZE$" ![stack_size string]] ;

    extract exe :
    when @isr_obj (6*) ->
        #object is an isr.
        #check that SIGNAL is present.
        @string sig;
        additional_string_key_required !"SIGNAL" !others !name ?sig;
        result := [result stringByReplacingStringByString !"$STACK_SIZE$" ![stack_size string]] ;
    else
    end extract ;
end routine ;

routine generate_isr_libpcl
  ?? @isr_map isrs
  ?? @prefix_map unused p
  ?!  @string code
:
  @string result := "";
  @bool first := true;
  foreach isrs (@lstring isr_name @isr_obj isr) :
    if not first then result .= ",\n";
    end if;
    first := false;
    @string key := "SIGNAL";
    @ident_map others := [isr other_fields];
    if [others hasKey !key]
    then
        @basic_type value ;
        [others searchIdent ![@lstring new !key !here] ?value] ;
        extract value :
        when @string_class (@string str) ->
            result := result."\t".str;
        else 
            error isr_name : key." should be a string" ;
        end extract ;
    else
        error isr_name : "no ".key." specified" ;
    end if ;
  end foreach ;
  code := [code stringByReplacingStringByString !"$ISR_SIGNAL_LIST$" !result] ;
end routine ;

routine generate_counter_libpcl
  ?? @counter_map counters
  ?? @prefix_map p
  ?!  @string code
:
  @string result := "";
  foreach counters (@lstring counter_name @counter_obj counter) :
    @string tmp;
    template ?tmp !"counter_list_specific";
    replace !p !"counter" ![counter_name string] !?tmp;
    result .= tmp;
  end foreach ;

  code := [code stringByReplacingStringByString !"$COUNTER_LIST$" !result] ;
end routine ;

end semantics ;
# vim:ft=ggs:ts=4:sw=4
