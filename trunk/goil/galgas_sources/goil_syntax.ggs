#
# Trampoline OS
#
# Trampoline is copyright (c) IRCCyN 2005+
# Trampoline est protégé par la loi sur la propriété intellectuelle
#
# This software is distributed under the Lesser GNU Public Licence
#
# GOIL parser
#
# $Date$
# $Rev$
# $Author$
# $URL$
#

syntax goil_syntax :
import lexique goil_lexique in "goil_lexique.ggs" ;
import option goil_options in "goil_options.ggs" ;
import semantics goil_semantics in "goil_semantics.ggs" ;
import grammar goil_cpu_level_include in "goil_grammar.ggs" ;

nonterminal <file> ;
nonterminal <OIL_version> !@lstring version !@lstring desc ;
nonterminal <description> !@lstring desc ;

nonterminal <application_definition> ;
nonterminal <object_definition_list>
    ?!@task_map     tasks
    ?!@counter_map  counters
    ?!@alarm_map    alarms
    ?!@resource_map resources
    ?!@event_map    events
    ?!@isr_map      isrs
    ?!@message_map  messages
;
nonterminal <nm> ;

nonterminal <boolean> !@bool val ;
nonterminal <free_field> ?!@ident_map ids ;
nonterminal <include_file_level> ;
nonterminal <include_cpu_level>
    ?!@task_map     tasks
    ?!@counter_map  counters
    ?!@alarm_map    alarms
    ?!@resource_map resources
    ?!@event_map    events
    ?!@isr_map      isrs
    ?!@message_map  messages
;

#--------------------------------------------------------------------
# extern nonterminals
#--------------------------------------------------------------------
nonterminal <implementation_definition> ?!@implementation imp ;

nonterminal <os> ;
nonterminal <appmode> ;
nonterminal <task> 
    ?!@task_map outTask;

nonterminal <counter>
    ?!@counter_map counters ;

nonterminal <alarm>
    ?!@alarm_map alarms ;

nonterminal <resource>
    ?!@resource_map resources ;

nonterminal <event> 
    ?!@event_map events;

nonterminal <isr>
    ?!@isr_map isrs ;

nonterminal <mess>
    ?!@message_map messages ;

nonterminal <networkmess> ;
nonterminal <com> ;
nonterminal <ipdu> ;

#
# root
#
rule <file> :
    @lstring version := [@lstring new !"" !here] ;
    @lstring desc := [@lstring new !"" !here] ;
    @implementation imp [emptyMap] ;
    repeat
    while
        <include_file_level> ;
    while
        <OIL_version> ?version ?desc ;
    while
        <implementation_definition> !?imp ;
    while
        <application_definition> ;
    end repeat ;
end rule ;

#
# Description of an OIL declaration
#
rule <description> !@lstring desc :
    select
        desc := [@lstring new !"" !here] ;
    or
        $:$ ;
        $string$ ?desc ;
    end select ;
end rule ;

#
# OIL version appears at the beginning of OIL files
#
rule <OIL_version> !@lstring version !@lstring desc :
    $OIL_VERSION$ ;
    $=$ ;
    $string$ ?version ;
    <description> ?desc ;
    $;$ ;
end rule ;

#         or  $ENUM$ ;    type := "ENUM" ;
#        or  $STRING$ ;  type := "STRING" ;
#        or  $BOOLEAN$ ; type := "BOOLEAN" ;
#    end select ;
#    <auto_specifier> ?auto ;
#    <number_range> !type ?range ;
#    <attribute_name> ?name ;
#    <multiple_specifier> ?multiple ;
#    <default_val> !type ?default_val ;
#end rule ;

#--------------------------------------------------------------------
# Application definition part
#--------------------------------------------------------------------
rule <application_definition> :

    @task_map     tasks     [emptyMap] ;
    @counter_map  counters  [emptyMap] ;
    @alarm_map    alarms    [emptyMap] ;
    @resource_map resources [emptyMap] ;
    @event_map    events    [emptyMap] ;
    @isr_map      isrs      [emptyMap] ;
    @message_map  messages  [emptyMap] ;

    $CPU$ ;
    $idf$ ?* ;
    ${$ ;
    <object_definition_list>
        !?tasks
        !?counters
        !?alarms
        !?resources
        !?events
        !?isrs
        !?messages
    ;
    $}$ ;
    <description> ?* ;
    $;$ ;

  #
  # semantics constraint checking
  #

  # per object static verification
    tasks_well_formed !tasks ;
    counters_well_formed !counters ;
    alarms_well_formed !alarms ;
    resources_well_formed !resources ;
    isrs_well_formed !isrs ;
    events_well_formed !events ;

  # cross-objects static verification 
    resolve_linked_resources !?resources ;
    all_events_and_resources_and_messages_defined_and_used !tasks !isrs !events !resources !messages ;
    all_event_masks_different !events ;
    all_alarm_actions_correct !alarms !tasks ;

    if [@uint errorCount] == 0 then
        # code generation
        @string timestamp := [@string stringWithCurrentDateTime] ;

        @string temp_dir ;
        templates_directory ?temp_dir ;

        if temp_dir != "" then
            @string target := [option goil_options.target_platform] ;
            if target != "" then
                @string header ;
                @string obj_header ;
                @string implementation ;

                template ?header !"app_header" ;
                template ?obj_header !"obj_header" ;
                template ?implementation !"app_implementation" ;
                @prefix_map prefix := [@prefix_map emptyMap] ;

                init_prefixes !?prefix ;

                generate_events    !events    !tasks        !prefix !?header !?implementation ;
                generate_counters  !counters                !prefix !?header !?implementation ;
                generate_alarms    !alarms                  !prefix !?header !?obj_header !?implementation ;
                generate_tasks     !tasks     !resources    !prefix !?header !?obj_header !?implementation ;
                generate_isrs      !isrs                    !prefix !?header !?obj_header !?implementation ;
                generate_resources !resources !tasks  !isrs !prefix !?header !?obj_header !?implementation ;
                generate_messages  !messages                !prefix !?header !?obj_header !?implementation ;

                # write the result to files
                @string directory := [[@string stringWithSourceFilePath] stringByDeletingPathExtension];
                if [option goil_options.project_dir] != "" then
                    directory := [option goil_options.project_dir] ;
                end if ;
                
                @string header_file := "tpl_os_generated_configuration.h" ;
                @string obj_header_file  := "tpl_app_objects.h" ;
                @string implementation_file  := "tpl_os_generated_configuration.c" ;

                header := [header stringByReplacingStringByString !"$HEADER$" !header_file];
                header := [header stringByReplacingStringByString !"$IMPLEMENTATION$" !implementation_file];
                header := [header stringByReplacingStringByString !"$TIMESTAMP$" !timestamp];
                obj_header := [obj_header stringByReplacingStringByString !"$OBJ_HEADER$" !obj_header_file];
                obj_header := [obj_header stringByReplacingStringByString !"$TIMESTAMP$" !timestamp];
                implementation := [implementation stringByReplacingStringByString !"$HEADER$" !header_file];
                implementation := [implementation stringByReplacingStringByString !"$OBJ_HEADER$" !obj_header_file];
                implementation := [implementation stringByReplacingStringByString !"$IMPLEMENTATION$" !implementation_file];
                implementation := [implementation stringByReplacingStringByString !"$TIMESTAMP$" !timestamp];

                @uint error_count := [@uint errorCount] ;

                header_file := directory . "/" . header_file;
                obj_header_file := directory . "/" . obj_header_file;
                implementation_file := directory . "/" . implementation_file;

                if error_count == 0 then
                    if [option .verbose_output] then
                        message "creating " . header_file . "\n" ;
                    end if;
                    [header makeDirectoryAndWriteToFile !header_file] ;
                    if [option .verbose_output] then
                        message "creating " . obj_header_file . "\n" ;
                    end if;
                    [obj_header makeDirectoryAndWriteToFile !obj_header_file] ;
                    if [option .verbose_output] then
                        message "creating " . implementation_file . "\n" ;
                    end if;
                    [implementation makeDirectoryAndWriteToFile !implementation_file] ;
                    end if ;
            else
                message "No target platform given, compiling aborted\n" ;
            end if ;
        else
            message "No template directory defined, compiling aborted\n" ;
        end if ;
    end if ;
end rule ;

rule <object_definition_list>
    ?!@task_map     tasks
    ?!@counter_map  counters
    ?!@alarm_map    alarms
    ?!@resource_map resources
    ?!@event_map    events
    ?!@isr_map      isrs
    ?!@message_map  messages
:

   repeat
    while <os> ;
    while <appmode> ; <description> ?* ;
    while <task> !?tasks ;
    while <counter> !?counters ;
    while <alarm> !?alarms ; <description> ?* ;
    while <resource> !?resources ; <description> ?* ;
    while <event> !?events ; <description> ?* ;
    while <isr> !?isrs ; <description> ?* ;
    while <mess> !?messages ; <description> ?* ;
    while <networkmess> ; <description> ?* ;
    while <com> ; <description> ?* ;
    while <ipdu> ; <description> ?* ;
    while <nm> ; <description> ?* ;
    while <include_cpu_level>
        !?tasks
        !?counters
        !?alarms
        !?resources
        !?events
        !?isrs
        !?messages
    ;
    end repeat ;
end rule ;

rule <nm> :
   $NM$ ;
   $idf$ ?* ;
   ${$ ;
   $}$ ;
   $;$ ;
end rule ;

#--------------------------------------------------------------------
# Miscellaneous non terminals
#--------------------------------------------------------------------
rule <boolean> !@bool val :
    select
        $TRUE$ ;
        val := true ;
    or
        $FALSE$ ;
        val := false ;
    end select ;
end rule ;

rule <free_field> ?!@ident_map ids :
    @lstring idf ;
    @basic_type val ;
    $idf$ ?idf ;
    $=$ ;
    select
        @lstring value ;
        $idf$ ?value ;
        val := [@string_class new  ![value location] ![value string]] ;
    or
        @luint64 value ;
        $uint_number$ ?value ;
        val := [@uint_class new  ![value location] ![value uint64]] ;
    or
        @bool value ;
        <boolean> ?value ;
        val := [@bool_class new ![idf location] !value] ;
    end select ;
    [!?ids put !idf !val] ; 
end rule ;

rule <include_file_level> :
    $include$ ;
    select
        $g_string$ ?* ;
    or
        $string$ ?* ;
    end select ;
end rule ;

rule <include_cpu_level>
    ?!@task_map     tasks
    ?!@counter_map  counters
    ?!@alarm_map    alarms
    ?!@resource_map resources
    ?!@event_map    events
    ?!@isr_map      isrs
    ?!@message_map  messages
:
    $include$ ;
    @lstring file_name ;
    select
        $g_string$ ?file_name ;
# search the include path for the file.
        @string include_path := [@string stringWithEnvironmentVariable !"GOIL_INCLUDE_PATH"] ;
        @stringlist path_list := [include_path componentsSeparatedByString !":"] ;
        @bool not_found := true ;
        foreach path_list (@string path):
            @string full_file_path := path ;
            if full_file_path != "" then
                if [full_file_path characterAtIndex !([full_file_path length] - 1)] != '/' then
                    full_file_path .= "/" ;
                end if ;
            end if ;
            full_file_path .= file_name ;
            if ([full_file_path fileExists] & not_found) then
                file_name := [@lstring new !full_file_path !here] ;
                not_found := false ;
            end if ;
        end foreach ;
    or
        $string$ ?file_name ;
    end select ;
    grammar goil_cpu_level_include in file_name
        !?tasks
        !?counters
        !?alarms
        !?resources
        !?events
        !?isrs
        !?messages
    ;        
end rule ;

end syntax ;
# vim:ft=ggs:ts=4:sw=4
