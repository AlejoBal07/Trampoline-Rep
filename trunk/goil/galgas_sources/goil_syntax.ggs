#
# Trampoline OS
#
# Trampoline is copyright (c) IRCCyN 2005+
# Trampoline est protégé par la loi sur la propriété intellectuelle
#
# This software is distributed under the Lesser GNU Public Licence
#
# GOIL parser
#
# $Date$
# $Rev$
# $Author$
# $URL$
#

syntax goil_syntax :
import lexique goil_lexique in "goil_lexique.ggs" ;
import option goil_options in "goil_options.ggs" ;
import semantics goil_semantics in "goil_semantics.ggs" ;

rule <file> ;
rule <OIL_version> !@lstring version !@lstring description ;
rule <description> !@lstring description ;
rule <implementation_definition> ?!@implementation imp ;
rule <implementation_spec_list> ?!@implementation imp ;
rule <implementation_spec> ?!@implementation imp ;
rule <implementation_list> ?!@implementationSpec spec ;
rule <impl_attr_def> ?!@implementationSpec spec ;
rule <auto_specifier> !@bool auto ;
rule <number_range_or_nil> !@bool has_range !@number_set set ;
rule <number_range> !@number_set set ;
rule <attribute_name> !@lstring name ;
rule <multiple_specifier> !@bool multiple ;
rule <default_number> !@bool has_default !@luint64 default_number ;
rule <default_name> !@bool has_default !@lstring default_name ;
rule <enumeration> ;
rule <enumerator> ;
rule <impl_parameter_list> ;
rule <implementation_def> ;

rule <application_definition> ;
rule <object_definition_list> ;
rule <nm> ;

rule <boolean> !@bool val ;
rule <free_field> ?!@ident_map ids ;


#--------------------------------------------------------------------
# Code generation rules declaration
#--------------------------------------------------------------------
rule <target> !@string target_platform ;
rule <template> !@string template ?@string obj ;
rule <generate_alarms> ?@alarm_map alarms ;

#--------------------------------------------------------------------
# extern rules
#--------------------------------------------------------------------
rule <appmode> ;
rule <task> 
	?!@task_map outTask;

rule <counter>
    ?!@counter_map counters ;

rule <alarm>
    ?!@alarm_map alarms ;

rule <resource>
	?!@resource_map resources ;

rule <event> 
	?!@event_map events;

rule <isr>
    ?!@isr_map isrs ;

rule <mess>
    ?!@message_map messages ;

rule <networkmess> ;
rule <com> ;
rule <ipdu> ;

#
# root
#
rule <file> :
#    message [option goil_options.target_platform]."\n" ;

    @lstring version ;
    @lstring description ;
    @implementation imp [emptyMap] ;
    <OIL_version> ?version ?description ;	 
    <implementation_definition> !?imp ;
    <application_definition> ;
#    message [version string] ;
#    message [description string] ;
#    message [imp description] ;
#    @base_class v := [@version new !version !description] ;
#    action generateHeader !version !description ;
end rule ;

#
# Description of an OIL declaration
#
rule <description> !@lstring description :
    select
        description := [@lstring new !"" !here] ;
    or
        $:$ ;
        $string$ ?description ;
    end select ;
end rule ;

#
# OIL version appears at the beginning of OIL files
#
rule <OIL_version> !@lstring version !@lstring description :
    $OIL_VERSION$ ;
    $=$ ;
    $string$ ?version ;
    <description> ?description ;
    $;$ ;
end rule ;

#
# implementation definition is the part of OIL files
# that specify the data size used for various types
# as well as default values
#
rule <implementation_definition> ?!@implementation imp :
    $IMPLEMENTATION$ ;
    $idf$ ?* ;
    ${$ ;
    <implementation_spec_list> !?imp ;
    $}$ ;
    <description> ?* ;
    $;$ ;
end rule ;

rule <implementation_spec_list> ?!@implementation imp :
    repeat
    while <implementation_spec> !?imp ;
    end repeat ;
end rule ;

rule <implementation_spec> ?!@implementation imp :
    @implementationSpec spec [emptyMap] ;
    select  $OS$ ;          <implementation_list> !?spec ;
            [!?imp insertSpec ![@lstring new !"OS" !here] !spec] ;
        or  $TASK$ ;        <implementation_list> !?spec ;
            [!?imp insertSpec ![@lstring new !"TASK" !here] !spec] ;
        or  $COUNTER$ ;     <implementation_list> !?spec ;
            [!?imp insertSpec ![@lstring new !"COUNTER" !here] !spec] ;
        or  $ALARM$ ;       <implementation_list> !?spec ;
            [!?imp insertSpec ![@lstring new !"ALARM" !here] !spec] ;
        or  $RESOURCE$ ;    <implementation_list> !?spec ;
            [!?imp insertSpec ![@lstring new !"RESOURCE" !here] !spec] ;
        or  $EVENT$ ;       <implementation_list> !?spec ;
            [!?imp insertSpec ![@lstring new !"EVENT" !here] !spec] ;
        or  $ISR$ ;         <implementation_list> !?spec ;
            [!?imp insertSpec ![@lstring new !"ISR" !here] !spec] ;
        or  $MESSAGE$ ;     <implementation_list> !?spec ;
            [!?imp insertSpec ![@lstring new !"MESSAGE" !here] !spec] ;
        or  $COM$ ;         <implementation_list> !?spec ;
            [!?imp insertSpec ![@lstring new !"COM" !here] !spec] ;
        or  $NM$ ;          <implementation_list> !?spec ;
            [!?imp insertSpec ![@lstring new !"NM" !here] !spec] ;
        or  $APPMODE$ ;     <implementation_list> !?spec ;
            [!?imp insertSpec ![@lstring new !"APPMODE" !here] !spec] ;
        or  $IPDU$ ;        <implementation_list> !?spec ;
            [!?imp insertSpec ![@lstring new !"IPDU" !here] !spec] ;
    end select ;
    <description> ?* ;
    $;$ ;
end rule ;

rule <implementation_list> ?!@implementationSpec spec :
    ${$ ;
    repeat
    while
        <impl_attr_def> !?spec ;
        $;$ ;
    end repeat ;
    $}$ ;
end rule ;

rule <impl_attr_def> ?!@implementationSpec unused spec :
  	@lstring type ;
  	@bool auto ;
   	@number_set range ;
   	@bool has_range ;
	@lstring attr_name ;
	@bool multiple ;
	@luint64 default_number;
	@bool has_default ;

   	select  $UINT32$ ?type ;
   	  	or  $INT32$ 	?type ;
 	 	or  $UINT64$ ?type ;
      	or  $INT64$  ?type ;
  	end select ;
  	<auto_specifier> ?auto ;
	<number_range_or_nil> ?has_range ?range ;
 	<attribute_name> ?attr_name ;
	<multiple_specifier> ?multiple ;
 	<default_number> ?has_default ?default_number ;
end rule ;

rule <impl_attr_def> ?!@implementationSpec unused spec :
	@lstring type ;    
	@bool auto ;
    $FLOAT$ ?type ;
    <auto_specifier> ?auto ;
#    <float_range> ?range ;
#    <attribute_name> ?name ;
#    <multiple_specifier> ?multiple ;
#    <default_float> ?default_float ;
end rule ;

rule <impl_attr_def> ?!@implementationSpec unused spec :
	@lstring type ;
	@bool auto ;

	$ENUM$ ?type ;
  	<auto_specifier> ?auto ;
	<enumeration> ;
	<attribute_name> ?* ;
	<multiple_specifier> ?* ;
	<default_name> ?* ?* ;
end rule ;

rule <auto_specifier> !@bool auto :
    select
        $WITH_AUTO$ ; auto := true ;
    or
        auto := false ;
    end select ;
end rule ;

rule <number_range_or_nil> !@bool has_range !@number_set set :
	select
		<number_range> ?set ;
		has_range := true ;
	or
		@luint64 zero := [@luint64 new !0L !here] ;
		set := [@uint_range new !zero !zero] ;
		has_range := false ;
	end select ;
end rule ;

rule <number_range> !@number_set set :
	@luint64 first ;
	$[$ ;
	select
		@luint64 last ;
		$set_start_uint_number$ ?first ;
       $uint_number$ ?last;
		set := [@uint_range new !first !last] ;
	or
		$uint_number$ ?first ;
		select
			@luint64 last ;
			$..$ ;
			$uint_number$ ?last ;
			set := [@uint_range new !first !last] ;
		or
			@number_list numList := [@number_list emptyList];
			numList += !first ;
	     	repeat
	     	while
				$,$ ;
				$uint_number$ ?first;
				numList += !first ;
   		 	end repeat ;
			set := [@uint_list new !numList];
		end select ;
	end select ;
  	$]$ ;
end rule ;  

rule <attribute_name> !@lstring name :
	$idf$ ?name;
end rule ;

rule <multiple_specifier> !@bool multiple :
	select
		$[$ ; $]$ ;
		multiple := true;
	or
		multiple := false;
	end select ;
end rule ;

rule <default_number> !@bool has_default !@luint64 default_number :
	select
		$=$ ;
		$uint_number$ ?default_number ;
		has_default := true ;
	or
		default_number := [@luint64 new !0L !here] ;
		has_default := false ;
	end select ;
end rule ;

rule <default_name> !@bool has_default !@lstring default_name :
	select
		$=$ ;
		$idf$ ?default_name ;
		has_default := true ;
	or
		default_name := [@lstring new !"" !here] ;
		has_default := false ;
	end select ;
end rule ;

#
# Enumeration.
#
rule <enumeration> :
	$[$ ;
	<enumerator> ;
	repeat
	while
		$,$ ;
		<enumerator> ;
	end repeat ;
	$]$ ;
end rule ;

rule <enumerator> :
	$idf$ ?* ;
	<impl_parameter_list> ;
	<description> ?* ;
end rule ;

rule <impl_parameter_list> :
	select
		${$ ;
		repeat
		while
			<implementation_def> ;
		end repeat ;
		$}$ ;
	or
	end select ;
end rule ;

rule <implementation_def> :
	$idf$ ?* ;
	$idf$ ?* ;
	$;$ ;
end rule ;

#         or  $ENUM$ ;    type := "ENUM" ;
#        or  $STRING$ ;  type := "STRING" ;
#        or  $BOOLEAN$ ; type := "BOOLEAN" ;
#    end select ;
#    <auto_specifier> ?auto ;
#    <number_range> !type ?range ;
#    <attribute_name> ?name ;
#    <multiple_specifier> ?multiple ;
#    <default_val> !type ?default_val ;
#end rule ;

#--------------------------------------------------------------------
# Application definition part
#--------------------------------------------------------------------
rule <application_definition> :
    repeat
    while
        $CPU$ ;
        $idf$ ?* ;
        ${$ ;
        <object_definition_list> ;
        $}$ ;
        <description> ?* ;
        $;$ ;
    end repeat ;
end rule ;

rule <object_definition_list> :

    @task_map tasks := [@task_map emptyMap] ;
    @counter_map counters := [@counter_map emptyMap] ;
    @alarm_map alarms := [@alarm_map emptyMap] ;
    @resource_map resources := [@resource_map emptyMap] ;
    @event_map events := [@event_map emptyMap] ;
    @isr_map isrs := [@isr_map emptyMap] ;
    @message_map messages [emptyMap] ;

    repeat
    while <appmode> ; <description> ?* ;
    while <task> !?tasks ;
    while <counter> !?counters ;
    while <alarm> !?alarms ;
    while <resource> !?resources ;
    while <event> !?events ;
    while <isr> !?isrs ;
    while <mess> !?messages ;
    while <networkmess> ; <description> ?* ;
    while <com> ; <description> ?* ;
    while <ipdu> ; <description> ?* ;
    while <nm> ; <description> ?* ;
    end repeat ;

#    message [alarms description] ;
#    message [isrs description] ;
#    message [counters description] ;
	
    # semantics constraint checking
    resolve_linked_resources !?resources ;
#    message [resources description] ;

    all_events_and_resources_defined_and_used !tasks !events !resources ;
    all_event_masks_different !events ;

    # code generation
    @string header ;
    @string implementation ;
    template ?header !"app_header" ;
    template ?implementation !"app_implementation" ;
    @prefix_map prefix := [@prefix_map emptyMap] ;

    init_prefixes !?prefix ;

    generate_events    !events    !tasks        !prefix !?header !?implementation ;
    generate_counters  !counters                !prefix !?header !?implementation ;
    generate_alarms    !alarms                  !prefix !?header !?implementation ;
    generate_tasks     !tasks                   !prefix !?header !?implementation ;
    generate_isrs      !isrs                    !prefix !?header !?implementation ;
    generate_resources !resources !tasks  !isrs !prefix !?header !?implementation ;
    generate_messages  !messages                !?header !?implementation ;

    # write the result to files
    @string directory := [[@string stringWithSourceFilePath] stringByDeletingPathExtension];
    @string header_file := "tpl_os_generated_configuration.h" ;
    @string implementation_file  := "tpl_os_generated_configuration.c" ;

    header := [header stringByReplacingStringByString !"$HEADER$" !header_file];
    header := [header stringByReplacingStringByString !"$IMPLEMENTATION$" !implementation_file];
    implementation := [implementation stringByReplacingStringByString !"$HEADER$" !header_file];
    implementation := [implementation stringByReplacingStringByString !"$IMPLEMENTATION$" !implementation_file];

    @uint error_count := [@uint errorCount] ;

    header_file := directory . "/" . header_file;
    implementation_file := directory . "/" . implementation_file;

    if error_count == 0 then
        if [option .verbose_output] then
            message "creating " . header_file . "\n" ;
        end if;
        [header makeDirectoryAndWriteToFile !header_file] ;
        if [option .verbose_output] then
            message "creating " . implementation_file . "\n" ;
        end if;
        [implementation makeDirectoryAndWriteToFile !implementation_file] ;
    end if ;
end rule ;

rule <nm> :
   $NM$ ;
   $idf$ ?* ;
   ${$ ;
   $}$ ;
   $;$ ;
end rule ;

#--------------------------------------------------------------------
# Miscellaneous non terminals
#--------------------------------------------------------------------
rule <boolean> !@bool val :
    select
        $TRUE$ ;
        val := true ;
    or
        $FALSE$ ;
        val := false ;
    end select ;
end rule ;

rule <free_field> ?!@ident_map ids :
    @lstring idf ;
    @basic_type val ;
    $idf$ ?idf ;
    $=$ ;
    select
        @lstring value ;
        $idf$ ?value ;
        val := [@string_class new ![value string]] ;
    or
        @luint64 value ;
        $uint_number$ ?value ;
        val := [@uint_class new ![value uint64]] ;
    or
        @bool value ;
        <boolean> ?value ;
        val := [@bool_class new !value] ;
    end select ;
    [!?ids insertIdent !idf !val] ; 
end rule ;

end syntax ;
