semantics goil_target_ppc :

import semantics goil_semantic_types in "goil_semantic_types.ggs" ;
import semantics goil_routines in "goil_routines.ggs" ;

routine init_ppc_prefixes ?!@prefix_map prefix :
    [!?prefix insert_prefix ![@lstring new !"ppc_stack" !here]
              !"stack_zone_of_" !"$STACK_ZONE$"] ;
    [!?prefix insert_prefix ![@lstring new !"ppc_int_context" !here]
              !"integer_context_of_" !"$EXEC_INTEGER_CONTEXT$"] ;
    [!?prefix insert_prefix ![@lstring new !"ppc_float_context" !here]
              !"float_context_of_" !"$EXEC_FLOAT_CONTEXT$"] ;
    [!?prefix insert_prefix ![@lstring new !"use_float" !here]
              !"using_float_for_" !"$EXEC_USE_FLOAT$"] ;
end routine ;

routine generate_target_ppc
    ?@lstring name
    ?@ident_map others
    ?@prefix_map p
    ?@oil_obj unused exe
    ?!@string result :

    replace !p !"ppc_stack" ![name string] !?result ;
    replace !p !"ppc_int_context" ![name string] !?result ;
    replace !p !"ppc_float_context" ![name string] !?result ;
    replace !p !"use_float" ![name string] !?result ;
    
    additional_int_key_required !"STACKSIZE" !"$STACK_SIZE$" !others !name !?result;

    @string use_float := "0" ;
    if [others hasKey !"USEFLOAT"]
    then
        @basic_type value ;
        [others searchIdent ![@lstring new !"USEFLOAT" !here] ?value] ;
        extract value :
        when @bool_class (@bool task_use_float) ->
            if task_use_float
            then use_float := "1" ;
            end if ;
        else error name : "USEFLOAT should be a boolean" ;
        end extract ;
    end if ;
   result := [result stringByReplacingStringByString !"$FLAG_USE_FLOAT$" !use_float] ;

end routine ;

routine generate_counter_ppc
  ?? @counter_map unused counters
  ?? @prefix_map p
  ?!  @string unused code
:
    #TODO
end routine ;

end semantics ;
