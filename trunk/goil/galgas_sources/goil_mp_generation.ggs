#
# @file goil_mp_generation.ggs
#
# @section File description
#
# This file compile all the galgas sources of Goil.
#
# @section Copyright
#
# Goil OIL compiler for Trampoline
#
# Goil is copyright (c) IRCCyN 2005+
# Goil is protected by the french law of intellectual property
#
# This software is distributed under the GNU Public Licence V2
#
# @section File informations
#
# $Date$
# $Rev$
# $Author$
# $URL$
#

semantics goil_mp_generation :

import semantics goil_routines         in "goil_routines.ggs" ;
import semantics goil_types_task       in "goil_types_task.ggs" ;
import semantics goil_types_isr        in "goil_types_isr.ggs" ;
import semantics goil_types_app        in "goil_types_app.ggs" ;
import semantics goil_env_verification in "goil_env_verification.ggs" ;

import option goil_options in "goil_options.ggs" ;

#
# generate_mp generates the descriptors used for memory protection
#
routine generate_mp
  ?@task_map   tasks
  ?@isr_map    isrs
  ?@app_map    apps
  ?@string_map app_for_obj
:
  @string tpl_mp ;
  @string dec := "" ;
  @string init := "" ;
  @string ext := "" ;

  retrieveTemplateString ?tpl_mp !"mp" ;
  doReplace !?tpl_mp !"$TIMESTAMP$" ![@string stringWithCurrentDateTime];

  @stringset known_osapp [emptySet] ;

  foreach tasks do
    dec .= "VAR(tpl_mem_prot_desc, OS_VAR) ".[key string]."_mp_desc;\n" ;
    ext .= "extern void *__SEG_START_TASK_".[key string]."_VAR_RGN;\n" ;
    ext .= "extern void *__SEG_END_TASK_".[key string]."_VAR_RGN;\n" ;
    ext .= "extern void *__SEG_START_TASK_".[key string]."_STACK_RGN;\n" ;
    ext .= "extern void *__SEG_END_TASK_".[key string]."_STACK_RGN;\n" ;
    if [option goil_options.autosar_on] then
      if [app_for_obj count] > 0 then
        @string app_name ;
        [app_for_obj get !key ?app_name] ;
        if not [known_osapp hasKey !app_name] then
          ext .= "extern void *__SEG_START_APP_".app_name."_VAR_RGN;\n" ;
          ext .= "extern void *__SEG_END_APP_".app_name."_VAR_RGN;\n" ;
          known_osapp += !app_name ;
        end if ;
      end if ;
    end if ;
    init .= "  ".[key string]."_mp_desc.proc_var.start = __SEG_START_TASK_".[key string]."_VAR_RGN;\n" ;
    init .= "  ".[key string]."_mp_desc.proc_var.end = __SEG_END_TASK_".[key string]."_VAR_RGN;\n" ;
    init .= "  ".[key string]."_mp_desc.proc_stack.start = __SEG_START_TASK_".[key string]."_STACK_RGN;\n" ;
    init .= "  ".[key string]."_mp_desc.proc_stack.end = __SEG_END_TASK_".[key string]."_STACK_RGN;\n" ;
    if [option goil_options.autosar_on] then
      if [app_for_obj count] > 0 then
        @string app_name ;
        [app_for_obj get !key ?app_name] ;
        init .= "#ifdef WITH_OSAPPLICATION\n" ;
        init .= "  ".[key string]."_mp_desc.osap_var.start = __SEG_START_APP_".app_name."_VAR_RGN;\n" ;
        init .= "  ".[key string]."_mp_desc.osap_var.end = __SEG_END_APP_".app_name."_VAR_RGN;\n" ;
        init .= "#endif\n" ;
      end if ;
    end if ;
  end foreach ;

  foreach isrs do
    dec .= "VAR(tpl_mem_prot_desc, OS_VAR) ".[key string]."_mp_desc;\n" ;
    ext .= "extern void *__SEG_START_ISR_".[key string]."_VAR_RGN;\n" ;
    ext .= "extern void *__SEG_END_ISR_".[key string]."_VAR_RGN;\n" ;
    ext .= "extern void *__SEG_START_ISR_".[key string]."_STACK_RGN;\n" ;
    ext .= "extern void *__SEG_END_ISR_".[key string]."_STACK_RGN;\n" ;
    if [option goil_options.autosar_on] then
      if [app_for_obj count] > 0 then
        @string app_name ;
        [app_for_obj get !key ?app_name] ;
        if not [known_osapp hasKey !app_name] then
          ext .= "extern void *__SEG_START_APP_".app_name."_VAR_RGN;\n" ;
          ext .= "extern void *__SEG_END_APP_".app_name."_VAR_RGN;\n" ;
          known_osapp += !app_name ;
        end if ;
      end if ;
    end if ;
    init .= "  ".[key string]."_mp_desc.proc_var.start = __SEG_START_ISR_".[key string]."_VAR_RGN;\n" ;
    init .= "  ".[key string]."_mp_desc.proc_var.end = __SEG_END_ISR_".[key string]."_VAR_RGN;\n" ;
    init .= "  ".[key string]."_mp_desc.proc_stack.start = __SEG_START_ISR_".[key string]."_STACK_RGN;\n" ;
    init .= "  ".[key string]."_mp_desc.proc_stack.end = __SEG_END_ISR_".[key string]."_STACK_RGN;\n" ;
    if [option goil_options.autosar_on] then
      if [app_for_obj count] > 0 then
        @string app_name ;
        [app_for_obj get !key ?app_name] ;
        init .= "#ifdef WITH_OSAPPLICATION\n" ;
        init .= "  ".[key string]."_mp_desc.osap_var.start = __SEG_START_APP_".app_name."_VAR_RGN;\n" ;
        init .= "  ".[key string]."_mp_desc.osap_var.end = __SEG_END_APP_".app_name."_VAR_RGN;\n" ;
        init .= "#endif\n" ;
      end if ;
    end if ;
  end foreach ;

  @tasks_by_type stasks [emptySortedList];
  # sort tasks according to type (basic or extended)
  foreach tasks do
    if [[task events] length] > 0 then
      stasks += !0 ![key string] ;
    else
      stasks += !1 ![key string] ;
    end if ;
  end foreach ;

  @string mp_table := "CONSTP2VAR(tpl_mem_prot_desc, AUTOMATIC, OS_VAR) tpl_mp_table[TASK_COUNT + ISR_COUNT + 1] = {\n" ;
  foreach stasks do
    # if the task belongs to a trusted OS Application, the corresponding
    # table entry is set to NULL
    if [option goil_options.autosar_on] then
      if [app_for_obj count] > 0 then
        @string app_name ;
        [app_for_obj get ![@lstring new !name !here] ?app_name] ;
        @app_obj app ;
        [apps get ![@lstring new !app_name !here] ?app] ;
        cast [app trusted] :
        when == @app_trusted_true do
          mp_table .= "  NULL,\n" ;
        else
          mp_table .= "  &".name."_mp_desc,\n" ;
        end cast ; 
      end if ;
    else
      mp_table .= "  &".name."_mp_desc,\n" ;
    end if ;
  end foreach;

  foreach isrs
  do
    mp_table .= "  &".[key string]."_mp_desc,\n" ;
  end foreach;
  mp_table .= "  NULL\n};" ;

  @string directory := getProjectName();

  doReplace !?tpl_mp !"$APPLICATION$" !directory ;
  doReplace !?tpl_mp !"$LINKER_SYM$"  !ext ;
  doReplace !?tpl_mp !"$REGION_DESC$" !dec ;
  doReplace !?tpl_mp !"$INIT_CODE$"   !init ;
  doReplace !?tpl_mp !"$DESC_TABLE$"  !mp_table ;

  if [@uint errorCount] == 0 then
   if [option .verbose_output] then
      message "creating tpl_generated_mp.c\n" ;
    end if;
    [tpl_mp makeDirectoryAndWriteToFile !directory."/tpl_generated_mp.c"] ;
  end if ;
end routine ;

end semantics ;