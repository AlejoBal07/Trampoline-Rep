#
# Trampoline OS
#
# Trampoline is copyright (c) IRCCyN 2005+
# Trampoline est protªgª par la loi sur la propriªtª intellectuelle
#
# This software is distributed under the Lesser GNU Public Licence
#
# GOIL task object parser
#
# $Date$
# $Rev$
# $Author$
# $URL$
#

syntax goil_obj_task :

import lexique goil_lexique in "goil_lexique.ggs" ;
import option goil_options in "goil_options.ggs" ;
import semantics goil_semantics in "goil_semantics.ggs" ;

#
# local rules declaration
#
nonterminal <task>
	?!@task_map tasks ;

nonterminal <task_attributes>
    ?@lstring task_name
    ?!@basic_type priority
    ?!@lstring schedule
    ?!@basic_type activation
    ?!@task_autostart_obj autostart
    ?!@stringset resources
    ?!@stringset events
    ?!@stringset messages
    ?!@ident_map others ;

nonterminal <task_autostart_params>
	?!@task_autostart_obj task_autostart ;

#
# external rules 
#
nonterminal <description>
    !@lstring desc ;
nonterminal <boolean>
    !@bool val ;
nonterminal <free_field>
    ?!@ident_map ids ;

#
# local rules implementation
#
rule <task>
	?!@task_map tasks 
:
    @lstring task_name ;
    @task_obj task ;
    @basic_type priority ;
    @lstring schedule ;
    @basic_type activation ;
    @task_autostart_obj autostart ;
    @stringset resources ;
    @stringset events ;
    @stringset messages ;
    @lstring desc ;
    @ident_map others ;

    $TASK$ ;
    $idf$ ?task_name ;
    if [tasks hasKey ![task_name string]] then
        [!?tasks del !task_name ?task] ;
        priority := [task priority];
        schedule := [task schedule] ;
        activation := [task activation] ;
        autostart := [task autostart] ;
        resources := [task resources] ;
        events := [task events] ;
        messages := [task messages] ;
        desc := [task desc] ;
        others := [task others] ;
    else
        priority := [@void new !here] ;
        schedule := [@lstring new !"" !here] ;
        activation := [@void new !here] ;
        autostart := [@task_autostart_void new !here] ;
        resources := [@stringset emptySet] ;
        events := [@stringset emptySet] ;
        messages := [@stringset emptySet] ;
        desc := [@lstring new !"" !here] ;
        others := [@ident_map emptyMap] ;
        task := [@task_obj new !desc !priority !schedule !activation !autostart !resources !events !messages !others] ;
    end if ;
    ${$ ;
    <task_attributes> !task_name !?priority !?schedule !?activation !?autostart !?resources !?events !?messages !?others ; 
    $}$ ;
    <description> ?desc ;
    $;$ ;

    task := [@task_obj new !desc !priority !schedule !activation !autostart !resources !events !messages !others] ;
    [!?tasks put !task_name !task] ;
end rule ;	

rule <task_attributes>
    ?@lstring task_name
    ?!@basic_type priority
    ?!@lstring schedule
    ?!@basic_type activation
    ?!@task_autostart_obj autostart
    ?!@stringset resources
    ?!@stringset events
    ?!@stringset messages
    ?!@ident_map others
:
    repeat
    while
        @luint64 prio ;
        $PRIORITY$ ; $=$ ; $uint_number$ ?prio ;  <description> ?* ; $;$ ;
        extract priority :
            when @void (@location l) ->
                priority := [@uint_class new !here ![prio uint64]] ;
            else
                error here : "PRIORITY attribute already defined for TASK " . [task_name string] ;
                error [priority location] : "was previously defined here" ;
        end extract ;
    while
        if [schedule string] != "" then
            error here : "SCHEDULE attribute already defined for TASK " . [task_name string] ;
            error [schedule location] : "was previously defined here" ;
        end if ;
        $SCHEDULE$ ; $=$ ; 
            select
                $FULL$ ;
                schedule := [@lstring new !"FULL" !here] ;
            or
                $NON$ ;
                schedule := [@lstring new !"NON" !here] ;
            end select ;
        <description> ?* ; $;$ ;
    while
        extract autostart :
        when @task_autostart_void (@location l) ->
        else 
            error here : "AUTOSTART attribute already defined for TASK " . [task_name string] ;
            error [autostart location] : "was previously defined here" ;
        end extract ;
		 $AUTOSTART$ ; $=$ ;
        select
            $TRUE$ ; ${$ ;
            <task_autostart_params> !?autostart ;
            $}$ ;
        or
            $FALSE$ ; 
            autostart := [@task_autostart_false new !here] ;
		 end select ;
        <description> ?* ; $;$ ;
    while
        @luint64 act ;
        $ACTIVATION$ ; $=$ ; $uint_number$ ?act ; <description> ?* ; $;$ ;
        extract activation :
        when @void (@location l) ->
            activation := [@uint_class new !here ![act uint64]] ;
        else
            error here : "ACTIVATION attribute already defined for TASK " . [task_name string] ;
            error [activation location] : "was previously defined here" ;
        end extract ;
    while
        @lstring  resource ;
        $RESOURCE$ ; $=$ ; $idf$ ?resource ; <description> ?* ; $;$ ;
        if ([resources hasKey ![resource string]]) then
            warning here : "RESOURCE " . [resource string] . " already defined for TASK " . [task_name string] ;
        end if ;
        resources += ![resource string] ;
    while
        @lstring event ;
        $EVENT$ ; $=$ ; $idf$ ?event ; <description> ?* ; $;$ ;
        if ([events hasKey ![event string]]) then
            warning here : "EVENT " . [event string] . " already defined for TASK " . [task_name string] ;
        end if ;
        events += ![event string] ;
    while
        @lstring mess ;
        $MESSAGE$ ; $=$ ; $idf$ ?mess ; <description> ?* ; $;$ ;
        if [messages hasKey ![mess string]] then
            warning here : "MESSAGE " . [mess string] . " already defined for TASK " . [task_name string] ;
        end if ;
        messages += ![mess string] ;
    while
        <free_field> !?others ; <description> ?* ; $;$ ;
    end repeat ;
end rule;

rule <task_autostart_params>
	?!@task_autostart_obj autostart
:
	@lstring appmode := [@lstring new !"" !here];
	@stringset appmodes [emptySet] ;
	repeat
	while
		$APPMODE$ ; $=$ ; $idf$ ?appmode ; <description> ?* ; $;$ ;
		if ([appmodes hasKey ![appmode string]]) then
			warning here : "APPMODE " . [appmode string] . " already defined for this task AUTOSTART attribute" ;
		end if ; 
		appmodes += ![appmode string] ;
	end repeat;
	autostart := [@task_autostart_true new !here !appmodes] ;
end rule ;

end syntax ;
# vim:ft=ggs:ts=4:sw=4
