//---------------------------------------------------------------------------*
//                                                                           *
//                          File 'cfg_lexique.cpp'                           *
//                        Generated by version 1.8.0                         *
//                       march 5th, 2009, at 9h31'47"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != 451
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <ctype.h>
#include <string.h>

#include "utilities/MF_MemoryControl.h"
#include "cfg_lexique.h"

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define LINE_AND_SOURCE_FILE sourceText ()->sourceFileName ().cString (), lineNumber ()
  #define COMMA_LINE_AND_SOURCE_FILE , LINE_AND_SOURCE_FILE
#else
  #define LINE_AND_SOURCE_FILE
  #define COMMA_LINE_AND_SOURCE_FILE
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                               Constructors                                *
//                                                                           *
//---------------------------------------------------------------------------*

cTokenFor_cfg_lexique::cTokenFor_cfg_lexique (void) :
keyword (),
string (),
integer (),
number () {
}

//---------------------------------------------------------------------------*

cfg_lexique::
cfg_lexique (C_Compiler * inCallerCompiler,
                const C_String & inDependencyFileExtension,
                const C_String & inDependencyFilePath,
                C_galgas_io * inParametersPtr,
                const C_String & inSourceFileName
                COMMA_LOCATION_ARGS) :
C_Lexique (inCallerCompiler, inDependencyFileExtension, inDependencyFilePath, inParametersPtr, inSourceFileName COMMA_THERE) {
}

//---------------------------------------------------------------------------*

cfg_lexique::
cfg_lexique (C_Compiler * inCallerCompiler,
                C_galgas_io * inParametersPtr,
                const C_String & inSourceString,
                const C_String & inStringForError
                COMMA_LOCATION_ARGS) :
C_Lexique (inCallerCompiler, inParametersPtr, inSourceString, inStringForError COMMA_THERE) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        Lexical error message list                         *
//                                                                           *
//---------------------------------------------------------------------------*

//--- Message 0
static const char * gErrorMessage_0 = "unterminated comment" ;
//--- Message 1
static const char * gErrorMessage_1 = "unterminated litteral string" ;
//--- Message 2
static const char * gErrorMessage_2 = "decimal number too large" ;
//--- Message 3
static const char * gErrorMessage_3 = "internal error" ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          Syntax error messages                            *
//                                                                           *
//---------------------------------------------------------------------------*

//--- Syntax error message for terminal '$tp_ns_per_counter_tick$' :
static const char * gSyntaxErrorMessage_tp_5Fns_5Fper_5Fcounter_5Ftick = "Config file keyword 'tp_ns_per_counter_tick'" ;

//--- Syntax error message for terminal '$stack_alignment$' :
static const char * gSyntaxErrorMessage_stack_5Falignment = "Config file keyword 'stack_alignment'" ;

//--- Syntax error message for terminal '$task$' :
static const char * gSyntaxErrorMessage_task = "Config file keyword 'task'" ;

//--- Syntax error message for terminal '$isr$' :
static const char * gSyntaxErrorMessage_isr = "Config file keyword 'isr'" ;

//--- Syntax error message for terminal '$isr_code$' :
static const char * gSyntaxErrorMessage_isr_5Fcode = "Config file keyword 'isr_code'" ;

//--- Syntax error message for terminal '$counter_code$' :
static const char * gSyntaxErrorMessage_counter_5Fcode = "Config file keyword 'counter_code'" ;

//--- Syntax error message for terminal '$uint8$' :
static const char * gSyntaxErrorMessage_uint8 = "Config file data type 'uint8'" ;

//--- Syntax error message for terminal '$sint8$' :
static const char * gSyntaxErrorMessage_sint8 = "Config file data type 'sint8'" ;

//--- Syntax error message for terminal '$uint16$' :
static const char * gSyntaxErrorMessage_uint16 = "Config file data type 'uint16'" ;

//--- Syntax error message for terminal '$sint16$' :
static const char * gSyntaxErrorMessage_sint16 = "Config file data type 'sint16'" ;

//--- Syntax error message for terminal '$uint32$' :
static const char * gSyntaxErrorMessage_uint32 = "Config file data type 'uint32'" ;

//--- Syntax error message for terminal '$sint32$' :
static const char * gSyntaxErrorMessage_sint32 = "Config file data type 'sint32'" ;

//--- Syntax error message for terminal '$uint64$' :
static const char * gSyntaxErrorMessage_uint64 = "Config file data type 'uint64'" ;

//--- Syntax error message for terminal '$sint64$' :
static const char * gSyntaxErrorMessage_sint64 = "Config file data type 'sint64'" ;

//--- Syntax error message for terminal '$idf$' :
static const char * gSyntaxErrorMessage_idf = "identifier" ;

//--- Syntax error message for terminal '$string$' :
static const char * gSyntaxErrorMessage_string = "litteral string" ;

//--- Syntax error message for terminal '$uint$' :
static const char * gSyntaxErrorMessage_uint = "litteral unsigned 64 bits integer" ;

//--- Syntax error message for terminal '$;$' :
static const char * gSyntaxErrorMessage__3B = "';' delimiter" ;

//--- Syntax error message for terminal '$=$' :
static const char * gSyntaxErrorMessage__3D = "'=' delimiter" ;

//--- Syntax error message for terminal '${$' :
static const char * gSyntaxErrorMessage__7B = "'{' delimiter" ;

//--- Syntax error message for terminal '$}$' :
static const char * gSyntaxErrorMessage__7D = "'}' delimiter" ;

//---------------------------------------------------------------------------*
//                                                                           *
//                appendTerminalMessageToSyntaxErrorMessage                  *
//                                                                           *
//---------------------------------------------------------------------------*

void cfg_lexique::
appendTerminalMessageToSyntaxErrorMessage (const sint16 inTerminalIndex,
                                           C_String & outSyntaxErrorMessage) {
  static const char * syntaxErrorMessageArray [22] = {"end of source",
       gSyntaxErrorMessage_tp_5Fns_5Fper_5Fcounter_5Ftick,
       gSyntaxErrorMessage_stack_5Falignment,
       gSyntaxErrorMessage_task,
       gSyntaxErrorMessage_isr,
       gSyntaxErrorMessage_isr_5Fcode,
       gSyntaxErrorMessage_counter_5Fcode,
       gSyntaxErrorMessage_uint8,
       gSyntaxErrorMessage_sint8,
       gSyntaxErrorMessage_uint16,
       gSyntaxErrorMessage_sint16,
       gSyntaxErrorMessage_uint32,
       gSyntaxErrorMessage_sint32,
       gSyntaxErrorMessage_uint64,
       gSyntaxErrorMessage_sint64,
       gSyntaxErrorMessage_idf,
       gSyntaxErrorMessage_string,
       gSyntaxErrorMessage_uint,
       gSyntaxErrorMessage__3B,
       gSyntaxErrorMessage__3D,
       gSyntaxErrorMessage__7B,
       gSyntaxErrorMessage__7D} ;
  outSyntaxErrorMessage << syntaxErrorMessageArray [inTerminalIndex] ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Key words table 'cfg_keywords'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const sint16 cfg_lexique::cfg_lexique_table_size_cfg_keywords = 6 ;

const C_lexique_table_entry cfg_lexique::cfg_lexique_table_for_cfg_keywords [6] = {
  C_lexique_table_entry ("isr", 3, cfg_lexique_1_isr),
  C_lexique_table_entry ("task", 4, cfg_lexique_1_task),
  C_lexique_table_entry ("isr_code", 8, cfg_lexique_1_isr_5Fcode),
  C_lexique_table_entry ("counter_code", 12, cfg_lexique_1_counter_5Fcode),
  C_lexique_table_entry ("stack_alignment", 15, cfg_lexique_1_stack_5Falignment),
  C_lexique_table_entry ("tp_ns_per_counter_tick", 22, cfg_lexique_1_tp_5Fns_5Fper_5Fcounter_5Ftick)
} ;

sint16 cfg_lexique::search_into_cfg_keywords (const C_String & inSearchedString) {
  return searchInList (inSearchedString, cfg_lexique_table_for_cfg_keywords, cfg_lexique_table_size_cfg_keywords) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        Key words table 'cfg_type'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const sint16 cfg_lexique::cfg_lexique_table_size_cfg_type = 8 ;

const C_lexique_table_entry cfg_lexique::cfg_lexique_table_for_cfg_type [8] = {
  C_lexique_table_entry ("sint8", 5, cfg_lexique_1_sint8),
  C_lexique_table_entry ("uint8", 5, cfg_lexique_1_uint8),
  C_lexique_table_entry ("sint16", 6, cfg_lexique_1_sint16),
  C_lexique_table_entry ("sint32", 6, cfg_lexique_1_sint32),
  C_lexique_table_entry ("sint64", 6, cfg_lexique_1_sint64),
  C_lexique_table_entry ("uint16", 6, cfg_lexique_1_uint16),
  C_lexique_table_entry ("uint32", 6, cfg_lexique_1_uint32),
  C_lexique_table_entry ("uint64", 6, cfg_lexique_1_uint64)
} ;

sint16 cfg_lexique::search_into_cfg_type (const C_String & inSearchedString) {
  return searchInList (inSearchedString, cfg_lexique_table_for_cfg_type, cfg_lexique_table_size_cfg_type) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Key words table 'cfg_delimiters'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const sint16 cfg_lexique::cfg_lexique_table_size_cfg_delimiters = 4 ;

const C_lexique_table_entry cfg_lexique::cfg_lexique_table_for_cfg_delimiters [4] = {
  C_lexique_table_entry (";", 1, cfg_lexique_1__3B),
  C_lexique_table_entry ("=", 1, cfg_lexique_1__3D),
  C_lexique_table_entry ("{", 1, cfg_lexique_1__7B),
  C_lexique_table_entry ("}", 1, cfg_lexique_1__7D)
} ;

sint16 cfg_lexique::search_into_cfg_delimiters (const C_String & inSearchedString) {
  return searchInList (inSearchedString, cfg_lexique_table_for_cfg_delimiters, cfg_lexique_table_size_cfg_delimiters) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          getCurrentTokenString                            *
//                                                                           *
//---------------------------------------------------------------------------*

C_String cfg_lexique::
getCurrentTokenString (const cToken * inTokenPtr) const {
  cTokenFor_cfg_lexique * _p = (cTokenFor_cfg_lexique *) inTokenPtr ;
  C_String s ;
  if (_p == NULL) {
    s << "$$" ;
  }else{
    switch (_p->_mTokenCode) {
    case  cfg_lexique_1_:
      s << "$$" ;
      break ;
    case  cfg_lexique_1_tp_5Fns_5Fper_5Fcounter_5Ftick:
      s << '$'
        << "tp_ns_per_counter_tick"
        << '$' ;
      break;
    case  cfg_lexique_1_stack_5Falignment:
      s << '$'
        << "stack_alignment"
        << '$' ;
      break;
    case  cfg_lexique_1_task:
      s << '$'
        << "task"
        << '$' ;
      break;
    case  cfg_lexique_1_isr:
      s << '$'
        << "isr"
        << '$' ;
      break;
    case  cfg_lexique_1_isr_5Fcode:
      s << '$'
        << "isr_code"
        << '$' ;
      break;
    case  cfg_lexique_1_counter_5Fcode:
      s << '$'
        << "counter_code"
        << '$' ;
      break;
    case  cfg_lexique_1_uint8:
      s << '$'
        << "uint8"
        << '$' ;
      break;
    case  cfg_lexique_1_sint8:
      s << '$'
        << "sint8"
        << '$' ;
      break;
    case  cfg_lexique_1_uint16:
      s << '$'
        << "uint16"
        << '$' ;
      break;
    case  cfg_lexique_1_sint16:
      s << '$'
        << "sint16"
        << '$' ;
      break;
    case  cfg_lexique_1_uint32:
      s << '$'
        << "uint32"
        << '$' ;
      break;
    case  cfg_lexique_1_sint32:
      s << '$'
        << "sint32"
        << '$' ;
      break;
    case  cfg_lexique_1_uint64:
      s << '$'
        << "uint64"
        << '$' ;
      break;
    case  cfg_lexique_1_sint64:
      s << '$'
        << "sint64"
        << '$' ;
      break;
    case  cfg_lexique_1_idf:
      s << '$'
        << "idf"
        << '$' ;
    s << ' ' ;
    s.appendCLiteralStringConstant (_p->keyword) ;
      break;
    case  cfg_lexique_1_string:
      s << '$'
        << "string"
        << '$' ;
    s << ' ' ;
    s.appendCLiteralStringConstant (_p->string) ;
      break;
    case  cfg_lexique_1_uint:
      s << '$'
        << "uint"
        << '$' ;
    s << ' ' << _p->integer ;
      break;
    case  cfg_lexique_1__3B:
      s << '$'
        << ";"
        << '$' ;
      break;
    case  cfg_lexique_1__3D:
      s << '$'
        << "="
        << '$' ;
      break;
    case  cfg_lexique_1__7B:
      s << '$'
        << "{"
        << '$' ;
      break;
    case  cfg_lexique_1__7D:
      s << '$'
        << "}"
        << '$' ;
      break;
    default:
      break ;
    }
  }
  return s ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            parseLexicalToken                              *
//                                                                           *
//---------------------------------------------------------------------------*

bool cfg_lexique::
parseLexicalToken (void) {
  cTokenFor_cfg_lexique _token ;
  bool loop_ = true ;
  _token._mTokenCode = -1 ;
  while ((_token._mTokenCode < 0) && (mCurrentChar != '\0')) {
    _token.keyword.clear () ;
    _token.string.clear () ;
    _token.integer = 0 ;
    _token.number.clear () ;
    _mTokenFirstLocation = _mCurrentLocation ;
    try{
      if (testForInputString ("//", 2)) {
        do {
          if (testForInputChar ('\x1', '\t') ||
              testForInputChar ('\v') ||
              testForInputChar ('\f') ||
              testForInputChar ('\xE', '\xFF')) {
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
      }else if (testForInputString ("/*", 2)) {
        do {
          if (notTestForInputString ("*/", 2, gErrorMessage_0 COMMA_LINE_AND_SOURCE_FILE)) {
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
      }else if (testForInputChar ('a', 'z') ||
          testForInputChar ('A', 'Z')) {
        do {
          scanner_action_enterCharacterIntoString (_token.keyword, previousChar ()) ;
          if (testForInputChar ('a', 'z') ||
              testForInputChar ('A', 'Z') ||
              testForInputChar ('_') ||
              testForInputChar ('0', '9')) {
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
        _token._mTokenCode = search_into_cfg_keywords (_token.keyword) ;
        if (_token._mTokenCode == -1) {
          _token._mTokenCode = cfg_lexique_1_idf ;
        }
        _enterToken (_token) ;
      }else if (testForInputChar ('\"')) {
        do {
          if (testForInputChar (' ', '!') ||
              testForInputChar ('#', '\xFF')) {
            scanner_action_enterCharacterIntoString (_token.string, previousChar ()) ;
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
        if (testForInputChar ('\"')) {
          _token._mTokenCode = cfg_lexique_1_string ;
          _enterToken (_token) ;
        }else{
          lexicalError (gErrorMessage_1 COMMA_LINE_AND_SOURCE_FILE) ;
        }
      }else if (testForInputChar ('0', '9')) {
        do {
          scanner_action_enterCharacterIntoString (_token.number, previousChar ()) ;
          scanner_action_enterDigitIntoUInt64 (previousChar (), _token.integer, gErrorMessage_2, gErrorMessage_3) ;
          if (testForInputChar ('0', '9')) {
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
        _token._mTokenCode = cfg_lexique_1_uint ;
        _enterToken (_token) ;
      }else if (testForInputString (";", 1)) {
        _token._mTokenCode = cfg_lexique_1__3B ;
        _enterToken (_token) ;
      }else if (testForInputString ("=", 1)) {
        _token._mTokenCode = cfg_lexique_1__3D ;
        _enterToken (_token) ;
      }else if (testForInputString ("{", 1)) {
        _token._mTokenCode = cfg_lexique_1__7B ;
        _enterToken (_token) ;
      }else if (testForInputString ("}", 1)) {
        _token._mTokenCode = cfg_lexique_1__7D ;
        _enterToken (_token) ;
      }else if (testForInputChar ('\x1', ' ')) {
      }else if (testForInputChar ('\0')) { // End of source text ? 
        _token._mTokenCode = cfg_lexique_1_ ; // Empty string code
      }else{ // Unknown input character
        unknownCharacterLexicalError (LINE_AND_SOURCE_FILE) ;
      }
    }catch (const C_lexicalErrorException &) {
      _token._mTokenCode = -1 ; // No token
      advance () ; // ... go throught unknown character
    }
  }
  if ((mCurrentChar == '\0') && (_token._mTemplateStringBeforeToken.length () > 0)) {
    _token._mTokenCode = 0 ;
    _enterToken (_token) ;
  }
  return _token._mTokenCode > 0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   parseLexicalTokenForLexicalColoring                     *
//                                                                           *
//---------------------------------------------------------------------------*

sint16 cfg_lexique::
parseLexicalTokenForLexicalColoring (void) {
  cTokenFor_cfg_lexique _token ;
  bool loop_ = true ;
  _token._mTokenCode = -1 ;
  while (_token._mTokenCode < 0) {
    _token.keyword.clear () ;
    _token.string.clear () ;
    _token.integer = 0 ;
    _token.number.clear () ;
    _mTokenFirstLocation = _mCurrentLocation ;
    try{
      if (testForInputString ("//", 2)) {
        do {
          if (testForInputChar ('\x1', '\t') ||
              testForInputChar ('\v') ||
              testForInputChar ('\f') ||
              testForInputChar ('\xE', '\xFF')) {
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
      }else if (testForInputString ("/*", 2)) {
        do {
          if (notTestForInputString ("*/", 2, gErrorMessage_0 COMMA_LINE_AND_SOURCE_FILE)) {
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
      }else if (testForInputChar ('a', 'z') ||
          testForInputChar ('A', 'Z')) {
        do {
          scanner_action_enterCharacterIntoString (_token.keyword, previousChar ()) ;
          if (testForInputChar ('a', 'z') ||
              testForInputChar ('A', 'Z') ||
              testForInputChar ('_') ||
              testForInputChar ('0', '9')) {
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
        _token._mTokenCode = search_into_cfg_keywords (_token.keyword) ;
        if (_token._mTokenCode == -1) {
          _token._mTokenCode = cfg_lexique_1_idf ;
        }
      }else if (testForInputChar ('\"')) {
        do {
          if (testForInputChar (' ', '!') ||
              testForInputChar ('#', '\xFF')) {
            scanner_action_enterCharacterIntoString (_token.string, previousChar ()) ;
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
        if (testForInputChar ('\"')) {
          _token._mTokenCode = cfg_lexique_1_string ;
        }else{
          lexicalError (gErrorMessage_1 COMMA_LINE_AND_SOURCE_FILE) ;
        }
      }else if (testForInputChar ('0', '9')) {
        do {
          scanner_action_enterCharacterIntoString (_token.number, previousChar ()) ;
          scanner_action_enterDigitIntoUInt64 (previousChar (), _token.integer, gErrorMessage_2, gErrorMessage_3) ;
          if (testForInputChar ('0', '9')) {
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
        _token._mTokenCode = cfg_lexique_1_uint ;
      }else if (testForInputString (";", 1)) {
        _token._mTokenCode = cfg_lexique_1__3B ;
      }else if (testForInputString ("=", 1)) {
        _token._mTokenCode = cfg_lexique_1__3D ;
      }else if (testForInputString ("{", 1)) {
        _token._mTokenCode = cfg_lexique_1__7B ;
      }else if (testForInputString ("}", 1)) {
        _token._mTokenCode = cfg_lexique_1__7D ;
      }else if (testForInputChar ('\x1', ' ')) {
      }else if (testForInputChar ('\0')) { // End of source text ? 
        _token._mTokenCode = cfg_lexique_1_ ; // Empty string code
      }else{ // Unknown input character
        unknownCharacterLexicalError (LINE_AND_SOURCE_FILE) ;
      }
    }catch (const C_lexicalErrorException &) {
      _token._mTokenCode = -1 ; // No token
      advance () ; // ... go throught unknown character
      throw ;
    }
  }
  return _token._mTokenCode ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            Styles definition                              *
//                                                                           *
//---------------------------------------------------------------------------*

sint32 cfg_lexique::getStylesCount (void) {
  return 1 ;
}

//---------------------------------------------------------------------------*

const char * cfg_lexique::getStyleName (const sint32 inIndex) {
  const char * kStylesArray [2] = {"Default style", NULL} ;
  return (inIndex < 1) ? kStylesArray [inIndex] : NULL ;
} ;

//---------------------------------------------------------------------------*

const char * cfg_lexique::getStyleIdentifier (const sint32 inIndex) {
  const char * kStylesArray [2] = {"", NULL} ;
  return (inIndex < 1) ? kStylesArray [inIndex] : NULL ;
} ;

//---------------------------------------------------------------------------*

uint8 cfg_lexique::
terminalStyleIndex (const sint32 inTerminal) {
  static const uint8 kTerminalSymbolStyles [22] = {0,
    0 /* cfg_lexique_1_tp_5Fns_5Fper_5Fcounter_5Ftick */,
    0 /* cfg_lexique_1_stack_5Falignment */,
    0 /* cfg_lexique_1_task */,
    0 /* cfg_lexique_1_isr */,
    0 /* cfg_lexique_1_isr_5Fcode */,
    0 /* cfg_lexique_1_counter_5Fcode */,
    0 /* cfg_lexique_1_uint8 */,
    0 /* cfg_lexique_1_sint8 */,
    0 /* cfg_lexique_1_uint16 */,
    0 /* cfg_lexique_1_sint16 */,
    0 /* cfg_lexique_1_uint32 */,
    0 /* cfg_lexique_1_sint32 */,
    0 /* cfg_lexique_1_uint64 */,
    0 /* cfg_lexique_1_sint64 */,
    0 /* cfg_lexique_1_idf */,
    0 /* cfg_lexique_1_string */,
    0 /* cfg_lexique_1_uint */,
    0 /* cfg_lexique_1__3B */,
    0 /* cfg_lexique_1__3D */,
    0 /* cfg_lexique_1__7B */,
    0 /* cfg_lexique_1__7D */
  } ;
  return kTerminalSymbolStyles [inTerminal] ;
}

//---------------------------------------------------------------------------*

void cfg_lexique::_enterToken (const cTokenFor_cfg_lexique & inToken) {
  cTokenFor_cfg_lexique * _p = NULL ;
  macroMyNew (_p, cTokenFor_cfg_lexique ()) ;
  _p->_mTokenCode = inToken._mTokenCode ;
  _p->_mFirstLocation = _mTokenFirstLocation ;
  _p->_mLastLocation  = _mTokenLastLocation ;
  _p->_mTemplateStringBeforeToken  = inToken._mTemplateStringBeforeToken ;
  _p->keyword = inToken.keyword ;
  _p->string = inToken.string ;
  _p->integer = inToken.integer ;
  _p->number = inToken.number ;
  _enterTokenFromPointer (_p) ;
}

//---------------------------------------------------------------------------*

void cfg_lexique::
_assignFromAttribute_keyword (GGS_lstring & outValue) const {
  cTokenFor_cfg_lexique * _p = (cTokenFor_cfg_lexique *) mCurrentTokenPtr ;
  outValue = GGS_lstring (* this, _p->keyword) ;
}

//---------------------------------------------------------------------------*

C_String cfg_lexique::
_attributeValue_keyword (void) const {
  cTokenFor_cfg_lexique * _p = (cTokenFor_cfg_lexique *) mCurrentTokenPtr ;
  return _p->keyword ;
}

//---------------------------------------------------------------------------*

void cfg_lexique::
_assignFromAttribute_string (GGS_lstring & outValue) const {
  cTokenFor_cfg_lexique * _p = (cTokenFor_cfg_lexique *) mCurrentTokenPtr ;
  outValue = GGS_lstring (* this, _p->string) ;
}

//---------------------------------------------------------------------------*

C_String cfg_lexique::
_attributeValue_string (void) const {
  cTokenFor_cfg_lexique * _p = (cTokenFor_cfg_lexique *) mCurrentTokenPtr ;
  return _p->string ;
}

//---------------------------------------------------------------------------*

void cfg_lexique::
_assignFromAttribute_integer (GGS_luint64 & outValue) const {
  cTokenFor_cfg_lexique * _p = (cTokenFor_cfg_lexique *) mCurrentTokenPtr ;
  outValue = GGS_luint64 (* this, _p->integer) ;
}

//---------------------------------------------------------------------------*

uint64 cfg_lexique::
_attributeValue_integer (void) const {
  cTokenFor_cfg_lexique * _p = (cTokenFor_cfg_lexique *) mCurrentTokenPtr ;
  return _p->integer ;
}

//---------------------------------------------------------------------------*

void cfg_lexique::
_assignFromAttribute_number (GGS_lstring & outValue) const {
  cTokenFor_cfg_lexique * _p = (cTokenFor_cfg_lexique *) mCurrentTokenPtr ;
  outValue = GGS_lstring (* this, _p->number) ;
}

//---------------------------------------------------------------------------*

C_String cfg_lexique::
_attributeValue_number (void) const {
  cTokenFor_cfg_lexique * _p = (cTokenFor_cfg_lexique *) mCurrentTokenPtr ;
  return _p->number ;
}

//---------------------------------------------------------------------------*

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*

