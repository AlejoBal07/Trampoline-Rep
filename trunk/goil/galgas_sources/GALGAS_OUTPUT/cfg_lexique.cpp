//---------------------------------------------------------------------------*
//                                                                           *
//                          File 'cfg_lexique.cpp'                           *
//                        Generated by version 1.8.5                         *
//                      june 19th, 2009, at 17h54'42"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != 515
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <ctype.h>
#include <string.h>

#include "utilities/MF_MemoryControl.h"
#include "cfg_lexique.h"

#include "strings/unicode_character.h"
#include "galgas/scanner_actions.h"
#ifndef DO_NOT_GENERATE_CHECKINGS
  #define LINE_AND_SOURCE_FILE sourceText ()->sourceFileName ().cString (HERE), lineNumber ()
  #define COMMA_LINE_AND_SOURCE_FILE , LINE_AND_SOURCE_FILE
#else
  #define LINE_AND_SOURCE_FILE
  #define COMMA_LINE_AND_SOURCE_FILE
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                               Constructors                                *
//                                                                           *
//---------------------------------------------------------------------------*

cTokenFor_cfg_lexique::cTokenFor_cfg_lexique (void) :
mLexicalAttribute_keyword (),
mLexicalAttribute_string (),
mLexicalAttribute_integer (),
mLexicalAttribute_number () {
}

//---------------------------------------------------------------------------*

cfg_lexique::
cfg_lexique (C_Compiler * inCallerCompiler,
                const C_String & inDependencyFileExtension,
                const C_String & inDependencyFilePath,
                C_galgas_io * inParametersPtr,
                const C_String & inSourceFileName
                COMMA_LOCATION_ARGS) :
C_Lexique (inCallerCompiler, inDependencyFileExtension, inDependencyFilePath, inParametersPtr, inSourceFileName COMMA_THERE) {
}

//---------------------------------------------------------------------------*

cfg_lexique::
cfg_lexique (C_Compiler * inCallerCompiler,
                C_galgas_io * inParametersPtr,
                const C_String & inSourceString,
                const C_String & inStringForError
                COMMA_LOCATION_ARGS) :
C_Lexique (inCallerCompiler, inParametersPtr, inSourceString, inStringForError COMMA_THERE) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        Lexical error message list                         *
//                                                                           *
//---------------------------------------------------------------------------*

//--- Message 0
static const utf32 gLexicalMessage_0 [] = {
  TO_UNICODE ('u'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('m'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('m'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (0)
} ;
//--- Message 1
static const utf32 gLexicalMessage_1 [] = {
  TO_UNICODE ('u'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('m'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('t'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('g'),
  TO_UNICODE (0)
} ;
//--- Message 2
static const utf32 gLexicalMessage_2 [] = {
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('i'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('u'),
  TO_UNICODE ('m'),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('o'),
  TO_UNICODE (' '),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('g'),
  TO_UNICODE ('e'),
  TO_UNICODE (0)
} ;
//--- Message 3
static const utf32 gLexicalMessage_3 [] = {
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          Syntax error messages                            *
//                                                                           *
//---------------------------------------------------------------------------*

//--- Syntax error message for terminal '$tp_ns_per_counter_tick$' :
static const utf32 gSyntaxErrorMessage_tp_5F_ns_5F_per_5F_counter_5F_tick [] = {
  TO_UNICODE ('C'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('g'),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('k'),
  TO_UNICODE ('e'),
  TO_UNICODE ('y'),
  TO_UNICODE ('w'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('t'),
  TO_UNICODE ('p'),
  TO_UNICODE ('_'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('_'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('_'),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('u'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('_'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('c'),
  TO_UNICODE ('k'),
  TO_UNICODE ('\''),
  TO_UNICODE (0)
} ;

//--- Syntax error message for terminal '$stack_alignment$' :
static const utf32 gSyntaxErrorMessage_stack_5F_alignment [] = {
  TO_UNICODE ('C'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('g'),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('k'),
  TO_UNICODE ('e'),
  TO_UNICODE ('y'),
  TO_UNICODE ('w'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('c'),
  TO_UNICODE ('k'),
  TO_UNICODE ('_'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('g'),
  TO_UNICODE ('n'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('\''),
  TO_UNICODE (0)
} ;

//--- Syntax error message for terminal '$task$' :
static const utf32 gSyntaxErrorMessage_task [] = {
  TO_UNICODE ('C'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('g'),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('k'),
  TO_UNICODE ('e'),
  TO_UNICODE ('y'),
  TO_UNICODE ('w'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE ('k'),
  TO_UNICODE ('\''),
  TO_UNICODE (0)
} ;

//--- Syntax error message for terminal '$isr$' :
static const utf32 gSyntaxErrorMessage_isr [] = {
  TO_UNICODE ('C'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('g'),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('k'),
  TO_UNICODE ('e'),
  TO_UNICODE ('y'),
  TO_UNICODE ('w'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE ('r'),
  TO_UNICODE ('\''),
  TO_UNICODE (0)
} ;

//--- Syntax error message for terminal '$isr_code$' :
static const utf32 gSyntaxErrorMessage_isr_5F_code [] = {
  TO_UNICODE ('C'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('g'),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('k'),
  TO_UNICODE ('e'),
  TO_UNICODE ('y'),
  TO_UNICODE ('w'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE ('r'),
  TO_UNICODE ('_'),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('\''),
  TO_UNICODE (0)
} ;

//--- Syntax error message for terminal '$counter_code$' :
static const utf32 gSyntaxErrorMessage_counter_5F_code [] = {
  TO_UNICODE ('C'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('g'),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('k'),
  TO_UNICODE ('e'),
  TO_UNICODE ('y'),
  TO_UNICODE ('w'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('u'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('_'),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('\''),
  TO_UNICODE (0)
} ;

//--- Syntax error message for terminal '$interrupts$' :
static const utf32 gSyntaxErrorMessage_interrupts [] = {
  TO_UNICODE ('C'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('g'),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('k'),
  TO_UNICODE ('e'),
  TO_UNICODE ('y'),
  TO_UNICODE ('w'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('r'),
  TO_UNICODE ('u'),
  TO_UNICODE ('p'),
  TO_UNICODE ('t'),
  TO_UNICODE ('s'),
  TO_UNICODE ('\''),
  TO_UNICODE (0)
} ;

//--- Syntax error message for terminal '$uint8$' :
static const utf32 gSyntaxErrorMessage_uint_38_ [] = {
  TO_UNICODE ('C'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('g'),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('u'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('8'),
  TO_UNICODE ('\''),
  TO_UNICODE (0)
} ;

//--- Syntax error message for terminal '$sint8$' :
static const utf32 gSyntaxErrorMessage_sint_38_ [] = {
  TO_UNICODE ('C'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('g'),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('s'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('8'),
  TO_UNICODE ('\''),
  TO_UNICODE (0)
} ;

//--- Syntax error message for terminal '$uint16$' :
static const utf32 gSyntaxErrorMessage_uint_31__36_ [] = {
  TO_UNICODE ('C'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('g'),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('u'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('1'),
  TO_UNICODE ('6'),
  TO_UNICODE ('\''),
  TO_UNICODE (0)
} ;

//--- Syntax error message for terminal '$sint16$' :
static const utf32 gSyntaxErrorMessage_sint_31__36_ [] = {
  TO_UNICODE ('C'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('g'),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('s'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('1'),
  TO_UNICODE ('6'),
  TO_UNICODE ('\''),
  TO_UNICODE (0)
} ;

//--- Syntax error message for terminal '$uint32$' :
static const utf32 gSyntaxErrorMessage_uint_33__32_ [] = {
  TO_UNICODE ('C'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('g'),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('u'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('3'),
  TO_UNICODE ('2'),
  TO_UNICODE ('\''),
  TO_UNICODE (0)
} ;

//--- Syntax error message for terminal '$sint32$' :
static const utf32 gSyntaxErrorMessage_sint_33__32_ [] = {
  TO_UNICODE ('C'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('g'),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('s'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('3'),
  TO_UNICODE ('2'),
  TO_UNICODE ('\''),
  TO_UNICODE (0)
} ;

//--- Syntax error message for terminal '$uint64$' :
static const utf32 gSyntaxErrorMessage_uint_36__34_ [] = {
  TO_UNICODE ('C'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('g'),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('u'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('6'),
  TO_UNICODE ('4'),
  TO_UNICODE ('\''),
  TO_UNICODE (0)
} ;

//--- Syntax error message for terminal '$sint64$' :
static const utf32 gSyntaxErrorMessage_sint_36__34_ [] = {
  TO_UNICODE ('C'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('g'),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('s'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('6'),
  TO_UNICODE ('4'),
  TO_UNICODE ('\''),
  TO_UNICODE (0)
} ;

//--- Syntax error message for terminal '$idf$' :
static const utf32 gSyntaxErrorMessage_idf [] = {
  TO_UNICODE ('i'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (0)
} ;

//--- Syntax error message for terminal '$string$' :
static const utf32 gSyntaxErrorMessage_string [] = {
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('t'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('g'),
  TO_UNICODE (0)
} ;

//--- Syntax error message for terminal '$uint$' :
static const utf32 gSyntaxErrorMessage_uint [] = {
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('t'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('u'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('i'),
  TO_UNICODE ('g'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('6'),
  TO_UNICODE ('4'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('i'),
  TO_UNICODE ('t'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('g'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (0)
} ;

//--- Syntax error message for terminal '$;$' :
static const utf32 gSyntaxErrorMessage__3B_ [] = {
  TO_UNICODE ('\''),
  TO_UNICODE (';'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('m'),
  TO_UNICODE ('i'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (0)
} ;

//--- Syntax error message for terminal '$=$' :
static const utf32 gSyntaxErrorMessage__3D_ [] = {
  TO_UNICODE ('\''),
  TO_UNICODE ('='),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('m'),
  TO_UNICODE ('i'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (0)
} ;

//--- Syntax error message for terminal '${$' :
static const utf32 gSyntaxErrorMessage__7B_ [] = {
  TO_UNICODE ('\''),
  TO_UNICODE ('{'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('m'),
  TO_UNICODE ('i'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (0)
} ;

//--- Syntax error message for terminal '$}$' :
static const utf32 gSyntaxErrorMessage__7D_ [] = {
  TO_UNICODE ('\''),
  TO_UNICODE ('}'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('m'),
  TO_UNICODE ('i'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                appendTerminalMessageToSyntaxErrorMessage                  *
//                                                                           *
//---------------------------------------------------------------------------*

void cfg_lexique::
appendTerminalMessageToSyntaxErrorMessage (const sint16 inTerminalIndex,
                                           C_String & outSyntaxErrorMessage) {
  static const utf32 * syntaxErrorMessageArray [23] = {kEndOfSourceLexicalErrorMessage,
       gSyntaxErrorMessage_tp_5F_ns_5F_per_5F_counter_5F_tick,
       gSyntaxErrorMessage_stack_5F_alignment,
       gSyntaxErrorMessage_task,
       gSyntaxErrorMessage_isr,
       gSyntaxErrorMessage_isr_5F_code,
       gSyntaxErrorMessage_counter_5F_code,
       gSyntaxErrorMessage_interrupts,
       gSyntaxErrorMessage_uint_38_,
       gSyntaxErrorMessage_sint_38_,
       gSyntaxErrorMessage_uint_31__36_,
       gSyntaxErrorMessage_sint_31__36_,
       gSyntaxErrorMessage_uint_33__32_,
       gSyntaxErrorMessage_sint_33__32_,
       gSyntaxErrorMessage_uint_36__34_,
       gSyntaxErrorMessage_sint_36__34_,
       gSyntaxErrorMessage_idf,
       gSyntaxErrorMessage_string,
       gSyntaxErrorMessage_uint,
       gSyntaxErrorMessage__3B_,
       gSyntaxErrorMessage__3D_,
       gSyntaxErrorMessage__7B_,
       gSyntaxErrorMessage__7D_} ;
  outSyntaxErrorMessage << syntaxErrorMessageArray [inTerminalIndex] ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Key words table 'cfg_keywords'                       *
//                                                                           *
//---------------------------------------------------------------------------*

static const sint32 ktable_size_cfg_keywords = 7 ;

static const utf32 kEntry_0_forTable_cfg_keywords [] = {
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE ('r'),
  TO_UNICODE (0)
}; 

static const utf32 kEntry_1_forTable_cfg_keywords [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE ('k'),
  TO_UNICODE (0)
}; 

static const utf32 kEntry_2_forTable_cfg_keywords [] = {
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE ('r'),
  TO_UNICODE ('_'),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE (0)
}; 

static const utf32 kEntry_3_forTable_cfg_keywords [] = {
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('r'),
  TO_UNICODE ('u'),
  TO_UNICODE ('p'),
  TO_UNICODE ('t'),
  TO_UNICODE ('s'),
  TO_UNICODE (0)
}; 

static const utf32 kEntry_4_forTable_cfg_keywords [] = {
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('u'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('_'),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE (0)
}; 

static const utf32 kEntry_5_forTable_cfg_keywords [] = {
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('c'),
  TO_UNICODE ('k'),
  TO_UNICODE ('_'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('g'),
  TO_UNICODE ('n'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (0)
}; 

static const utf32 kEntry_6_forTable_cfg_keywords [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('p'),
  TO_UNICODE ('_'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('_'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('_'),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('u'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('_'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('c'),
  TO_UNICODE ('k'),
  TO_UNICODE (0)
}; 

static const C_unicode_lexique_table_entry ktable_for_cfg_keywords [ktable_size_cfg_keywords] = {
  {kEntry_0_forTable_cfg_keywords, 3, cfg_lexique::cfg_lexique_1_isr},
  {kEntry_1_forTable_cfg_keywords, 4, cfg_lexique::cfg_lexique_1_task},
  {kEntry_2_forTable_cfg_keywords, 8, cfg_lexique::cfg_lexique_1_isr_5F_code},
  {kEntry_3_forTable_cfg_keywords, 10, cfg_lexique::cfg_lexique_1_interrupts},
  {kEntry_4_forTable_cfg_keywords, 12, cfg_lexique::cfg_lexique_1_counter_5F_code},
  {kEntry_5_forTable_cfg_keywords, 15, cfg_lexique::cfg_lexique_1_stack_5F_alignment},
  {kEntry_6_forTable_cfg_keywords, 22, cfg_lexique::cfg_lexique_1_tp_5F_ns_5F_per_5F_counter_5F_tick}
} ;

sint16 cfg_lexique::search_into_cfg_keywords (const C_String & inSearchedString) {
  return searchInList (inSearchedString, ktable_for_cfg_keywords, ktable_size_cfg_keywords) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        Key words table 'cfg_type'                         *
//                                                                           *
//---------------------------------------------------------------------------*

static const sint32 ktable_size_cfg_type = 8 ;

static const utf32 kEntry_0_forTable_cfg_type [] = {
  TO_UNICODE ('s'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('8'),
  TO_UNICODE (0)
}; 

static const utf32 kEntry_1_forTable_cfg_type [] = {
  TO_UNICODE ('u'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('8'),
  TO_UNICODE (0)
}; 

static const utf32 kEntry_2_forTable_cfg_type [] = {
  TO_UNICODE ('s'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('1'),
  TO_UNICODE ('6'),
  TO_UNICODE (0)
}; 

static const utf32 kEntry_3_forTable_cfg_type [] = {
  TO_UNICODE ('s'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('3'),
  TO_UNICODE ('2'),
  TO_UNICODE (0)
}; 

static const utf32 kEntry_4_forTable_cfg_type [] = {
  TO_UNICODE ('s'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('6'),
  TO_UNICODE ('4'),
  TO_UNICODE (0)
}; 

static const utf32 kEntry_5_forTable_cfg_type [] = {
  TO_UNICODE ('u'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('1'),
  TO_UNICODE ('6'),
  TO_UNICODE (0)
}; 

static const utf32 kEntry_6_forTable_cfg_type [] = {
  TO_UNICODE ('u'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('3'),
  TO_UNICODE ('2'),
  TO_UNICODE (0)
}; 

static const utf32 kEntry_7_forTable_cfg_type [] = {
  TO_UNICODE ('u'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('6'),
  TO_UNICODE ('4'),
  TO_UNICODE (0)
}; 

static const C_unicode_lexique_table_entry ktable_for_cfg_type [ktable_size_cfg_type] = {
  {kEntry_0_forTable_cfg_type, 5, cfg_lexique::cfg_lexique_1_sint_38_},
  {kEntry_1_forTable_cfg_type, 5, cfg_lexique::cfg_lexique_1_uint_38_},
  {kEntry_2_forTable_cfg_type, 6, cfg_lexique::cfg_lexique_1_sint_31__36_},
  {kEntry_3_forTable_cfg_type, 6, cfg_lexique::cfg_lexique_1_sint_33__32_},
  {kEntry_4_forTable_cfg_type, 6, cfg_lexique::cfg_lexique_1_sint_36__34_},
  {kEntry_5_forTable_cfg_type, 6, cfg_lexique::cfg_lexique_1_uint_31__36_},
  {kEntry_6_forTable_cfg_type, 6, cfg_lexique::cfg_lexique_1_uint_33__32_},
  {kEntry_7_forTable_cfg_type, 6, cfg_lexique::cfg_lexique_1_uint_36__34_}
} ;

sint16 cfg_lexique::search_into_cfg_type (const C_String & inSearchedString) {
  return searchInList (inSearchedString, ktable_for_cfg_type, ktable_size_cfg_type) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Key words table 'cfg_delimiters'                      *
//                                                                           *
//---------------------------------------------------------------------------*

static const sint32 ktable_size_cfg_delimiters = 4 ;

static const utf32 kEntry_0_forTable_cfg_delimiters [] = {
  TO_UNICODE (';'),
  TO_UNICODE (0)
}; 

static const utf32 kEntry_1_forTable_cfg_delimiters [] = {
  TO_UNICODE ('='),
  TO_UNICODE (0)
}; 

static const utf32 kEntry_2_forTable_cfg_delimiters [] = {
  TO_UNICODE ('{'),
  TO_UNICODE (0)
}; 

static const utf32 kEntry_3_forTable_cfg_delimiters [] = {
  TO_UNICODE ('}'),
  TO_UNICODE (0)
}; 

static const C_unicode_lexique_table_entry ktable_for_cfg_delimiters [ktable_size_cfg_delimiters] = {
  {kEntry_0_forTable_cfg_delimiters, 1, cfg_lexique::cfg_lexique_1__3B_},
  {kEntry_1_forTable_cfg_delimiters, 1, cfg_lexique::cfg_lexique_1__3D_},
  {kEntry_2_forTable_cfg_delimiters, 1, cfg_lexique::cfg_lexique_1__7B_},
  {kEntry_3_forTable_cfg_delimiters, 1, cfg_lexique::cfg_lexique_1__7D_}
} ;

sint16 cfg_lexique::search_into_cfg_delimiters (const C_String & inSearchedString) {
  return searchInList (inSearchedString, ktable_for_cfg_delimiters, ktable_size_cfg_delimiters) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          getCurrentTokenString                            *
//                                                                           *
//---------------------------------------------------------------------------*

C_String cfg_lexique::
getCurrentTokenString (const cToken * inTokenPtr) const {
  cTokenFor_cfg_lexique * ptr = (cTokenFor_cfg_lexique *) inTokenPtr ;
  C_String s ;
  if (ptr == NULL) {
    s << "$$" ;
  }else{
    switch (ptr->mTokenCode) {
    case  cfg_lexique_1_:
      s << "$$" ;
      break ;
    case  cfg_lexique_1_tp_5F_ns_5F_per_5F_counter_5F_tick:
      s << "$"
        << "tp_ns_per_counter_tick"
        << "$" ;
      break;
    case  cfg_lexique_1_stack_5F_alignment:
      s << "$"
        << "stack_alignment"
        << "$" ;
      break;
    case  cfg_lexique_1_task:
      s << "$"
        << "task"
        << "$" ;
      break;
    case  cfg_lexique_1_isr:
      s << "$"
        << "isr"
        << "$" ;
      break;
    case  cfg_lexique_1_isr_5F_code:
      s << "$"
        << "isr_code"
        << "$" ;
      break;
    case  cfg_lexique_1_counter_5F_code:
      s << "$"
        << "counter_code"
        << "$" ;
      break;
    case  cfg_lexique_1_interrupts:
      s << "$"
        << "interrupts"
        << "$" ;
      break;
    case  cfg_lexique_1_uint_38_:
      s << "$"
        << "uint8"
        << "$" ;
      break;
    case  cfg_lexique_1_sint_38_:
      s << "$"
        << "sint8"
        << "$" ;
      break;
    case  cfg_lexique_1_uint_31__36_:
      s << "$"
        << "uint16"
        << "$" ;
      break;
    case  cfg_lexique_1_sint_31__36_:
      s << "$"
        << "sint16"
        << "$" ;
      break;
    case  cfg_lexique_1_uint_33__32_:
      s << "$"
        << "uint32"
        << "$" ;
      break;
    case  cfg_lexique_1_sint_33__32_:
      s << "$"
        << "sint32"
        << "$" ;
      break;
    case  cfg_lexique_1_uint_36__34_:
      s << "$"
        << "uint64"
        << "$" ;
      break;
    case  cfg_lexique_1_sint_36__34_:
      s << "$"
        << "sint64"
        << "$" ;
      break;
    case  cfg_lexique_1_idf:
      s << "$"
        << "idf"
        << "$" ;
    s << " " ;
    s.appendCLiteralStringConstant (ptr->mLexicalAttribute_keyword) ;
      break;
    case  cfg_lexique_1_string:
      s << "$"
        << "string"
        << "$" ;
    s << " " ;
    s.appendCLiteralStringConstant (ptr->mLexicalAttribute_string) ;
      break;
    case  cfg_lexique_1_uint:
      s << "$"
        << "uint"
        << "$" ;
      s << " " ;
      s.appendUnsigned64 (ptr->mLexicalAttribute_integer) ;
      break;
    case  cfg_lexique_1__3B_:
      s << "$"
        << ";"
        << "$" ;
      break;
    case  cfg_lexique_1__3D_:
      s << "$"
        << "="
        << "$" ;
      break;
    case  cfg_lexique_1__7B_:
      s << "$"
        << "{"
        << "$" ;
      break;
    case  cfg_lexique_1__7D_:
      s << "$"
        << "}"
        << "$" ;
      break;
    default:
      break ;
    }
  }
  return s ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      U N I C O D E    S T R I N G S                       *
//                                                                           *
//---------------------------------------------------------------------------*

//--- Unicode string for '*/'
static const utf32 kUnicodeString__2A__2F_ [] = {
  TO_UNICODE ('*'),
  TO_UNICODE ('/'),
  TO_UNICODE (0)
} ; 

//--- Unicode string for '/*'
static const utf32 kUnicodeString__2F__2A_ [] = {
  TO_UNICODE ('/'),
  TO_UNICODE ('*'),
  TO_UNICODE (0)
} ; 

//--- Unicode string for '//'
static const utf32 kUnicodeString__2F__2F_ [] = {
  TO_UNICODE ('/'),
  TO_UNICODE ('/'),
  TO_UNICODE (0)
} ; 

//--- Unicode string for ';'
static const utf32 kUnicodeString__3B_ [] = {
  TO_UNICODE (';'),
  TO_UNICODE (0)
} ; 

//--- Unicode string for '='
static const utf32 kUnicodeString__3D_ [] = {
  TO_UNICODE ('='),
  TO_UNICODE (0)
} ; 

//--- Unicode string for '{'
static const utf32 kUnicodeString__7B_ [] = {
  TO_UNICODE ('{'),
  TO_UNICODE (0)
} ; 

//--- Unicode string for '}'
static const utf32 kUnicodeString__7D_ [] = {
  TO_UNICODE ('}'),
  TO_UNICODE (0)
} ; 

//---------------------------------------------------------------------------*
//                                                                           *
//                            parseLexicalToken                              *
//                                                                           *
//---------------------------------------------------------------------------*

bool cfg_lexique::
parseLexicalToken (void) {
  cTokenFor_cfg_lexique token ;
  mLoop = true ;
  token.mTokenCode = -1 ;
  while ((token.mTokenCode < 0) && (UNICODE_VALUE (mCurrentChar) != '\0')) {
    token.mLexicalAttribute_keyword.setLengthToZero () ;
    token.mLexicalAttribute_string.setLengthToZero () ;
    token.mLexicalAttribute_integer = 0 ;
    token.mLexicalAttribute_number.setLengthToZero () ;
    mTokenFirstLocation = mCurrentLocation ;
    try{
      if (testForInputUTF32String (kUnicodeString__2F__2F_, 2, true)) {
        do {
          if (testForInputUTF32CharRange (TO_UNICODE (1), TO_UNICODE ('\t')) ||
              testForInputUTF32Char (TO_UNICODE ('\v')) ||
              testForInputUTF32Char (TO_UNICODE ('\f')) ||
              testForInputUTF32CharRange (TO_UNICODE (14), TO_UNICODE (65533))) {
          }else{
            mLoop = false ;
          }
        }while (mLoop) ;
        mLoop = true ;
      }else if (testForInputUTF32String (kUnicodeString__2F__2A_, 2, true)) {
        do {
          if (notTestForInputUTF32String (kUnicodeString__2A__2F_, 2, gLexicalMessage_0 COMMA_LINE_AND_SOURCE_FILE)) {
          }else{
            mLoop = false ;
          }
        }while (mLoop) ;
        mLoop = true ;
      }else if (testForInputUTF32CharRange (TO_UNICODE ('a'), TO_UNICODE ('z')) ||
          testForInputUTF32CharRange (TO_UNICODE ('A'), TO_UNICODE ('Z'))) {
        do {
          ::scanner_routine_enterCharacterIntoString (*this, token.mLexicalAttribute_keyword, previousChar ()) ;
          if (testForInputUTF32CharRange (TO_UNICODE ('a'), TO_UNICODE ('z')) ||
              testForInputUTF32CharRange (TO_UNICODE ('A'), TO_UNICODE ('Z')) ||
              testForInputUTF32Char (TO_UNICODE ('_')) ||
              testForInputUTF32CharRange (TO_UNICODE ('0'), TO_UNICODE ('9'))) {
          }else{
            mLoop = false ;
          }
        }while (mLoop) ;
        mLoop = true ;
        token.mTokenCode = search_into_cfg_keywords (token.mLexicalAttribute_keyword) ;
        if (token.mTokenCode == -1) {
          token.mTokenCode = cfg_lexique_1_idf ;
        }
        enterToken (token) ;
      }else if (testForInputUTF32Char (TO_UNICODE ('\"'))) {
        do {
          if (testForInputUTF32CharRange (TO_UNICODE (' '), TO_UNICODE ('!')) ||
              testForInputUTF32CharRange (TO_UNICODE ('#'), TO_UNICODE (65533))) {
            ::scanner_routine_enterCharacterIntoString (*this, token.mLexicalAttribute_string, previousChar ()) ;
          }else{
            mLoop = false ;
          }
        }while (mLoop) ;
        mLoop = true ;
        if (testForInputUTF32Char (TO_UNICODE ('\"'))) {
          token.mTokenCode = cfg_lexique_1_string ;
          enterToken (token) ;
        }else{
          lexicalError (gLexicalMessage_1 COMMA_LINE_AND_SOURCE_FILE) ;
        }
      }else if (testForInputUTF32CharRange (TO_UNICODE ('0'), TO_UNICODE ('9'))) {
        do {
          ::scanner_routine_enterCharacterIntoString (*this, token.mLexicalAttribute_number, previousChar ()) ;
          ::scanner_routine_enterDigitIntoUInt64 (*this, previousChar (), token.mLexicalAttribute_integer, gLexicalMessage_2, gLexicalMessage_3) ;
          if (testForInputUTF32CharRange (TO_UNICODE ('0'), TO_UNICODE ('9'))) {
          }else{
            mLoop = false ;
          }
        }while (mLoop) ;
        mLoop = true ;
        token.mTokenCode = cfg_lexique_1_uint ;
        enterToken (token) ;
      }else if (testForInputUTF32String (kUnicodeString__3B_, 1, true)) {
        token.mTokenCode = cfg_lexique_1__3B_ ;
        enterToken (token) ;
      }else if (testForInputUTF32String (kUnicodeString__3D_, 1, true)) {
        token.mTokenCode = cfg_lexique_1__3D_ ;
        enterToken (token) ;
      }else if (testForInputUTF32String (kUnicodeString__7B_, 1, true)) {
        token.mTokenCode = cfg_lexique_1__7B_ ;
        enterToken (token) ;
      }else if (testForInputUTF32String (kUnicodeString__7D_, 1, true)) {
        token.mTokenCode = cfg_lexique_1__7D_ ;
        enterToken (token) ;
      }else if (testForInputUTF32CharRange (TO_UNICODE (1), TO_UNICODE (' '))) {
      }else if (testForInputUTF32Char (TO_UNICODE ('\0'))) { // End of source text ? 
        token.mTokenCode = cfg_lexique_1_ ; // Empty string code
      }else{ // Unknown input character
        unknownCharacterLexicalError (LINE_AND_SOURCE_FILE) ;
      }
    }catch (const C_lexicalErrorException &) {
      token.mTokenCode = -1 ; // No token
      advance () ; // ... go throught unknown character
    }
  }
  if ((UNICODE_VALUE (mCurrentChar) == '\0') && (token.mTemplateStringBeforeToken.length () > 0)) {
    token.mTokenCode = 0 ;
    enterToken (token) ;
  }
  return token.mTokenCode > 0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   parseLexicalTokenForLexicalColoring                     *
//                                                                           *
//---------------------------------------------------------------------------*

sint16 cfg_lexique::
parseLexicalTokenForLexicalColoring (void) {
  cTokenFor_cfg_lexique token ;
  mLoop = true ;
  token.mTokenCode = -1 ;
  while (token.mTokenCode < 0) {
    token.mLexicalAttribute_keyword.setLengthToZero () ;
    token.mLexicalAttribute_string.setLengthToZero () ;
    token.mLexicalAttribute_integer = 0 ;
    token.mLexicalAttribute_number.setLengthToZero () ;
    mTokenFirstLocation = mCurrentLocation ;
    try{
      if (testForInputUTF32String (kUnicodeString__2F__2F_, 2, true)) {
        do {
          if (testForInputUTF32CharRange (TO_UNICODE (1), TO_UNICODE ('\t')) ||
              testForInputUTF32Char (TO_UNICODE ('\v')) ||
              testForInputUTF32Char (TO_UNICODE ('\f')) ||
              testForInputUTF32CharRange (TO_UNICODE (14), TO_UNICODE (65533))) {
          }else{
            mLoop = false ;
          }
        }while (mLoop) ;
        mLoop = true ;
      }else if (testForInputUTF32String (kUnicodeString__2F__2A_, 2, true)) {
        do {
          if (notTestForInputUTF32String (kUnicodeString__2A__2F_, 2, gLexicalMessage_0 COMMA_LINE_AND_SOURCE_FILE)) {
          }else{
            mLoop = false ;
          }
        }while (mLoop) ;
        mLoop = true ;
      }else if (testForInputUTF32CharRange (TO_UNICODE ('a'), TO_UNICODE ('z')) ||
          testForInputUTF32CharRange (TO_UNICODE ('A'), TO_UNICODE ('Z'))) {
        do {
          ::scanner_routine_enterCharacterIntoString (*this, token.mLexicalAttribute_keyword, previousChar ()) ;
          if (testForInputUTF32CharRange (TO_UNICODE ('a'), TO_UNICODE ('z')) ||
              testForInputUTF32CharRange (TO_UNICODE ('A'), TO_UNICODE ('Z')) ||
              testForInputUTF32Char (TO_UNICODE ('_')) ||
              testForInputUTF32CharRange (TO_UNICODE ('0'), TO_UNICODE ('9'))) {
          }else{
            mLoop = false ;
          }
        }while (mLoop) ;
        mLoop = true ;
        token.mTokenCode = search_into_cfg_keywords (token.mLexicalAttribute_keyword) ;
        if (token.mTokenCode == -1) {
          token.mTokenCode = cfg_lexique_1_idf ;
        }
      }else if (testForInputUTF32Char (TO_UNICODE ('\"'))) {
        do {
          if (testForInputUTF32CharRange (TO_UNICODE (' '), TO_UNICODE ('!')) ||
              testForInputUTF32CharRange (TO_UNICODE ('#'), TO_UNICODE (65533))) {
            ::scanner_routine_enterCharacterIntoString (*this, token.mLexicalAttribute_string, previousChar ()) ;
          }else{
            mLoop = false ;
          }
        }while (mLoop) ;
        mLoop = true ;
        if (testForInputUTF32Char (TO_UNICODE ('\"'))) {
          token.mTokenCode = cfg_lexique_1_string ;
        }else{
          lexicalError (gLexicalMessage_1 COMMA_LINE_AND_SOURCE_FILE) ;
        }
      }else if (testForInputUTF32CharRange (TO_UNICODE ('0'), TO_UNICODE ('9'))) {
        do {
          ::scanner_routine_enterCharacterIntoString (*this, token.mLexicalAttribute_number, previousChar ()) ;
          ::scanner_routine_enterDigitIntoUInt64 (*this, previousChar (), token.mLexicalAttribute_integer, gLexicalMessage_2, gLexicalMessage_3) ;
          if (testForInputUTF32CharRange (TO_UNICODE ('0'), TO_UNICODE ('9'))) {
          }else{
            mLoop = false ;
          }
        }while (mLoop) ;
        mLoop = true ;
        token.mTokenCode = cfg_lexique_1_uint ;
      }else if (testForInputUTF32String (kUnicodeString__3B_, 1, true)) {
        token.mTokenCode = cfg_lexique_1__3B_ ;
      }else if (testForInputUTF32String (kUnicodeString__3D_, 1, true)) {
        token.mTokenCode = cfg_lexique_1__3D_ ;
      }else if (testForInputUTF32String (kUnicodeString__7B_, 1, true)) {
        token.mTokenCode = cfg_lexique_1__7B_ ;
      }else if (testForInputUTF32String (kUnicodeString__7D_, 1, true)) {
        token.mTokenCode = cfg_lexique_1__7D_ ;
      }else if (testForInputUTF32CharRange (TO_UNICODE (1), TO_UNICODE (' '))) {
      }else if (testForInputUTF32Char (TO_UNICODE ('\0'))) { // End of source text ? 
        token.mTokenCode = cfg_lexique_1_ ; // Empty string code
      }else{ // Unknown input character
        unknownCharacterLexicalError (LINE_AND_SOURCE_FILE) ;
      }
    }catch (const C_lexicalErrorException &) {
      token.mTokenCode = -1 ; // No token
      advance () ; // ... go throught unknown character
      throw ;
    }
  }
  return token.mTokenCode ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            Styles definition                              *
//                                                                           *
//---------------------------------------------------------------------------*

sint32 cfg_lexique::getStylesCount (void) {
  return 1 ;
}

//---------------------------------------------------------------------------*

const char * cfg_lexique::getStyleName (const sint32 inIndex) {
  const char * kStylesArray [2] = {"Default style", NULL} ;
  return (inIndex < 1) ? kStylesArray [inIndex] : NULL ;
} ;

//---------------------------------------------------------------------------*

const char * cfg_lexique::getStyleIdentifier (const sint32 inIndex) {
  const char * kStylesArray [2] = {"", NULL} ;
  return (inIndex < 1) ? kStylesArray [inIndex] : NULL ;
} ;

//---------------------------------------------------------------------------*

uint8 cfg_lexique::
terminalStyleIndex (const sint32 inTerminal) {
  static const uint8 kTerminalSymbolStyles [23] = {0,
    0 /* cfg_lexique_1_tp_5F_ns_5F_per_5F_counter_5F_tick */,
    0 /* cfg_lexique_1_stack_5F_alignment */,
    0 /* cfg_lexique_1_task */,
    0 /* cfg_lexique_1_isr */,
    0 /* cfg_lexique_1_isr_5F_code */,
    0 /* cfg_lexique_1_counter_5F_code */,
    0 /* cfg_lexique_1_interrupts */,
    0 /* cfg_lexique_1_uint_38_ */,
    0 /* cfg_lexique_1_sint_38_ */,
    0 /* cfg_lexique_1_uint_31__36_ */,
    0 /* cfg_lexique_1_sint_31__36_ */,
    0 /* cfg_lexique_1_uint_33__32_ */,
    0 /* cfg_lexique_1_sint_33__32_ */,
    0 /* cfg_lexique_1_uint_36__34_ */,
    0 /* cfg_lexique_1_sint_36__34_ */,
    0 /* cfg_lexique_1_idf */,
    0 /* cfg_lexique_1_string */,
    0 /* cfg_lexique_1_uint */,
    0 /* cfg_lexique_1__3B_ */,
    0 /* cfg_lexique_1__3D_ */,
    0 /* cfg_lexique_1__7B_ */,
    0 /* cfg_lexique_1__7D_ */
  } ;
  return kTerminalSymbolStyles [inTerminal] ;
}

//---------------------------------------------------------------------------*

void cfg_lexique::enterToken (const cTokenFor_cfg_lexique & inToken) {
  cTokenFor_cfg_lexique * ptr = NULL ;
  macroMyNew (ptr, cTokenFor_cfg_lexique ()) ;
  ptr->mTokenCode = inToken.mTokenCode ;
  ptr->mFirstLocation = mTokenFirstLocation ;
  ptr->mLastLocation  = mTokenLastLocation ;
  ptr->mTemplateStringBeforeToken  = inToken.mTemplateStringBeforeToken ;
  ptr->mLexicalAttribute_keyword = inToken.mLexicalAttribute_keyword ;
  ptr->mLexicalAttribute_string = inToken.mLexicalAttribute_string ;
  ptr->mLexicalAttribute_integer = inToken.mLexicalAttribute_integer ;
  ptr->mLexicalAttribute_number = inToken.mLexicalAttribute_number ;
  enterTokenFromPointer (ptr) ;
}

//---------------------------------------------------------------------------*

void cfg_lexique::
assignFromAttribute_keyword (GGS_lstring & outValue) const {
  cTokenFor_cfg_lexique * ptr = (cTokenFor_cfg_lexique *) mCurrentTokenPtr ;
  outValue = GGS_lstring (* this, ptr->mLexicalAttribute_keyword) ;
}

//---------------------------------------------------------------------------*

C_String cfg_lexique::
attributeValue_keyword (void) const {
  cTokenFor_cfg_lexique * ptr = (cTokenFor_cfg_lexique *) mCurrentTokenPtr ;
  return ptr->mLexicalAttribute_keyword ;
}

//---------------------------------------------------------------------------*

void cfg_lexique::
assignFromAttribute_string (GGS_lstring & outValue) const {
  cTokenFor_cfg_lexique * ptr = (cTokenFor_cfg_lexique *) mCurrentTokenPtr ;
  outValue = GGS_lstring (* this, ptr->mLexicalAttribute_string) ;
}

//---------------------------------------------------------------------------*

C_String cfg_lexique::
attributeValue_string (void) const {
  cTokenFor_cfg_lexique * ptr = (cTokenFor_cfg_lexique *) mCurrentTokenPtr ;
  return ptr->mLexicalAttribute_string ;
}

//---------------------------------------------------------------------------*

void cfg_lexique::
assignFromAttribute_integer (GGS_luint64 & outValue) const {
  cTokenFor_cfg_lexique * ptr = (cTokenFor_cfg_lexique *) mCurrentTokenPtr ;
  outValue = GGS_luint64 (* this, ptr->mLexicalAttribute_integer) ;
}

//---------------------------------------------------------------------------*

uint64 cfg_lexique::
attributeValue_integer (void) const {
  cTokenFor_cfg_lexique * ptr = (cTokenFor_cfg_lexique *) mCurrentTokenPtr ;
  return ptr->mLexicalAttribute_integer ;
}

//---------------------------------------------------------------------------*

void cfg_lexique::
assignFromAttribute_number (GGS_lstring & outValue) const {
  cTokenFor_cfg_lexique * ptr = (cTokenFor_cfg_lexique *) mCurrentTokenPtr ;
  outValue = GGS_lstring (* this, ptr->mLexicalAttribute_number) ;
}

//---------------------------------------------------------------------------*

C_String cfg_lexique::
attributeValue_number (void) const {
  cTokenFor_cfg_lexique * ptr = (cTokenFor_cfg_lexique *) mCurrentTokenPtr ;
  return ptr->mLexicalAttribute_number ;
}

//---------------------------------------------------------------------------*

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*

