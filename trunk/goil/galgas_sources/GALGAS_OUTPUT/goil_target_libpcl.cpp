//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'goil_target_libpcl.cpp'                        *
//                        Generated by version 1.8.2                         *
//                      april 27th, 2009, at 22h45'44"                       *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != 463
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "goil_target_libpcl.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "goil_target_libpcl.ggs", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of routine "generate_target_libpcl"             *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_generate_target_libpcl (C_Compiler & _inLexique,
                                GGS_lstring   var_cas_name,
                                GGS_ident_map   var_cas_others,
                                GGS_oil_obj   var_cas_exe,
                                GGS_string & var_cas_result COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_generate_target_libpcl at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  ::routine_doReplace (_inLexique,  var_cas_result,  GGS_string (true, "$STACK_ZONE$"),  (var_cas_name.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (22)))._operator_concat (GGS_string (true, "_stack")) COMMA_SOURCE_FILE_AT_LINE (22)) ;
  ::routine_doReplace (_inLexique,  var_cas_result,  GGS_string (true, "$EXEC_ALL_CONTEXT$"),  (var_cas_name.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (24)))._operator_concat (GGS_string (true, "_int_context")) COMMA_SOURCE_FILE_AT_LINE (24)) ;
  GGS_uint  var_cas_stack_size ;
  ::routine_additional_int_key_required (_inLexique,  GGS_string (true, "STACKSIZE"),  var_cas_others,  var_cas_name,  var_cas_stack_size COMMA_SOURCE_FILE_AT_LINE (27)) ;
  ::routine_doReplace (_inLexique,  var_cas_result,  GGS_string (true, "$STACK_SIZE$"),  var_cas_stack_size.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (28)) COMMA_SOURCE_FILE_AT_LINE (28)) ;
  { const GGS_oil_obj _var_1320 = var_cas_exe ; // CAST instruction
    if (_var_1320.getPtr () != NULL) {
      macroValidPointer (_var_1320.getPtr ()) ;
      if (typeid (cPtr_isr_obj) == typeid (* (_var_1320.getPtr ()))) {
        GGS_string var_cas_sig ;
        ::routine_additional_string_key_required (_inLexique,  GGS_string (true, "SOURCE"),  var_cas_others,  var_cas_name,  var_cas_sig COMMA_SOURCE_FILE_AT_LINE (35)) ;
      }else{
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_generate_target_libpcl\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "generate_isr_libpcl"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_generate_isr_libpcl (C_Compiler & _inLexique,
                                const GGS_isr_map   var_cas_isrs,
                                GGS_string & var_cas_code COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_generate_isr_libpcl at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_string var_cas_result ;
  var_cas_result = GGS_string (true, "") ;
  GGS_bool var_cas_first ;
  var_cas_first = GGS_bool (true, true) ;
  GGS_isr_list  var_cas_list_isr ;
  var_cas_list_isr = GGS_isr_list ::constructor_emptySortedList () ;
  {
    GGS_isr_map::cEnumerator enumerator_1532 (var_cas_isrs, true) ;
    const GGS_isr_map::cElement * operand_1532 = NULL ;
    while (((operand_1532 = enumerator_1532.nextObject ()))) {
      macroValidPointer (operand_1532) ;
      var_cas_list_isr._addAssign_operation (operand_1532->mKey, operand_1532->mKey.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (49))) ;
    }
  }
  {
    GGS_isr_list::cEnumerator enumerator_1642 (var_cas_list_isr, true) ;
    const GGS_isr_list::cElement * operand_1642 = NULL ;
    while (((operand_1642 = enumerator_1642.nextObject ()))) {
      macroValidPointer (operand_1642) ;
      GGS_isr_obj  var_cas_isr ;
      const GGS_isr_map  _temp_1699 = var_cas_isrs ;
      if (_temp_1699._isBuilt ()) {
        _temp_1699 (HERE)->method_get (_inLexique, operand_1642->key, var_cas_isr COMMA_SOURCE_FILE_AT_LINE (54)) ;
      }
      if (((var_cas_first)._operator_not ()).isBuiltAndTrue ()) {
        var_cas_result.appendCstring (",\n") ;
      }
      var_cas_first = GGS_bool (true, false) ;
      GGS_string var_cas_key ;
      var_cas_key = GGS_string (true, "SOURCE") ;
      GGS_ident_map  var_cas_others ;
      var_cas_others = var_cas_isr.reader_other_fields (_inLexique COMMA_SOURCE_FILE_AT_LINE (59)) ;
      if ((var_cas_others.reader_hasKey (_inLexique, var_cas_key COMMA_SOURCE_FILE_AT_LINE (60))).isBuiltAndTrue ()) {
        GGS_basic_type  var_cas_value ;
        const GGS_ident_map  _temp_1946 = var_cas_others ;
        if (_temp_1946._isBuilt ()) {
          _temp_1946 (HERE)->method_get (_inLexique, GGS_lstring ::constructor_new (_inLexique, var_cas_key, GGS_location (_inLexique) COMMA_HERE), var_cas_value COMMA_SOURCE_FILE_AT_LINE (63)) ;
        }
        { const GGS_basic_type _var_2167 = var_cas_value ; // CAST instruction
          if (_var_2167.getPtr () != NULL) {
            macroValidPointer (_var_2167.getPtr ()) ;
            if (typeid (cPtr_string_class) == typeid (* (_var_2167.getPtr ()))) {
              const GGS_string_class var_cas_s (_var_2167.getPtr ()) ;
              var_cas_result = ((var_cas_result)._operator_concat (GGS_string (true, "\t")))._operator_concat (var_cas_s.reader_value (_inLexique COMMA_SOURCE_FILE_AT_LINE (66))) ;
            }else{
              operand_1642->key.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, (var_cas_key)._operator_concat (GGS_string (true, " should be a string")) COMMA_SOURCE_FILE_AT_LINE (69)) ;
            }
          }
        }
      }else{
        operand_1642->key.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((GGS_string (true, "no "))._operator_concat (var_cas_key))._operator_concat (GGS_string (true, " specified")) COMMA_SOURCE_FILE_AT_LINE (72)) ;
      }
    }
  }
  var_cas_code = var_cas_code.reader_stringByReplacingStringByString (_inLexique, GGS_string (true, "$ISR_SIGNAL_LIST$"), var_cas_result COMMA_SOURCE_FILE_AT_LINE (74)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_generate_isr_libpcl\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of routine "generate_counter_libpcl"             *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_generate_counter_libpcl (C_Compiler & _inLexique,
                                const GGS_counter_map   var_cas_counters,
                                GGS_string & var_cas_code COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_generate_counter_libpcl at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_string var_cas_result ;
  var_cas_result = GGS_string (true, "") ;
  {
    GGS_counter_map::cEnumerator enumerator_2477 (var_cas_counters, true) ;
    const GGS_counter_map::cElement * operand_2477 = NULL ;
    while (((operand_2477 = enumerator_2477.nextObject ()))) {
      macroValidPointer (operand_2477) ;
      { const GGS_counter_type _var_2777 = operand_2477->mInfo.counter.reader_type (_inLexique COMMA_SOURCE_FILE_AT_LINE (83)) ; // CAST instruction
        if (_var_2777.getPtr () != NULL) {
          macroValidPointer (_var_2777.getPtr ()) ;
          if (typeid (cPtr_software_counter) == typeid (* (_var_2777.getPtr ()))) {
          }else{
            GGS_string var_cas_tmp ;
            ::routine_retrieveTemplateString (_inLexique,  var_cas_tmp,  GGS_string (true, "counter_list_specific") COMMA_SOURCE_FILE_AT_LINE (87)) ;
            ::routine_doReplace (_inLexique,  var_cas_tmp,  GGS_string (true, "$COUNTER$"),  (operand_2477->mKey.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (88)))._operator_concat (GGS_string (true, "_counter_desc")) COMMA_SOURCE_FILE_AT_LINE (88)) ;
            var_cas_result._dotAssign_operation (var_cas_tmp) ;
          }
        }
      }
    }
  }
  ::routine_doReplace (_inLexique,  var_cas_code,  GGS_string (true, "$COUNTER_LIST$"),  var_cas_result COMMA_SOURCE_FILE_AT_LINE (93)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_generate_counter_libpcl\n") ;
  #endif
}

//---------------------------------------------------------------------------*

