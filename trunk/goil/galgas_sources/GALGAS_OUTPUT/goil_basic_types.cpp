//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'goil_basic_types.cpp'                         *
//                        Generated by version 1.8.5                         *
//                       june 19th, 2009, at 17h39'1"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != 515
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "goil_basic_types.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "goil_basic_types.ggs", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_basic_type'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_basic_type::
cPtr_basic_type (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
location (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_basic_type * GGS_basic_type::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_basic_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_basic_type *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_basic_type::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@basic_type:"
           << location.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_basic_type::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_basic_type::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_basic_type (& typeid (cPtr_basic_type), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_basic_type::galgasRTTI (void) const {
  return & gClassInfoFor__basic_type ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_basic_type'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_basic_type::
GGS_basic_type (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_basic_type::
GGS_basic_type (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_basic_type GGS_basic_type::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_basic_type result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_basic_type *> (inPointer) != NULL)
      : (typeid (cPtr_basic_type) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_basic_type (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_basic_type),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_basic_type::
reader_location (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_basic_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_basic_type *) mPointer)->location ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_basic_type::actualTypeName (void) const {
  return "basic_type" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_basic_type::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__basic_type ("basic_type") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'cPtr_void'                              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_void::
cPtr_void (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_basic_type (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_void * GGS_void::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_void *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_void *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_void::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_void * ptr = dynamic_cast <const cPtr_void *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_void::
method_string (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_s COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_s = GGS_string ("") ;
}

//---------------------------------------------------------------------------*

void cPtr_void::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@void:"
           << location.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_void::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_void::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_void (& typeid (cPtr_void), & typeid (cPtr_basic_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_void::galgasRTTI (void) const {
  return & gClassInfoFor__void ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_void::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_void (location COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         GALGAS class 'GGS_void'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_void::
GGS_void (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_void::
GGS_void (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_void GGS_void::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_void result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_void *> (inPointer) != NULL)
      : (typeid (cPtr_void) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_void (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_void),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void GGS_void::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_void result ;
  macroMyNew (result.mPointer, cPtr_void (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_void::actualTypeName (void) const {
  return "void" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__void ("void", gClassInfoFor__basic_type) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_uint32_class'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint32_class::
cPtr_uint32_class (const GGS_location & argument_0,
                                const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_basic_type (argument_0 COMMA_THERE),
value (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint32_class * GGS_uint32_class::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint32_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_uint32_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uint32_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_uint32_class * ptr = dynamic_cast <const cPtr_uint32_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_uint32_class::
method_string (C_Compiler & inLexique,
                                GGS_string& var_cas_s COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_s = value.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (43)) ;
}

//---------------------------------------------------------------------------*

void cPtr_uint32_class::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@uint32_class:"
           << location.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << value.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uint32_class::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uint32_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uint32_class (& typeid (cPtr_uint32_class), & typeid (cPtr_basic_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_uint32_class::galgasRTTI (void) const {
  return & gClassInfoFor__uint32_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_uint32_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_uint32_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_uint32_class'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint32_class::
GGS_uint32_class (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uint32_class::
GGS_uint32_class (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uint32_class GGS_uint32_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uint32_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uint32_class *> (inPointer) != NULL)
      : (typeid (cPtr_uint32_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uint32_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uint32_class),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint32_class GGS_uint32_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_uint32_class result ;
  macroMyNew (result.mPointer, cPtr_uint32_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_uint32_class::
reader_value (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint32_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_uint32_class *) mPointer)->value ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uint32_class::actualTypeName (void) const {
  return "uint32_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__uint32_class ("uint32_class", gClassInfoFor__basic_type) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_sint32_class'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sint32_class::
cPtr_sint32_class (const GGS_location & argument_0,
                                const GGS_sint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_basic_type (argument_0 COMMA_THERE),
value (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sint32_class * GGS_sint32_class::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint32_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_sint32_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sint32_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sint32_class * ptr = dynamic_cast <const cPtr_sint32_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sint32_class::
method_string (C_Compiler & inLexique,
                                GGS_string& var_cas_s COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_s = value.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (50)) ;
}

//---------------------------------------------------------------------------*

void cPtr_sint32_class::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@sint32_class:"
           << location.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << value.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sint32_class::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sint32_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sint32_class (& typeid (cPtr_sint32_class), & typeid (cPtr_basic_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_sint32_class::galgasRTTI (void) const {
  return & gClassInfoFor__sint32_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sint32_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sint32_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_sint32_class'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sint32_class::
GGS_sint32_class (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sint32_class::
GGS_sint32_class (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sint32_class GGS_sint32_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sint32_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sint32_class *> (inPointer) != NULL)
      : (typeid (cPtr_sint32_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sint32_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sint32_class),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint32_class GGS_sint32_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_sint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_sint32_class result ;
  macroMyNew (result.mPointer, cPtr_sint32_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint  GGS_sint32_class::
reader_value (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint32_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sint32_class *) mPointer)->value ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sint32_class::actualTypeName (void) const {
  return "sint32_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__sint32_class ("sint32_class", gClassInfoFor__basic_type) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_uint64_class'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint64_class::
cPtr_uint64_class (const GGS_location & argument_0,
                                const GGS_uint64 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_basic_type (argument_0 COMMA_THERE),
value (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint64_class * GGS_uint64_class::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint64_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_uint64_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uint64_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_uint64_class * ptr = dynamic_cast <const cPtr_uint64_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_uint64_class::
method_string (C_Compiler & inLexique,
                                GGS_string& var_cas_s COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_s = value.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (57)) ;
}

//---------------------------------------------------------------------------*

void cPtr_uint64_class::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@uint64_class:"
           << location.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << value.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uint64_class::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uint64_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uint64_class (& typeid (cPtr_uint64_class), & typeid (cPtr_basic_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_uint64_class::galgasRTTI (void) const {
  return & gClassInfoFor__uint64_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_uint64_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_uint64_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_uint64_class'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint64_class::
GGS_uint64_class (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uint64_class::
GGS_uint64_class (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uint64_class GGS_uint64_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uint64_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uint64_class *> (inPointer) != NULL)
      : (typeid (cPtr_uint64_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uint64_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uint64_class),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64_class GGS_uint64_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_uint64 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_uint64_class result ;
  macroMyNew (result.mPointer, cPtr_uint64_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64  GGS_uint64_class::
reader_value (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint64_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_uint64_class *) mPointer)->value ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uint64_class::actualTypeName (void) const {
  return "uint64_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__uint64_class ("uint64_class", gClassInfoFor__basic_type) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_sint64_class'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sint64_class::
cPtr_sint64_class (const GGS_location & argument_0,
                                const GGS_sint64 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_basic_type (argument_0 COMMA_THERE),
value (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sint64_class * GGS_sint64_class::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint64_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_sint64_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sint64_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sint64_class * ptr = dynamic_cast <const cPtr_sint64_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sint64_class::
method_string (C_Compiler & inLexique,
                                GGS_string& var_cas_s COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_s = value.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (64)) ;
}

//---------------------------------------------------------------------------*

void cPtr_sint64_class::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@sint64_class:"
           << location.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << value.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sint64_class::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sint64_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sint64_class (& typeid (cPtr_sint64_class), & typeid (cPtr_basic_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_sint64_class::galgasRTTI (void) const {
  return & gClassInfoFor__sint64_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sint64_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sint64_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_sint64_class'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sint64_class::
GGS_sint64_class (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sint64_class::
GGS_sint64_class (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sint64_class GGS_sint64_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sint64_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sint64_class *> (inPointer) != NULL)
      : (typeid (cPtr_sint64_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sint64_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sint64_class),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64_class GGS_sint64_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_sint64 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_sint64_class result ;
  macroMyNew (result.mPointer, cPtr_sint64_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64  GGS_sint64_class::
reader_value (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint64_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sint64_class *) mPointer)->value ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sint64_class::actualTypeName (void) const {
  return "sint64_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__sint64_class ("sint64_class", gClassInfoFor__basic_type) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_float_class'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_float_class::
cPtr_float_class (const GGS_location & argument_0,
                                const GGS_double& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_basic_type (argument_0 COMMA_THERE),
value (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_float_class * GGS_float_class::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_float_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_float_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_float_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_float_class * ptr = dynamic_cast <const cPtr_float_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_float_class::
method_string (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_s COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_s = GGS_string ("") ;
}

//---------------------------------------------------------------------------*

void cPtr_float_class::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@float_class:"
           << location.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << value.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_float_class::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_float_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_float_class (& typeid (cPtr_float_class), & typeid (cPtr_basic_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_float_class::galgasRTTI (void) const {
  return & gClassInfoFor__float_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_float_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_float_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_float_class'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_float_class::
GGS_float_class (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_float_class::
GGS_float_class (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_float_class GGS_float_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_float_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_float_class *> (inPointer) != NULL)
      : (typeid (cPtr_float_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_float_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_float_class),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_float_class GGS_float_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_double& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_float_class result ;
  macroMyNew (result.mPointer, cPtr_float_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_double GGS_float_class::
reader_value (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_double  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_float_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_float_class *) mPointer)->value ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_float_class::actualTypeName (void) const {
  return "float_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__float_class ("float_class", gClassInfoFor__basic_type) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_string_class'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_string_class::
cPtr_string_class (const GGS_location & argument_0,
                                const GGS_string& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_basic_type (argument_0 COMMA_THERE),
value (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_string_class * GGS_string_class::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_string_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_string_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_string_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_string_class * ptr = dynamic_cast <const cPtr_string_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_string_class::
method_string (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_s COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_s = value ;
}

//---------------------------------------------------------------------------*

void cPtr_string_class::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@string_class:"
           << location.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << value.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_string_class::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_string_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_string_class (& typeid (cPtr_string_class), & typeid (cPtr_basic_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_string_class::galgasRTTI (void) const {
  return & gClassInfoFor__string_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_string_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_string_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_string_class'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string_class::
GGS_string_class (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_string_class::
GGS_string_class (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_string_class GGS_string_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_string_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_string_class *> (inPointer) != NULL)
      : (typeid (cPtr_string_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_string_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_string_class),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string_class GGS_string_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_string& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_string_class result ;
  macroMyNew (result.mPointer, cPtr_string_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_string_class::
reader_value (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_string_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_string_class *) mPointer)->value ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_string_class::actualTypeName (void) const {
  return "string_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__string_class ("string_class", gClassInfoFor__basic_type) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_bool_class'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_bool_class::
cPtr_bool_class (const GGS_location & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_basic_type (argument_0 COMMA_THERE),
value (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_bool_class * GGS_bool_class::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bool_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_bool_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_bool_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_bool_class * ptr = dynamic_cast <const cPtr_bool_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_bool_class::
method_string (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_s COMMA_UNUSED_LOCATION_ARGS) const {
  if ((value).isBuiltAndTrue ()) {
    var_cas_s = GGS_string ("true") ;
  }else{
    var_cas_s = GGS_string ("false") ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_bool_class::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@bool_class:"
           << location.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << value.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_bool_class::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_bool_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_bool_class (& typeid (cPtr_bool_class), & typeid (cPtr_basic_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_bool_class::galgasRTTI (void) const {
  return & gClassInfoFor__bool_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_bool_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_bool_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_bool_class'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bool_class::
GGS_bool_class (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_bool_class::
GGS_bool_class (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_bool_class GGS_bool_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_bool_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_bool_class *> (inPointer) != NULL)
      : (typeid (cPtr_bool_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_bool_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_bool_class),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool_class GGS_bool_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_bool_class result ;
  macroMyNew (result.mPointer, cPtr_bool_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_bool_class::
reader_value (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bool_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_bool_class *) mPointer)->value ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_bool_class::actualTypeName (void) const {
  return "bool_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__bool_class ("bool_class", gClassInfoFor__basic_type) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_void_uint32_class'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_void_uint32_class::
cPtr_void_uint32_class (const GGS_location & argument_0,
                                const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_uint32_class (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_void_uint32_class * GGS_void_uint32_class::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_void_uint32_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_void_uint32_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_void_uint32_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_void_uint32_class * ptr = dynamic_cast <const cPtr_void_uint32_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_void_uint32_class::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@void_uint32_class:"
           << location.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << value.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_void_uint32_class::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_void_uint32_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_void_uint32_class (& typeid (cPtr_void_uint32_class), & typeid (cPtr_uint32_class), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_void_uint32_class::galgasRTTI (void) const {
  return & gClassInfoFor__void_uint32_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_void_uint32_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_void_uint32_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_void_uint32_class'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_void_uint32_class::
GGS_void_uint32_class (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_void_uint32_class::
GGS_void_uint32_class (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_void_uint32_class GGS_void_uint32_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_void_uint32_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_void_uint32_class *> (inPointer) != NULL)
      : (typeid (cPtr_void_uint32_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_void_uint32_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_void_uint32_class),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_uint32_class GGS_void_uint32_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_void_uint32_class result ;
  macroMyNew (result.mPointer, cPtr_void_uint32_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_void_uint32_class::actualTypeName (void) const {
  return "void_uint32_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__void_uint32_class ("void_uint32_class", gClassInfoFor__uint32_class) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_void_sint32_class'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_void_sint32_class::
cPtr_void_sint32_class (const GGS_location & argument_0,
                                const GGS_sint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_sint32_class (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_void_sint32_class * GGS_void_sint32_class::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_void_sint32_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_void_sint32_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_void_sint32_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_void_sint32_class * ptr = dynamic_cast <const cPtr_void_sint32_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_void_sint32_class::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@void_sint32_class:"
           << location.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << value.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_void_sint32_class::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_void_sint32_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_void_sint32_class (& typeid (cPtr_void_sint32_class), & typeid (cPtr_sint32_class), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_void_sint32_class::galgasRTTI (void) const {
  return & gClassInfoFor__void_sint32_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_void_sint32_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_void_sint32_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_void_sint32_class'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_void_sint32_class::
GGS_void_sint32_class (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_void_sint32_class::
GGS_void_sint32_class (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_void_sint32_class GGS_void_sint32_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_void_sint32_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_void_sint32_class *> (inPointer) != NULL)
      : (typeid (cPtr_void_sint32_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_void_sint32_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_void_sint32_class),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_sint32_class GGS_void_sint32_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_sint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_void_sint32_class result ;
  macroMyNew (result.mPointer, cPtr_void_sint32_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_void_sint32_class::actualTypeName (void) const {
  return "void_sint32_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__void_sint32_class ("void_sint32_class", gClassInfoFor__sint32_class) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_void_uint64_class'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_void_uint64_class::
cPtr_void_uint64_class (const GGS_location & argument_0,
                                const GGS_uint64 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_uint64_class (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_void_uint64_class * GGS_void_uint64_class::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_void_uint64_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_void_uint64_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_void_uint64_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_void_uint64_class * ptr = dynamic_cast <const cPtr_void_uint64_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_void_uint64_class::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@void_uint64_class:"
           << location.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << value.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_void_uint64_class::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_void_uint64_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_void_uint64_class (& typeid (cPtr_void_uint64_class), & typeid (cPtr_uint64_class), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_void_uint64_class::galgasRTTI (void) const {
  return & gClassInfoFor__void_uint64_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_void_uint64_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_void_uint64_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_void_uint64_class'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_void_uint64_class::
GGS_void_uint64_class (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_void_uint64_class::
GGS_void_uint64_class (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_void_uint64_class GGS_void_uint64_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_void_uint64_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_void_uint64_class *> (inPointer) != NULL)
      : (typeid (cPtr_void_uint64_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_void_uint64_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_void_uint64_class),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_uint64_class GGS_void_uint64_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_uint64 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_void_uint64_class result ;
  macroMyNew (result.mPointer, cPtr_void_uint64_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_void_uint64_class::actualTypeName (void) const {
  return "void_uint64_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__void_uint64_class ("void_uint64_class", gClassInfoFor__uint64_class) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_void_sint64_class'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_void_sint64_class::
cPtr_void_sint64_class (const GGS_location & argument_0,
                                const GGS_sint64 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_sint64_class (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_void_sint64_class * GGS_void_sint64_class::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_void_sint64_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_void_sint64_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_void_sint64_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_void_sint64_class * ptr = dynamic_cast <const cPtr_void_sint64_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_void_sint64_class::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@void_sint64_class:"
           << location.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << value.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_void_sint64_class::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_void_sint64_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_void_sint64_class (& typeid (cPtr_void_sint64_class), & typeid (cPtr_sint64_class), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_void_sint64_class::galgasRTTI (void) const {
  return & gClassInfoFor__void_sint64_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_void_sint64_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_void_sint64_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_void_sint64_class'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_void_sint64_class::
GGS_void_sint64_class (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_void_sint64_class::
GGS_void_sint64_class (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_void_sint64_class GGS_void_sint64_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_void_sint64_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_void_sint64_class *> (inPointer) != NULL)
      : (typeid (cPtr_void_sint64_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_void_sint64_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_void_sint64_class),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_sint64_class GGS_void_sint64_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_sint64 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_void_sint64_class result ;
  macroMyNew (result.mPointer, cPtr_void_sint64_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_void_sint64_class::actualTypeName (void) const {
  return "void_sint64_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__void_sint64_class ("void_sint64_class", gClassInfoFor__sint64_class) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_void_float_class'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_void_float_class::
cPtr_void_float_class (const GGS_location & argument_0,
                                const GGS_double& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_float_class (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_void_float_class * GGS_void_float_class::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_void_float_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_void_float_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_void_float_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_void_float_class * ptr = dynamic_cast <const cPtr_void_float_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_void_float_class::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@void_float_class:"
           << location.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << value.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_void_float_class::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_void_float_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_void_float_class (& typeid (cPtr_void_float_class), & typeid (cPtr_float_class), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_void_float_class::galgasRTTI (void) const {
  return & gClassInfoFor__void_float_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_void_float_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_void_float_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_void_float_class'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_void_float_class::
GGS_void_float_class (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_void_float_class::
GGS_void_float_class (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_void_float_class GGS_void_float_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_void_float_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_void_float_class *> (inPointer) != NULL)
      : (typeid (cPtr_void_float_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_void_float_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_void_float_class),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_float_class GGS_void_float_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_double& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_void_float_class result ;
  macroMyNew (result.mPointer, cPtr_void_float_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_void_float_class::actualTypeName (void) const {
  return "void_float_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__void_float_class ("void_float_class", gClassInfoFor__float_class) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_void_string_class'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_void_string_class::
cPtr_void_string_class (const GGS_location & argument_0,
                                const GGS_string& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_string_class (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_void_string_class * GGS_void_string_class::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_void_string_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_void_string_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_void_string_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_void_string_class * ptr = dynamic_cast <const cPtr_void_string_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_void_string_class::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@void_string_class:"
           << location.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << value.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_void_string_class::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_void_string_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_void_string_class (& typeid (cPtr_void_string_class), & typeid (cPtr_string_class), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_void_string_class::galgasRTTI (void) const {
  return & gClassInfoFor__void_string_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_void_string_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_void_string_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_void_string_class'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_void_string_class::
GGS_void_string_class (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_void_string_class::
GGS_void_string_class (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_void_string_class GGS_void_string_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_void_string_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_void_string_class *> (inPointer) != NULL)
      : (typeid (cPtr_void_string_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_void_string_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_void_string_class),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_string_class GGS_void_string_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_string& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_void_string_class result ;
  macroMyNew (result.mPointer, cPtr_void_string_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_void_string_class::actualTypeName (void) const {
  return "void_string_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__void_string_class ("void_string_class", gClassInfoFor__string_class) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_void_bool_class'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_void_bool_class::
cPtr_void_bool_class (const GGS_location & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_bool_class (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_void_bool_class * GGS_void_bool_class::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_void_bool_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_void_bool_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_void_bool_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_void_bool_class * ptr = dynamic_cast <const cPtr_void_bool_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_void_bool_class::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@void_bool_class:"
           << location.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << value.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_void_bool_class::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_void_bool_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_void_bool_class (& typeid (cPtr_void_bool_class), & typeid (cPtr_bool_class), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_void_bool_class::galgasRTTI (void) const {
  return & gClassInfoFor__void_bool_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_void_bool_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_void_bool_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_void_bool_class'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_void_bool_class::
GGS_void_bool_class (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_void_bool_class::
GGS_void_bool_class (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_void_bool_class GGS_void_bool_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_void_bool_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_void_bool_class *> (inPointer) != NULL)
      : (typeid (cPtr_void_bool_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_void_bool_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_void_bool_class),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_bool_class GGS_void_bool_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_void_bool_class result ;
  macroMyNew (result.mPointer, cPtr_void_bool_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_void_bool_class::actualTypeName (void) const {
  return "void_bool_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__void_bool_class ("void_bool_class", gClassInfoFor__bool_class) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_auto_uint32_class'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_auto_uint32_class::
cPtr_auto_uint32_class (const GGS_location & argument_0,
                                const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_uint32_class (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_auto_uint32_class * GGS_auto_uint32_class::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_auto_uint32_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_auto_uint32_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_auto_uint32_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_auto_uint32_class * ptr = dynamic_cast <const cPtr_auto_uint32_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_auto_uint32_class::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@auto_uint32_class:"
           << location.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << value.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_auto_uint32_class::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_auto_uint32_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_auto_uint32_class (& typeid (cPtr_auto_uint32_class), & typeid (cPtr_uint32_class), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_auto_uint32_class::galgasRTTI (void) const {
  return & gClassInfoFor__auto_uint32_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_auto_uint32_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_auto_uint32_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_auto_uint32_class'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_auto_uint32_class::
GGS_auto_uint32_class (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_auto_uint32_class::
GGS_auto_uint32_class (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_auto_uint32_class GGS_auto_uint32_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_auto_uint32_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_auto_uint32_class *> (inPointer) != NULL)
      : (typeid (cPtr_auto_uint32_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_auto_uint32_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_auto_uint32_class),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_auto_uint32_class GGS_auto_uint32_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_auto_uint32_class result ;
  macroMyNew (result.mPointer, cPtr_auto_uint32_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_auto_uint32_class::actualTypeName (void) const {
  return "auto_uint32_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__auto_uint32_class ("auto_uint32_class", gClassInfoFor__uint32_class) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_auto_sint32_class'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_auto_sint32_class::
cPtr_auto_sint32_class (const GGS_location & argument_0,
                                const GGS_sint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_sint32_class (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_auto_sint32_class * GGS_auto_sint32_class::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_auto_sint32_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_auto_sint32_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_auto_sint32_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_auto_sint32_class * ptr = dynamic_cast <const cPtr_auto_sint32_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_auto_sint32_class::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@auto_sint32_class:"
           << location.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << value.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_auto_sint32_class::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_auto_sint32_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_auto_sint32_class (& typeid (cPtr_auto_sint32_class), & typeid (cPtr_sint32_class), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_auto_sint32_class::galgasRTTI (void) const {
  return & gClassInfoFor__auto_sint32_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_auto_sint32_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_auto_sint32_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_auto_sint32_class'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_auto_sint32_class::
GGS_auto_sint32_class (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_auto_sint32_class::
GGS_auto_sint32_class (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_auto_sint32_class GGS_auto_sint32_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_auto_sint32_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_auto_sint32_class *> (inPointer) != NULL)
      : (typeid (cPtr_auto_sint32_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_auto_sint32_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_auto_sint32_class),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_auto_sint32_class GGS_auto_sint32_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_sint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_auto_sint32_class result ;
  macroMyNew (result.mPointer, cPtr_auto_sint32_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_auto_sint32_class::actualTypeName (void) const {
  return "auto_sint32_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__auto_sint32_class ("auto_sint32_class", gClassInfoFor__sint32_class) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_auto_uint64_class'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_auto_uint64_class::
cPtr_auto_uint64_class (const GGS_location & argument_0,
                                const GGS_uint64 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_uint64_class (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_auto_uint64_class * GGS_auto_uint64_class::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_auto_uint64_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_auto_uint64_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_auto_uint64_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_auto_uint64_class * ptr = dynamic_cast <const cPtr_auto_uint64_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_auto_uint64_class::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@auto_uint64_class:"
           << location.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << value.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_auto_uint64_class::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_auto_uint64_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_auto_uint64_class (& typeid (cPtr_auto_uint64_class), & typeid (cPtr_uint64_class), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_auto_uint64_class::galgasRTTI (void) const {
  return & gClassInfoFor__auto_uint64_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_auto_uint64_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_auto_uint64_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_auto_uint64_class'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_auto_uint64_class::
GGS_auto_uint64_class (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_auto_uint64_class::
GGS_auto_uint64_class (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_auto_uint64_class GGS_auto_uint64_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_auto_uint64_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_auto_uint64_class *> (inPointer) != NULL)
      : (typeid (cPtr_auto_uint64_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_auto_uint64_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_auto_uint64_class),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_auto_uint64_class GGS_auto_uint64_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_uint64 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_auto_uint64_class result ;
  macroMyNew (result.mPointer, cPtr_auto_uint64_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_auto_uint64_class::actualTypeName (void) const {
  return "auto_uint64_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__auto_uint64_class ("auto_uint64_class", gClassInfoFor__uint64_class) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_auto_sint64_class'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_auto_sint64_class::
cPtr_auto_sint64_class (const GGS_location & argument_0,
                                const GGS_sint64 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_sint64_class (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_auto_sint64_class * GGS_auto_sint64_class::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_auto_sint64_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_auto_sint64_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_auto_sint64_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_auto_sint64_class * ptr = dynamic_cast <const cPtr_auto_sint64_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_auto_sint64_class::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@auto_sint64_class:"
           << location.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << value.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_auto_sint64_class::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_auto_sint64_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_auto_sint64_class (& typeid (cPtr_auto_sint64_class), & typeid (cPtr_sint64_class), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_auto_sint64_class::galgasRTTI (void) const {
  return & gClassInfoFor__auto_sint64_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_auto_sint64_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_auto_sint64_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_auto_sint64_class'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_auto_sint64_class::
GGS_auto_sint64_class (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_auto_sint64_class::
GGS_auto_sint64_class (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_auto_sint64_class GGS_auto_sint64_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_auto_sint64_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_auto_sint64_class *> (inPointer) != NULL)
      : (typeid (cPtr_auto_sint64_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_auto_sint64_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_auto_sint64_class),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_auto_sint64_class GGS_auto_sint64_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_sint64 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_auto_sint64_class result ;
  macroMyNew (result.mPointer, cPtr_auto_sint64_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_auto_sint64_class::actualTypeName (void) const {
  return "auto_sint64_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__auto_sint64_class ("auto_sint64_class", gClassInfoFor__sint64_class) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_auto_string_class'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_auto_string_class::
cPtr_auto_string_class (const GGS_location & argument_0,
                                const GGS_string& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_string_class (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_auto_string_class * GGS_auto_string_class::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_auto_string_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_auto_string_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_auto_string_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_auto_string_class * ptr = dynamic_cast <const cPtr_auto_string_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_auto_string_class::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@auto_string_class:"
           << location.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << value.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_auto_string_class::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_auto_string_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_auto_string_class (& typeid (cPtr_auto_string_class), & typeid (cPtr_string_class), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_auto_string_class::galgasRTTI (void) const {
  return & gClassInfoFor__auto_string_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_auto_string_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_auto_string_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_auto_string_class'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_auto_string_class::
GGS_auto_string_class (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_auto_string_class::
GGS_auto_string_class (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_auto_string_class GGS_auto_string_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_auto_string_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_auto_string_class *> (inPointer) != NULL)
      : (typeid (cPtr_auto_string_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_auto_string_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_auto_string_class),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_auto_string_class GGS_auto_string_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_string& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_auto_string_class result ;
  macroMyNew (result.mPointer, cPtr_auto_string_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_auto_string_class::actualTypeName (void) const {
  return "auto_string_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__auto_string_class ("auto_string_class", gClassInfoFor__string_class) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_auto_bool_class'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_auto_bool_class::
cPtr_auto_bool_class (const GGS_location & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_bool_class (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_auto_bool_class * GGS_auto_bool_class::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_auto_bool_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_auto_bool_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_auto_bool_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_auto_bool_class * ptr = dynamic_cast <const cPtr_auto_bool_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_auto_bool_class::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@auto_bool_class:"
           << location.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << value.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_auto_bool_class::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_auto_bool_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_auto_bool_class (& typeid (cPtr_auto_bool_class), & typeid (cPtr_bool_class), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_auto_bool_class::galgasRTTI (void) const {
  return & gClassInfoFor__auto_bool_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_auto_bool_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_auto_bool_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_auto_bool_class'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_auto_bool_class::
GGS_auto_bool_class (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_auto_bool_class::
GGS_auto_bool_class (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_auto_bool_class GGS_auto_bool_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_auto_bool_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_auto_bool_class *> (inPointer) != NULL)
      : (typeid (cPtr_auto_bool_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_auto_bool_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_auto_bool_class),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_auto_bool_class GGS_auto_bool_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_auto_bool_class result ;
  macroMyNew (result.mPointer, cPtr_auto_bool_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_auto_bool_class::actualTypeName (void) const {
  return "auto_bool_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__auto_bool_class ("auto_bool_class", gClassInfoFor__bool_class) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      Element of list '@list_uint32'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_list_uint32::
elementOf_GGS_list_uint32 (const GGS_uint & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
val (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_list_uint32::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_list_uint32 * ptr = dynamic_cast <const elementOf_GGS_list_uint32 *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = val.operator_isEqual (ptr->val).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_list_uint32::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << val.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           List '@list_uint32'                             *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_list_uint32::
_internalAppendValues (const GGS_uint & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_list_uint32::
_internalPrependValues (const GGS_uint & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_list_uint32::
_addAssign_operation (const GGS_uint & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_list_uint32 GGS_list_uint32::
operator_concat (const GGS_list_uint32 & inOperand) const {
  GGS_list_uint32 result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_list_uint32::
dotAssign_operation (const GGS_list_uint32 inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_list_uint32 * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_uint  p_0 = p->val ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_list_uint32::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_uint & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_list_uint32::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->val
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_list_uint32  GGS_list_uint32::
constructor_emptyList (void) {
  GGS_list_uint32 result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_list_uint32  GGS_list_uint32::
constructor_listWithValue (const GGS_uint & argument_0) {
  GGS_list_uint32 result ;
  result.alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_list_uint32::
internalSubListWithRange (GGS_list_uint32 & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList._addAssign_operation (ptr->val) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_list_uint32 GGS_list_uint32::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_list_uint32 result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_list_uint32 GGS_list_uint32::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_list_uint32 result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_list_uint32::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (inLexique, "@list_uint32", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_list_uint32::
method_first (C_Compiler & inLexique,
              GGS_uint & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->val ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_list_uint32::
method_last (C_Compiler & inLexique,
             GGS_uint & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->val ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_list_uint32::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_uint & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->val ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_list_uint32::
modifier_popLast (C_Compiler & inLexique,
                GGS_uint & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->val ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_list_uint32::
reader_valAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_uint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->val ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_list_uint32::
modifier_setValAtIndex (C_Compiler & inLexique,
                              const GGS_uint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->val = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_list_uint32::cEnumerator::_val (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->val ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Element of list '@list_sint32'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_list_sint32::
elementOf_GGS_list_sint32 (const GGS_sint & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
val (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_list_sint32::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_list_sint32 * ptr = dynamic_cast <const elementOf_GGS_list_sint32 *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = val.operator_isEqual (ptr->val).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_list_sint32::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << val.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           List '@list_sint32'                             *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_list_sint32::
_internalAppendValues (const GGS_sint & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_list_sint32::
_internalPrependValues (const GGS_sint & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_list_sint32::
_addAssign_operation (const GGS_sint & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_list_sint32 GGS_list_sint32::
operator_concat (const GGS_list_sint32 & inOperand) const {
  GGS_list_sint32 result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_list_sint32::
dotAssign_operation (const GGS_list_sint32 inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_list_sint32 * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_sint  p_0 = p->val ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_list_sint32::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_sint & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_list_sint32::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->val
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_list_sint32  GGS_list_sint32::
constructor_emptyList (void) {
  GGS_list_sint32 result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_list_sint32  GGS_list_sint32::
constructor_listWithValue (const GGS_sint & argument_0) {
  GGS_list_sint32 result ;
  result.alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_list_sint32::
internalSubListWithRange (GGS_list_sint32 & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList._addAssign_operation (ptr->val) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_list_sint32 GGS_list_sint32::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_list_sint32 result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_list_sint32 GGS_list_sint32::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_list_sint32 result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_list_sint32::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (inLexique, "@list_sint32", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_list_sint32::
method_first (C_Compiler & inLexique,
              GGS_sint & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->val ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_list_sint32::
method_last (C_Compiler & inLexique,
             GGS_sint & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->val ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_list_sint32::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_sint & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->val ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_list_sint32::
modifier_popLast (C_Compiler & inLexique,
                GGS_sint & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->val ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_sint  GGS_list_sint32::
reader_valAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_sint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->val ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_list_sint32::
modifier_setValAtIndex (C_Compiler & inLexique,
                              const GGS_sint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->val = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_sint  & GGS_list_sint32::cEnumerator::_val (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->val ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Element of list '@list_uint64'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_list_uint64::
elementOf_GGS_list_uint64 (const GGS_uint64 & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
val (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_list_uint64::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_list_uint64 * ptr = dynamic_cast <const elementOf_GGS_list_uint64 *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = val.operator_isEqual (ptr->val).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_list_uint64::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << val.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           List '@list_uint64'                             *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_list_uint64::
_internalAppendValues (const GGS_uint64 & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_list_uint64::
_internalPrependValues (const GGS_uint64 & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_list_uint64::
_addAssign_operation (const GGS_uint64 & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_list_uint64 GGS_list_uint64::
operator_concat (const GGS_list_uint64 & inOperand) const {
  GGS_list_uint64 result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_list_uint64::
dotAssign_operation (const GGS_list_uint64 inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_list_uint64 * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_uint64  p_0 = p->val ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_list_uint64::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_uint64 & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_list_uint64::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->val
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_list_uint64  GGS_list_uint64::
constructor_emptyList (void) {
  GGS_list_uint64 result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_list_uint64  GGS_list_uint64::
constructor_listWithValue (const GGS_uint64 & argument_0) {
  GGS_list_uint64 result ;
  result.alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_list_uint64::
internalSubListWithRange (GGS_list_uint64 & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList._addAssign_operation (ptr->val) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_list_uint64 GGS_list_uint64::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_list_uint64 result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_list_uint64 GGS_list_uint64::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_list_uint64 result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_list_uint64::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (inLexique, "@list_uint64", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_list_uint64::
method_first (C_Compiler & inLexique,
              GGS_uint64 & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->val ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_list_uint64::
method_last (C_Compiler & inLexique,
             GGS_uint64 & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->val ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_list_uint64::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_uint64 & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->val ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_list_uint64::
modifier_popLast (C_Compiler & inLexique,
                GGS_uint64 & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->val ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_uint64  GGS_list_uint64::
reader_valAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_uint64  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->val ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_list_uint64::
modifier_setValAtIndex (C_Compiler & inLexique,
                              const GGS_uint64  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->val = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint64  & GGS_list_uint64::cEnumerator::_val (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->val ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Element of list '@list_sint64'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_list_sint64::
elementOf_GGS_list_sint64 (const GGS_sint64 & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
val (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_list_sint64::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_list_sint64 * ptr = dynamic_cast <const elementOf_GGS_list_sint64 *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = val.operator_isEqual (ptr->val).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_list_sint64::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << val.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           List '@list_sint64'                             *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_list_sint64::
_internalAppendValues (const GGS_sint64 & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_list_sint64::
_internalPrependValues (const GGS_sint64 & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_list_sint64::
_addAssign_operation (const GGS_sint64 & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_list_sint64 GGS_list_sint64::
operator_concat (const GGS_list_sint64 & inOperand) const {
  GGS_list_sint64 result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_list_sint64::
dotAssign_operation (const GGS_list_sint64 inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_list_sint64 * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_sint64  p_0 = p->val ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_list_sint64::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_sint64 & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_list_sint64::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->val
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_list_sint64  GGS_list_sint64::
constructor_emptyList (void) {
  GGS_list_sint64 result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_list_sint64  GGS_list_sint64::
constructor_listWithValue (const GGS_sint64 & argument_0) {
  GGS_list_sint64 result ;
  result.alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_list_sint64::
internalSubListWithRange (GGS_list_sint64 & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList._addAssign_operation (ptr->val) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_list_sint64 GGS_list_sint64::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_list_sint64 result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_list_sint64 GGS_list_sint64::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_list_sint64 result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_list_sint64::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (inLexique, "@list_sint64", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_list_sint64::
method_first (C_Compiler & inLexique,
              GGS_sint64 & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->val ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_list_sint64::
method_last (C_Compiler & inLexique,
             GGS_sint64 & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->val ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_list_sint64::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_sint64 & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->val ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_list_sint64::
modifier_popLast (C_Compiler & inLexique,
                GGS_sint64 & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->val ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_sint64  GGS_list_sint64::
reader_valAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_sint64  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->val ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_list_sint64::
modifier_setValAtIndex (C_Compiler & inLexique,
                              const GGS_sint64  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->val = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_sint64  & GGS_list_sint64::cEnumerator::_val (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->val ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_number_set'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_number_set::
cPtr_number_set (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
loc (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_number_set * GGS_number_set::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_number_set *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_number_set *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_number_set::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@number_set:"
           << loc.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_number_set::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_number_set::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_number_set (& typeid (cPtr_number_set), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_number_set::galgasRTTI (void) const {
  return & gClassInfoFor__number_set ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_number_set'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_number_set::
GGS_number_set (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_number_set::
GGS_number_set (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_number_set GGS_number_set::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_number_set result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_number_set *> (inPointer) != NULL)
      : (typeid (cPtr_number_set) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_number_set (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_number_set),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_number_set::
reader_loc (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_number_set *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_number_set *) mPointer)->loc ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_number_set::actualTypeName (void) const {
  return "number_set" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_number_set::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__number_set ("number_set") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_uint32_set'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint32_set::
cPtr_uint32_set (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_number_set (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint32_set * GGS_uint32_set::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint32_set *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_uint32_set *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_uint32_set::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@uint32_set:"
           << loc.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uint32_set::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uint32_set::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uint32_set (& typeid (cPtr_uint32_set), & typeid (cPtr_number_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_uint32_set::galgasRTTI (void) const {
  return & gClassInfoFor__uint32_set ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_uint32_set'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint32_set::
GGS_uint32_set (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uint32_set::
GGS_uint32_set (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uint32_set GGS_uint32_set::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uint32_set result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uint32_set *> (inPointer) != NULL)
      : (typeid (cPtr_uint32_set) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uint32_set (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uint32_set),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uint32_set::actualTypeName (void) const {
  return "uint32_set" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__uint32_set ("uint32_set", gClassInfoFor__number_set) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_sint32_set'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sint32_set::
cPtr_sint32_set (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_number_set (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sint32_set * GGS_sint32_set::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint32_set *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_sint32_set *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_sint32_set::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@sint32_set:"
           << loc.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sint32_set::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sint32_set::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sint32_set (& typeid (cPtr_sint32_set), & typeid (cPtr_number_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_sint32_set::galgasRTTI (void) const {
  return & gClassInfoFor__sint32_set ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_sint32_set'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sint32_set::
GGS_sint32_set (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sint32_set::
GGS_sint32_set (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sint32_set GGS_sint32_set::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sint32_set result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sint32_set *> (inPointer) != NULL)
      : (typeid (cPtr_sint32_set) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sint32_set (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sint32_set),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sint32_set::actualTypeName (void) const {
  return "sint32_set" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__sint32_set ("sint32_set", gClassInfoFor__number_set) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_uint64_set'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint64_set::
cPtr_uint64_set (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_number_set (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint64_set * GGS_uint64_set::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint64_set *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_uint64_set *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_uint64_set::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@uint64_set:"
           << loc.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uint64_set::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uint64_set::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uint64_set (& typeid (cPtr_uint64_set), & typeid (cPtr_number_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_uint64_set::galgasRTTI (void) const {
  return & gClassInfoFor__uint64_set ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_uint64_set'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint64_set::
GGS_uint64_set (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uint64_set::
GGS_uint64_set (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uint64_set GGS_uint64_set::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uint64_set result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uint64_set *> (inPointer) != NULL)
      : (typeid (cPtr_uint64_set) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uint64_set (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uint64_set),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uint64_set::actualTypeName (void) const {
  return "uint64_set" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__uint64_set ("uint64_set", gClassInfoFor__number_set) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_sint64_set'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sint64_set::
cPtr_sint64_set (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_number_set (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sint64_set * GGS_sint64_set::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint64_set *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_sint64_set *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_sint64_set::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@sint64_set:"
           << loc.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sint64_set::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sint64_set::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sint64_set (& typeid (cPtr_sint64_set), & typeid (cPtr_number_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_sint64_set::galgasRTTI (void) const {
  return & gClassInfoFor__sint64_set ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_sint64_set'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sint64_set::
GGS_sint64_set (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sint64_set::
GGS_sint64_set (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sint64_set GGS_sint64_set::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sint64_set result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sint64_set *> (inPointer) != NULL)
      : (typeid (cPtr_sint64_set) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sint64_set (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sint64_set),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sint64_set::actualTypeName (void) const {
  return "sint64_set" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__sint64_set ("sint64_set", gClassInfoFor__number_set) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_float_set'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_float_set::
cPtr_float_set (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_number_set (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_float_set * GGS_float_set::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_float_set *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_float_set *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_float_set::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@float_set:"
           << loc.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_float_set::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_float_set::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_float_set (& typeid (cPtr_float_set), & typeid (cPtr_number_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_float_set::galgasRTTI (void) const {
  return & gClassInfoFor__float_set ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_float_set'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_float_set::
GGS_float_set (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_float_set::
GGS_float_set (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_float_set GGS_float_set::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_float_set result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_float_set *> (inPointer) != NULL)
      : (typeid (cPtr_float_set) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_float_set (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_float_set),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_float_set::actualTypeName (void) const {
  return "float_set" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__float_set ("float_set", gClassInfoFor__number_set) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_uint32_empty_set'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint32_empty_set::
cPtr_uint32_empty_set (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_uint32_set (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint32_empty_set * GGS_uint32_empty_set::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint32_empty_set *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_uint32_empty_set *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uint32_empty_set::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_uint32_empty_set * ptr = dynamic_cast <const cPtr_uint32_empty_set *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_uint32_empty_set::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@uint32_empty_set:"
           << loc.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uint32_empty_set::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uint32_empty_set::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uint32_empty_set (& typeid (cPtr_uint32_empty_set), & typeid (cPtr_uint32_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_uint32_empty_set::galgasRTTI (void) const {
  return & gClassInfoFor__uint32_empty_set ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_uint32_empty_set::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_uint32_empty_set (loc COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_uint32_empty_set'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint32_empty_set::
GGS_uint32_empty_set (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uint32_empty_set::
GGS_uint32_empty_set (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uint32_empty_set GGS_uint32_empty_set::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uint32_empty_set result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uint32_empty_set *> (inPointer) != NULL)
      : (typeid (cPtr_uint32_empty_set) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uint32_empty_set (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uint32_empty_set),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint32_empty_set GGS_uint32_empty_set::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_uint32_empty_set result ;
  macroMyNew (result.mPointer, cPtr_uint32_empty_set (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uint32_empty_set::actualTypeName (void) const {
  return "uint32_empty_set" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__uint32_empty_set ("uint32_empty_set", gClassInfoFor__uint32_set) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_sint32_empty_set'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sint32_empty_set::
cPtr_sint32_empty_set (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_sint32_set (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sint32_empty_set * GGS_sint32_empty_set::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint32_empty_set *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_sint32_empty_set *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sint32_empty_set::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sint32_empty_set * ptr = dynamic_cast <const cPtr_sint32_empty_set *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sint32_empty_set::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@sint32_empty_set:"
           << loc.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sint32_empty_set::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sint32_empty_set::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sint32_empty_set (& typeid (cPtr_sint32_empty_set), & typeid (cPtr_sint32_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_sint32_empty_set::galgasRTTI (void) const {
  return & gClassInfoFor__sint32_empty_set ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sint32_empty_set::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sint32_empty_set (loc COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_sint32_empty_set'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sint32_empty_set::
GGS_sint32_empty_set (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sint32_empty_set::
GGS_sint32_empty_set (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sint32_empty_set GGS_sint32_empty_set::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sint32_empty_set result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sint32_empty_set *> (inPointer) != NULL)
      : (typeid (cPtr_sint32_empty_set) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sint32_empty_set (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sint32_empty_set),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint32_empty_set GGS_sint32_empty_set::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_sint32_empty_set result ;
  macroMyNew (result.mPointer, cPtr_sint32_empty_set (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sint32_empty_set::actualTypeName (void) const {
  return "sint32_empty_set" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__sint32_empty_set ("sint32_empty_set", gClassInfoFor__sint32_set) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_uint64_empty_set'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint64_empty_set::
cPtr_uint64_empty_set (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_uint64_set (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint64_empty_set * GGS_uint64_empty_set::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint64_empty_set *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_uint64_empty_set *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uint64_empty_set::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_uint64_empty_set * ptr = dynamic_cast <const cPtr_uint64_empty_set *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_uint64_empty_set::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@uint64_empty_set:"
           << loc.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uint64_empty_set::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uint64_empty_set::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uint64_empty_set (& typeid (cPtr_uint64_empty_set), & typeid (cPtr_uint64_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_uint64_empty_set::galgasRTTI (void) const {
  return & gClassInfoFor__uint64_empty_set ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_uint64_empty_set::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_uint64_empty_set (loc COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_uint64_empty_set'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint64_empty_set::
GGS_uint64_empty_set (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uint64_empty_set::
GGS_uint64_empty_set (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uint64_empty_set GGS_uint64_empty_set::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uint64_empty_set result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uint64_empty_set *> (inPointer) != NULL)
      : (typeid (cPtr_uint64_empty_set) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uint64_empty_set (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uint64_empty_set),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64_empty_set GGS_uint64_empty_set::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_uint64_empty_set result ;
  macroMyNew (result.mPointer, cPtr_uint64_empty_set (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uint64_empty_set::actualTypeName (void) const {
  return "uint64_empty_set" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__uint64_empty_set ("uint64_empty_set", gClassInfoFor__uint64_set) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_sint64_empty_set'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sint64_empty_set::
cPtr_sint64_empty_set (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_sint64_set (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sint64_empty_set * GGS_sint64_empty_set::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint64_empty_set *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_sint64_empty_set *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sint64_empty_set::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sint64_empty_set * ptr = dynamic_cast <const cPtr_sint64_empty_set *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sint64_empty_set::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@sint64_empty_set:"
           << loc.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sint64_empty_set::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sint64_empty_set::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sint64_empty_set (& typeid (cPtr_sint64_empty_set), & typeid (cPtr_sint64_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_sint64_empty_set::galgasRTTI (void) const {
  return & gClassInfoFor__sint64_empty_set ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sint64_empty_set::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sint64_empty_set (loc COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_sint64_empty_set'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sint64_empty_set::
GGS_sint64_empty_set (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sint64_empty_set::
GGS_sint64_empty_set (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sint64_empty_set GGS_sint64_empty_set::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sint64_empty_set result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sint64_empty_set *> (inPointer) != NULL)
      : (typeid (cPtr_sint64_empty_set) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sint64_empty_set (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sint64_empty_set),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64_empty_set GGS_sint64_empty_set::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_sint64_empty_set result ;
  macroMyNew (result.mPointer, cPtr_sint64_empty_set (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sint64_empty_set::actualTypeName (void) const {
  return "sint64_empty_set" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__sint64_empty_set ("sint64_empty_set", gClassInfoFor__sint64_set) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_float_empty_set'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_float_empty_set::
cPtr_float_empty_set (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_float_set (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_float_empty_set * GGS_float_empty_set::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_float_empty_set *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_float_empty_set *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_float_empty_set::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_float_empty_set * ptr = dynamic_cast <const cPtr_float_empty_set *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_float_empty_set::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@float_empty_set:"
           << loc.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_float_empty_set::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_float_empty_set::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_float_empty_set (& typeid (cPtr_float_empty_set), & typeid (cPtr_float_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_float_empty_set::galgasRTTI (void) const {
  return & gClassInfoFor__float_empty_set ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_float_empty_set::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_float_empty_set (loc COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_float_empty_set'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_float_empty_set::
GGS_float_empty_set (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_float_empty_set::
GGS_float_empty_set (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_float_empty_set GGS_float_empty_set::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_float_empty_set result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_float_empty_set *> (inPointer) != NULL)
      : (typeid (cPtr_float_empty_set) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_float_empty_set (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_float_empty_set),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_float_empty_set GGS_float_empty_set::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_float_empty_set result ;
  macroMyNew (result.mPointer, cPtr_float_empty_set (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_float_empty_set::actualTypeName (void) const {
  return "float_empty_set" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__float_empty_set ("float_empty_set", gClassInfoFor__float_set) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_uint32_range'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint32_range::
cPtr_uint32_range (const GGS_location & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_uint & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_uint32_set (argument_0 COMMA_THERE),
min (argument_1),
max (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint32_range * GGS_uint32_range::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint32_range *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_uint32_range *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uint32_range::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_uint32_range * ptr = dynamic_cast <const cPtr_uint32_range *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && min.operator_isEqual (ptr->min).boolValue ()
         && max.operator_isEqual (ptr->max).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_uint32_range::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@uint32_range:"
           << loc.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << min.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << max.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uint32_range::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uint32_range::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uint32_range (& typeid (cPtr_uint32_range), & typeid (cPtr_uint32_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_uint32_range::galgasRTTI (void) const {
  return & gClassInfoFor__uint32_range ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_uint32_range::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_uint32_range (loc, min, max COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_uint32_range'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint32_range::
GGS_uint32_range (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uint32_range::
GGS_uint32_range (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uint32_range GGS_uint32_range::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uint32_range result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uint32_range *> (inPointer) != NULL)
      : (typeid (cPtr_uint32_range) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uint32_range (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uint32_range),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint32_range GGS_uint32_range::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_uint & argument_1,
                 const GGS_uint & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_uint32_range result ;
  macroMyNew (result.mPointer, cPtr_uint32_range (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_uint32_range::
reader_min (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint32_range *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_uint32_range *) mPointer)->min ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_uint32_range::
reader_max (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint32_range *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_uint32_range *) mPointer)->max ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uint32_range::actualTypeName (void) const {
  return "uint32_range" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__uint32_range ("uint32_range", gClassInfoFor__uint32_set) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_uint32_list'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint32_list::
cPtr_uint32_list (const GGS_location & argument_0,
                                const GGS_list_uint32 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_uint32_set (argument_0 COMMA_THERE),
li (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint32_list * GGS_uint32_list::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint32_list *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_uint32_list *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uint32_list::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_uint32_list * ptr = dynamic_cast <const cPtr_uint32_list *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && li.operator_isEqual (ptr->li).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_uint32_list::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@uint32_list:"
           << loc.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << li.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uint32_list::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uint32_list::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uint32_list (& typeid (cPtr_uint32_list), & typeid (cPtr_uint32_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_uint32_list::galgasRTTI (void) const {
  return & gClassInfoFor__uint32_list ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_uint32_list::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_uint32_list (loc, li COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_uint32_list'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint32_list::
GGS_uint32_list (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uint32_list::
GGS_uint32_list (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uint32_list GGS_uint32_list::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uint32_list result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uint32_list *> (inPointer) != NULL)
      : (typeid (cPtr_uint32_list) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uint32_list (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uint32_list),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint32_list GGS_uint32_list::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_list_uint32 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_uint32_list result ;
  macroMyNew (result.mPointer, cPtr_uint32_list (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_list_uint32  GGS_uint32_list::
reader_li (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_list_uint32   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint32_list *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_uint32_list *) mPointer)->li ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uint32_list::actualTypeName (void) const {
  return "uint32_list" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__uint32_list ("uint32_list", gClassInfoFor__uint32_set) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_sint32_range'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sint32_range::
cPtr_sint32_range (const GGS_location & argument_0,
                                const GGS_sint & argument_1,
                                const GGS_sint & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_sint32_set (argument_0 COMMA_THERE),
min (argument_1),
max (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sint32_range * GGS_sint32_range::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint32_range *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_sint32_range *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sint32_range::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sint32_range * ptr = dynamic_cast <const cPtr_sint32_range *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && min.operator_isEqual (ptr->min).boolValue ()
         && max.operator_isEqual (ptr->max).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sint32_range::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@sint32_range:"
           << loc.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << min.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << max.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sint32_range::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sint32_range::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sint32_range (& typeid (cPtr_sint32_range), & typeid (cPtr_sint32_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_sint32_range::galgasRTTI (void) const {
  return & gClassInfoFor__sint32_range ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sint32_range::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sint32_range (loc, min, max COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_sint32_range'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sint32_range::
GGS_sint32_range (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sint32_range::
GGS_sint32_range (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sint32_range GGS_sint32_range::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sint32_range result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sint32_range *> (inPointer) != NULL)
      : (typeid (cPtr_sint32_range) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sint32_range (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sint32_range),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint32_range GGS_sint32_range::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_sint & argument_1,
                 const GGS_sint & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_sint32_range result ;
  macroMyNew (result.mPointer, cPtr_sint32_range (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint  GGS_sint32_range::
reader_min (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint32_range *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sint32_range *) mPointer)->min ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint  GGS_sint32_range::
reader_max (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint32_range *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sint32_range *) mPointer)->max ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sint32_range::actualTypeName (void) const {
  return "sint32_range" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__sint32_range ("sint32_range", gClassInfoFor__sint32_set) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_sint32_list'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sint32_list::
cPtr_sint32_list (const GGS_location & argument_0,
                                const GGS_list_sint32 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_sint32_set (argument_0 COMMA_THERE),
li (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sint32_list * GGS_sint32_list::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint32_list *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_sint32_list *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sint32_list::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sint32_list * ptr = dynamic_cast <const cPtr_sint32_list *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && li.operator_isEqual (ptr->li).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sint32_list::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@sint32_list:"
           << loc.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << li.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sint32_list::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sint32_list::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sint32_list (& typeid (cPtr_sint32_list), & typeid (cPtr_sint32_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_sint32_list::galgasRTTI (void) const {
  return & gClassInfoFor__sint32_list ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sint32_list::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sint32_list (loc, li COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_sint32_list'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sint32_list::
GGS_sint32_list (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sint32_list::
GGS_sint32_list (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sint32_list GGS_sint32_list::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sint32_list result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sint32_list *> (inPointer) != NULL)
      : (typeid (cPtr_sint32_list) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sint32_list (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sint32_list),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint32_list GGS_sint32_list::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_list_sint32 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_sint32_list result ;
  macroMyNew (result.mPointer, cPtr_sint32_list (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_list_sint32  GGS_sint32_list::
reader_li (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_list_sint32   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint32_list *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sint32_list *) mPointer)->li ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sint32_list::actualTypeName (void) const {
  return "sint32_list" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__sint32_list ("sint32_list", gClassInfoFor__sint32_set) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_uint64_range'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint64_range::
cPtr_uint64_range (const GGS_location & argument_0,
                                const GGS_uint64 & argument_1,
                                const GGS_uint64 & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_uint64_set (argument_0 COMMA_THERE),
min (argument_1),
max (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint64_range * GGS_uint64_range::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint64_range *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_uint64_range *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uint64_range::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_uint64_range * ptr = dynamic_cast <const cPtr_uint64_range *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && min.operator_isEqual (ptr->min).boolValue ()
         && max.operator_isEqual (ptr->max).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_uint64_range::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@uint64_range:"
           << loc.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << min.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << max.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uint64_range::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uint64_range::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uint64_range (& typeid (cPtr_uint64_range), & typeid (cPtr_uint64_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_uint64_range::galgasRTTI (void) const {
  return & gClassInfoFor__uint64_range ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_uint64_range::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_uint64_range (loc, min, max COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_uint64_range'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint64_range::
GGS_uint64_range (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uint64_range::
GGS_uint64_range (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uint64_range GGS_uint64_range::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uint64_range result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uint64_range *> (inPointer) != NULL)
      : (typeid (cPtr_uint64_range) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uint64_range (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uint64_range),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64_range GGS_uint64_range::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_uint64 & argument_1,
                 const GGS_uint64 & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_uint64_range result ;
  macroMyNew (result.mPointer, cPtr_uint64_range (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64  GGS_uint64_range::
reader_min (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint64_range *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_uint64_range *) mPointer)->min ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64  GGS_uint64_range::
reader_max (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint64_range *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_uint64_range *) mPointer)->max ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uint64_range::actualTypeName (void) const {
  return "uint64_range" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__uint64_range ("uint64_range", gClassInfoFor__uint64_set) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_uint64_list'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint64_list::
cPtr_uint64_list (const GGS_location & argument_0,
                                const GGS_list_uint64 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_uint64_set (argument_0 COMMA_THERE),
li (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint64_list * GGS_uint64_list::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint64_list *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_uint64_list *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uint64_list::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_uint64_list * ptr = dynamic_cast <const cPtr_uint64_list *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && li.operator_isEqual (ptr->li).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_uint64_list::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@uint64_list:"
           << loc.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << li.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uint64_list::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uint64_list::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uint64_list (& typeid (cPtr_uint64_list), & typeid (cPtr_uint64_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_uint64_list::galgasRTTI (void) const {
  return & gClassInfoFor__uint64_list ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_uint64_list::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_uint64_list (loc, li COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_uint64_list'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint64_list::
GGS_uint64_list (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uint64_list::
GGS_uint64_list (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uint64_list GGS_uint64_list::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uint64_list result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uint64_list *> (inPointer) != NULL)
      : (typeid (cPtr_uint64_list) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uint64_list (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uint64_list),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64_list GGS_uint64_list::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_list_uint64 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_uint64_list result ;
  macroMyNew (result.mPointer, cPtr_uint64_list (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_list_uint64  GGS_uint64_list::
reader_li (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_list_uint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint64_list *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_uint64_list *) mPointer)->li ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uint64_list::actualTypeName (void) const {
  return "uint64_list" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__uint64_list ("uint64_list", gClassInfoFor__uint64_set) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_sint64_range'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sint64_range::
cPtr_sint64_range (const GGS_location & argument_0,
                                const GGS_sint64 & argument_1,
                                const GGS_sint64 & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_sint64_set (argument_0 COMMA_THERE),
min (argument_1),
max (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sint64_range * GGS_sint64_range::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint64_range *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_sint64_range *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sint64_range::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sint64_range * ptr = dynamic_cast <const cPtr_sint64_range *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && min.operator_isEqual (ptr->min).boolValue ()
         && max.operator_isEqual (ptr->max).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sint64_range::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@sint64_range:"
           << loc.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << min.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << max.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sint64_range::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sint64_range::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sint64_range (& typeid (cPtr_sint64_range), & typeid (cPtr_sint64_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_sint64_range::galgasRTTI (void) const {
  return & gClassInfoFor__sint64_range ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sint64_range::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sint64_range (loc, min, max COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_sint64_range'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sint64_range::
GGS_sint64_range (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sint64_range::
GGS_sint64_range (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sint64_range GGS_sint64_range::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sint64_range result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sint64_range *> (inPointer) != NULL)
      : (typeid (cPtr_sint64_range) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sint64_range (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sint64_range),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64_range GGS_sint64_range::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_sint64 & argument_1,
                 const GGS_sint64 & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_sint64_range result ;
  macroMyNew (result.mPointer, cPtr_sint64_range (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64  GGS_sint64_range::
reader_min (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint64_range *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sint64_range *) mPointer)->min ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64  GGS_sint64_range::
reader_max (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint64_range *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sint64_range *) mPointer)->max ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sint64_range::actualTypeName (void) const {
  return "sint64_range" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__sint64_range ("sint64_range", gClassInfoFor__sint64_set) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_sint64_list'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sint64_list::
cPtr_sint64_list (const GGS_location & argument_0,
                                const GGS_list_sint64 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_sint64_set (argument_0 COMMA_THERE),
li (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sint64_list * GGS_sint64_list::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint64_list *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_sint64_list *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sint64_list::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sint64_list * ptr = dynamic_cast <const cPtr_sint64_list *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && li.operator_isEqual (ptr->li).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sint64_list::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@sint64_list:"
           << loc.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << li.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sint64_list::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sint64_list::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sint64_list (& typeid (cPtr_sint64_list), & typeid (cPtr_sint64_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_sint64_list::galgasRTTI (void) const {
  return & gClassInfoFor__sint64_list ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sint64_list::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sint64_list (loc, li COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_sint64_list'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sint64_list::
GGS_sint64_list (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sint64_list::
GGS_sint64_list (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sint64_list GGS_sint64_list::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sint64_list result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sint64_list *> (inPointer) != NULL)
      : (typeid (cPtr_sint64_list) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sint64_list (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sint64_list),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64_list GGS_sint64_list::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_list_sint64 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_sint64_list result ;
  macroMyNew (result.mPointer, cPtr_sint64_list (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_list_sint64  GGS_sint64_list::
reader_li (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_list_sint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint64_list *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sint64_list *) mPointer)->li ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sint64_list::actualTypeName (void) const {
  return "sint64_list" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__sint64_list ("sint64_list", gClassInfoFor__sint64_set) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_imp_type'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_imp_type::
cPtr_imp_type (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
loc (argument_0),
desc (argument_1),
multiple (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_imp_type * GGS_imp_type::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_imp_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_imp_type *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_imp_type::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@imp_type:"
           << loc.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << desc.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << multiple.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_imp_type::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_imp_type::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_imp_type (& typeid (cPtr_imp_type), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_imp_type::galgasRTTI (void) const {
  return & gClassInfoFor__imp_type ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_imp_type'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_imp_type::
GGS_imp_type (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_imp_type::
GGS_imp_type (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_imp_type GGS_imp_type::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_imp_type result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_imp_type *> (inPointer) != NULL)
      : (typeid (cPtr_imp_type) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_imp_type (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_imp_type),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_imp_type::
reader_loc (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_imp_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_imp_type *) mPointer)->loc ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_imp_type::
reader_desc (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_imp_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_imp_type *) mPointer)->desc ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_imp_type::
reader_multiple (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_imp_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_imp_type *) mPointer)->multiple ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_imp_type::actualTypeName (void) const {
  return "imp_type" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_imp_type::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__imp_type ("imp_type") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_imp_sca_type'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_imp_sca_type::
cPtr_imp_sca_type (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_imp_type (argument_0, argument_1, argument_2 COMMA_THERE),
with_auto (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_imp_sca_type * GGS_imp_sca_type::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_imp_sca_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_imp_sca_type *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_imp_sca_type::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@imp_sca_type:"
           << loc.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << desc.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << multiple.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << with_auto.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_imp_sca_type::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_imp_sca_type::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_imp_sca_type (& typeid (cPtr_imp_sca_type), & typeid (cPtr_imp_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_imp_sca_type::galgasRTTI (void) const {
  return & gClassInfoFor__imp_sca_type ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_imp_sca_type'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_imp_sca_type::
GGS_imp_sca_type (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_imp_sca_type::
GGS_imp_sca_type (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_imp_sca_type GGS_imp_sca_type::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_imp_sca_type result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_imp_sca_type *> (inPointer) != NULL)
      : (typeid (cPtr_imp_sca_type) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_imp_sca_type (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_imp_sca_type),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_imp_sca_type::
reader_with_auto (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_imp_sca_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_imp_sca_type *) mPointer)->with_auto ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_imp_sca_type::actualTypeName (void) const {
  return "imp_sca_type" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__imp_sca_type ("imp_sca_type", gClassInfoFor__imp_type) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_imp_obj_ref'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_imp_obj_ref::
cPtr_imp_obj_ref (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_imp_type (argument_0, argument_1, argument_2 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_imp_obj_ref * GGS_imp_obj_ref::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_imp_obj_ref *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_imp_obj_ref *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_imp_obj_ref::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@imp_obj_ref:"
           << loc.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << desc.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << multiple.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_imp_obj_ref::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_imp_obj_ref::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_imp_obj_ref (& typeid (cPtr_imp_obj_ref), & typeid (cPtr_imp_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_imp_obj_ref::galgasRTTI (void) const {
  return & gClassInfoFor__imp_obj_ref ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_imp_obj_ref'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_imp_obj_ref::
GGS_imp_obj_ref (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_imp_obj_ref::
GGS_imp_obj_ref (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_imp_obj_ref GGS_imp_obj_ref::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_imp_obj_ref result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_imp_obj_ref *> (inPointer) != NULL)
      : (typeid (cPtr_imp_obj_ref) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_imp_obj_ref (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_imp_obj_ref),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_imp_obj_ref::actualTypeName (void) const {
  return "imp_obj_ref" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__imp_obj_ref ("imp_obj_ref", gClassInfoFor__imp_type) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_void_type'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_void_type::
cPtr_void_type (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_imp_type (argument_0, argument_1, argument_2 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_void_type * GGS_void_type::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_void_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_void_type *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_void_type::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_void_type * ptr = dynamic_cast <const cPtr_void_type *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && desc.operator_isEqual (ptr->desc).boolValue ()
         && multiple.operator_isEqual (ptr->multiple).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_void_type::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@void_type:"
           << loc.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << desc.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << multiple.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_void_type::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_void_type::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_void_type (& typeid (cPtr_void_type), & typeid (cPtr_imp_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_void_type::galgasRTTI (void) const {
  return & gClassInfoFor__void_type ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_void_type::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_void_type (loc, desc, multiple COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_void_type'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_void_type::
GGS_void_type (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_void_type::
GGS_void_type (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_void_type GGS_void_type::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_void_type result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_void_type *> (inPointer) != NULL)
      : (typeid (cPtr_void_type) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_void_type (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_void_type),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_type GGS_void_type::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_void_type result ;
  macroMyNew (result.mPointer, cPtr_void_type (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_void_type::actualTypeName (void) const {
  return "void_type" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__void_type ("void_type", gClassInfoFor__imp_type) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_uint32_type'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint32_type::
cPtr_uint32_type (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_bool& argument_3,
                                const GGS_uint32_class & argument_4,
                                const GGS_uint32_set & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_imp_sca_type (argument_0, argument_1, argument_2, argument_3 COMMA_THERE),
def_val (argument_4),
set (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint32_type * GGS_uint32_type::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint32_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_uint32_type *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uint32_type::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_uint32_type * ptr = dynamic_cast <const cPtr_uint32_type *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && desc.operator_isEqual (ptr->desc).boolValue ()
         && multiple.operator_isEqual (ptr->multiple).boolValue ()
         && with_auto.operator_isEqual (ptr->with_auto).boolValue ()
         && def_val.operator_isEqual (ptr->def_val).boolValue ()
         && set.operator_isEqual (ptr->set).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_uint32_type::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@uint32_type:"
           << loc.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << desc.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << multiple.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << with_auto.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << def_val.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << set.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uint32_type::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uint32_type::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uint32_type (& typeid (cPtr_uint32_type), & typeid (cPtr_imp_sca_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_uint32_type::galgasRTTI (void) const {
  return & gClassInfoFor__uint32_type ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_uint32_type::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_uint32_type (loc, desc, multiple, with_auto, def_val, set COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_uint32_type'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint32_type::
GGS_uint32_type (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uint32_type::
GGS_uint32_type (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uint32_type GGS_uint32_type::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uint32_type result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uint32_type *> (inPointer) != NULL)
      : (typeid (cPtr_uint32_type) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uint32_type (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uint32_type),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint32_type GGS_uint32_type::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_bool& argument_2,
                 const GGS_bool& argument_3,
                 const GGS_uint32_class & argument_4,
                 const GGS_uint32_set & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_uint32_type result ;
  macroMyNew (result.mPointer, cPtr_uint32_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint32_class  GGS_uint32_type::
reader_def_val (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint32_class   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint32_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_uint32_type *) mPointer)->def_val ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint32_set  GGS_uint32_type::
reader_set (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint32_set   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint32_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_uint32_type *) mPointer)->set ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uint32_type::actualTypeName (void) const {
  return "uint32_type" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__uint32_type ("uint32_type", gClassInfoFor__imp_sca_type) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_sint32_type'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sint32_type::
cPtr_sint32_type (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_bool& argument_3,
                                const GGS_sint32_class & argument_4,
                                const GGS_sint32_set & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_imp_sca_type (argument_0, argument_1, argument_2, argument_3 COMMA_THERE),
def_val (argument_4),
set (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sint32_type * GGS_sint32_type::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint32_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_sint32_type *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sint32_type::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sint32_type * ptr = dynamic_cast <const cPtr_sint32_type *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && desc.operator_isEqual (ptr->desc).boolValue ()
         && multiple.operator_isEqual (ptr->multiple).boolValue ()
         && with_auto.operator_isEqual (ptr->with_auto).boolValue ()
         && def_val.operator_isEqual (ptr->def_val).boolValue ()
         && set.operator_isEqual (ptr->set).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sint32_type::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@sint32_type:"
           << loc.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << desc.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << multiple.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << with_auto.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << def_val.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << set.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sint32_type::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sint32_type::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sint32_type (& typeid (cPtr_sint32_type), & typeid (cPtr_imp_sca_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_sint32_type::galgasRTTI (void) const {
  return & gClassInfoFor__sint32_type ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sint32_type::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sint32_type (loc, desc, multiple, with_auto, def_val, set COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_sint32_type'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sint32_type::
GGS_sint32_type (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sint32_type::
GGS_sint32_type (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sint32_type GGS_sint32_type::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sint32_type result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sint32_type *> (inPointer) != NULL)
      : (typeid (cPtr_sint32_type) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sint32_type (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sint32_type),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint32_type GGS_sint32_type::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_bool& argument_2,
                 const GGS_bool& argument_3,
                 const GGS_sint32_class & argument_4,
                 const GGS_sint32_set & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_sint32_type result ;
  macroMyNew (result.mPointer, cPtr_sint32_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint32_class  GGS_sint32_type::
reader_def_val (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sint32_class   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint32_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sint32_type *) mPointer)->def_val ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint32_set  GGS_sint32_type::
reader_set (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sint32_set   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint32_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sint32_type *) mPointer)->set ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sint32_type::actualTypeName (void) const {
  return "sint32_type" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__sint32_type ("sint32_type", gClassInfoFor__imp_sca_type) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_uint64_type'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint64_type::
cPtr_uint64_type (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_bool& argument_3,
                                const GGS_uint64_class & argument_4,
                                const GGS_uint64_set & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_imp_sca_type (argument_0, argument_1, argument_2, argument_3 COMMA_THERE),
def_val (argument_4),
set (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint64_type * GGS_uint64_type::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint64_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_uint64_type *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uint64_type::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_uint64_type * ptr = dynamic_cast <const cPtr_uint64_type *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && desc.operator_isEqual (ptr->desc).boolValue ()
         && multiple.operator_isEqual (ptr->multiple).boolValue ()
         && with_auto.operator_isEqual (ptr->with_auto).boolValue ()
         && def_val.operator_isEqual (ptr->def_val).boolValue ()
         && set.operator_isEqual (ptr->set).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_uint64_type::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@uint64_type:"
           << loc.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << desc.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << multiple.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << with_auto.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << def_val.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << set.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uint64_type::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uint64_type::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uint64_type (& typeid (cPtr_uint64_type), & typeid (cPtr_imp_sca_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_uint64_type::galgasRTTI (void) const {
  return & gClassInfoFor__uint64_type ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_uint64_type::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_uint64_type (loc, desc, multiple, with_auto, def_val, set COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_uint64_type'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint64_type::
GGS_uint64_type (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uint64_type::
GGS_uint64_type (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uint64_type GGS_uint64_type::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uint64_type result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uint64_type *> (inPointer) != NULL)
      : (typeid (cPtr_uint64_type) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uint64_type (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uint64_type),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64_type GGS_uint64_type::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_bool& argument_2,
                 const GGS_bool& argument_3,
                 const GGS_uint64_class & argument_4,
                 const GGS_uint64_set & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_uint64_type result ;
  macroMyNew (result.mPointer, cPtr_uint64_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64_class  GGS_uint64_type::
reader_def_val (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint64_class   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint64_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_uint64_type *) mPointer)->def_val ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64_set  GGS_uint64_type::
reader_set (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint64_set   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint64_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_uint64_type *) mPointer)->set ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uint64_type::actualTypeName (void) const {
  return "uint64_type" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__uint64_type ("uint64_type", gClassInfoFor__imp_sca_type) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_sint64_type'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sint64_type::
cPtr_sint64_type (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_bool& argument_3,
                                const GGS_sint64_class & argument_4,
                                const GGS_sint64_set & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_imp_sca_type (argument_0, argument_1, argument_2, argument_3 COMMA_THERE),
def_val (argument_4),
set (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sint64_type * GGS_sint64_type::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint64_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_sint64_type *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sint64_type::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sint64_type * ptr = dynamic_cast <const cPtr_sint64_type *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && desc.operator_isEqual (ptr->desc).boolValue ()
         && multiple.operator_isEqual (ptr->multiple).boolValue ()
         && with_auto.operator_isEqual (ptr->with_auto).boolValue ()
         && def_val.operator_isEqual (ptr->def_val).boolValue ()
         && set.operator_isEqual (ptr->set).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sint64_type::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@sint64_type:"
           << loc.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << desc.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << multiple.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << with_auto.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << def_val.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << set.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sint64_type::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sint64_type::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sint64_type (& typeid (cPtr_sint64_type), & typeid (cPtr_imp_sca_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_sint64_type::galgasRTTI (void) const {
  return & gClassInfoFor__sint64_type ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sint64_type::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sint64_type (loc, desc, multiple, with_auto, def_val, set COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_sint64_type'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sint64_type::
GGS_sint64_type (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sint64_type::
GGS_sint64_type (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sint64_type GGS_sint64_type::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sint64_type result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sint64_type *> (inPointer) != NULL)
      : (typeid (cPtr_sint64_type) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sint64_type (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sint64_type),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64_type GGS_sint64_type::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_bool& argument_2,
                 const GGS_bool& argument_3,
                 const GGS_sint64_class & argument_4,
                 const GGS_sint64_set & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_sint64_type result ;
  macroMyNew (result.mPointer, cPtr_sint64_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64_class  GGS_sint64_type::
reader_def_val (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sint64_class   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint64_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sint64_type *) mPointer)->def_val ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64_set  GGS_sint64_type::
reader_set (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sint64_set   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint64_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sint64_type *) mPointer)->set ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sint64_type::actualTypeName (void) const {
  return "sint64_type" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__sint64_type ("sint64_type", gClassInfoFor__imp_sca_type) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_ident_map'                             *
//                                                                           *
//---------------------------------------------------------------------------*

e_ident_map::e_ident_map (void) :
value () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map '@ident_map'                           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_ident_map::
elementOf_GGS_ident_map (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_ident_map & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ident_map::
appendForMapDescription (C_Compiler & inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.value.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_ident_map::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_ident_map * ptr = dynamic_cast <const elementOf_GGS_ident_map *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.value.operator_isEqual (ptr->mInfo.value)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_ident_map::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_ident_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_ident_map * info = (e_ident_map *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_ident_map::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_ident_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_ident_map * info = (e_ident_map *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_ident_map GGS_ident_map::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_ident_map result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ident_map::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_ident_map info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ident_map::
operator_isEqual (const GGS_ident_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ident_map::
operator_isNotEqual (const GGS_ident_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_ident_map::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_ident_map::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_basic_type & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_ident_map info  ;
    info.value = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ident_map::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_basic_type   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.value ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_ident_map::kSearchMessage_get [] = {
  TO_UNICODE ('I'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_ident_map::
method_get (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_basic_type   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_get,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_ident_map::kInsertMessage_put [] = {
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('u'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_ident_map::
modifier_put (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_basic_type & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_put,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_ident_map GGS_ident_map::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_ident_map & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_ident_map result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ident_map GGS_ident_map::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ident_map result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ident_map::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @ident_map " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_basic_type  & GGS_ident_map::cEnumerator::_value (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.value ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_string_map'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_string_map::e_string_map (void) :
value () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@string_map'                           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_string_map::
elementOf_GGS_string_map (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_string_map & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_string_map::
appendForMapDescription (C_Compiler & inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.value.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_string_map::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_string_map * ptr = dynamic_cast <const elementOf_GGS_string_map *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.value.operator_isEqual (ptr->mInfo.value)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_string_map::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_string_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_string_map * info = (e_string_map *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_string_map::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_string_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_string_map * info = (e_string_map *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_string_map GGS_string_map::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_string_map result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_string_map::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_string_map info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_string_map::
operator_isEqual (const GGS_string_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_string_map::
operator_isNotEqual (const GGS_string_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_string_map::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_string_map::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_string& inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_string_map info  ;
    info.value = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_string_map::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_string  & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.value ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_string_map::kSearchMessage_get [] = {
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('g'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE (' '),
  TO_UNICODE ('k'),
  TO_UNICODE ('e'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_string_map::
method_get (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_string  & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_get,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_string_map::kInsertMessage_put [] = {
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('u'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_string_map::
modifier_put (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_string& inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_put,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_string_map GGS_string_map::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_string_map & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_string_map result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string_map GGS_string_map::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string_map result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_string_map::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @string_map " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_string_map::cEnumerator::_value (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.value ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_prefix_map'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_prefix_map::e_prefix_map (void) :
prefix (),
tag_to_rep () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@prefix_map'                           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_prefix_map::
elementOf_GGS_prefix_map (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_prefix_map & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_prefix_map::
appendForMapDescription (C_Compiler & inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.prefix.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.tag_to_rep.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_prefix_map::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_prefix_map * ptr = dynamic_cast <const elementOf_GGS_prefix_map *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.prefix.operator_isEqual (ptr->mInfo.prefix)).boolValue ()
           && (mInfo.tag_to_rep.operator_isEqual (ptr->mInfo.tag_to_rep)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_prefix_map::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_prefix_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_prefix_map * info = (e_prefix_map *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_prefix_map::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_prefix_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_prefix_map * info = (e_prefix_map *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_prefix_map GGS_prefix_map::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_prefix_map result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_prefix_map::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_prefix_map info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_prefix_map::
operator_isEqual (const GGS_prefix_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_prefix_map::
operator_isNotEqual (const GGS_prefix_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_prefix_map::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_prefix_map::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_string& inParameter0,
                const GGS_string& inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_prefix_map info  ;
    info.prefix = inParameter0 ;
    info.tag_to_rep = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_prefix_map::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_string  & outParameter0,
               GGS_string  & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.prefix ;
    outParameter1 = node->mInfo.tag_to_rep ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_prefix_map::kSearchMessage_prefix [] = {
  TO_UNICODE ('p'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('x'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_prefix_map::
method_prefix (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_string  & outParameter0,
                                GGS_string  & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_prefix,
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_prefix_map::kInsertMessage_add [] = {
  TO_UNICODE ('p'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('x'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('u'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_prefix_map::kInsertMessage_insert_prefix [] = {
  TO_UNICODE ('p'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('x'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('u'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_prefix_map::
modifier_add (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_string& inParameter0,
                                const GGS_string& inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_add,
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_prefix_map::
modifier_insert_prefix (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_string& inParameter0,
                                const GGS_string& inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insert_prefix,
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_prefix_map GGS_prefix_map::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_prefix_map & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_prefix_map result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_prefix_map GGS_prefix_map::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_prefix_map result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_prefix_map::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @prefix_map " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_prefix_map::cEnumerator::_prefix (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.prefix ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_prefix_map::cEnumerator::_tag_to_rep (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.tag_to_rep ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_stringset_map'                           *
//                                                                           *
//---------------------------------------------------------------------------*

e_stringset_map::e_stringset_map (void) :
ids () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map '@stringset_map'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_stringset_map::
elementOf_GGS_stringset_map (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_stringset_map & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_stringset_map::
appendForMapDescription (C_Compiler & inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.ids.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_stringset_map::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_stringset_map * ptr = dynamic_cast <const elementOf_GGS_stringset_map *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.ids.operator_isEqual (ptr->mInfo.ids)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_stringset_map::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_stringset_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_stringset_map * info = (e_stringset_map *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_stringset_map::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_stringset_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_stringset_map * info = (e_stringset_map *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_stringset_map GGS_stringset_map::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_stringset_map result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_stringset_map::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_stringset_map info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_stringset_map::
operator_isEqual (const GGS_stringset_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_stringset_map::
operator_isNotEqual (const GGS_stringset_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_stringset_map::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_stringset_map::
removeElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_stringset & outParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  AC_galgas_map_element * removedElement = NULL ;
  sint32 elementID = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    removedElement = internalRemove (inKey) ;
    if (removedElement == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
      outParameter0.drop () ;
    }else{
      cElement * ptr = (cElement *) removedElement ;
      elementID = ptr->mID ;
      outParameter0 = ptr->mInfo.ids ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
  macroMyDelete (removedElement, cElement) ;
}

//---------------------------------------------------------------------------*

void GGS_stringset_map::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_stringset & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_stringset_map info  ;
    info.ids = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_stringset_map::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_stringset   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.ids ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_stringset_map::kSearchMessage_get [] = {
  TO_UNICODE ('K'),
  TO_UNICODE ('e'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_stringset_map::
method_get (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_stringset   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_get,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_stringset_map::kRemoveMessage_delete [] = {
  TO_UNICODE ('K'),
  TO_UNICODE ('e'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_stringset_map::
modifier_delete (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_stringset & outParameter0 COMMA_LOCATION_ARGS) {
  removeElement (inLexique,
                  kRemoveMessage_delete,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_stringset_map::kInsertMessage_add [] = {
  TO_UNICODE ('K'),
  TO_UNICODE ('e'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('u'),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_stringset_map::
modifier_add (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_stringset & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_add,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_stringset_map GGS_stringset_map::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_stringset_map & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_stringset_map result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset_map GGS_stringset_map::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_stringset_map result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_stringset_map::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @stringset_map " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_stringset  & GGS_stringset_map::cEnumerator::_ids (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.ids ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Element of list '@ident_list'                        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_ident_list::
elementOf_GGS_ident_list (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
obj_name (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_ident_list::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_ident_list * ptr = dynamic_cast <const elementOf_GGS_ident_list *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = obj_name.operator_isEqual (ptr->obj_name).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ident_list::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << obj_name.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            List '@ident_list'                             *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_ident_list::
_internalAppendValues (const GGS_lstring & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ident_list::
_internalPrependValues (const GGS_lstring & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ident_list::
_addAssign_operation (const GGS_lstring & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_ident_list GGS_ident_list::
operator_concat (const GGS_ident_list & inOperand) const {
  GGS_ident_list result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ident_list::
dotAssign_operation (const GGS_ident_list inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_ident_list * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->obj_name ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ident_list::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ident_list::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->obj_name
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ident_list  GGS_ident_list::
constructor_emptyList (void) {
  GGS_ident_list result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ident_list  GGS_ident_list::
constructor_listWithValue (const GGS_lstring & argument_0) {
  GGS_ident_list result ;
  result.alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ident_list::
internalSubListWithRange (GGS_ident_list & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList._addAssign_operation (ptr->obj_name) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ident_list GGS_ident_list::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_ident_list result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ident_list GGS_ident_list::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_ident_list result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ident_list::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (inLexique, "@ident_list", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_ident_list::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->obj_name ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ident_list::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->obj_name ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ident_list::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->obj_name ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ident_list::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->obj_name ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_ident_list::
reader_obj_nameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->obj_name ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ident_list::
modifier_setObj_nameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->obj_name = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_ident_list::cEnumerator::_obj_name (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->obj_name ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_ident_list_map'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_ident_list_map::e_ident_list_map (void) :
objs () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@ident_list_map'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_ident_list_map::
elementOf_GGS_ident_list_map (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_ident_list_map & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ident_list_map::
appendForMapDescription (C_Compiler & inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.objs.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_ident_list_map::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_ident_list_map * ptr = dynamic_cast <const elementOf_GGS_ident_list_map *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.objs.operator_isEqual (ptr->mInfo.objs)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_ident_list_map::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_ident_list_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_ident_list_map * info = (e_ident_list_map *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_ident_list_map::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_ident_list_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_ident_list_map * info = (e_ident_list_map *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_ident_list_map GGS_ident_list_map::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_ident_list_map result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ident_list_map::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_ident_list_map info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ident_list_map::
operator_isEqual (const GGS_ident_list_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ident_list_map::
operator_isNotEqual (const GGS_ident_list_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_ident_list_map::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_ident_list_map::
removeElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_ident_list & outParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  AC_galgas_map_element * removedElement = NULL ;
  sint32 elementID = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    removedElement = internalRemove (inKey) ;
    if (removedElement == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
      outParameter0.drop () ;
    }else{
      cElement * ptr = (cElement *) removedElement ;
      elementID = ptr->mID ;
      outParameter0 = ptr->mInfo.objs ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
  macroMyDelete (removedElement, cElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ident_list_map::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_ident_list & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_ident_list_map info  ;
    info.objs = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ident_list_map::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_ident_list   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.objs ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_ident_list_map::kSearchMessage_get [] = {
  TO_UNICODE ('K'),
  TO_UNICODE ('e'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_ident_list_map::
method_get (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_ident_list   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_get,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_ident_list_map::kRemoveMessage_delete [] = {
  TO_UNICODE ('K'),
  TO_UNICODE ('e'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_ident_list_map::
modifier_delete (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_ident_list & outParameter0 COMMA_LOCATION_ARGS) {
  removeElement (inLexique,
                  kRemoveMessage_delete,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_ident_list_map::kInsertMessage_add [] = {
  TO_UNICODE ('K'),
  TO_UNICODE ('e'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('u'),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_ident_list_map::
modifier_add (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_ident_list & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_add,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_ident_list_map GGS_ident_list_map::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_ident_list_map & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_ident_list_map result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ident_list_map GGS_ident_list_map::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ident_list_map result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ident_list_map::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @ident_list_map " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_ident_list  & GGS_ident_list_map::cEnumerator::_objs (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.objs ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'cPtr_oil_obj'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_oil_obj::
cPtr_oil_obj (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
desc (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_oil_obj * GGS_oil_obj::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_oil_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_oil_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_oil_obj::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@oil_obj:"
           << desc.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_oil_obj::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_oil_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_oil_obj (& typeid (cPtr_oil_obj), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_oil_obj::galgasRTTI (void) const {
  return & gClassInfoFor__oil_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        GALGAS class 'GGS_oil_obj'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_oil_obj::
GGS_oil_obj (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_oil_obj::
GGS_oil_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_oil_obj GGS_oil_obj::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_oil_obj result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_oil_obj *> (inPointer) != NULL)
      : (typeid (cPtr_oil_obj) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_oil_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_oil_obj),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_oil_obj::
reader_desc (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_oil_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_oil_obj *) mPointer)->desc ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_oil_obj::actualTypeName (void) const {
  return "oil_obj" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_oil_obj::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__oil_obj ("oil_obj") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_autostart_obj'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_autostart_obj::
cPtr_autostart_obj (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
location (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_autostart_obj * GGS_autostart_obj::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_autostart_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_autostart_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_autostart_obj::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@autostart_obj:"
           << location.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_autostart_obj::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_autostart_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_autostart_obj (& typeid (cPtr_autostart_obj), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_autostart_obj::galgasRTTI (void) const {
  return & gClassInfoFor__autostart_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_autostart_obj'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_autostart_obj::
GGS_autostart_obj (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_autostart_obj::
GGS_autostart_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_autostart_obj GGS_autostart_obj::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_autostart_obj result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_autostart_obj *> (inPointer) != NULL)
      : (typeid (cPtr_autostart_obj) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_autostart_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_autostart_obj),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_autostart_obj::
reader_location (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_autostart_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_autostart_obj *) mPointer)->location ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_autostart_obj::actualTypeName (void) const {
  return "autostart_obj" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_autostart_obj::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__autostart_obj ("autostart_obj") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_autostart_void'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_autostart_void::
cPtr_autostart_void (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_autostart_obj (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_autostart_void * GGS_autostart_void::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_autostart_void *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_autostart_void *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_autostart_void::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_autostart_void * ptr = dynamic_cast <const cPtr_autostart_void *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_autostart_void::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@autostart_void:"
           << location.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_autostart_void::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_autostart_void::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_autostart_void (& typeid (cPtr_autostart_void), & typeid (cPtr_autostart_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_autostart_void::galgasRTTI (void) const {
  return & gClassInfoFor__autostart_void ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_autostart_void::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_autostart_void (location COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_autostart_void'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_autostart_void::
GGS_autostart_void (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_autostart_void::
GGS_autostart_void (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_autostart_void GGS_autostart_void::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_autostart_void result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_autostart_void *> (inPointer) != NULL)
      : (typeid (cPtr_autostart_void) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_autostart_void (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_autostart_void),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_autostart_void GGS_autostart_void::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_autostart_void result ;
  macroMyNew (result.mPointer, cPtr_autostart_void (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_autostart_void::actualTypeName (void) const {
  return "autostart_void" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__autostart_void ("autostart_void", gClassInfoFor__autostart_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_autostart_false'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_autostart_false::
cPtr_autostart_false (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_autostart_obj (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_autostart_false * GGS_autostart_false::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_autostart_false *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_autostart_false *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_autostart_false::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_autostart_false * ptr = dynamic_cast <const cPtr_autostart_false *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_autostart_false::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@autostart_false:"
           << location.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_autostart_false::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_autostart_false::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_autostart_false (& typeid (cPtr_autostart_false), & typeid (cPtr_autostart_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_autostart_false::galgasRTTI (void) const {
  return & gClassInfoFor__autostart_false ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_autostart_false::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_autostart_false (location COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_autostart_false'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_autostart_false::
GGS_autostart_false (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_autostart_false::
GGS_autostart_false (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_autostart_false GGS_autostart_false::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_autostart_false result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_autostart_false *> (inPointer) != NULL)
      : (typeid (cPtr_autostart_false) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_autostart_false (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_autostart_false),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_autostart_false GGS_autostart_false::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_autostart_false result ;
  macroMyNew (result.mPointer, cPtr_autostart_false (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_autostart_false::actualTypeName (void) const {
  return "autostart_false" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__autostart_false ("autostart_false", gClassInfoFor__autostart_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Implementation of function "empty_lstring"                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lstring  function_empty_lstring (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_empty_lstring at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_lstring  var_cas_ls ;
  var_cas_ls = GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_empty_lstring\n") ;
  #endif
  return var_cas_ls ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Implementation of function "void_class"                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_basic_type  function_void_class (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_void_class at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_basic_type  var_cas_v ;
  var_cas_v = GGS_void ::constructor_new (inLexique, GGS_location (inLexique) COMMA_HERE) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_void_class\n") ;
  #endif
  return var_cas_v ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Implementation of routine "set_uint32"                   *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_set_uint32 (C_Compiler & inLexique,
                                GGS_basic_type  & var_cas_t,
                                GGS_luint64   var_cas_i,
                                GGS_string  var_cas_att COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_set_uint32 at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  { const GGS_basic_type _var_6553 = var_cas_t ; // CAST instruction
    if (_var_6553.getPtr () != NULL) {
      macroValidPointer (_var_6553.getPtr ()) ;
      if (typeid (cPtr_void) == typeid (* (_var_6553.getPtr ()))) {
        var_cas_t = GGS_uint32_class ::constructor_new (inLexique, var_cas_i.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (268)), var_cas_i.reader_uint64 (inLexique COMMA_SOURCE_FILE_AT_LINE (268)).reader_uint (inLexique COMMA_SOURCE_FILE_AT_LINE (268)) COMMA_HERE) ;
      }else{
        var_cas_i.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (GGS_string ("Redefinition of ")).operator_concat (var_cas_att) COMMA_SOURCE_FILE_AT_LINE (271)) ;
        var_cas_t.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (271)).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("was defined here") COMMA_SOURCE_FILE_AT_LINE (272)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_set_uint32\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Implementation of routine "set_uint64"                   *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_set_uint64 (C_Compiler & inLexique,
                                GGS_basic_type  & var_cas_t,
                                GGS_luint64   var_cas_i,
                                GGS_string  var_cas_att COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_set_uint64 at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  { const GGS_basic_type _var_7155 = var_cas_t ; // CAST instruction
    if (_var_7155.getPtr () != NULL) {
      macroValidPointer (_var_7155.getPtr ()) ;
      if (typeid (cPtr_void) == typeid (* (_var_7155.getPtr ()))) {
        var_cas_t = GGS_uint64_class ::constructor_new (inLexique, var_cas_i.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (292)), var_cas_i.reader_uint64 (inLexique COMMA_SOURCE_FILE_AT_LINE (292)) COMMA_HERE) ;
      }else{
        var_cas_i.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (GGS_string ("Redefinition of ")).operator_concat (var_cas_att) COMMA_SOURCE_FILE_AT_LINE (295)) ;
        var_cas_t.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (295)).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("was defined here") COMMA_SOURCE_FILE_AT_LINE (296)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_set_uint64\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Implementation of routine "set_lstring"                   *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_set_lstring (C_Compiler & inLexique,
                                GGS_basic_type  & var_cas_t,
                                const GGS_lstring   var_cas_s,
                                const GGS_string  var_cas_att COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_set_lstring at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  { const GGS_basic_type _var_7766 = var_cas_t ; // CAST instruction
    if (_var_7766.getPtr () != NULL) {
      macroValidPointer (_var_7766.getPtr ()) ;
      if (typeid (cPtr_void) == typeid (* (_var_7766.getPtr ()))) {
        var_cas_t = GGS_string_class ::constructor_new (inLexique, var_cas_s.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (316)), var_cas_s.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (316)) COMMA_HERE) ;
      }else{
        var_cas_s.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (GGS_string ("Redefinition of ")).operator_concat (var_cas_att) COMMA_SOURCE_FILE_AT_LINE (319)) ;
        var_cas_t.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (319)).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("was defined here") COMMA_SOURCE_FILE_AT_LINE (320)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_set_lstring\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Implementation of routine "set_bool"                    *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_set_bool (C_Compiler & inLexique,
                                GGS_basic_type  & var_cas_t,
                                GGS_lbool   var_cas_b,
                                GGS_string  var_cas_att COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_set_bool at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  { const GGS_basic_type _var_8357 = var_cas_t ; // CAST instruction
    if (_var_8357.getPtr () != NULL) {
      macroValidPointer (_var_8357.getPtr ()) ;
      if (typeid (cPtr_bool_class) == typeid (* (_var_8357.getPtr ()))) {
        var_cas_b.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (GGS_string ("Redefinition of ")).operator_concat (var_cas_att) COMMA_SOURCE_FILE_AT_LINE (341)) ;
        var_cas_t.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (341)).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("was defined here") COMMA_SOURCE_FILE_AT_LINE (342)) ;
      }else{
        var_cas_t = GGS_bool_class ::constructor_new (inLexique, var_cas_b.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (343)), var_cas_b.reader_bool (inLexique COMMA_SOURCE_FILE_AT_LINE (343)) COMMA_HERE) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_set_bool\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Implementation of function "get_bool"                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bool function_get_bool (C_Compiler & inLexique,
                                const GGS_basic_type   var_cas_t,
                                const GGS_bool  var_cas_def COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_get_bool at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_bool var_cas_b ;
  { const GGS_basic_type _var_8544 = var_cas_t ; // CAST instruction
    if (_var_8544.getPtr () != NULL) {
      macroValidPointer (_var_8544.getPtr ()) ;
      if (typeid (cPtr_bool_class) == typeid (* (_var_8544.getPtr ()))) {
        const GGS_bool_class var_cas_bc (_var_8544.getPtr ()) ;
        var_cas_b = var_cas_bc.reader_value (inLexique COMMA_SOURCE_FILE_AT_LINE (354)) ;
      }else{
        var_cas_b = var_cas_def ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_get_bool\n") ;
  #endif
  return var_cas_b ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Implementation of function "yes_no"                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string function_yes_no (C_Compiler &,
                                GGS_bool  var_cas_b COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_yes_no at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_string var_cas_res ;
  if ((var_cas_b).isBuiltAndTrue ()) {
    var_cas_res = GGS_string ("YES") ;
  }else{
    var_cas_res = GGS_string ("NO") ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_yes_no\n") ;
  #endif
  return var_cas_res ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Implementation of function "bool_define"                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string function_bool_define (C_Compiler & inLexique,
                                GGS_string  var_cas_flag,
                                GGS_bool  var_cas_b COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_bool_define at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_string var_cas_res ;
  var_cas_res = ((((GGS_string ("#define    ")).operator_concat (var_cas_flag)).operator_concat (GGS_string ("    "))).operator_concat (function_yes_no (inLexique, var_cas_b COMMA_SOURCE_FILE_AT_LINE (369)))).operator_concat (GGS_string ("\n")) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_bool_define\n") ;
  #endif
  return var_cas_res ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of function "bool_class_define"               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string function_bool_class_define (C_Compiler & inLexique,
                                GGS_string  var_cas_flag,
                                GGS_basic_type   var_cas_t,
                                GGS_bool  var_cas_def COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_bool_class_define at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_string var_cas_res ;
  { const GGS_basic_type _var_9056 = var_cas_t ; // CAST instruction
    if (_var_9056.getPtr () != NULL) {
      macroValidPointer (_var_9056.getPtr ()) ;
      if (typeid (cPtr_bool_class) == typeid (* (_var_9056.getPtr ()))) {
        const GGS_bool_class var_cas_b (_var_9056.getPtr ()) ;
        var_cas_res = function_bool_define (inLexique, var_cas_flag, var_cas_b.reader_value (inLexique COMMA_SOURCE_FILE_AT_LINE (380)) COMMA_SOURCE_FILE_AT_LINE (380)) ;
      }else{
        var_cas_res = function_bool_define (inLexique, var_cas_flag, var_cas_def COMMA_SOURCE_FILE_AT_LINE (382)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_bool_class_define\n") ;
  #endif
  return var_cas_res ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Implementation of routine "bool_flag"                    *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_bool_flag (C_Compiler & inLexique,
                                GGS_string & var_cas_res,
                                GGS_basic_type   var_cas_b,
                                GGS_string  var_cas_flag COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_bool_flag at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  { const GGS_basic_type _var_9459 = var_cas_b ; // CAST instruction
    if (_var_9459.getPtr () != NULL) {
      macroValidPointer (_var_9459.getPtr ()) ;
      if (typeid (cPtr_void) == typeid (* (_var_9459.getPtr ()))) {
      }else if (typeid (cPtr_bool_class) == typeid (* (_var_9459.getPtr ()))) {
        const GGS_bool_class var_cas_bo (_var_9459.getPtr ()) ;
        if ((var_cas_bo.reader_value (inLexique COMMA_SOURCE_FILE_AT_LINE (395))).isBuiltAndTrue ()) {
          var_cas_res.appendCString ("#define ") ;
          var_cas_res.dotAssign_operation (var_cas_flag) ;
          var_cas_res.appendCString ("\n") ;
        }
      }else{
        var_cas_b.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (401)).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("Internal error, wrong datatype") COMMA_SOURCE_FILE_AT_LINE (402)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_bool_flag\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Implementation of routine "p_bt"                      *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_p_bt (C_Compiler & inLexique,
                                const GGS_basic_type   var_cas_bt COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_p_bt at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_string var_cas_res ;
  const GGS_basic_type  temp_9543 = var_cas_bt ;
  if (temp_9543.isBuilt ()) {
    temp_9543 (HERE)->method_string (inLexique, var_cas_res COMMA_SOURCE_FILE_AT_LINE (409)) ;
  }
  inLexique.printMessage ((((var_cas_bt.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (410)).reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (410))).operator_concat (GGS_string (": "))).operator_concat (var_cas_res)).operator_concat (GGS_string ("\n")) COMMA_SOURCE_FILE_AT_LINE (410)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_p_bt\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Implementation of function "luint64_value"                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_luint64  function_luint64_value (C_Compiler & inLexique,
                                const GGS_uint64_class   var_cas_c COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_luint64_value at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_luint64  var_cas_v ;
  var_cas_v = GGS_luint64 ::constructor_new (inLexique, var_cas_c.reader_value (inLexique COMMA_SOURCE_FILE_AT_LINE (417)), var_cas_c.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (417)) COMMA_HERE) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_luint64_value\n") ;
  #endif
  return var_cas_v ;
}

//---------------------------------------------------------------------------*

