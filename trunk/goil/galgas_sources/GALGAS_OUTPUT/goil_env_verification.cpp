//---------------------------------------------------------------------------*
//                                                                           *
//                     File 'goil_env_verification.cpp'                      *
//                        Generated by version 1.8.2                         *
//                       may 6th, 2009, at 16h16'46"                         *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != 463
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "goil_env_verification.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "goil_env_verification.ggs", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                Implementation of routine "getProjectName"                 *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_getProjectName (C_Compiler & _inLexique,
                                GGS_string & var_cas_directory COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_getProjectName at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_directory = GGS_string::constructor_stringWithSourceFilePath (_inLexique COMMA_HERE).reader_stringByDeletingPathExtension (_inLexique COMMA_SOURCE_FILE_AT_LINE (34)) ;
  if (((GGS_string (true, _inLexique.stringOptionValueFromKeys ("goil_options", "project_dir" COMMA_SOURCE_FILE_AT_LINE (35))))._operator_isNotEqual (GGS_string (true, ""))).isBuiltAndTrue ()) {
    var_cas_directory = GGS_string (true, _inLexique.stringOptionValueFromKeys ("goil_options", "project_dir" COMMA_SOURCE_FILE_AT_LINE (36))) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_getProjectName\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "getAbsoluteSourceFilePath"            *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_getAbsoluteSourceFilePath (C_Compiler & _inLexique,
                                const GGS_string  var_cas_fileName,
                                GGS_string & var_cas_absoluteFilePath COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_getAbsoluteSourceFilePath at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_string var_cas_sourceFilePath ;
  var_cas_sourceFilePath = GGS_string::constructor_stringWithSourceFilePath (_inLexique COMMA_HERE).reader_stringByDeletingLastPathComponent (_inLexique COMMA_SOURCE_FILE_AT_LINE (44)) ;
  if (((var_cas_sourceFilePath)._operator_isEqual (GGS_string (true, ""))).isBuiltAndTrue ()) {
    if (((GGS_string::constructor_stringWithSourceFilePath (_inLexique COMMA_HERE).reader_firstCharacterOrNul (_inLexique COMMA_SOURCE_FILE_AT_LINE (46)))._operator_isNotEqual (GGS_char (true, '/'))).isBuiltAndTrue ()) {
      var_cas_sourceFilePath = GGS_string (true, ".") ;
    }
  }
  var_cas_absoluteFilePath = var_cas_fileName.reader_absolutePathFromPath (_inLexique, var_cas_sourceFilePath COMMA_SOURCE_FILE_AT_LINE (50)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_getAbsoluteSourceFilePath\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Implementation of routine "checkFileExists"                 *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_checkFileExists (C_Compiler & _inLexique,
                                const GGS_lstring   var_cas_fileName COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_checkFileExists at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_string var_cas_absoluteFilePath ;
  ::routine_getAbsoluteSourceFilePath (_inLexique,  var_cas_fileName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (58)),  var_cas_absoluteFilePath COMMA_SOURCE_FILE_AT_LINE (58)) ;
  if (((var_cas_absoluteFilePath.reader_fileExists (_inLexique COMMA_SOURCE_FILE_AT_LINE (59)))._operator_not ()).isBuiltAndTrue ()) {
    var_cas_fileName.reader_location (_inLexique COMMA_SOURCE_FILE_AT_LINE (60)).reader_location (_inLexique COMMA_HERE).signalGGSSemanticWarning (_inLexique, ((GGS_string (true, "The file '"))._operator_concat (var_cas_absoluteFilePath))._operator_concat (GGS_string (true, "' does not exists!")) COMMA_SOURCE_FILE_AT_LINE (60)) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_checkFileExists\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of routine "checkFileDoesNotExists"             *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_checkFileDoesNotExists (C_Compiler & _inLexique,
                                const GGS_lstring   var_cas_fileName COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_checkFileDoesNotExists at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_string var_cas_absoluteFilePath ;
  ::routine_getAbsoluteSourceFilePath (_inLexique,  var_cas_fileName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (73)),  var_cas_absoluteFilePath COMMA_SOURCE_FILE_AT_LINE (73)) ;
  if ((var_cas_fileName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (74)).reader_directoryExists (_inLexique COMMA_SOURCE_FILE_AT_LINE (74))).isBuiltAndTrue ()) {
    var_cas_fileName.reader_location (_inLexique COMMA_SOURCE_FILE_AT_LINE (75)).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((GGS_string (true, "The file '"))._operator_concat (var_cas_absoluteFilePath))._operator_concat (GGS_string (true, "' already exists and is a directory. It will not be overwritten.")) COMMA_SOURCE_FILE_AT_LINE (78)) ;
  }else{
    GGS_string var_cas_projectDir ;
    ::routine_getProjectName (_inLexique,  var_cas_projectDir COMMA_SOURCE_FILE_AT_LINE (81)) ;
    var_cas_projectDir = var_cas_projectDir.reader_absolutePathFromPath (_inLexique, GGS_string::constructor_stringWithCurrentDirectory (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (82)) ;
    if (((var_cas_projectDir)._operator_isEqual (var_cas_absoluteFilePath)).isBuiltAndTrue ()) {
      var_cas_fileName.reader_location (_inLexique COMMA_SOURCE_FILE_AT_LINE (84)).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((GGS_string (true, "The file '"))._operator_concat (var_cas_absoluteFilePath))._operator_concat (GGS_string (true, "' is already the project directory. It will not be overwritten.")) COMMA_SOURCE_FILE_AT_LINE (85)) ;
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_checkFileDoesNotExists\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "checkTrampolinePath"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_checkTrampolinePath (C_Compiler & _inLexique,
                                const GGS_lstring   var_cas_path COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_checkTrampolinePath at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_string var_cas_absolutePath ;
  ::routine_getAbsoluteSourceFilePath (_inLexique,  var_cas_path.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (98)),  var_cas_absolutePath COMMA_SOURCE_FILE_AT_LINE (98)) ;
  GGS_string var_cas_osPath ;
  var_cas_osPath = (var_cas_absolutePath)._operator_concat (GGS_string (true, "/os")) ;
  if (((var_cas_osPath.reader_directoryExists (_inLexique COMMA_SOURCE_FILE_AT_LINE (101)))._operator_not ()).isBuiltAndTrue ()) {
    var_cas_path.reader_location (_inLexique COMMA_SOURCE_FILE_AT_LINE (102)).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, (((GGS_string (true, "The directory '"))._operator_concat (var_cas_absolutePath))._operator_concat (GGS_string (true, "' does not seem to be the Trampoline base path.")))._operator_concat (GGS_string (true, " I can't find the os/ subfolder.")) COMMA_SOURCE_FILE_AT_LINE (104)) ;
  }
  GGS_string var_cas_machinesPath ;
  var_cas_machinesPath = (var_cas_absolutePath)._operator_concat (GGS_string (true, "/machines")) ;
  if (((var_cas_machinesPath.reader_directoryExists (_inLexique COMMA_SOURCE_FILE_AT_LINE (107)))._operator_not ()).isBuiltAndTrue ()) {
    var_cas_path.reader_location (_inLexique COMMA_SOURCE_FILE_AT_LINE (108)).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, (((GGS_string (true, "The directory '"))._operator_concat (var_cas_absolutePath))._operator_concat (GGS_string (true, "' does not seem to be the Trampoline base path.")))._operator_concat (GGS_string (true, "I can't find the machines/ subfolder.")) COMMA_SOURCE_FILE_AT_LINE (110)) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_checkTrampolinePath\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Implementation of routine "check_target"                  *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_check_target (C_Compiler & _inLexique,
                                const GGS_string  var_cas_trampoline_path COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_check_target at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_string var_cas_machines_path ;
  ::routine_getAbsoluteSourceFilePath (_inLexique,  var_cas_trampoline_path,  var_cas_machines_path COMMA_SOURCE_FILE_AT_LINE (119)) ;
  var_cas_machines_path.appendCstring ("/machines") ;
  GGS_string var_cas_arch_path ;
  var_cas_arch_path = ((var_cas_machines_path)._operator_concat (GGS_string (true, "/")))._operator_concat (function_arch (_inLexique COMMA_SOURCE_FILE_AT_LINE (121))) ;
  GGS_string var_cas_chip_path ;
  var_cas_chip_path = ((var_cas_arch_path)._operator_concat (GGS_string (true, "/")))._operator_concat (function_chip (_inLexique COMMA_SOURCE_FILE_AT_LINE (122))) ;
  GGS_string var_cas_board_path ;
  var_cas_board_path = ((var_cas_chip_path)._operator_concat (GGS_string (true, "/")))._operator_concat (function_board (_inLexique COMMA_SOURCE_FILE_AT_LINE (123))) ;
  if (((var_cas_arch_path.reader_directoryExists (_inLexique COMMA_SOURCE_FILE_AT_LINE (124)))._operator_not ()).isBuiltAndTrue ()) {
    GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticWarning (_inLexique, ((GGS_string (true, "The directory '"))._operator_concat (var_cas_arch_path))._operator_concat (GGS_string (true, "' does not exist")) COMMA_SOURCE_FILE_AT_LINE (125)) ;
  }else if (((var_cas_chip_path.reader_directoryExists (_inLexique COMMA_SOURCE_FILE_AT_LINE (126)))._operator_not ()).isBuiltAndTrue ()) {
    GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticWarning (_inLexique, ((GGS_string (true, "The directory '"))._operator_concat (var_cas_chip_path))._operator_concat (GGS_string (true, "' does not exist")) COMMA_SOURCE_FILE_AT_LINE (127)) ;
  }else if (((var_cas_board_path.reader_directoryExists (_inLexique COMMA_SOURCE_FILE_AT_LINE (128)))._operator_not ()).isBuiltAndTrue ()) {
    GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticWarning (_inLexique, ((GGS_string (true, "The directory '"))._operator_concat (var_cas_board_path))._operator_concat (GGS_string (true, "' does not exist")) COMMA_SOURCE_FILE_AT_LINE (129)) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_check_target\n") ;
  #endif
}

//---------------------------------------------------------------------------*

