//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'goil_semantic_types.cpp'                       *
//                        Generated by version 1.8.2                         *
//                      april 27th, 2009, at 22h44'26"                       *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != 463
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "goil_semantic_types.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "goil_semantic_types.ggs", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'e_implementation_spec'                        *
//                                                                           *
//---------------------------------------------------------------------------*

e_implementation_spec::e_implementation_spec (void) :
type () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map '@implementation_spec'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_implementation_spec::
elementOf_GGS_implementation_spec (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_implementation_spec & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_implementation_spec::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.type.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_implementation_spec::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_implementation_spec * _p = dynamic_cast <const elementOf_GGS_implementation_spec *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.type._operator_isEqual (_p->mInfo.type)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_implementation_spec::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_implementation_spec *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_implementation_spec * info = (e_implementation_spec *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_implementation_spec::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_implementation_spec *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_implementation_spec * info = (e_implementation_spec *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_implementation_spec GGS_implementation_spec::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_implementation_spec result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_implementation_spec::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_implementation_spec info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_implementation_spec::
_operator_isEqual (const GGS_implementation_spec & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_implementation_spec::
_operator_isNotEqual (const GGS_implementation_spec & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_implementation_spec::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_implementation_spec::
_removeElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_imp_type & outParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  AC_galgas_map_element * removedElement = NULL ;
  sint32 elementID = - 1 ;
  if (_isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    bool unused ;
    _internalRemove (mSharedMapRoot->_mRoot, inKey, removedElement, unused) ;
    if (removedElement == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
      outParameter0._drop () ;
    }else{
      cElement * _p = (cElement *) removedElement ;
      elementID = _p->mID ;
      outParameter0 = _p->mInfo.type ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
  macroMyDelete (removedElement, cElement) ;
}

//---------------------------------------------------------------------------*

void GGS_implementation_spec::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_imp_type & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_implementation_spec info  ;
    info.type = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_implementation_spec::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_imp_type   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.type ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_implementation_spec::
modifier_setTypeForKey (C_Compiler & inLexique,
                        const GGS_imp_type & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setTypeForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.type = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_implementation_spec::
method_get (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_imp_type   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "%K does not exists",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_implementation_spec::
modifier_del (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_imp_type & outParameter0 COMMA_LOCATION_ARGS) {
  _removeElement (_inLexique,
                  "%K does not exists",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_implementation_spec::
modifier_put (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_imp_type & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "%K is duplicated in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_implementation_spec GGS_implementation_spec::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_implementation_spec & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_implementation_spec result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_implementation_spec GGS_implementation_spec::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_implementation_spec result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_implementation_spec::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @implementation_spec " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_imp_type  & GGS_implementation_spec::cEnumerator::_type (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.type ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_implementation'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_implementation::e_implementation (void) :
spec () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@implementation'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_implementation::
elementOf_GGS_implementation (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_implementation & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_implementation::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.spec.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_implementation::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_implementation * _p = dynamic_cast <const elementOf_GGS_implementation *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.spec._operator_isEqual (_p->mInfo.spec)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_implementation::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_implementation *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_implementation * info = (e_implementation *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_implementation::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_implementation *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_implementation * info = (e_implementation *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_implementation GGS_implementation::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_implementation result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_implementation::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_implementation info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_implementation::
_operator_isEqual (const GGS_implementation & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_implementation::
_operator_isNotEqual (const GGS_implementation & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_implementation::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_implementation::
_removeElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_implementation_spec & outParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  AC_galgas_map_element * removedElement = NULL ;
  sint32 elementID = - 1 ;
  if (_isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    bool unused ;
    _internalRemove (mSharedMapRoot->_mRoot, inKey, removedElement, unused) ;
    if (removedElement == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
      outParameter0._drop () ;
    }else{
      cElement * _p = (cElement *) removedElement ;
      elementID = _p->mID ;
      outParameter0 = _p->mInfo.spec ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
  macroMyDelete (removedElement, cElement) ;
}

//---------------------------------------------------------------------------*

void GGS_implementation::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_implementation_spec & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_implementation info  ;
    info.spec = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_implementation::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_implementation_spec   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.spec ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_implementation::
modifier_setSpecForKey (C_Compiler & inLexique,
                        const GGS_implementation_spec & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setSpecForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.spec = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_implementation::
method_get (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_implementation_spec   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "%K does not exists",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_implementation::
modifier_del (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_implementation_spec & outParameter0 COMMA_LOCATION_ARGS) {
  _removeElement (_inLexique,
                  "%K does not exists",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_implementation::
modifier_put (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_implementation_spec & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "%K is duplicated in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_implementation GGS_implementation::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_implementation & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_implementation result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_implementation GGS_implementation::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_implementation result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_implementation::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @implementation " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_implementation_spec  & GGS_implementation::cEnumerator::_spec (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.spec ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                             class 'e_os_imp'                              *
//                                                                           *
//---------------------------------------------------------------------------*

e_os_imp::e_os_imp (void) :
type () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class map '@os_imp'                             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_os_imp::
elementOf_GGS_os_imp (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_os_imp & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_os_imp::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.type.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_os_imp::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_os_imp * _p = dynamic_cast <const elementOf_GGS_os_imp *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.type._operator_isEqual (_p->mInfo.type)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_os_imp::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_os_imp *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_os_imp * info = (e_os_imp *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_os_imp::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_os_imp *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_os_imp * info = (e_os_imp *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_os_imp GGS_os_imp::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_os_imp result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_os_imp::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_os_imp info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_os_imp::
_operator_isEqual (const GGS_os_imp & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_os_imp::
_operator_isNotEqual (const GGS_os_imp & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_os_imp::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_os_imp::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lstring & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_os_imp info  ;
    info.type = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_imp::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.type ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_os_imp::
modifier_setTypeForKey (C_Compiler & inLexique,
                        const GGS_lstring & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setTypeForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.type = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_os_imp GGS_os_imp::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_os_imp & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_os_imp result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_os_imp GGS_os_imp::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_os_imp result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_os_imp::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @os_imp " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_os_imp::cEnumerator::_type (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.type ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_event_mask_obj'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_event_mask_obj::
cPtr_event_mask_obj (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
location (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_event_mask_obj * GGS_event_mask_obj::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_event_mask_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_event_mask_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_event_mask_obj::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@event_mask_obj:"
           << location.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_event_mask_obj::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_event_mask_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_event_mask_obj (& typeid (cPtr_event_mask_obj), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_event_mask_obj::galgasRTTI (void) const {
  return & gClassInfoFor__event_mask_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_event_mask_obj'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_event_mask_obj::
GGS_event_mask_obj (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_event_mask_obj::
GGS_event_mask_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_event_mask_obj GGS_event_mask_obj::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_event_mask_obj _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_event_mask_obj *> (inPointer) != NULL)
      : (typeid (cPtr_event_mask_obj) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_event_mask_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_event_mask_obj),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_event_mask_obj::
reader_location (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_event_mask_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_event_mask_obj *) mPointer)->location ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_event_mask_obj::actualTypeName (void) const {
  return "event_mask_obj" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_event_mask_obj::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__event_mask_obj ("event_mask_obj") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_event_mask_void_obj'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_event_mask_void_obj::
cPtr_event_mask_void_obj (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_event_mask_obj (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_event_mask_void_obj * GGS_event_mask_void_obj::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_event_mask_void_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_event_mask_void_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_event_mask_void_obj::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_event_mask_void_obj * _p = dynamic_cast <const cPtr_event_mask_void_obj *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = location._operator_isEqual (_p->location).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_event_mask_void_obj::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@event_mask_void_obj:"
           << location.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_event_mask_void_obj::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_event_mask_void_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_event_mask_void_obj (& typeid (cPtr_event_mask_void_obj), & typeid (cPtr_event_mask_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_event_mask_void_obj::galgasRTTI (void) const {
  return & gClassInfoFor__event_mask_void_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_event_mask_void_obj'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_event_mask_void_obj::
GGS_event_mask_void_obj (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_event_mask_void_obj::
GGS_event_mask_void_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_event_mask_void_obj GGS_event_mask_void_obj::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_event_mask_void_obj _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_event_mask_void_obj *> (inPointer) != NULL)
      : (typeid (cPtr_event_mask_void_obj) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_event_mask_void_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_event_mask_void_obj),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_event_mask_void_obj GGS_event_mask_void_obj::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_event_mask_void_obj result ;
  macroMyNew (result.mPointer, cPtr_event_mask_void_obj (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_event_mask_void_obj::actualTypeName (void) const {
  return "event_mask_void_obj" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__event_mask_void_obj ("event_mask_void_obj", gClassInfoFor__event_mask_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_event_mask_user_obj'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_event_mask_user_obj::
cPtr_event_mask_user_obj (const GGS_location & argument_0,
                                const GGS_luint64 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_event_mask_obj (argument_0 COMMA_THERE),
mask (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_event_mask_user_obj * GGS_event_mask_user_obj::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_event_mask_user_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_event_mask_user_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_event_mask_user_obj::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_event_mask_user_obj * _p = dynamic_cast <const cPtr_event_mask_user_obj *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = location._operator_isEqual (_p->location).boolValue ()
         && mask._operator_isEqual (_p->mask).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_event_mask_user_obj::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@event_mask_user_obj:"
           << location.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mask.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_event_mask_user_obj::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_event_mask_user_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_event_mask_user_obj (& typeid (cPtr_event_mask_user_obj), & typeid (cPtr_event_mask_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_event_mask_user_obj::galgasRTTI (void) const {
  return & gClassInfoFor__event_mask_user_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_event_mask_user_obj'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_event_mask_user_obj::
GGS_event_mask_user_obj (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_event_mask_user_obj::
GGS_event_mask_user_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_event_mask_user_obj GGS_event_mask_user_obj::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_event_mask_user_obj _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_event_mask_user_obj *> (inPointer) != NULL)
      : (typeid (cPtr_event_mask_user_obj) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_event_mask_user_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_event_mask_user_obj),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_event_mask_user_obj GGS_event_mask_user_obj::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint64 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_event_mask_user_obj result ;
  macroMyNew (result.mPointer, cPtr_event_mask_user_obj (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_event_mask_user_obj::
reader_mask (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_event_mask_user_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_event_mask_user_obj *) mPointer)->mask ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_event_mask_user_obj::actualTypeName (void) const {
  return "event_mask_user_obj" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__event_mask_user_obj ("event_mask_user_obj", gClassInfoFor__event_mask_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_event_mask_auto_obj'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_event_mask_auto_obj::
cPtr_event_mask_auto_obj (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_event_mask_obj (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_event_mask_auto_obj * GGS_event_mask_auto_obj::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_event_mask_auto_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_event_mask_auto_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_event_mask_auto_obj::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_event_mask_auto_obj * _p = dynamic_cast <const cPtr_event_mask_auto_obj *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = location._operator_isEqual (_p->location).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_event_mask_auto_obj::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@event_mask_auto_obj:"
           << location.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_event_mask_auto_obj::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_event_mask_auto_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_event_mask_auto_obj (& typeid (cPtr_event_mask_auto_obj), & typeid (cPtr_event_mask_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_event_mask_auto_obj::galgasRTTI (void) const {
  return & gClassInfoFor__event_mask_auto_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_event_mask_auto_obj'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_event_mask_auto_obj::
GGS_event_mask_auto_obj (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_event_mask_auto_obj::
GGS_event_mask_auto_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_event_mask_auto_obj GGS_event_mask_auto_obj::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_event_mask_auto_obj _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_event_mask_auto_obj *> (inPointer) != NULL)
      : (typeid (cPtr_event_mask_auto_obj) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_event_mask_auto_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_event_mask_auto_obj),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_event_mask_auto_obj GGS_event_mask_auto_obj::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_event_mask_auto_obj result ;
  macroMyNew (result.mPointer, cPtr_event_mask_auto_obj (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_event_mask_auto_obj::actualTypeName (void) const {
  return "event_mask_auto_obj" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__event_mask_auto_obj ("event_mask_auto_obj", gClassInfoFor__event_mask_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_event_obj'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_event_obj::
cPtr_event_obj (const GGS_lstring & argument_0,
                                const GGS_event_mask_obj & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_oil_obj (argument_0 COMMA_THERE),
mask (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_event_obj * GGS_event_obj::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_event_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_event_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_event_obj::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_event_obj * _p = dynamic_cast <const cPtr_event_obj *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = desc._operator_isEqual (_p->desc).boolValue ()
         && mask._operator_isEqual (_p->mask).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_event_obj::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@event_obj:"
           << desc.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mask.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_event_obj::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_event_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_event_obj (& typeid (cPtr_event_obj), & typeid (cPtr_oil_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_event_obj::galgasRTTI (void) const {
  return & gClassInfoFor__event_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_event_obj'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_event_obj::
GGS_event_obj (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_event_obj::
GGS_event_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_event_obj GGS_event_obj::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_event_obj _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_event_obj *> (inPointer) != NULL)
      : (typeid (cPtr_event_obj) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_event_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_event_obj),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_event_obj GGS_event_obj::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_event_mask_obj & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_event_obj result ;
  macroMyNew (result.mPointer, cPtr_event_obj (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_event_mask_obj  GGS_event_obj::
reader_mask (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_event_mask_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_event_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_event_obj *) mPointer)->mask ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_event_obj::actualTypeName (void) const {
  return "event_obj" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__event_obj ("event_obj", gClassInfoFor__oil_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_event_map'                             *
//                                                                           *
//---------------------------------------------------------------------------*

e_event_map::e_event_map (void) :
event () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map '@event_map'                           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_event_map::
elementOf_GGS_event_map (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_event_map & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_event_map::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.event.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_event_map::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_event_map * _p = dynamic_cast <const elementOf_GGS_event_map *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.event._operator_isEqual (_p->mInfo.event)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_event_map::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_event_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_event_map * info = (e_event_map *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_event_map::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_event_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_event_map * info = (e_event_map *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_event_map GGS_event_map::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_event_map result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_event_map::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_event_map info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_event_map::
_operator_isEqual (const GGS_event_map & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_event_map::
_operator_isNotEqual (const GGS_event_map & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_event_map::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_event_map::
_removeElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_event_obj & outParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  AC_galgas_map_element * removedElement = NULL ;
  sint32 elementID = - 1 ;
  if (_isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    bool unused ;
    _internalRemove (mSharedMapRoot->_mRoot, inKey, removedElement, unused) ;
    if (removedElement == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
      outParameter0._drop () ;
    }else{
      cElement * _p = (cElement *) removedElement ;
      elementID = _p->mID ;
      outParameter0 = _p->mInfo.event ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
  macroMyDelete (removedElement, cElement) ;
}

//---------------------------------------------------------------------------*

void GGS_event_map::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_event_obj & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_event_map info  ;
    info.event = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_event_map::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_event_obj   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.event ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_event_map::
modifier_setEventForKey (C_Compiler & inLexique,
                        const GGS_event_obj & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setEventForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.event = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_event_map::
method_get (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_event_obj   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "Event %K is not defined",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_event_map::
modifier_del (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_event_obj & outParameter0 COMMA_LOCATION_ARGS) {
  _removeElement (_inLexique,
                  "Event %K is not defined",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_event_map::
modifier_put (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_event_obj & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "Event %K is already defined in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_event_map GGS_event_map::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_event_map & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_event_map result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_event_map GGS_event_map::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_event_map result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_event_map::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @event_map " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_event_obj  & GGS_event_map::cEnumerator::_event (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.event ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'e_event_usage_map'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_event_usage_map::e_event_usage_map (void) :
count () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@event_usage_map'                        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_event_usage_map::
elementOf_GGS_event_usage_map (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_event_usage_map & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_event_usage_map::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.count.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_event_usage_map::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_event_usage_map * _p = dynamic_cast <const elementOf_GGS_event_usage_map *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.count._operator_isEqual (_p->mInfo.count)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_event_usage_map::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_event_usage_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_event_usage_map * info = (e_event_usage_map *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_event_usage_map::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_event_usage_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_event_usage_map * info = (e_event_usage_map *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_event_usage_map GGS_event_usage_map::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_event_usage_map result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_event_usage_map::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_event_usage_map info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_event_usage_map::
_operator_isEqual (const GGS_event_usage_map & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_event_usage_map::
_operator_isNotEqual (const GGS_event_usage_map & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_event_usage_map::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_event_usage_map::
_removeElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_uint & outParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  AC_galgas_map_element * removedElement = NULL ;
  sint32 elementID = - 1 ;
  if (_isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    bool unused ;
    _internalRemove (mSharedMapRoot->_mRoot, inKey, removedElement, unused) ;
    if (removedElement == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
      outParameter0._drop () ;
    }else{
      cElement * _p = (cElement *) removedElement ;
      elementID = _p->mID ;
      outParameter0 = _p->mInfo.count ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
  macroMyDelete (removedElement, cElement) ;
}

//---------------------------------------------------------------------------*

void GGS_event_usage_map::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_uint & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_event_usage_map info  ;
    info.count = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_event_usage_map::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.count ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_event_usage_map::
modifier_setCountForKey (C_Compiler & inLexique,
                        const GGS_uint & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setCountForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.count = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_event_usage_map::
method_get_count (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "Key %K is not there",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_event_usage_map::
modifier_delete (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint & outParameter0 COMMA_LOCATION_ARGS) {
  _removeElement (_inLexique,
                  "Key %K cannot be deleted",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_event_usage_map::
modifier_insert_count (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "Key %K is already there",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_event_usage_map GGS_event_usage_map::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_event_usage_map & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_event_usage_map result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_event_usage_map GGS_event_usage_map::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_event_usage_map result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_event_usage_map::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @event_usage_map " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_event_usage_map::cEnumerator::_count (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.count ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@sorted_events'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_sorted_events::
elementOf_GGS_sorted_events (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1):
event_name (argument_0),
count (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_sorted_events::
isEqualToObject (const cSortedListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_sorted_events * _p = dynamic_cast <const elementOf_GGS_sorted_events *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = event_name._operator_isEqual (_p->event_name).boolValue ()
         && count._operator_isEqual (_p->count).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

sint32 elementOf_GGS_sorted_events::
compareForSorting (const cSortedListElement * inOperand) const {
  elementOf_GGS_sorted_events * operand = (elementOf_GGS_sorted_events *) inOperand ;
  sint32 result = - count.compareForSortedList (operand->count) ;
  return result ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_sorted_events::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << event_name.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << count.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@sorted_events'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sorted_events::GGS_sorted_events (void): AC_galgas_sortedlist () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_sorted_events::
GGS_sorted_events (const GGS_sorted_events & inSource): AC_galgas_sortedlist (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_sorted_events::
_operator_isEqual (const GGS_sorted_events & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_sorted_events::
_operator_isNotEqual (const GGS_sorted_events & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_sorted_events::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_uint & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_sorted_events::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_sorted_events GGS_sorted_events::
_operator_concat (const GGS_sorted_events & inOperand) const {
  GGS_sorted_events result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_sorted_events::
_dotAssign_operation (const GGS_sorted_events inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      *this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_sorted_events * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->event_name ;
          GGS_uint  p_1 = p->count ;
          _internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_sorted_events::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->event_name,
                                _p->count) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_sorted_events  GGS_sorted_events::
constructor_emptySortedList (void) {
  GGS_sorted_events result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sorted_events  GGS_sorted_events::
constructor_sortedListWithValue (const GGS_lstring & argument_0,
                           const GGS_uint & argument_1) {
  GGS_sorted_events result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_sorted_events::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@sorted_events", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_sorted_events::
method_smallest (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_uint & _out_1
                 COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->event_name ;
    _out_1 = _p->count ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sorted_events::
method_greatest (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_uint & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'greatest' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->event_name ;
    _out_1 = _p->count ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sorted_events::
modifier_popSmallest (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_uint & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popSmallest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->event_name ;
    _out_1 = _p->count ;
    _insulateList () ;
    _internalRemoveSmallest () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sorted_events::
modifier_popGreatest (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_uint & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popGreatest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->event_name ;
    _out_1 = _p->count ;
    _insulateList () ;
    _internalRemoveGreatest () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_sorted_events::cEnumerator::_event_name (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->event_name ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_sorted_events::cEnumerator::_count (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->count ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_alarm_autostart_true'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_alarm_autostart_true::
cPtr_alarm_autostart_true (const GGS_location & argument_0,
                                const GGS_luint64 & argument_1,
                                const GGS_luint64 & argument_2,
                                const GGS_stringset & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_autostart_obj (argument_0 COMMA_THERE),
alarm_time (argument_1),
cycle_time (argument_2),
app_modes (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_alarm_autostart_true * GGS_alarm_autostart_true::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_alarm_autostart_true *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_alarm_autostart_true *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_alarm_autostart_true::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_alarm_autostart_true * _p = dynamic_cast <const cPtr_alarm_autostart_true *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = location._operator_isEqual (_p->location).boolValue ()
         && alarm_time._operator_isEqual (_p->alarm_time).boolValue ()
         && cycle_time._operator_isEqual (_p->cycle_time).boolValue ()
         && app_modes._operator_isEqual (_p->app_modes).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_alarm_autostart_true::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@alarm_autostart_true:"
           << location.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << alarm_time.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << cycle_time.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << app_modes.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_alarm_autostart_true::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_alarm_autostart_true::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_alarm_autostart_true (& typeid (cPtr_alarm_autostart_true), & typeid (cPtr_autostart_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_alarm_autostart_true::galgasRTTI (void) const {
  return & gClassInfoFor__alarm_autostart_true ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_alarm_autostart_true'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_alarm_autostart_true::
GGS_alarm_autostart_true (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_alarm_autostart_true::
GGS_alarm_autostart_true (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_alarm_autostart_true GGS_alarm_autostart_true::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_alarm_autostart_true _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_alarm_autostart_true *> (inPointer) != NULL)
      : (typeid (cPtr_alarm_autostart_true) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_alarm_autostart_true (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_alarm_autostart_true),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_alarm_autostart_true GGS_alarm_autostart_true::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint64 & argument_1,
                 const GGS_luint64 & argument_2,
                 const GGS_stringset & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_alarm_autostart_true result ;
  macroMyNew (result.mPointer, cPtr_alarm_autostart_true (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_alarm_autostart_true::
reader_alarm_time (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_alarm_autostart_true *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_alarm_autostart_true *) mPointer)->alarm_time ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_alarm_autostart_true::
reader_cycle_time (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_alarm_autostart_true *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_alarm_autostart_true *) mPointer)->cycle_time ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset  GGS_alarm_autostart_true::
reader_app_modes (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_stringset   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_alarm_autostart_true *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_alarm_autostart_true *) mPointer)->app_modes ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_alarm_autostart_true::actualTypeName (void) const {
  return "alarm_autostart_true" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__alarm_autostart_true ("alarm_autostart_true", gClassInfoFor__autostart_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_alarm_obj'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_alarm_obj::
cPtr_alarm_obj (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_action_obj & argument_2,
                                const GGS_autostart_obj & argument_3,
                                const GGS_lstringlist & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_oil_obj (argument_0 COMMA_THERE),
counter_name (argument_1),
action_params (argument_2),
autostart_params (argument_3),
acc_apps (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_alarm_obj * GGS_alarm_obj::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_alarm_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_alarm_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_alarm_obj::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_alarm_obj * _p = dynamic_cast <const cPtr_alarm_obj *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = desc._operator_isEqual (_p->desc).boolValue ()
         && counter_name._operator_isEqual (_p->counter_name).boolValue ()
         && action_params._operator_isEqual (_p->action_params).boolValue ()
         && autostart_params._operator_isEqual (_p->autostart_params).boolValue ()
         && acc_apps._operator_isEqual (_p->acc_apps).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_alarm_obj::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@alarm_obj:"
           << desc.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << counter_name.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << action_params.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << autostart_params.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << acc_apps.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_alarm_obj::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_alarm_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_alarm_obj (& typeid (cPtr_alarm_obj), & typeid (cPtr_oil_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_alarm_obj::galgasRTTI (void) const {
  return & gClassInfoFor__alarm_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_alarm_obj'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_alarm_obj::
GGS_alarm_obj (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_alarm_obj::
GGS_alarm_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_alarm_obj GGS_alarm_obj::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_alarm_obj _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_alarm_obj *> (inPointer) != NULL)
      : (typeid (cPtr_alarm_obj) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_alarm_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_alarm_obj),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_alarm_obj GGS_alarm_obj::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_action_obj & argument_2,
                 const GGS_autostart_obj & argument_3,
                 const GGS_lstringlist & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_alarm_obj result ;
  macroMyNew (result.mPointer, cPtr_alarm_obj (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_alarm_obj::
reader_counter_name (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_alarm_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_alarm_obj *) mPointer)->counter_name ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_action_obj  GGS_alarm_obj::
reader_action_params (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_action_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_alarm_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_alarm_obj *) mPointer)->action_params ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_autostart_obj  GGS_alarm_obj::
reader_autostart_params (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_autostart_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_alarm_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_alarm_obj *) mPointer)->autostart_params ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_alarm_obj::
reader_acc_apps (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_alarm_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_alarm_obj *) mPointer)->acc_apps ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_alarm_obj::actualTypeName (void) const {
  return "alarm_obj" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__alarm_obj ("alarm_obj", gClassInfoFor__oil_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_alarm_map'                             *
//                                                                           *
//---------------------------------------------------------------------------*

e_alarm_map::e_alarm_map (void) :
alarm () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map '@alarm_map'                           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_alarm_map::
elementOf_GGS_alarm_map (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_alarm_map & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_alarm_map::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.alarm.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_alarm_map::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_alarm_map * _p = dynamic_cast <const elementOf_GGS_alarm_map *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.alarm._operator_isEqual (_p->mInfo.alarm)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_alarm_map::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_alarm_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_alarm_map * info = (e_alarm_map *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_alarm_map::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_alarm_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_alarm_map * info = (e_alarm_map *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_alarm_map GGS_alarm_map::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_alarm_map result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_alarm_map::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_alarm_map info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_alarm_map::
_operator_isEqual (const GGS_alarm_map & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_alarm_map::
_operator_isNotEqual (const GGS_alarm_map & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_alarm_map::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_alarm_map::
_removeElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_alarm_obj & outParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  AC_galgas_map_element * removedElement = NULL ;
  sint32 elementID = - 1 ;
  if (_isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    bool unused ;
    _internalRemove (mSharedMapRoot->_mRoot, inKey, removedElement, unused) ;
    if (removedElement == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
      outParameter0._drop () ;
    }else{
      cElement * _p = (cElement *) removedElement ;
      elementID = _p->mID ;
      outParameter0 = _p->mInfo.alarm ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
  macroMyDelete (removedElement, cElement) ;
}

//---------------------------------------------------------------------------*

void GGS_alarm_map::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_alarm_obj & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_alarm_map info  ;
    info.alarm = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_alarm_map::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_alarm_obj   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.alarm ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_alarm_map::
modifier_setAlarmForKey (C_Compiler & inLexique,
                        const GGS_alarm_obj & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setAlarmForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.alarm = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_alarm_map::
method_get (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_alarm_obj   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "Alarm %K is not defined",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_alarm_map::
modifier_del (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_alarm_obj & outParameter0 COMMA_LOCATION_ARGS) {
  _removeElement (_inLexique,
                  "Alarm %K is not defined",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_alarm_map::
modifier_put (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_alarm_obj & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "Alarm %K is duplicated in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_alarm_map GGS_alarm_map::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_alarm_map & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_alarm_map result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_alarm_map GGS_alarm_map::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_alarm_map result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_alarm_map::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @alarm_map " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_alarm_obj  & GGS_alarm_map::cEnumerator::_alarm (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.alarm ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_base_mess'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_base_mess::
cPtr_base_mess (const GGS_lstring & argument_0,
                                const GGS_action_obj & argument_1,
                                const GGS_action_obj & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_ident_map & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_oil_obj (argument_0 COMMA_THERE),
notification (argument_1),
notificationerror (argument_2),
acc_apps (argument_3),
other_fields (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_base_mess * GGS_base_mess::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_base_mess *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_base_mess *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_base_mess::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@base_mess:"
           << desc.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << notification.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << notificationerror.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << acc_apps.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << other_fields.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_base_mess::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_base_mess::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_base_mess (& typeid (cPtr_base_mess), & typeid (cPtr_oil_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_base_mess::galgasRTTI (void) const {
  return & gClassInfoFor__base_mess ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_base_mess'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_base_mess::
GGS_base_mess (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_base_mess::
GGS_base_mess (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_base_mess GGS_base_mess::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_base_mess _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_base_mess *> (inPointer) != NULL)
      : (typeid (cPtr_base_mess) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_base_mess (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_base_mess),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_action_obj  GGS_base_mess::
reader_notification (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_action_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_base_mess *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_base_mess *) mPointer)->notification ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_action_obj  GGS_base_mess::
reader_notificationerror (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_action_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_base_mess *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_base_mess *) mPointer)->notificationerror ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_base_mess::
reader_acc_apps (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_base_mess *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_base_mess *) mPointer)->acc_apps ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ident_map  GGS_base_mess::
reader_other_fields (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ident_map   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_base_mess *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_base_mess *) mPointer)->other_fields ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_base_mess::actualTypeName (void) const {
  return "base_mess" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__base_mess ("base_mess", gClassInfoFor__oil_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_mess_prop_obj'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_mess_prop_obj::
cPtr_mess_prop_obj (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
location (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_mess_prop_obj * GGS_mess_prop_obj::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mess_prop_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_mess_prop_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_mess_prop_obj::
method_generate_notif (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_base_mess  var_cas_mess,
                                GGS_string& var_cas_h_res,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_action_obj  var_cas_notif ;
  var_cas_notif = var_cas_mess.reader_notification (_inLexique COMMA_SOURCE_FILE_AT_LINE (131)) ;
  const GGS_action_obj  _temp_3102 = var_cas_notif ;
  if (_temp_3102._isBuilt ()) {
    _temp_3102 (HERE)->method_generate (_inLexique, var_cas_name, GGS_string (true, ""), GGS_string (true, "$NOTIFICATION_PTR$"), var_cas_h_res, var_cas_i_res COMMA_SOURCE_FILE_AT_LINE (132)) ;
  }
  var_cas_notif = var_cas_mess.reader_notificationerror (_inLexique COMMA_SOURCE_FILE_AT_LINE (135)) ;
  const GGS_action_obj  _temp_3259 = var_cas_notif ;
  if (_temp_3259._isBuilt ()) {
    _temp_3259 (HERE)->method_generate (_inLexique, var_cas_name, GGS_string (true, "_error"), GGS_string (true, "$NOTIFICATION_PTR$"), var_cas_h_res, var_cas_i_res COMMA_SOURCE_FILE_AT_LINE (136)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_mess_prop_obj::
method_generate_dest_list (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_lstring  var_cas_sendingmessage,
                                GGS_ident_list_map  var_cas_dests,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_next_mo ;
  GGS_ident_list  var_cas_dest_list ;
  GGS_bool var_cas_notfound ;
  var_cas_notfound = GGS_bool (true, true) ;
  GGS_bool var_cas_nextone ;
  var_cas_nextone = GGS_bool (true, false) ;
  const GGS_ident_list_map  _temp_3671 = var_cas_dests ;
  if (_temp_3671._isBuilt ()) {
    _temp_3671 (HERE)->method_get (_inLexique, var_cas_sendingmessage, var_cas_dest_list COMMA_SOURCE_FILE_AT_LINE (150)) ;
  }
  {
    GGS_ident_list::cEnumerator enumerator_3728 (var_cas_dest_list, true) ;
    const GGS_ident_list::cElement * operand_3728 = NULL ;
    while (((operand_3728 = enumerator_3728.nextObject ()))
        && (var_cas_notfound.isBuiltAndTrue ())) {
      macroValidPointer (operand_3728) ;
      if ((var_cas_nextone).isBuiltAndTrue ()) {
        ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$TARGET_PTR$"),  ((GGS_string (true, "&"))._operator_concat (operand_3728->obj_name.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (155))))._operator_concat (GGS_string (true, "_message")) COMMA_SOURCE_FILE_AT_LINE (155)) ;
        var_cas_notfound = GGS_bool (true, false) ;
      }
      if (((operand_3728->obj_name.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (158)))._operator_isEqual (var_cas_name.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (158)))).isBuiltAndTrue ()) {
        var_cas_nextone = GGS_bool (true, true) ;
      }
    }
  }
  if ((var_cas_notfound).isBuiltAndTrue ()) {
    ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$TARGET_PTR$"),  GGS_string (true, "NULL_PTR") COMMA_SOURCE_FILE_AT_LINE (163)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_mess_prop_obj::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@mess_prop_obj:"
           << location.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_mess_prop_obj::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mess_prop_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_mess_prop_obj (& typeid (cPtr_mess_prop_obj), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_mess_prop_obj::galgasRTTI (void) const {
  return & gClassInfoFor__mess_prop_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_mess_prop_obj'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_mess_prop_obj::
GGS_mess_prop_obj (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_mess_prop_obj::
GGS_mess_prop_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_mess_prop_obj GGS_mess_prop_obj::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_mess_prop_obj _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_mess_prop_obj *> (inPointer) != NULL)
      : (typeid (cPtr_mess_prop_obj) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_mess_prop_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_mess_prop_obj),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_mess_prop_obj::
reader_location (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mess_prop_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mess_prop_obj *) mPointer)->location ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_mess_prop_obj::actualTypeName (void) const {
  return "mess_prop_obj" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_mess_prop_obj::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__mess_prop_obj ("mess_prop_obj") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_message_obj'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_message_obj::
cPtr_message_obj (const GGS_lstring & argument_0,
                                const GGS_action_obj & argument_1,
                                const GGS_action_obj & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_ident_map & argument_4,
                                const GGS_mess_prop_obj & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_base_mess (argument_0, argument_1, argument_2, argument_3, argument_4 COMMA_THERE),
messageproperty (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_message_obj * GGS_message_obj::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_message_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_message_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_message_obj::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_message_obj * _p = dynamic_cast <const cPtr_message_obj *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = desc._operator_isEqual (_p->desc).boolValue ()
         && notification._operator_isEqual (_p->notification).boolValue ()
         && notificationerror._operator_isEqual (_p->notificationerror).boolValue ()
         && acc_apps._operator_isEqual (_p->acc_apps).boolValue ()
         && other_fields._operator_isEqual (_p->other_fields).boolValue ()
         && messageproperty._operator_isEqual (_p->messageproperty).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_message_obj::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@message_obj:"
           << desc.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << notification.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << notificationerror.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << acc_apps.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << other_fields.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << messageproperty.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_message_obj::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_message_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_message_obj (& typeid (cPtr_message_obj), & typeid (cPtr_base_mess), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_message_obj::galgasRTTI (void) const {
  return & gClassInfoFor__message_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_message_obj'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_message_obj::
GGS_message_obj (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_message_obj::
GGS_message_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_message_obj GGS_message_obj::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_message_obj _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_message_obj *> (inPointer) != NULL)
      : (typeid (cPtr_message_obj) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_message_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_message_obj),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_message_obj GGS_message_obj::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_action_obj & argument_1,
                 const GGS_action_obj & argument_2,
                 const GGS_lstringlist & argument_3,
                 const GGS_ident_map & argument_4,
                 const GGS_mess_prop_obj & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_message_obj result ;
  macroMyNew (result.mPointer, cPtr_message_obj (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mess_prop_obj  GGS_message_obj::
reader_messageproperty (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mess_prop_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_message_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_message_obj *) mPointer)->messageproperty ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_message_obj::actualTypeName (void) const {
  return "message_obj" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__message_obj ("message_obj", gClassInfoFor__base_mess) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'e_message_map'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_message_map::e_message_map (void) :
mess () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@message_map'                          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_message_map::
elementOf_GGS_message_map (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_message_map & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_message_map::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mess.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_message_map::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_message_map * _p = dynamic_cast <const elementOf_GGS_message_map *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mess._operator_isEqual (_p->mInfo.mess)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_message_map::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_message_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_message_map * info = (e_message_map *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_message_map::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_message_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_message_map * info = (e_message_map *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_message_map GGS_message_map::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_message_map result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_message_map::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_message_map info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_message_map::
_operator_isEqual (const GGS_message_map & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_message_map::
_operator_isNotEqual (const GGS_message_map & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_message_map::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_message_map::
_removeElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_message_obj & outParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  AC_galgas_map_element * removedElement = NULL ;
  sint32 elementID = - 1 ;
  if (_isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    bool unused ;
    _internalRemove (mSharedMapRoot->_mRoot, inKey, removedElement, unused) ;
    if (removedElement == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
      outParameter0._drop () ;
    }else{
      cElement * _p = (cElement *) removedElement ;
      elementID = _p->mID ;
      outParameter0 = _p->mInfo.mess ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
  macroMyDelete (removedElement, cElement) ;
}

//---------------------------------------------------------------------------*

void GGS_message_map::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_message_obj & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_message_map info  ;
    info.mess = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_message_map::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_message_obj   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mess ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_message_map::
modifier_setMessForKey (C_Compiler & inLexique,
                        const GGS_message_obj & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMessForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mess = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_message_map::
method_get (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_message_obj   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "Message %K does not exist",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_message_map::
modifier_del (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_message_obj & outParameter0 COMMA_LOCATION_ARGS) {
  _removeElement (_inLexique,
                  "Message %K does not exist",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_message_map::
modifier_put (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_message_obj & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "Message %K is duplicated in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_message_map GGS_message_map::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_message_map & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_message_map result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_message_map GGS_message_map::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_message_map result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_message_map::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @message_map " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_message_obj  & GGS_message_map::cEnumerator::_mess (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mess ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_filter_prop_obj'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_filter_prop_obj::
cPtr_filter_prop_obj (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_filter_prop_obj * GGS_filter_prop_obj::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filter_prop_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_filter_prop_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_filter_prop_obj::
method_base_generate (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$MESSAGE_NAME$"),  var_cas_name.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (187)) COMMA_SOURCE_FILE_AT_LINE (187)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$FILTER$"),  (var_cas_name.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (188)))._operator_concat (GGS_string (true, "_filter")) COMMA_SOURCE_FILE_AT_LINE (188)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$FILTER_PTR$"),  ((GGS_string (true, "&"))._operator_concat (var_cas_name.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (189))))._operator_concat (GGS_string (true, "_filter")) COMMA_SOURCE_FILE_AT_LINE (189)) ;
}

//---------------------------------------------------------------------------*

void cPtr_filter_prop_obj::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@filter_prop_obj:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_filter_prop_obj::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_filter_prop_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_filter_prop_obj (& typeid (cPtr_filter_prop_obj), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_filter_prop_obj::galgasRTTI (void) const {
  return & gClassInfoFor__filter_prop_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_filter_prop_obj'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_filter_prop_obj::
GGS_filter_prop_obj (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_filter_prop_obj::
GGS_filter_prop_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_filter_prop_obj GGS_filter_prop_obj::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_filter_prop_obj _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_filter_prop_obj *> (inPointer) != NULL)
      : (typeid (cPtr_filter_prop_obj) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_filter_prop_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_filter_prop_obj),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_filter_prop_obj::actualTypeName (void) const {
  return "filter_prop_obj" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_filter_prop_obj::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__filter_prop_obj ("filter_prop_obj") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_void_filter'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_void_filter::
cPtr_void_filter (LOCATION_ARGS)
:cPtr_filter_prop_obj (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_void_filter * GGS_void_filter::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_void_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_void_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_void_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_void_filter::
method_generate (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$FILTER_PTR$"),  GGS_string (true, "NULL_PTR") COMMA_SOURCE_FILE_AT_LINE (198)) ;
  method_base_generate (_inLexique, var_cas_name, var_cas_res COMMA_SOURCE_FILE_AT_LINE (199)) ;
}

//---------------------------------------------------------------------------*

void cPtr_void_filter::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@void_filter:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_void_filter::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_void_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_void_filter (& typeid (cPtr_void_filter), & typeid (cPtr_filter_prop_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_void_filter::galgasRTTI (void) const {
  return & gClassInfoFor__void_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_void_filter'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_void_filter::
GGS_void_filter (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_void_filter::
GGS_void_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_void_filter GGS_void_filter::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_void_filter _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_void_filter *> (inPointer) != NULL)
      : (typeid (cPtr_void_filter) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_void_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_void_filter),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_void_filter * gSingleton_void_filter = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_void_filter (void) {
  macroDetachPointer (gSingleton_void_filter, cPtr_void_filter) ;
}

//---------------------------------------------------------------------------*

GGS_void_filter GGS_void_filter::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_void_filter result ;
  if (NULL == gSingleton_void_filter) {
    macroMyNew (gSingleton_void_filter, cPtr_void_filter (THERE)) ;
    registerReleaseRoutine (cleanUp_void_filter) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_void_filter) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_void_filter::actualTypeName (void) const {
  return "void_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__void_filter ("void_filter", gClassInfoFor__filter_prop_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_always_filter'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_always_filter::
cPtr_always_filter (LOCATION_ARGS)
:cPtr_filter_prop_obj (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_always_filter * GGS_always_filter::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_always_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_always_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_always_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_always_filter::
method_generate (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_f_res ;
  ::routine_retrieveTemplateString (_inLexique,  var_cas_f_res,  GGS_string (true, "filter_noparam") COMMA_SOURCE_FILE_AT_LINE (209)) ;
  var_cas_res = (var_cas_f_res)._operator_concat (var_cas_res) ;
  method_base_generate (_inLexique, var_cas_name, var_cas_res COMMA_SOURCE_FILE_AT_LINE (211)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$FILTERING_FUNC$"),  GGS_string (true, "tpl_filter_always") COMMA_SOURCE_FILE_AT_LINE (212)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$FILTER_KIND$"),  GGS_string (true, "Always") COMMA_SOURCE_FILE_AT_LINE (213)) ;
}

//---------------------------------------------------------------------------*

void cPtr_always_filter::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@always_filter:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_always_filter::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_always_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_always_filter (& typeid (cPtr_always_filter), & typeid (cPtr_filter_prop_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_always_filter::galgasRTTI (void) const {
  return & gClassInfoFor__always_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_always_filter'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_always_filter::
GGS_always_filter (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_always_filter::
GGS_always_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_always_filter GGS_always_filter::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_always_filter _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_always_filter *> (inPointer) != NULL)
      : (typeid (cPtr_always_filter) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_always_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_always_filter),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_always_filter * gSingleton_always_filter = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_always_filter (void) {
  macroDetachPointer (gSingleton_always_filter, cPtr_always_filter) ;
}

//---------------------------------------------------------------------------*

GGS_always_filter GGS_always_filter::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_always_filter result ;
  if (NULL == gSingleton_always_filter) {
    macroMyNew (gSingleton_always_filter, cPtr_always_filter (THERE)) ;
    registerReleaseRoutine (cleanUp_always_filter) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_always_filter) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_always_filter::actualTypeName (void) const {
  return "always_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__always_filter ("always_filter", gClassInfoFor__filter_prop_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_never_filter'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_never_filter::
cPtr_never_filter (LOCATION_ARGS)
:cPtr_filter_prop_obj (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_never_filter * GGS_never_filter::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_never_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_never_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_never_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_never_filter::
method_generate (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_f_res ;
  ::routine_retrieveTemplateString (_inLexique,  var_cas_f_res,  GGS_string (true, "filter_noparam") COMMA_SOURCE_FILE_AT_LINE (223)) ;
  var_cas_res = (var_cas_f_res)._operator_concat (var_cas_res) ;
  method_base_generate (_inLexique, var_cas_name, var_cas_res COMMA_SOURCE_FILE_AT_LINE (225)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$FILTERING_FUNC$"),  GGS_string (true, "tpl_filter_never") COMMA_SOURCE_FILE_AT_LINE (226)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$FILTER_KIND$"),  GGS_string (true, "Never") COMMA_SOURCE_FILE_AT_LINE (227)) ;
}

//---------------------------------------------------------------------------*

void cPtr_never_filter::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@never_filter:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_never_filter::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_never_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_never_filter (& typeid (cPtr_never_filter), & typeid (cPtr_filter_prop_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_never_filter::galgasRTTI (void) const {
  return & gClassInfoFor__never_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_never_filter'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_never_filter::
GGS_never_filter (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_never_filter::
GGS_never_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_never_filter GGS_never_filter::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_never_filter _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_never_filter *> (inPointer) != NULL)
      : (typeid (cPtr_never_filter) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_never_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_never_filter),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_never_filter * gSingleton_never_filter = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_never_filter (void) {
  macroDetachPointer (gSingleton_never_filter, cPtr_never_filter) ;
}

//---------------------------------------------------------------------------*

GGS_never_filter GGS_never_filter::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_never_filter result ;
  if (NULL == gSingleton_never_filter) {
    macroMyNew (gSingleton_never_filter, cPtr_never_filter (THERE)) ;
    registerReleaseRoutine (cleanUp_never_filter) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_never_filter) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_never_filter::actualTypeName (void) const {
  return "never_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__never_filter ("never_filter", gClassInfoFor__filter_prop_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_maskednewequalsx_filter'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_maskednewequalsx_filter::
cPtr_maskednewequalsx_filter (const GGS_luint64 & argument_0,
                                const GGS_luint64 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_filter_prop_obj (THERE),
mask (argument_0),
x (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_maskednewequalsx_filter * GGS_maskednewequalsx_filter::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_maskednewequalsx_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_maskednewequalsx_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_maskednewequalsx_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_maskednewequalsx_filter * _p = dynamic_cast <const cPtr_maskednewequalsx_filter *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mask._operator_isEqual (_p->mask).boolValue ()
         && x._operator_isEqual (_p->x).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_maskednewequalsx_filter::
method_generate (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_f_res ;
  ::routine_retrieveTemplateString (_inLexique,  var_cas_f_res,  GGS_string (true, "filter_mask_x") COMMA_SOURCE_FILE_AT_LINE (239)) ;
  var_cas_res = (var_cas_f_res)._operator_concat (var_cas_res) ;
  method_base_generate (_inLexique, var_cas_name, var_cas_res COMMA_SOURCE_FILE_AT_LINE (241)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$FILTERING_FUNC$"),  GGS_string (true, "tpl_filter_masked_new_equals_x") COMMA_SOURCE_FILE_AT_LINE (242)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$FILTER_KIND$"),  GGS_string (true, "Masked New Equals X") COMMA_SOURCE_FILE_AT_LINE (243)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$MASK$"),  mask.reader_uint64 (_inLexique COMMA_SOURCE_FILE_AT_LINE (244)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (244)) COMMA_SOURCE_FILE_AT_LINE (244)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$X$"),  x.reader_uint64 (_inLexique COMMA_SOURCE_FILE_AT_LINE (245)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (245)) COMMA_SOURCE_FILE_AT_LINE (245)) ;
}

//---------------------------------------------------------------------------*

void cPtr_maskednewequalsx_filter::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@maskednewequalsx_filter:"
           << mask.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << x.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_maskednewequalsx_filter::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_maskednewequalsx_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_maskednewequalsx_filter (& typeid (cPtr_maskednewequalsx_filter), & typeid (cPtr_filter_prop_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_maskednewequalsx_filter::galgasRTTI (void) const {
  return & gClassInfoFor__maskednewequalsx_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_maskednewequalsx_filter'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_maskednewequalsx_filter::
GGS_maskednewequalsx_filter (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_maskednewequalsx_filter::
GGS_maskednewequalsx_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_maskednewequalsx_filter GGS_maskednewequalsx_filter::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_maskednewequalsx_filter _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_maskednewequalsx_filter *> (inPointer) != NULL)
      : (typeid (cPtr_maskednewequalsx_filter) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_maskednewequalsx_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_maskednewequalsx_filter),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_maskednewequalsx_filter GGS_maskednewequalsx_filter::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint64 & argument_0,
                 const GGS_luint64 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_maskednewequalsx_filter result ;
  macroMyNew (result.mPointer, cPtr_maskednewequalsx_filter (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_maskednewequalsx_filter::
reader_mask (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_maskednewequalsx_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_maskednewequalsx_filter *) mPointer)->mask ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_maskednewequalsx_filter::
reader_x (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_maskednewequalsx_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_maskednewequalsx_filter *) mPointer)->x ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_maskednewequalsx_filter::actualTypeName (void) const {
  return "maskednewequalsx_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__maskednewequalsx_filter ("maskednewequalsx_filter", gClassInfoFor__filter_prop_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_maskednewdiffersx_filter'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_maskednewdiffersx_filter::
cPtr_maskednewdiffersx_filter (const GGS_luint64 & argument_0,
                                const GGS_luint64 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_filter_prop_obj (THERE),
mask (argument_0),
x (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_maskednewdiffersx_filter * GGS_maskednewdiffersx_filter::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_maskednewdiffersx_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_maskednewdiffersx_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_maskednewdiffersx_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_maskednewdiffersx_filter * _p = dynamic_cast <const cPtr_maskednewdiffersx_filter *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mask._operator_isEqual (_p->mask).boolValue ()
         && x._operator_isEqual (_p->x).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_maskednewdiffersx_filter::
method_generate (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_f_res ;
  ::routine_retrieveTemplateString (_inLexique,  var_cas_f_res,  GGS_string (true, "filter_mask_x") COMMA_SOURCE_FILE_AT_LINE (257)) ;
  var_cas_res = (var_cas_f_res)._operator_concat (var_cas_res) ;
  method_base_generate (_inLexique, var_cas_name, var_cas_res COMMA_SOURCE_FILE_AT_LINE (259)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$FILTERING_FUNC$"),  GGS_string (true, "tpl_filter_masked_new_differs_x") COMMA_SOURCE_FILE_AT_LINE (260)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$FILTER_KIND$"),  GGS_string (true, "Masked New Differs X") COMMA_SOURCE_FILE_AT_LINE (261)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$MASK$"),  mask.reader_uint64 (_inLexique COMMA_SOURCE_FILE_AT_LINE (262)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (262)) COMMA_SOURCE_FILE_AT_LINE (262)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$X$"),  x.reader_uint64 (_inLexique COMMA_SOURCE_FILE_AT_LINE (263)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (263)) COMMA_SOURCE_FILE_AT_LINE (263)) ;
}

//---------------------------------------------------------------------------*

void cPtr_maskednewdiffersx_filter::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@maskednewdiffersx_filter:"
           << mask.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << x.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_maskednewdiffersx_filter::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_maskednewdiffersx_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_maskednewdiffersx_filter (& typeid (cPtr_maskednewdiffersx_filter), & typeid (cPtr_filter_prop_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_maskednewdiffersx_filter::galgasRTTI (void) const {
  return & gClassInfoFor__maskednewdiffersx_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_maskednewdiffersx_filter'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_maskednewdiffersx_filter::
GGS_maskednewdiffersx_filter (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_maskednewdiffersx_filter::
GGS_maskednewdiffersx_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_maskednewdiffersx_filter GGS_maskednewdiffersx_filter::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_maskednewdiffersx_filter _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_maskednewdiffersx_filter *> (inPointer) != NULL)
      : (typeid (cPtr_maskednewdiffersx_filter) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_maskednewdiffersx_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_maskednewdiffersx_filter),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_maskednewdiffersx_filter GGS_maskednewdiffersx_filter::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint64 & argument_0,
                 const GGS_luint64 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_maskednewdiffersx_filter result ;
  macroMyNew (result.mPointer, cPtr_maskednewdiffersx_filter (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_maskednewdiffersx_filter::
reader_mask (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_maskednewdiffersx_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_maskednewdiffersx_filter *) mPointer)->mask ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_maskednewdiffersx_filter::
reader_x (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_maskednewdiffersx_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_maskednewdiffersx_filter *) mPointer)->x ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_maskednewdiffersx_filter::actualTypeName (void) const {
  return "maskednewdiffersx_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__maskednewdiffersx_filter ("maskednewdiffersx_filter", gClassInfoFor__filter_prop_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_newisequal_filter'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_newisequal_filter::
cPtr_newisequal_filter (LOCATION_ARGS)
:cPtr_filter_prop_obj (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_newisequal_filter * GGS_newisequal_filter::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_newisequal_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_newisequal_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_newisequal_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_newisequal_filter::
method_generate (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_f_res ;
  ::routine_retrieveTemplateString (_inLexique,  var_cas_f_res,  GGS_string (true, "filter_noparam") COMMA_SOURCE_FILE_AT_LINE (273)) ;
  var_cas_res = (var_cas_f_res)._operator_concat (var_cas_res) ;
  method_base_generate (_inLexique, var_cas_name, var_cas_res COMMA_SOURCE_FILE_AT_LINE (275)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$FILTERING_FUNC$"),  GGS_string (true, "tpl_filter_new_is_equal") COMMA_SOURCE_FILE_AT_LINE (276)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$FILTER_KIND$"),  GGS_string (true, "New is Equal") COMMA_SOURCE_FILE_AT_LINE (277)) ;
}

//---------------------------------------------------------------------------*

void cPtr_newisequal_filter::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@newisequal_filter:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_newisequal_filter::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_newisequal_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_newisequal_filter (& typeid (cPtr_newisequal_filter), & typeid (cPtr_filter_prop_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_newisequal_filter::galgasRTTI (void) const {
  return & gClassInfoFor__newisequal_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_newisequal_filter'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_newisequal_filter::
GGS_newisequal_filter (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_newisequal_filter::
GGS_newisequal_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_newisequal_filter GGS_newisequal_filter::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_newisequal_filter _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_newisequal_filter *> (inPointer) != NULL)
      : (typeid (cPtr_newisequal_filter) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_newisequal_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_newisequal_filter),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_newisequal_filter * gSingleton_newisequal_filter = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_newisequal_filter (void) {
  macroDetachPointer (gSingleton_newisequal_filter, cPtr_newisequal_filter) ;
}

//---------------------------------------------------------------------------*

GGS_newisequal_filter GGS_newisequal_filter::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_newisequal_filter result ;
  if (NULL == gSingleton_newisequal_filter) {
    macroMyNew (gSingleton_newisequal_filter, cPtr_newisequal_filter (THERE)) ;
    registerReleaseRoutine (cleanUp_newisequal_filter) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_newisequal_filter) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_newisequal_filter::actualTypeName (void) const {
  return "newisequal_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__newisequal_filter ("newisequal_filter", gClassInfoFor__filter_prop_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_newisdifferent_filter'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_newisdifferent_filter::
cPtr_newisdifferent_filter (LOCATION_ARGS)
:cPtr_filter_prop_obj (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_newisdifferent_filter * GGS_newisdifferent_filter::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_newisdifferent_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_newisdifferent_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_newisdifferent_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_newisdifferent_filter::
method_generate (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_f_res ;
  ::routine_retrieveTemplateString (_inLexique,  var_cas_f_res,  GGS_string (true, "filter_noparam") COMMA_SOURCE_FILE_AT_LINE (287)) ;
  var_cas_res = (var_cas_f_res)._operator_concat (var_cas_res) ;
  method_base_generate (_inLexique, var_cas_name, var_cas_res COMMA_SOURCE_FILE_AT_LINE (289)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$FILTERING_FUNC$"),  GGS_string (true, "tpl_filter_new_is_different") COMMA_SOURCE_FILE_AT_LINE (290)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$FILTER_KIND$"),  GGS_string (true, "New is Different") COMMA_SOURCE_FILE_AT_LINE (291)) ;
}

//---------------------------------------------------------------------------*

void cPtr_newisdifferent_filter::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@newisdifferent_filter:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_newisdifferent_filter::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_newisdifferent_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_newisdifferent_filter (& typeid (cPtr_newisdifferent_filter), & typeid (cPtr_filter_prop_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_newisdifferent_filter::galgasRTTI (void) const {
  return & gClassInfoFor__newisdifferent_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_newisdifferent_filter'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_newisdifferent_filter::
GGS_newisdifferent_filter (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_newisdifferent_filter::
GGS_newisdifferent_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_newisdifferent_filter GGS_newisdifferent_filter::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_newisdifferent_filter _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_newisdifferent_filter *> (inPointer) != NULL)
      : (typeid (cPtr_newisdifferent_filter) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_newisdifferent_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_newisdifferent_filter),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_newisdifferent_filter * gSingleton_newisdifferent_filter = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_newisdifferent_filter (void) {
  macroDetachPointer (gSingleton_newisdifferent_filter, cPtr_newisdifferent_filter) ;
}

//---------------------------------------------------------------------------*

GGS_newisdifferent_filter GGS_newisdifferent_filter::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_newisdifferent_filter result ;
  if (NULL == gSingleton_newisdifferent_filter) {
    macroMyNew (gSingleton_newisdifferent_filter, cPtr_newisdifferent_filter (THERE)) ;
    registerReleaseRoutine (cleanUp_newisdifferent_filter) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_newisdifferent_filter) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_newisdifferent_filter::actualTypeName (void) const {
  return "newisdifferent_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__newisdifferent_filter ("newisdifferent_filter", gClassInfoFor__filter_prop_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_maskednewequalsmaskedold_filter'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_maskednewequalsmaskedold_filter::
cPtr_maskednewequalsmaskedold_filter (const GGS_luint64 & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_filter_prop_obj (THERE),
mask (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_maskednewequalsmaskedold_filter * GGS_maskednewequalsmaskedold_filter::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_maskednewequalsmaskedold_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_maskednewequalsmaskedold_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_maskednewequalsmaskedold_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_maskednewequalsmaskedold_filter * _p = dynamic_cast <const cPtr_maskednewequalsmaskedold_filter *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mask._operator_isEqual (_p->mask).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_maskednewequalsmaskedold_filter::
method_generate (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_f_res ;
  ::routine_retrieveTemplateString (_inLexique,  var_cas_f_res,  GGS_string (true, "filter_mask") COMMA_SOURCE_FILE_AT_LINE (302)) ;
  var_cas_res = (var_cas_f_res)._operator_concat (var_cas_res) ;
  method_base_generate (_inLexique, var_cas_name, var_cas_res COMMA_SOURCE_FILE_AT_LINE (304)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$FILTERING_FUNC$"),  GGS_string (true, "tpl_filter_masked_new_equals_masked_old") COMMA_SOURCE_FILE_AT_LINE (305)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$FILTER_KIND$"),  GGS_string (true, "Masked New Equals Masked Old") COMMA_SOURCE_FILE_AT_LINE (306)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$MASK$"),  mask.reader_uint64 (_inLexique COMMA_SOURCE_FILE_AT_LINE (307)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (307)) COMMA_SOURCE_FILE_AT_LINE (307)) ;
}

//---------------------------------------------------------------------------*

void cPtr_maskednewequalsmaskedold_filter::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@maskednewequalsmaskedold_filter:"
           << mask.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_maskednewequalsmaskedold_filter::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_maskednewequalsmaskedold_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_maskednewequalsmaskedold_filter (& typeid (cPtr_maskednewequalsmaskedold_filter), & typeid (cPtr_filter_prop_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_maskednewequalsmaskedold_filter::galgasRTTI (void) const {
  return & gClassInfoFor__maskednewequalsmaskedold_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_maskednewequalsmaskedold_filter'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_maskednewequalsmaskedold_filter::
GGS_maskednewequalsmaskedold_filter (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_maskednewequalsmaskedold_filter::
GGS_maskednewequalsmaskedold_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_maskednewequalsmaskedold_filter GGS_maskednewequalsmaskedold_filter::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_maskednewequalsmaskedold_filter _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_maskednewequalsmaskedold_filter *> (inPointer) != NULL)
      : (typeid (cPtr_maskednewequalsmaskedold_filter) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_maskednewequalsmaskedold_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_maskednewequalsmaskedold_filter),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_maskednewequalsmaskedold_filter GGS_maskednewequalsmaskedold_filter::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint64 & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_maskednewequalsmaskedold_filter result ;
  macroMyNew (result.mPointer, cPtr_maskednewequalsmaskedold_filter (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_maskednewequalsmaskedold_filter::
reader_mask (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_maskednewequalsmaskedold_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_maskednewequalsmaskedold_filter *) mPointer)->mask ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_maskednewequalsmaskedold_filter::actualTypeName (void) const {
  return "maskednewequalsmaskedold_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__maskednewequalsmaskedold_filter ("maskednewequalsmaskedold_filter", gClassInfoFor__filter_prop_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_maskednewdiffersmaskedold_filter'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_maskednewdiffersmaskedold_filter::
cPtr_maskednewdiffersmaskedold_filter (const GGS_luint64 & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_filter_prop_obj (THERE),
mask (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_maskednewdiffersmaskedold_filter * GGS_maskednewdiffersmaskedold_filter::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_maskednewdiffersmaskedold_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_maskednewdiffersmaskedold_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_maskednewdiffersmaskedold_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_maskednewdiffersmaskedold_filter * _p = dynamic_cast <const cPtr_maskednewdiffersmaskedold_filter *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mask._operator_isEqual (_p->mask).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_maskednewdiffersmaskedold_filter::
method_generate (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_f_res ;
  ::routine_retrieveTemplateString (_inLexique,  var_cas_f_res,  GGS_string (true, "filter_mask") COMMA_SOURCE_FILE_AT_LINE (318)) ;
  var_cas_res = (var_cas_f_res)._operator_concat (var_cas_res) ;
  method_base_generate (_inLexique, var_cas_name, var_cas_res COMMA_SOURCE_FILE_AT_LINE (320)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$FILTERING_FUNC$"),  GGS_string (true, "tpl_filter_masked_new_differs_masked_old") COMMA_SOURCE_FILE_AT_LINE (321)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$FILTER_KIND$"),  GGS_string (true, "Masked New Differs Masked Old") COMMA_SOURCE_FILE_AT_LINE (322)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$MASK$"),  mask.reader_uint64 (_inLexique COMMA_SOURCE_FILE_AT_LINE (323)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (323)) COMMA_SOURCE_FILE_AT_LINE (323)) ;
}

//---------------------------------------------------------------------------*

void cPtr_maskednewdiffersmaskedold_filter::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@maskednewdiffersmaskedold_filter:"
           << mask.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_maskednewdiffersmaskedold_filter::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_maskednewdiffersmaskedold_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_maskednewdiffersmaskedold_filter (& typeid (cPtr_maskednewdiffersmaskedold_filter), & typeid (cPtr_filter_prop_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_maskednewdiffersmaskedold_filter::galgasRTTI (void) const {
  return & gClassInfoFor__maskednewdiffersmaskedold_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_maskednewdiffersmaskedold_filter'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_maskednewdiffersmaskedold_filter::
GGS_maskednewdiffersmaskedold_filter (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_maskednewdiffersmaskedold_filter::
GGS_maskednewdiffersmaskedold_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_maskednewdiffersmaskedold_filter GGS_maskednewdiffersmaskedold_filter::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_maskednewdiffersmaskedold_filter _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_maskednewdiffersmaskedold_filter *> (inPointer) != NULL)
      : (typeid (cPtr_maskednewdiffersmaskedold_filter) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_maskednewdiffersmaskedold_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_maskednewdiffersmaskedold_filter),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_maskednewdiffersmaskedold_filter GGS_maskednewdiffersmaskedold_filter::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint64 & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_maskednewdiffersmaskedold_filter result ;
  macroMyNew (result.mPointer, cPtr_maskednewdiffersmaskedold_filter (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_maskednewdiffersmaskedold_filter::
reader_mask (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_maskednewdiffersmaskedold_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_maskednewdiffersmaskedold_filter *) mPointer)->mask ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_maskednewdiffersmaskedold_filter::actualTypeName (void) const {
  return "maskednewdiffersmaskedold_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__maskednewdiffersmaskedold_filter ("maskednewdiffersmaskedold_filter", gClassInfoFor__filter_prop_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_newiswithin'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_newiswithin::
cPtr_newiswithin (const GGS_luint64 & argument_0,
                                const GGS_luint64 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_filter_prop_obj (THERE),
min (argument_0),
max (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_newiswithin * GGS_newiswithin::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_newiswithin *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_newiswithin *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_newiswithin::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_newiswithin * _p = dynamic_cast <const cPtr_newiswithin *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = min._operator_isEqual (_p->min).boolValue ()
         && max._operator_isEqual (_p->max).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_newiswithin::
method_generate (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_f_res ;
  ::routine_retrieveTemplateString (_inLexique,  var_cas_f_res,  GGS_string (true, "filter_interval") COMMA_SOURCE_FILE_AT_LINE (335)) ;
  var_cas_res = (var_cas_f_res)._operator_concat (var_cas_res) ;
  method_base_generate (_inLexique, var_cas_name, var_cas_res COMMA_SOURCE_FILE_AT_LINE (337)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$FILTERING_FUNC$"),  GGS_string (true, "tpl_filter_new_is_within") COMMA_SOURCE_FILE_AT_LINE (338)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$FILTER_KIND$"),  GGS_string (true, "New is Within") COMMA_SOURCE_FILE_AT_LINE (339)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$MIN$"),  min.reader_uint64 (_inLexique COMMA_SOURCE_FILE_AT_LINE (340)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (340)) COMMA_SOURCE_FILE_AT_LINE (340)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$MAX$"),  max.reader_uint64 (_inLexique COMMA_SOURCE_FILE_AT_LINE (341)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (341)) COMMA_SOURCE_FILE_AT_LINE (341)) ;
}

//---------------------------------------------------------------------------*

void cPtr_newiswithin::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@newiswithin:"
           << min.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << max.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_newiswithin::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_newiswithin::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_newiswithin (& typeid (cPtr_newiswithin), & typeid (cPtr_filter_prop_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_newiswithin::galgasRTTI (void) const {
  return & gClassInfoFor__newiswithin ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_newiswithin'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_newiswithin::
GGS_newiswithin (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_newiswithin::
GGS_newiswithin (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_newiswithin GGS_newiswithin::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_newiswithin _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_newiswithin *> (inPointer) != NULL)
      : (typeid (cPtr_newiswithin) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_newiswithin (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_newiswithin),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_newiswithin GGS_newiswithin::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint64 & argument_0,
                 const GGS_luint64 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_newiswithin result ;
  macroMyNew (result.mPointer, cPtr_newiswithin (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_newiswithin::
reader_min (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_newiswithin *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_newiswithin *) mPointer)->min ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_newiswithin::
reader_max (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_newiswithin *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_newiswithin *) mPointer)->max ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_newiswithin::actualTypeName (void) const {
  return "newiswithin" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__newiswithin ("newiswithin", gClassInfoFor__filter_prop_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_newisoutside'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_newisoutside::
cPtr_newisoutside (const GGS_luint64 & argument_0,
                                const GGS_luint64 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_filter_prop_obj (THERE),
min (argument_0),
max (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_newisoutside * GGS_newisoutside::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_newisoutside *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_newisoutside *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_newisoutside::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_newisoutside * _p = dynamic_cast <const cPtr_newisoutside *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = min._operator_isEqual (_p->min).boolValue ()
         && max._operator_isEqual (_p->max).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_newisoutside::
method_generate (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_f_res ;
  ::routine_retrieveTemplateString (_inLexique,  var_cas_f_res,  GGS_string (true, "filter_interval") COMMA_SOURCE_FILE_AT_LINE (353)) ;
  var_cas_res = (var_cas_f_res)._operator_concat (var_cas_res) ;
  method_base_generate (_inLexique, var_cas_name, var_cas_res COMMA_SOURCE_FILE_AT_LINE (355)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$FILTERING_FUNC$"),  GGS_string (true, "tpl_filter_new_is_outside") COMMA_SOURCE_FILE_AT_LINE (356)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$FILTER_KIND$"),  GGS_string (true, "New is Outside") COMMA_SOURCE_FILE_AT_LINE (357)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$MIN$"),  min.reader_uint64 (_inLexique COMMA_SOURCE_FILE_AT_LINE (358)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (358)) COMMA_SOURCE_FILE_AT_LINE (358)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$MAX$"),  max.reader_uint64 (_inLexique COMMA_SOURCE_FILE_AT_LINE (359)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (359)) COMMA_SOURCE_FILE_AT_LINE (359)) ;
}

//---------------------------------------------------------------------------*

void cPtr_newisoutside::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@newisoutside:"
           << min.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << max.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_newisoutside::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_newisoutside::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_newisoutside (& typeid (cPtr_newisoutside), & typeid (cPtr_filter_prop_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_newisoutside::galgasRTTI (void) const {
  return & gClassInfoFor__newisoutside ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_newisoutside'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_newisoutside::
GGS_newisoutside (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_newisoutside::
GGS_newisoutside (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_newisoutside GGS_newisoutside::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_newisoutside _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_newisoutside *> (inPointer) != NULL)
      : (typeid (cPtr_newisoutside) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_newisoutside (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_newisoutside),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_newisoutside GGS_newisoutside::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint64 & argument_0,
                 const GGS_luint64 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_newisoutside result ;
  macroMyNew (result.mPointer, cPtr_newisoutside (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_newisoutside::
reader_min (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_newisoutside *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_newisoutside *) mPointer)->min ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_newisoutside::
reader_max (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_newisoutside *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_newisoutside *) mPointer)->max ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_newisoutside::actualTypeName (void) const {
  return "newisoutside" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__newisoutside ("newisoutside", gClassInfoFor__filter_prop_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_newisgreater_filter'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_newisgreater_filter::
cPtr_newisgreater_filter (LOCATION_ARGS)
:cPtr_filter_prop_obj (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_newisgreater_filter * GGS_newisgreater_filter::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_newisgreater_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_newisgreater_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_newisgreater_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_newisgreater_filter::
method_generate (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_f_res ;
  ::routine_retrieveTemplateString (_inLexique,  var_cas_f_res,  GGS_string (true, "filter_noparam") COMMA_SOURCE_FILE_AT_LINE (369)) ;
  var_cas_res = (var_cas_f_res)._operator_concat (var_cas_res) ;
  method_base_generate (_inLexique, var_cas_name, var_cas_res COMMA_SOURCE_FILE_AT_LINE (371)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$FILTERING_FUNC$"),  GGS_string (true, "tpl_filter_new_is_greater") COMMA_SOURCE_FILE_AT_LINE (372)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$FILTER_KIND$"),  GGS_string (true, "New is Greater") COMMA_SOURCE_FILE_AT_LINE (373)) ;
}

//---------------------------------------------------------------------------*

void cPtr_newisgreater_filter::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@newisgreater_filter:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_newisgreater_filter::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_newisgreater_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_newisgreater_filter (& typeid (cPtr_newisgreater_filter), & typeid (cPtr_filter_prop_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_newisgreater_filter::galgasRTTI (void) const {
  return & gClassInfoFor__newisgreater_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_newisgreater_filter'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_newisgreater_filter::
GGS_newisgreater_filter (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_newisgreater_filter::
GGS_newisgreater_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_newisgreater_filter GGS_newisgreater_filter::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_newisgreater_filter _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_newisgreater_filter *> (inPointer) != NULL)
      : (typeid (cPtr_newisgreater_filter) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_newisgreater_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_newisgreater_filter),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_newisgreater_filter * gSingleton_newisgreater_filter = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_newisgreater_filter (void) {
  macroDetachPointer (gSingleton_newisgreater_filter, cPtr_newisgreater_filter) ;
}

//---------------------------------------------------------------------------*

GGS_newisgreater_filter GGS_newisgreater_filter::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_newisgreater_filter result ;
  if (NULL == gSingleton_newisgreater_filter) {
    macroMyNew (gSingleton_newisgreater_filter, cPtr_newisgreater_filter (THERE)) ;
    registerReleaseRoutine (cleanUp_newisgreater_filter) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_newisgreater_filter) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_newisgreater_filter::actualTypeName (void) const {
  return "newisgreater_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__newisgreater_filter ("newisgreater_filter", gClassInfoFor__filter_prop_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_newislessorequal_filter'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_newislessorequal_filter::
cPtr_newislessorequal_filter (LOCATION_ARGS)
:cPtr_filter_prop_obj (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_newislessorequal_filter * GGS_newislessorequal_filter::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_newislessorequal_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_newislessorequal_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_newislessorequal_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_newislessorequal_filter::
method_generate (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_f_res ;
  ::routine_retrieveTemplateString (_inLexique,  var_cas_f_res,  GGS_string (true, "filter_noparam") COMMA_SOURCE_FILE_AT_LINE (383)) ;
  var_cas_res = (var_cas_f_res)._operator_concat (var_cas_res) ;
  method_base_generate (_inLexique, var_cas_name, var_cas_res COMMA_SOURCE_FILE_AT_LINE (385)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$FILTERING_FUNC$"),  GGS_string (true, "tpl_filter_new_is_less_or_equal") COMMA_SOURCE_FILE_AT_LINE (386)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$FILTER_KIND$"),  GGS_string (true, "New is Less or Equal") COMMA_SOURCE_FILE_AT_LINE (387)) ;
}

//---------------------------------------------------------------------------*

void cPtr_newislessorequal_filter::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@newislessorequal_filter:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_newislessorequal_filter::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_newislessorequal_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_newislessorequal_filter (& typeid (cPtr_newislessorequal_filter), & typeid (cPtr_filter_prop_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_newislessorequal_filter::galgasRTTI (void) const {
  return & gClassInfoFor__newislessorequal_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_newislessorequal_filter'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_newislessorequal_filter::
GGS_newislessorequal_filter (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_newislessorequal_filter::
GGS_newislessorequal_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_newislessorequal_filter GGS_newislessorequal_filter::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_newislessorequal_filter _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_newislessorequal_filter *> (inPointer) != NULL)
      : (typeid (cPtr_newislessorequal_filter) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_newislessorequal_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_newislessorequal_filter),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_newislessorequal_filter * gSingleton_newislessorequal_filter = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_newislessorequal_filter (void) {
  macroDetachPointer (gSingleton_newislessorequal_filter, cPtr_newislessorequal_filter) ;
}

//---------------------------------------------------------------------------*

GGS_newislessorequal_filter GGS_newislessorequal_filter::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_newislessorequal_filter result ;
  if (NULL == gSingleton_newislessorequal_filter) {
    macroMyNew (gSingleton_newislessorequal_filter, cPtr_newislessorequal_filter (THERE)) ;
    registerReleaseRoutine (cleanUp_newislessorequal_filter) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_newislessorequal_filter) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_newislessorequal_filter::actualTypeName (void) const {
  return "newislessorequal_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__newislessorequal_filter ("newislessorequal_filter", gClassInfoFor__filter_prop_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_newisless_filter'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_newisless_filter::
cPtr_newisless_filter (LOCATION_ARGS)
:cPtr_filter_prop_obj (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_newisless_filter * GGS_newisless_filter::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_newisless_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_newisless_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_newisless_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_newisless_filter::
method_generate (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_f_res ;
  ::routine_retrieveTemplateString (_inLexique,  var_cas_f_res,  GGS_string (true, "filter_noparam") COMMA_SOURCE_FILE_AT_LINE (397)) ;
  var_cas_res = (var_cas_f_res)._operator_concat (var_cas_res) ;
  method_base_generate (_inLexique, var_cas_name, var_cas_res COMMA_SOURCE_FILE_AT_LINE (399)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$FILTERING_FUNC$"),  GGS_string (true, "tpl_filter_new_is_less") COMMA_SOURCE_FILE_AT_LINE (400)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$FILTER_KIND$"),  GGS_string (true, "New is Less") COMMA_SOURCE_FILE_AT_LINE (401)) ;
}

//---------------------------------------------------------------------------*

void cPtr_newisless_filter::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@newisless_filter:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_newisless_filter::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_newisless_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_newisless_filter (& typeid (cPtr_newisless_filter), & typeid (cPtr_filter_prop_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_newisless_filter::galgasRTTI (void) const {
  return & gClassInfoFor__newisless_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_newisless_filter'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_newisless_filter::
GGS_newisless_filter (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_newisless_filter::
GGS_newisless_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_newisless_filter GGS_newisless_filter::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_newisless_filter _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_newisless_filter *> (inPointer) != NULL)
      : (typeid (cPtr_newisless_filter) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_newisless_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_newisless_filter),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_newisless_filter * gSingleton_newisless_filter = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_newisless_filter (void) {
  macroDetachPointer (gSingleton_newisless_filter, cPtr_newisless_filter) ;
}

//---------------------------------------------------------------------------*

GGS_newisless_filter GGS_newisless_filter::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_newisless_filter result ;
  if (NULL == gSingleton_newisless_filter) {
    macroMyNew (gSingleton_newisless_filter, cPtr_newisless_filter (THERE)) ;
    registerReleaseRoutine (cleanUp_newisless_filter) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_newisless_filter) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_newisless_filter::actualTypeName (void) const {
  return "newisless_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__newisless_filter ("newisless_filter", gClassInfoFor__filter_prop_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_newisgreaterorequal_filter'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_newisgreaterorequal_filter::
cPtr_newisgreaterorequal_filter (LOCATION_ARGS)
:cPtr_filter_prop_obj (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_newisgreaterorequal_filter * GGS_newisgreaterorequal_filter::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_newisgreaterorequal_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_newisgreaterorequal_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_newisgreaterorequal_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_newisgreaterorequal_filter::
method_generate (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_f_res ;
  ::routine_retrieveTemplateString (_inLexique,  var_cas_f_res,  GGS_string (true, "filter_noparam") COMMA_SOURCE_FILE_AT_LINE (411)) ;
  var_cas_res = (var_cas_f_res)._operator_concat (var_cas_res) ;
  method_base_generate (_inLexique, var_cas_name, var_cas_res COMMA_SOURCE_FILE_AT_LINE (413)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$FILTERING_FUNC$"),  GGS_string (true, "tpl_filter_new_is_greater_or_equal") COMMA_SOURCE_FILE_AT_LINE (414)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$FILTER_KIND$"),  GGS_string (true, "New is Greater or Equal") COMMA_SOURCE_FILE_AT_LINE (415)) ;
}

//---------------------------------------------------------------------------*

void cPtr_newisgreaterorequal_filter::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@newisgreaterorequal_filter:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_newisgreaterorequal_filter::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_newisgreaterorequal_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_newisgreaterorequal_filter (& typeid (cPtr_newisgreaterorequal_filter), & typeid (cPtr_filter_prop_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_newisgreaterorequal_filter::galgasRTTI (void) const {
  return & gClassInfoFor__newisgreaterorequal_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_newisgreaterorequal_filter'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_newisgreaterorequal_filter::
GGS_newisgreaterorequal_filter (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_newisgreaterorequal_filter::
GGS_newisgreaterorequal_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_newisgreaterorequal_filter GGS_newisgreaterorequal_filter::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_newisgreaterorequal_filter _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_newisgreaterorequal_filter *> (inPointer) != NULL)
      : (typeid (cPtr_newisgreaterorequal_filter) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_newisgreaterorequal_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_newisgreaterorequal_filter),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_newisgreaterorequal_filter * gSingleton_newisgreaterorequal_filter = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_newisgreaterorequal_filter (void) {
  macroDetachPointer (gSingleton_newisgreaterorequal_filter, cPtr_newisgreaterorequal_filter) ;
}

//---------------------------------------------------------------------------*

GGS_newisgreaterorequal_filter GGS_newisgreaterorequal_filter::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_newisgreaterorequal_filter result ;
  if (NULL == gSingleton_newisgreaterorequal_filter) {
    macroMyNew (gSingleton_newisgreaterorequal_filter, cPtr_newisgreaterorequal_filter (THERE)) ;
    registerReleaseRoutine (cleanUp_newisgreaterorequal_filter) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_newisgreaterorequal_filter) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_newisgreaterorequal_filter::actualTypeName (void) const {
  return "newisgreaterorequal_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__newisgreaterorequal_filter ("newisgreaterorequal_filter", gClassInfoFor__filter_prop_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_oneeveryn_filter'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_oneeveryn_filter::
cPtr_oneeveryn_filter (const GGS_luint64 & argument_0,
                                const GGS_luint64 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_filter_prop_obj (THERE),
period (argument_0),
offset (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_oneeveryn_filter * GGS_oneeveryn_filter::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_oneeveryn_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_oneeveryn_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_oneeveryn_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_oneeveryn_filter * _p = dynamic_cast <const cPtr_oneeveryn_filter *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = period._operator_isEqual (_p->period).boolValue ()
         && offset._operator_isEqual (_p->offset).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_oneeveryn_filter::
method_generate (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_f_res ;
  ::routine_retrieveTemplateString (_inLexique,  var_cas_f_res,  GGS_string (true, "filter_occurence") COMMA_SOURCE_FILE_AT_LINE (427)) ;
  var_cas_res = (var_cas_f_res)._operator_concat (var_cas_res) ;
  method_base_generate (_inLexique, var_cas_name, var_cas_res COMMA_SOURCE_FILE_AT_LINE (429)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$FILTERING_FUNC$"),  GGS_string (true, "tpl_filter_one_every_n") COMMA_SOURCE_FILE_AT_LINE (430)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$FILTER_KIND$"),  GGS_string (true, "One Every N") COMMA_SOURCE_FILE_AT_LINE (431)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$PERIOD$"),  period.reader_uint64 (_inLexique COMMA_SOURCE_FILE_AT_LINE (432)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (432)) COMMA_SOURCE_FILE_AT_LINE (432)) ;
  ::routine_doReplace (_inLexique,  var_cas_res,  GGS_string (true, "$OFFSET$"),  offset.reader_uint64 (_inLexique COMMA_SOURCE_FILE_AT_LINE (433)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (433)) COMMA_SOURCE_FILE_AT_LINE (433)) ;
}

//---------------------------------------------------------------------------*

void cPtr_oneeveryn_filter::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@oneeveryn_filter:"
           << period.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << offset.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_oneeveryn_filter::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_oneeveryn_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_oneeveryn_filter (& typeid (cPtr_oneeveryn_filter), & typeid (cPtr_filter_prop_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_oneeveryn_filter::galgasRTTI (void) const {
  return & gClassInfoFor__oneeveryn_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_oneeveryn_filter'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_oneeveryn_filter::
GGS_oneeveryn_filter (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_oneeveryn_filter::
GGS_oneeveryn_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_oneeveryn_filter GGS_oneeveryn_filter::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_oneeveryn_filter _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_oneeveryn_filter *> (inPointer) != NULL)
      : (typeid (cPtr_oneeveryn_filter) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_oneeveryn_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_oneeveryn_filter),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_oneeveryn_filter GGS_oneeveryn_filter::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint64 & argument_0,
                 const GGS_luint64 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_oneeveryn_filter result ;
  macroMyNew (result.mPointer, cPtr_oneeveryn_filter (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_oneeveryn_filter::
reader_period (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_oneeveryn_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_oneeveryn_filter *) mPointer)->period ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_oneeveryn_filter::
reader_offset (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_oneeveryn_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_oneeveryn_filter *) mPointer)->offset ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_oneeveryn_filter::actualTypeName (void) const {
  return "oneeveryn_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__oneeveryn_filter ("oneeveryn_filter", gClassInfoFor__filter_prop_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_link_obj'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_link_obj::
cPtr_link_obj (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
loc (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_link_obj * GGS_link_obj::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_link_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_link_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_link_obj::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@link_obj:"
           << loc.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_link_obj::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_link_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_link_obj (& typeid (cPtr_link_obj), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_link_obj::galgasRTTI (void) const {
  return & gClassInfoFor__link_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_link_obj'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_link_obj::
GGS_link_obj (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_link_obj::
GGS_link_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_link_obj GGS_link_obj::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_link_obj _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_link_obj *> (inPointer) != NULL)
      : (typeid (cPtr_link_obj) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_link_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_link_obj),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_link_obj::
reader_loc (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_link_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_link_obj *) mPointer)->loc ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_link_obj::actualTypeName (void) const {
  return "link_obj" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_link_obj::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__link_obj ("link_obj") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_void_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_void_mess_prop::
cPtr_void_mess_prop (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_void_mess_prop * GGS_void_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_void_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_void_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_void_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_void_mess_prop * _p = dynamic_cast <const cPtr_void_mess_prop *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = location._operator_isEqual (_p->location).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_void_mess_prop::
method_s_mess (C_Compiler & _inLexique,
                                GGS_lstring & var_cas_sd COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_sd = GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_void_mess_prop::
method_generate (C_Compiler & /* _inLexique */,
                                GGS_lstring  /* var_cas_name */,
                                GGS_base_mess  /* var_cas_mess */,
                                GGS_message_map  /* var_cas_messages */,
                                GGS_ident_list_map  /* var_cas_dests */,
                                GGS_string& var_cas_h_res,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_h_res = GGS_string (true, "") ;
  var_cas_i_res = GGS_string (true, "") ;
}

//---------------------------------------------------------------------------*

void cPtr_void_mess_prop::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@void_mess_prop:"
           << location.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_void_mess_prop::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_void_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_void_mess_prop (& typeid (cPtr_void_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_void_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__void_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_void_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_void_mess_prop::
GGS_void_mess_prop (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_void_mess_prop::
GGS_void_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_void_mess_prop GGS_void_mess_prop::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_void_mess_prop _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_void_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_void_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_void_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_void_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_void_mess_prop GGS_void_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_void_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_void_mess_prop (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_void_mess_prop::actualTypeName (void) const {
  return "void_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__void_mess_prop ("void_mess_prop", gClassInfoFor__mess_prop_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_ssi_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ssi_mess_prop::
cPtr_ssi_mess_prop (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
cdatatype (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ssi_mess_prop * GGS_ssi_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ssi_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ssi_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ssi_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ssi_mess_prop * _p = dynamic_cast <const cPtr_ssi_mess_prop *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = location._operator_isEqual (_p->location).boolValue ()
         && cdatatype._operator_isEqual (_p->cdatatype).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ssi_mess_prop::
method_s_mess (C_Compiler & _inLexique,
                                GGS_lstring & var_cas_sd COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_sd = GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_ssi_mess_prop::
method_generate (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_base_mess  /* var_cas_mess */,
                                GGS_message_map  /* var_cas_messages */,
                                GGS_ident_list_map  var_cas_dests,
                                GGS_string& var_cas_h_res,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_h_res = GGS_string (true, "") ;
  ::routine_retrieveTemplateString (_inLexique,  var_cas_i_res,  GGS_string (true, "message_ssi") COMMA_SOURCE_FILE_AT_LINE (467)) ;
  ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$MESSAGE_NAME$"),  var_cas_name.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (468)) COMMA_SOURCE_FILE_AT_LINE (468)) ;
  ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$MESSAGE$"),  (var_cas_name.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (469)))._operator_concat (GGS_string (true, "_message")) COMMA_SOURCE_FILE_AT_LINE (469)) ;
  if ((var_cas_dests.reader_hasKey (_inLexique, var_cas_name.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (470)) COMMA_SOURCE_FILE_AT_LINE (470))).isBuiltAndTrue ()) {
    GGS_ident_list  var_cas_d_mess_list ;
    const GGS_ident_list_map  _temp_14165 = var_cas_dests ;
    if (_temp_14165._isBuilt ()) {
      _temp_14165 (HERE)->method_get (_inLexique, var_cas_name, var_cas_d_mess_list COMMA_SOURCE_FILE_AT_LINE (472)) ;
    }
    GGS_lstring  var_cas_target ;
    const GGS_ident_list  _temp_14248 = var_cas_d_mess_list ;
    if (_temp_14248._isBuilt ()) {
      _temp_14248 (HERE)->method_first (_inLexique, var_cas_target COMMA_SOURCE_FILE_AT_LINE (474)) ;
    }
    ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$TARGET$"),  (var_cas_target.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (475)))._operator_concat (GGS_string (true, "_message")) COMMA_SOURCE_FILE_AT_LINE (475)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ssi_mess_prop::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ssi_mess_prop:"
           << location.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << cdatatype.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ssi_mess_prop::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ssi_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ssi_mess_prop (& typeid (cPtr_ssi_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ssi_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__ssi_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_ssi_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ssi_mess_prop::
GGS_ssi_mess_prop (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ssi_mess_prop::
GGS_ssi_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ssi_mess_prop GGS_ssi_mess_prop::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ssi_mess_prop _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ssi_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_ssi_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ssi_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ssi_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ssi_mess_prop GGS_ssi_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_ssi_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_ssi_mess_prop (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_ssi_mess_prop::
reader_cdatatype (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ssi_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ssi_mess_prop *) mPointer)->cdatatype ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ssi_mess_prop::actualTypeName (void) const {
  return "ssi_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ssi_mess_prop ("ssi_mess_prop", gClassInfoFor__mess_prop_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_sse_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sse_mess_prop::
cPtr_sse_mess_prop (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_filter_prop_obj & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_basic_type & argument_6,
                                const GGS_lstring & argument_7
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
cdatatype (argument_1),
tranferproperty (argument_2),
filter (argument_3),
networkordercallout (argument_4),
cpuordercallout (argument_5),
initialvalue (argument_6),
networkmessage (argument_7) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sse_mess_prop * GGS_sse_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sse_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_sse_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sse_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sse_mess_prop * _p = dynamic_cast <const cPtr_sse_mess_prop *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = location._operator_isEqual (_p->location).boolValue ()
         && cdatatype._operator_isEqual (_p->cdatatype).boolValue ()
         && tranferproperty._operator_isEqual (_p->tranferproperty).boolValue ()
         && filter._operator_isEqual (_p->filter).boolValue ()
         && networkordercallout._operator_isEqual (_p->networkordercallout).boolValue ()
         && cpuordercallout._operator_isEqual (_p->cpuordercallout).boolValue ()
         && initialvalue._operator_isEqual (_p->initialvalue).boolValue ()
         && networkmessage._operator_isEqual (_p->networkmessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sse_mess_prop::
method_s_mess (C_Compiler & _inLexique,
                                GGS_lstring & var_cas_sd COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_sd = GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_sse_mess_prop::
method_generate (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_base_mess  /* var_cas_mess */,
                                GGS_message_map  /* var_cas_messages */,
                                GGS_ident_list_map  /* var_cas_dests */,
                                GGS_string& var_cas_h_res,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_h_res = GGS_string (true, "") ;
  ::routine_retrieveTemplateString (_inLexique,  var_cas_i_res,  GGS_string (true, "message_sse") COMMA_SOURCE_FILE_AT_LINE (498)) ;
  ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$MESSAGE_NAME$"),  var_cas_name.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (499)) COMMA_SOURCE_FILE_AT_LINE (499)) ;
  ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$MESSAGE$"),  (var_cas_name.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (500)))._operator_concat (GGS_string (true, "_message")) COMMA_SOURCE_FILE_AT_LINE (500)) ;
  ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$NETWORKMESSAGE$"),  (networkmessage.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (501)))._operator_concat (GGS_string (true, "_net_message")) COMMA_SOURCE_FILE_AT_LINE (501)) ;
  ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$BUFFER$"),  (var_cas_name.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (502)))._operator_concat (GGS_string (true, "_buffer")) COMMA_SOURCE_FILE_AT_LINE (502)) ;
  if (((tranferproperty.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (503)))._operator_isNotEqual (GGS_string (true, "triggered"))).isBuiltAndTrue ()) {
    tranferproperty.reader_location (_inLexique COMMA_HERE).signalGGSSemanticWarning (_inLexique, GGS_string (true, "Only TRIGGERED transfer property is supported in this version") COMMA_SOURCE_FILE_AT_LINE (504)) ;
  }
  ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$CTYPE$"),  cdatatype.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (506)) COMMA_SOURCE_FILE_AT_LINE (506)) ;
  GGS_string var_cas_iv ;
  const GGS_basic_type  _temp_15789 = initialvalue ;
  if (_temp_15789._isBuilt ()) {
    _temp_15789 (HERE)->method_string (_inLexique, var_cas_iv COMMA_SOURCE_FILE_AT_LINE (512)) ;
  }
  if (((var_cas_iv)._operator_isNotEqual (GGS_string (true, ""))).isBuiltAndTrue ()) {
    var_cas_iv = (GGS_string (true, " = "))._operator_concat (var_cas_iv) ;
  }
  ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$INITIALVALUE$"),  var_cas_iv COMMA_SOURCE_FILE_AT_LINE (514)) ;
}

//---------------------------------------------------------------------------*

void cPtr_sse_mess_prop::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@sse_mess_prop:"
           << location.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << cdatatype.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << tranferproperty.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << filter.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << networkordercallout.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << cpuordercallout.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << initialvalue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << networkmessage.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sse_mess_prop::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sse_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sse_mess_prop (& typeid (cPtr_sse_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_sse_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__sse_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_sse_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sse_mess_prop::
GGS_sse_mess_prop (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sse_mess_prop::
GGS_sse_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_sse_mess_prop GGS_sse_mess_prop::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sse_mess_prop _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sse_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_sse_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_sse_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sse_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_sse_mess_prop GGS_sse_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_filter_prop_obj & argument_3,
                 const GGS_lstring & argument_4,
                 const GGS_lstring & argument_5,
                 const GGS_basic_type & argument_6,
                 const GGS_lstring & argument_7
                                COMMA_LOCATION_ARGS) {
  GGS_sse_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_sse_mess_prop (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sse_mess_prop::
reader_cdatatype (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sse_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sse_mess_prop *) mPointer)->cdatatype ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sse_mess_prop::
reader_tranferproperty (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sse_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sse_mess_prop *) mPointer)->tranferproperty ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filter_prop_obj  GGS_sse_mess_prop::
reader_filter (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_filter_prop_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sse_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sse_mess_prop *) mPointer)->filter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sse_mess_prop::
reader_networkordercallout (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sse_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sse_mess_prop *) mPointer)->networkordercallout ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sse_mess_prop::
reader_cpuordercallout (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sse_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sse_mess_prop *) mPointer)->cpuordercallout ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_sse_mess_prop::
reader_initialvalue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sse_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sse_mess_prop *) mPointer)->initialvalue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sse_mess_prop::
reader_networkmessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sse_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sse_mess_prop *) mPointer)->networkmessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sse_mess_prop::actualTypeName (void) const {
  return "sse_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__sse_mess_prop ("sse_mess_prop", gClassInfoFor__mess_prop_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_sde_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sde_mess_prop::
cPtr_sde_mess_prop (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_basic_type & argument_4,
                                const GGS_lstring & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
tranferproperty (argument_1),
networkordercallout (argument_2),
cpuordercallout (argument_3),
initialvalue (argument_4),
networkmessage (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sde_mess_prop * GGS_sde_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sde_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_sde_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sde_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sde_mess_prop * _p = dynamic_cast <const cPtr_sde_mess_prop *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = location._operator_isEqual (_p->location).boolValue ()
         && tranferproperty._operator_isEqual (_p->tranferproperty).boolValue ()
         && networkordercallout._operator_isEqual (_p->networkordercallout).boolValue ()
         && cpuordercallout._operator_isEqual (_p->cpuordercallout).boolValue ()
         && initialvalue._operator_isEqual (_p->initialvalue).boolValue ()
         && networkmessage._operator_isEqual (_p->networkmessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sde_mess_prop::
method_s_mess (C_Compiler & _inLexique,
                                GGS_lstring & var_cas_sd COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_sd = GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_sde_mess_prop::
method_generate (C_Compiler & /* _inLexique */,
                                GGS_lstring  /* var_cas_name */,
                                GGS_base_mess  /* var_cas_mess */,
                                GGS_message_map  /* var_cas_messages */,
                                GGS_ident_list_map  /* var_cas_dests */,
                                GGS_string& var_cas_h_res,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_h_res = GGS_string (true, "") ;
  var_cas_i_res = GGS_string (true, "") ;
}

//---------------------------------------------------------------------------*

void cPtr_sde_mess_prop::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@sde_mess_prop:"
           << location.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << tranferproperty.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << networkordercallout.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << cpuordercallout.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << initialvalue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << networkmessage.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sde_mess_prop::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sde_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sde_mess_prop (& typeid (cPtr_sde_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_sde_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__sde_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_sde_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sde_mess_prop::
GGS_sde_mess_prop (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sde_mess_prop::
GGS_sde_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_sde_mess_prop GGS_sde_mess_prop::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sde_mess_prop _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sde_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_sde_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_sde_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sde_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_sde_mess_prop GGS_sde_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_basic_type & argument_4,
                 const GGS_lstring & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_sde_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_sde_mess_prop (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sde_mess_prop::
reader_tranferproperty (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sde_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sde_mess_prop *) mPointer)->tranferproperty ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sde_mess_prop::
reader_networkordercallout (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sde_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sde_mess_prop *) mPointer)->networkordercallout ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sde_mess_prop::
reader_cpuordercallout (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sde_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sde_mess_prop *) mPointer)->cpuordercallout ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_sde_mess_prop::
reader_initialvalue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sde_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sde_mess_prop *) mPointer)->initialvalue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sde_mess_prop::
reader_networkmessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sde_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sde_mess_prop *) mPointer)->networkmessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sde_mess_prop::actualTypeName (void) const {
  return "sde_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__sde_mess_prop ("sde_mess_prop", gClassInfoFor__mess_prop_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_szi_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_szi_mess_prop::
cPtr_szi_mess_prop (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_szi_mess_prop * GGS_szi_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_szi_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_szi_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_szi_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_szi_mess_prop * _p = dynamic_cast <const cPtr_szi_mess_prop *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = location._operator_isEqual (_p->location).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_szi_mess_prop::
method_s_mess (C_Compiler & _inLexique,
                                GGS_lstring & var_cas_sd COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_sd = GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_szi_mess_prop::
method_generate (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_base_mess  /* var_cas_mess */,
                                GGS_message_map  /* var_cas_messages */,
                                GGS_ident_list_map  var_cas_dests,
                                GGS_string& var_cas_h_res,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_h_res = GGS_string (true, "") ;
  ::routine_retrieveTemplateString (_inLexique,  var_cas_i_res,  GGS_string (true, "message_szi") COMMA_SOURCE_FILE_AT_LINE (549)) ;
  ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$MESSAGE_NAME$"),  var_cas_name.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (550)) COMMA_SOURCE_FILE_AT_LINE (550)) ;
  ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$MESSAGE$"),  (var_cas_name.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (551)))._operator_concat (GGS_string (true, "_message")) COMMA_SOURCE_FILE_AT_LINE (551)) ;
  if ((var_cas_dests.reader_hasKey (_inLexique, var_cas_name.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (552)) COMMA_SOURCE_FILE_AT_LINE (552))).isBuiltAndTrue ()) {
    GGS_ident_list  var_cas_d_mess_list ;
    const GGS_ident_list_map  _temp_17201 = var_cas_dests ;
    if (_temp_17201._isBuilt ()) {
      _temp_17201 (HERE)->method_get (_inLexique, var_cas_name, var_cas_d_mess_list COMMA_SOURCE_FILE_AT_LINE (554)) ;
    }
    GGS_lstring  var_cas_target ;
    const GGS_ident_list  _temp_17284 = var_cas_d_mess_list ;
    if (_temp_17284._isBuilt ()) {
      _temp_17284 (HERE)->method_first (_inLexique, var_cas_target COMMA_SOURCE_FILE_AT_LINE (556)) ;
    }
    ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$TARGET$"),  (var_cas_target.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (557)))._operator_concat (GGS_string (true, "_message")) COMMA_SOURCE_FILE_AT_LINE (557)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_szi_mess_prop::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@szi_mess_prop:"
           << location.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_szi_mess_prop::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_szi_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_szi_mess_prop (& typeid (cPtr_szi_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_szi_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__szi_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_szi_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_szi_mess_prop::
GGS_szi_mess_prop (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_szi_mess_prop::
GGS_szi_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_szi_mess_prop GGS_szi_mess_prop::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_szi_mess_prop _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_szi_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_szi_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_szi_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_szi_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_szi_mess_prop GGS_szi_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_szi_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_szi_mess_prop (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_szi_mess_prop::actualTypeName (void) const {
  return "szi_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__szi_mess_prop ("szi_mess_prop", gClassInfoFor__mess_prop_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_sze_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sze_mess_prop::
cPtr_sze_mess_prop (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
networkordercallout (argument_1),
cpuordercallout (argument_2),
networkmessage (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sze_mess_prop * GGS_sze_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sze_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_sze_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sze_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sze_mess_prop * _p = dynamic_cast <const cPtr_sze_mess_prop *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = location._operator_isEqual (_p->location).boolValue ()
         && networkordercallout._operator_isEqual (_p->networkordercallout).boolValue ()
         && cpuordercallout._operator_isEqual (_p->cpuordercallout).boolValue ()
         && networkmessage._operator_isEqual (_p->networkmessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sze_mess_prop::
method_s_mess (C_Compiler & _inLexique,
                                GGS_lstring & var_cas_sd COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_sd = GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_sze_mess_prop::
method_generate (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_base_mess  /* var_cas_mess */,
                                GGS_message_map  /* var_cas_messages */,
                                GGS_ident_list_map  /* var_cas_dests */,
                                GGS_string& var_cas_h_res,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_h_res = GGS_string (true, "") ;
  ::routine_retrieveTemplateString (_inLexique,  var_cas_i_res,  GGS_string (true, "message_sze") COMMA_SOURCE_FILE_AT_LINE (576)) ;
  ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$MESSAGE_NAME$"),  var_cas_name.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (577)) COMMA_SOURCE_FILE_AT_LINE (577)) ;
  ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$MESSAGE$"),  (var_cas_name.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (578)))._operator_concat (GGS_string (true, "_message")) COMMA_SOURCE_FILE_AT_LINE (578)) ;
  ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$NETWORKMESSAGE$"),  (networkmessage.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (579)))._operator_concat (GGS_string (true, "_net_message")) COMMA_SOURCE_FILE_AT_LINE (579)) ;
}

//---------------------------------------------------------------------------*

void cPtr_sze_mess_prop::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@sze_mess_prop:"
           << location.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << networkordercallout.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << cpuordercallout.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << networkmessage.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sze_mess_prop::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sze_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sze_mess_prop (& typeid (cPtr_sze_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_sze_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__sze_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_sze_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sze_mess_prop::
GGS_sze_mess_prop (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sze_mess_prop::
GGS_sze_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_sze_mess_prop GGS_sze_mess_prop::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sze_mess_prop _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sze_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_sze_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_sze_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sze_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_sze_mess_prop GGS_sze_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_sze_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_sze_mess_prop (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sze_mess_prop::
reader_networkordercallout (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sze_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sze_mess_prop *) mPointer)->networkordercallout ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sze_mess_prop::
reader_cpuordercallout (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sze_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sze_mess_prop *) mPointer)->cpuordercallout ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sze_mess_prop::
reader_networkmessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sze_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sze_mess_prop *) mPointer)->networkmessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sze_mess_prop::actualTypeName (void) const {
  return "sze_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__sze_mess_prop ("sze_mess_prop", gClassInfoFor__mess_prop_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_rzi_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_rzi_mess_prop::
cPtr_rzi_mess_prop (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
sendingmessage (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_rzi_mess_prop * GGS_rzi_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rzi_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_rzi_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_rzi_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_rzi_mess_prop * _p = dynamic_cast <const cPtr_rzi_mess_prop *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = location._operator_isEqual (_p->location).boolValue ()
         && sendingmessage._operator_isEqual (_p->sendingmessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_rzi_mess_prop::
method_s_mess (C_Compiler & /* _inLexique */,
                                GGS_lstring & var_cas_sd COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_sd = sendingmessage ;
}

//---------------------------------------------------------------------------*

void cPtr_rzi_mess_prop::
method_generate (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_base_mess  var_cas_mess,
                                GGS_message_map  /* var_cas_messages */,
                                GGS_ident_list_map  var_cas_dests,
                                GGS_string& var_cas_h_res,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_h_res = GGS_string (true, "") ;
  ::routine_retrieveTemplateString (_inLexique,  var_cas_i_res,  GGS_string (true, "message_rzi") COMMA_SOURCE_FILE_AT_LINE (595)) ;
  ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$MESSAGE_NAME$"),  var_cas_name.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (596)) COMMA_SOURCE_FILE_AT_LINE (596)) ;
  ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$MESSAGE$"),  (var_cas_name.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (597)))._operator_concat (GGS_string (true, "_message")) COMMA_SOURCE_FILE_AT_LINE (597)) ;
  method_generate_notif (_inLexique, var_cas_name, var_cas_mess, var_cas_h_res, var_cas_i_res COMMA_SOURCE_FILE_AT_LINE (600)) ;
  method_generate_dest_list (_inLexique, var_cas_name, sendingmessage, var_cas_dests, var_cas_i_res COMMA_SOURCE_FILE_AT_LINE (603)) ;
}

//---------------------------------------------------------------------------*

void cPtr_rzi_mess_prop::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@rzi_mess_prop:"
           << location.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << sendingmessage.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_rzi_mess_prop::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_rzi_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_rzi_mess_prop (& typeid (cPtr_rzi_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_rzi_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__rzi_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_rzi_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_rzi_mess_prop::
GGS_rzi_mess_prop (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_rzi_mess_prop::
GGS_rzi_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_rzi_mess_prop GGS_rzi_mess_prop::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_rzi_mess_prop _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_rzi_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_rzi_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_rzi_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_rzi_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_rzi_mess_prop GGS_rzi_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_rzi_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_rzi_mess_prop (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_rzi_mess_prop::
reader_sendingmessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rzi_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rzi_mess_prop *) mPointer)->sendingmessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_rzi_mess_prop::actualTypeName (void) const {
  return "rzi_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__rzi_mess_prop ("rzi_mess_prop", gClassInfoFor__mess_prop_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_rze_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_rze_mess_prop::
cPtr_rze_mess_prop (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
networkordercallout (argument_1),
cpuordercallout (argument_2),
networkmessage (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_rze_mess_prop * GGS_rze_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rze_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_rze_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_rze_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_rze_mess_prop * _p = dynamic_cast <const cPtr_rze_mess_prop *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = location._operator_isEqual (_p->location).boolValue ()
         && networkordercallout._operator_isEqual (_p->networkordercallout).boolValue ()
         && cpuordercallout._operator_isEqual (_p->cpuordercallout).boolValue ()
         && networkmessage._operator_isEqual (_p->networkmessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_rze_mess_prop::
method_s_mess (C_Compiler & _inLexique,
                                GGS_lstring & var_cas_sd COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_sd = GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_rze_mess_prop::
method_generate (C_Compiler & /* _inLexique */,
                                GGS_lstring  /* var_cas_name */,
                                GGS_base_mess  /* var_cas_mess */,
                                GGS_message_map  /* var_cas_messages */,
                                GGS_ident_list_map  /* var_cas_dests */,
                                GGS_string& var_cas_h_res,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_h_res = GGS_string (true, "") ;
  var_cas_i_res = GGS_string (true, "") ;
}

//---------------------------------------------------------------------------*

void cPtr_rze_mess_prop::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@rze_mess_prop:"
           << location.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << networkordercallout.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << cpuordercallout.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << networkmessage.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_rze_mess_prop::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_rze_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_rze_mess_prop (& typeid (cPtr_rze_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_rze_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__rze_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_rze_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_rze_mess_prop::
GGS_rze_mess_prop (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_rze_mess_prop::
GGS_rze_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_rze_mess_prop GGS_rze_mess_prop::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_rze_mess_prop _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_rze_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_rze_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_rze_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_rze_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_rze_mess_prop GGS_rze_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_rze_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_rze_mess_prop (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_rze_mess_prop::
reader_networkordercallout (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rze_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rze_mess_prop *) mPointer)->networkordercallout ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_rze_mess_prop::
reader_cpuordercallout (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rze_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rze_mess_prop *) mPointer)->cpuordercallout ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_rze_mess_prop::
reader_networkmessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rze_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rze_mess_prop *) mPointer)->networkmessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_rze_mess_prop::actualTypeName (void) const {
  return "rze_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__rze_mess_prop ("rze_mess_prop", gClassInfoFor__mess_prop_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_rui_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_rui_mess_prop::
cPtr_rui_mess_prop (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_filter_prop_obj & argument_2,
                                const GGS_basic_type & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
sendingmessage (argument_1),
filter (argument_2),
initialvalue (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_rui_mess_prop * GGS_rui_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rui_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_rui_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_rui_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_rui_mess_prop * _p = dynamic_cast <const cPtr_rui_mess_prop *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = location._operator_isEqual (_p->location).boolValue ()
         && sendingmessage._operator_isEqual (_p->sendingmessage).boolValue ()
         && filter._operator_isEqual (_p->filter).boolValue ()
         && initialvalue._operator_isEqual (_p->initialvalue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_rui_mess_prop::
method_s_mess (C_Compiler & /* _inLexique */,
                                GGS_lstring & var_cas_sd COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_sd = sendingmessage ;
}

//---------------------------------------------------------------------------*

void cPtr_rui_mess_prop::
method_generate (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_base_mess  var_cas_mess,
                                GGS_message_map  var_cas_messages,
                                GGS_ident_list_map  var_cas_dests,
                                GGS_string& var_cas_h_res,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_h_res = GGS_string (true, "") ;
  ::routine_retrieveTemplateString (_inLexique,  var_cas_i_res,  GGS_string (true, "message_rui") COMMA_SOURCE_FILE_AT_LINE (640)) ;
  ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$MESSAGE_NAME$"),  var_cas_name.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (641)) COMMA_SOURCE_FILE_AT_LINE (641)) ;
  ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$MESSAGE$"),  (var_cas_name.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (642)))._operator_concat (GGS_string (true, "_message")) COMMA_SOURCE_FILE_AT_LINE (642)) ;
  ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$BUFFER$"),  (var_cas_name.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (643)))._operator_concat (GGS_string (true, "_buffer")) COMMA_SOURCE_FILE_AT_LINE (643)) ;
  const GGS_filter_prop_obj  _temp_20343 = filter ;
  if (_temp_20343._isBuilt ()) {
    _temp_20343 (HERE)->method_generate (_inLexique, var_cas_name, var_cas_i_res COMMA_SOURCE_FILE_AT_LINE (646)) ;
  }
  method_generate_notif (_inLexique, var_cas_name, var_cas_mess, var_cas_h_res, var_cas_i_res COMMA_SOURCE_FILE_AT_LINE (649)) ;
  method_generate_dest_list (_inLexique, var_cas_name, sendingmessage, var_cas_dests, var_cas_i_res COMMA_SOURCE_FILE_AT_LINE (652)) ;
  GGS_message_obj  var_cas_sender ;
  const GGS_message_map  _temp_20696 = var_cas_messages ;
  if (_temp_20696._isBuilt ()) {
    _temp_20696 (HERE)->method_get (_inLexique, sendingmessage, var_cas_sender COMMA_SOURCE_FILE_AT_LINE (656)) ;
  }
  GGS_mess_prop_obj  var_cas_prop ;
  var_cas_prop = var_cas_sender.reader_messageproperty (_inLexique COMMA_SOURCE_FILE_AT_LINE (657)) ;
  { const GGS_mess_prop_obj _var_21253 = var_cas_prop ; // CAST instruction
    if (_var_21253.getPtr () != NULL) {
      macroValidPointer (_var_21253.getPtr ()) ;
      if (typeid (cPtr_ssi_mess_prop) == typeid (* (_var_21253.getPtr ()))) {
        const GGS_ssi_mess_prop var_cas_ssi (_var_21253.getPtr ()) ;
        ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$CTYPE$"),  var_cas_ssi.reader_cdatatype (_inLexique COMMA_SOURCE_FILE_AT_LINE (660)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (660)) COMMA_SOURCE_FILE_AT_LINE (660)) ;
        ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$SIZE$"),  ((GGS_string (true, "sizeof("))._operator_concat (var_cas_ssi.reader_cdatatype (_inLexique COMMA_SOURCE_FILE_AT_LINE (661)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (661))))._operator_concat (GGS_string (true, ")")) COMMA_SOURCE_FILE_AT_LINE (661)) ;
        GGS_string var_cas_iv ;
        const GGS_basic_type  _temp_21047 = initialvalue ;
        if (_temp_21047._isBuilt ()) {
          _temp_21047 (HERE)->method_string (_inLexique, var_cas_iv COMMA_SOURCE_FILE_AT_LINE (663)) ;
        }
        if (((var_cas_iv)._operator_isNotEqual (GGS_string (true, ""))).isBuiltAndTrue ()) {
          var_cas_iv = (GGS_string (true, " = "))._operator_concat (var_cas_iv) ;
        }
        ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$INITIALVALUE$"),  var_cas_iv COMMA_SOURCE_FILE_AT_LINE (665)) ;
      }else{
        GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "Incompatible sending message object") COMMA_SOURCE_FILE_AT_LINE (668)) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_rui_mess_prop::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@rui_mess_prop:"
           << location.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << sendingmessage.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << filter.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << initialvalue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_rui_mess_prop::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_rui_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_rui_mess_prop (& typeid (cPtr_rui_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_rui_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__rui_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_rui_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_rui_mess_prop::
GGS_rui_mess_prop (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_rui_mess_prop::
GGS_rui_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_rui_mess_prop GGS_rui_mess_prop::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_rui_mess_prop _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_rui_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_rui_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_rui_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_rui_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_rui_mess_prop GGS_rui_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_filter_prop_obj & argument_2,
                 const GGS_basic_type & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_rui_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_rui_mess_prop (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_rui_mess_prop::
reader_sendingmessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rui_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rui_mess_prop *) mPointer)->sendingmessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filter_prop_obj  GGS_rui_mess_prop::
reader_filter (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_filter_prop_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rui_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rui_mess_prop *) mPointer)->filter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_rui_mess_prop::
reader_initialvalue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rui_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rui_mess_prop *) mPointer)->initialvalue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_rui_mess_prop::actualTypeName (void) const {
  return "rui_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__rui_mess_prop ("rui_mess_prop", gClassInfoFor__mess_prop_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_rqi_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_rqi_mess_prop::
cPtr_rqi_mess_prop (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_filter_prop_obj & argument_2,
                                const GGS_basic_type & argument_3,
                                const GGS_luint64 & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
sendingmessage (argument_1),
filter (argument_2),
initialvalue (argument_3),
queuesize (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_rqi_mess_prop * GGS_rqi_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rqi_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_rqi_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_rqi_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_rqi_mess_prop * _p = dynamic_cast <const cPtr_rqi_mess_prop *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = location._operator_isEqual (_p->location).boolValue ()
         && sendingmessage._operator_isEqual (_p->sendingmessage).boolValue ()
         && filter._operator_isEqual (_p->filter).boolValue ()
         && initialvalue._operator_isEqual (_p->initialvalue).boolValue ()
         && queuesize._operator_isEqual (_p->queuesize).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_rqi_mess_prop::
method_s_mess (C_Compiler & /* _inLexique */,
                                GGS_lstring & var_cas_sd COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_sd = sendingmessage ;
}

//---------------------------------------------------------------------------*

void cPtr_rqi_mess_prop::
method_generate (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_base_mess  var_cas_mess,
                                GGS_message_map  var_cas_messages,
                                GGS_ident_list_map  var_cas_dests,
                                GGS_string& var_cas_h_res,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_h_res = GGS_string (true, "") ;
  ::routine_retrieveTemplateString (_inLexique,  var_cas_i_res,  GGS_string (true, "message_rqi") COMMA_SOURCE_FILE_AT_LINE (687)) ;
  ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$MESSAGE_NAME$"),  var_cas_name.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (688)) COMMA_SOURCE_FILE_AT_LINE (688)) ;
  ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$MESSAGE$"),  (var_cas_name.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (689)))._operator_concat (GGS_string (true, "_message")) COMMA_SOURCE_FILE_AT_LINE (689)) ;
  ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$BUFFER$"),  (var_cas_name.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (690)))._operator_concat (GGS_string (true, "_buffer")) COMMA_SOURCE_FILE_AT_LINE (690)) ;
  const GGS_filter_prop_obj  _temp_22079 = filter ;
  if (_temp_22079._isBuilt ()) {
    _temp_22079 (HERE)->method_generate (_inLexique, var_cas_name, var_cas_i_res COMMA_SOURCE_FILE_AT_LINE (693)) ;
  }
  method_generate_notif (_inLexique, var_cas_name, var_cas_mess, var_cas_h_res, var_cas_i_res COMMA_SOURCE_FILE_AT_LINE (696)) ;
  method_generate_dest_list (_inLexique, var_cas_name, sendingmessage, var_cas_dests, var_cas_i_res COMMA_SOURCE_FILE_AT_LINE (699)) ;
  GGS_message_obj  var_cas_sender ;
  const GGS_message_map  _temp_22432 = var_cas_messages ;
  if (_temp_22432._isBuilt ()) {
    _temp_22432 (HERE)->method_get (_inLexique, sendingmessage, var_cas_sender COMMA_SOURCE_FILE_AT_LINE (703)) ;
  }
  GGS_mess_prop_obj  var_cas_prop ;
  var_cas_prop = var_cas_sender.reader_messageproperty (_inLexique COMMA_SOURCE_FILE_AT_LINE (704)) ;
  { const GGS_mess_prop_obj _var_22734 = var_cas_prop ; // CAST instruction
    if (_var_22734.getPtr () != NULL) {
      macroValidPointer (_var_22734.getPtr ()) ;
      if (typeid (cPtr_ssi_mess_prop) == typeid (* (_var_22734.getPtr ()))) {
        const GGS_ssi_mess_prop var_cas_ssi (_var_22734.getPtr ()) ;
        ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$CTYPE$"),  var_cas_ssi.reader_cdatatype (_inLexique COMMA_SOURCE_FILE_AT_LINE (707)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (707)) COMMA_SOURCE_FILE_AT_LINE (707)) ;
      }else{
        GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "Incompatible sending message object") COMMA_SOURCE_FILE_AT_LINE (710)) ;
      }
    }
  }
  ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$QUEUE_SIZE$"),  queuesize.reader_uint64 (_inLexique COMMA_SOURCE_FILE_AT_LINE (713)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (713)) COMMA_SOURCE_FILE_AT_LINE (713)) ;
  ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$DYN_QUEUE$"),  (var_cas_name.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (716)))._operator_concat (GGS_string (true, "_dyn_queue")) COMMA_SOURCE_FILE_AT_LINE (716)) ;
}

//---------------------------------------------------------------------------*

void cPtr_rqi_mess_prop::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@rqi_mess_prop:"
           << location.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << sendingmessage.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << filter.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << initialvalue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << queuesize.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_rqi_mess_prop::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_rqi_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_rqi_mess_prop (& typeid (cPtr_rqi_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_rqi_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__rqi_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_rqi_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_rqi_mess_prop::
GGS_rqi_mess_prop (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_rqi_mess_prop::
GGS_rqi_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_rqi_mess_prop GGS_rqi_mess_prop::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_rqi_mess_prop _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_rqi_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_rqi_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_rqi_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_rqi_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_rqi_mess_prop GGS_rqi_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_filter_prop_obj & argument_2,
                 const GGS_basic_type & argument_3,
                 const GGS_luint64 & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_rqi_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_rqi_mess_prop (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_rqi_mess_prop::
reader_sendingmessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rqi_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rqi_mess_prop *) mPointer)->sendingmessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filter_prop_obj  GGS_rqi_mess_prop::
reader_filter (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_filter_prop_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rqi_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rqi_mess_prop *) mPointer)->filter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_rqi_mess_prop::
reader_initialvalue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rqi_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rqi_mess_prop *) mPointer)->initialvalue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_rqi_mess_prop::
reader_queuesize (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rqi_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rqi_mess_prop *) mPointer)->queuesize ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_rqi_mess_prop::actualTypeName (void) const {
  return "rqi_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__rqi_mess_prop ("rqi_mess_prop", gClassInfoFor__mess_prop_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_rue_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_rue_mess_prop::
cPtr_rue_mess_prop (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_filter_prop_obj & argument_2,
                                const GGS_link_obj & argument_3,
                                const GGS_basic_type & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
cdatatype (argument_1),
filter (argument_2),
link (argument_3),
initialvalue (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_rue_mess_prop * GGS_rue_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rue_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_rue_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_rue_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_rue_mess_prop * _p = dynamic_cast <const cPtr_rue_mess_prop *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = location._operator_isEqual (_p->location).boolValue ()
         && cdatatype._operator_isEqual (_p->cdatatype).boolValue ()
         && filter._operator_isEqual (_p->filter).boolValue ()
         && link._operator_isEqual (_p->link).boolValue ()
         && initialvalue._operator_isEqual (_p->initialvalue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_rue_mess_prop::
method_s_mess (C_Compiler & _inLexique,
                                GGS_lstring & var_cas_sd COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_sd = GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_rue_mess_prop::
method_generate (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_base_mess  var_cas_mess,
                                GGS_message_map  /* var_cas_messages */,
                                GGS_ident_list_map  /* var_cas_dests */,
                                GGS_string& var_cas_h_res,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_h_res = GGS_string (true, "") ;
  ::routine_retrieveTemplateString (_inLexique,  var_cas_i_res,  GGS_string (true, "message_rue") COMMA_SOURCE_FILE_AT_LINE (736)) ;
  ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$MESSAGE_NAME$"),  var_cas_name.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (737)) COMMA_SOURCE_FILE_AT_LINE (737)) ;
  ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$MESSAGE$"),  (var_cas_name.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (738)))._operator_concat (GGS_string (true, "_message")) COMMA_SOURCE_FILE_AT_LINE (738)) ;
  ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$BUFFER$"),  (var_cas_name.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (739)))._operator_concat (GGS_string (true, "_buffer")) COMMA_SOURCE_FILE_AT_LINE (739)) ;
  const GGS_filter_prop_obj  _temp_23793 = filter ;
  if (_temp_23793._isBuilt ()) {
    _temp_23793 (HERE)->method_generate (_inLexique, var_cas_name, var_cas_i_res COMMA_SOURCE_FILE_AT_LINE (742)) ;
  }
  method_generate_notif (_inLexique, var_cas_name, var_cas_mess, var_cas_h_res, var_cas_i_res COMMA_SOURCE_FILE_AT_LINE (745)) ;
  ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$CTYPE$"),  cdatatype.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (751)) COMMA_SOURCE_FILE_AT_LINE (751)) ;
  ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$SIZE$"),  ((GGS_string (true, "sizeof("))._operator_concat (cdatatype.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (752))))._operator_concat (GGS_string (true, ")")) COMMA_SOURCE_FILE_AT_LINE (752)) ;
  GGS_string var_cas_iv ;
  const GGS_basic_type  _temp_24287 = initialvalue ;
  if (_temp_24287._isBuilt ()) {
    _temp_24287 (HERE)->method_string (_inLexique, var_cas_iv COMMA_SOURCE_FILE_AT_LINE (754)) ;
  }
  if (((var_cas_iv)._operator_isNotEqual (GGS_string (true, ""))).isBuiltAndTrue ()) {
    var_cas_iv = (GGS_string (true, " = "))._operator_concat (var_cas_iv) ;
  }
  ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$INITIALVALUE$"),  var_cas_iv COMMA_SOURCE_FILE_AT_LINE (756)) ;
  ::routine_doReplace (_inLexique,  var_cas_i_res,  GGS_string (true, "$TARGET_PTR$"),  GGS_string (true, "NULL_PTR") COMMA_SOURCE_FILE_AT_LINE (757)) ;
}

//---------------------------------------------------------------------------*

void cPtr_rue_mess_prop::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@rue_mess_prop:"
           << location.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << cdatatype.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << filter.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << link.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << initialvalue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_rue_mess_prop::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_rue_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_rue_mess_prop (& typeid (cPtr_rue_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_rue_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__rue_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_rue_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_rue_mess_prop::
GGS_rue_mess_prop (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_rue_mess_prop::
GGS_rue_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_rue_mess_prop GGS_rue_mess_prop::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_rue_mess_prop _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_rue_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_rue_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_rue_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_rue_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_rue_mess_prop GGS_rue_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_filter_prop_obj & argument_2,
                 const GGS_link_obj & argument_3,
                 const GGS_basic_type & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_rue_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_rue_mess_prop (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_rue_mess_prop::
reader_cdatatype (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rue_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rue_mess_prop *) mPointer)->cdatatype ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filter_prop_obj  GGS_rue_mess_prop::
reader_filter (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_filter_prop_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rue_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rue_mess_prop *) mPointer)->filter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_link_obj  GGS_rue_mess_prop::
reader_link (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_link_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rue_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rue_mess_prop *) mPointer)->link ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_rue_mess_prop::
reader_initialvalue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rue_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rue_mess_prop *) mPointer)->initialvalue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_rue_mess_prop::actualTypeName (void) const {
  return "rue_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__rue_mess_prop ("rue_mess_prop", gClassInfoFor__mess_prop_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_rqe_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_rqe_mess_prop::
cPtr_rqe_mess_prop (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_luint64 & argument_2,
                                const GGS_filter_prop_obj & argument_3,
                                const GGS_link_obj & argument_4,
                                const GGS_basic_type & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
cdatatype (argument_1),
queuesize (argument_2),
filter (argument_3),
link (argument_4),
initialvalue (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_rqe_mess_prop * GGS_rqe_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rqe_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_rqe_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_rqe_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_rqe_mess_prop * _p = dynamic_cast <const cPtr_rqe_mess_prop *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = location._operator_isEqual (_p->location).boolValue ()
         && cdatatype._operator_isEqual (_p->cdatatype).boolValue ()
         && queuesize._operator_isEqual (_p->queuesize).boolValue ()
         && filter._operator_isEqual (_p->filter).boolValue ()
         && link._operator_isEqual (_p->link).boolValue ()
         && initialvalue._operator_isEqual (_p->initialvalue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_rqe_mess_prop::
method_s_mess (C_Compiler & _inLexique,
                                GGS_lstring & var_cas_sd COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_sd = GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_rqe_mess_prop::
method_generate (C_Compiler & /* _inLexique */,
                                GGS_lstring  /* var_cas_name */,
                                GGS_base_mess  /* var_cas_mess */,
                                GGS_message_map  /* var_cas_messages */,
                                GGS_ident_list_map  /* var_cas_dests */,
                                GGS_string& var_cas_h_res,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_h_res = GGS_string (true, "") ;
  var_cas_i_res = GGS_string (true, "") ;
}

//---------------------------------------------------------------------------*

void cPtr_rqe_mess_prop::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@rqe_mess_prop:"
           << location.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << cdatatype.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << queuesize.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << filter.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << link.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << initialvalue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_rqe_mess_prop::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_rqe_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_rqe_mess_prop (& typeid (cPtr_rqe_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_rqe_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__rqe_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_rqe_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_rqe_mess_prop::
GGS_rqe_mess_prop (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_rqe_mess_prop::
GGS_rqe_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_rqe_mess_prop GGS_rqe_mess_prop::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_rqe_mess_prop _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_rqe_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_rqe_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_rqe_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_rqe_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_rqe_mess_prop GGS_rqe_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_luint64 & argument_2,
                 const GGS_filter_prop_obj & argument_3,
                 const GGS_link_obj & argument_4,
                 const GGS_basic_type & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_rqe_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_rqe_mess_prop (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_rqe_mess_prop::
reader_cdatatype (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rqe_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rqe_mess_prop *) mPointer)->cdatatype ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_rqe_mess_prop::
reader_queuesize (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rqe_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rqe_mess_prop *) mPointer)->queuesize ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filter_prop_obj  GGS_rqe_mess_prop::
reader_filter (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_filter_prop_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rqe_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rqe_mess_prop *) mPointer)->filter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_link_obj  GGS_rqe_mess_prop::
reader_link (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_link_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rqe_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rqe_mess_prop *) mPointer)->link ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_rqe_mess_prop::
reader_initialvalue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rqe_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rqe_mess_prop *) mPointer)->initialvalue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_rqe_mess_prop::actualTypeName (void) const {
  return "rqe_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__rqe_mess_prop ("rqe_mess_prop", gClassInfoFor__mess_prop_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_rde_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_rde_mess_prop::
cPtr_rde_mess_prop (const GGS_location & argument_0,
                                const GGS_link_obj & argument_1,
                                const GGS_basic_type & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
link (argument_1),
initialvalue (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_rde_mess_prop * GGS_rde_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rde_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_rde_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_rde_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_rde_mess_prop * _p = dynamic_cast <const cPtr_rde_mess_prop *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = location._operator_isEqual (_p->location).boolValue ()
         && link._operator_isEqual (_p->link).boolValue ()
         && initialvalue._operator_isEqual (_p->initialvalue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_rde_mess_prop::
method_s_mess (C_Compiler & _inLexique,
                                GGS_lstring & var_cas_sd COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_sd = GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_rde_mess_prop::
method_generate (C_Compiler & /* _inLexique */,
                                GGS_lstring  /* var_cas_name */,
                                GGS_base_mess  /* var_cas_mess */,
                                GGS_message_map  /* var_cas_messages */,
                                GGS_ident_list_map  /* var_cas_dests */,
                                GGS_string& var_cas_h_res,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_h_res = GGS_string (true, "") ;
  var_cas_i_res = GGS_string (true, "") ;
}

//---------------------------------------------------------------------------*

void cPtr_rde_mess_prop::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@rde_mess_prop:"
           << location.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << link.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << initialvalue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_rde_mess_prop::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_rde_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_rde_mess_prop (& typeid (cPtr_rde_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_rde_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__rde_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_rde_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_rde_mess_prop::
GGS_rde_mess_prop (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_rde_mess_prop::
GGS_rde_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_rde_mess_prop GGS_rde_mess_prop::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_rde_mess_prop _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_rde_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_rde_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_rde_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_rde_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_rde_mess_prop GGS_rde_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_link_obj & argument_1,
                 const GGS_basic_type & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_rde_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_rde_mess_prop (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_link_obj  GGS_rde_mess_prop::
reader_link (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_link_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rde_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rde_mess_prop *) mPointer)->link ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_rde_mess_prop::
reader_initialvalue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rde_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rde_mess_prop *) mPointer)->initialvalue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_rde_mess_prop::actualTypeName (void) const {
  return "rde_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__rde_mess_prop ("rde_mess_prop", gClassInfoFor__mess_prop_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_rzs_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_rzs_mess_prop::
cPtr_rzs_mess_prop (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_basic_type & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
cdatatype (argument_1),
initialvalue (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_rzs_mess_prop * GGS_rzs_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rzs_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_rzs_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_rzs_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_rzs_mess_prop * _p = dynamic_cast <const cPtr_rzs_mess_prop *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = location._operator_isEqual (_p->location).boolValue ()
         && cdatatype._operator_isEqual (_p->cdatatype).boolValue ()
         && initialvalue._operator_isEqual (_p->initialvalue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_rzs_mess_prop::
method_s_mess (C_Compiler & _inLexique,
                                GGS_lstring & var_cas_sd COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_sd = GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_rzs_mess_prop::
method_generate (C_Compiler & /* _inLexique */,
                                GGS_lstring  /* var_cas_name */,
                                GGS_base_mess  /* var_cas_mess */,
                                GGS_message_map  /* var_cas_messages */,
                                GGS_ident_list_map  /* var_cas_dests */,
                                GGS_string& var_cas_h_res,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_h_res = GGS_string (true, "") ;
  var_cas_i_res = GGS_string (true, "") ;
}

//---------------------------------------------------------------------------*

void cPtr_rzs_mess_prop::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@rzs_mess_prop:"
           << location.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << cdatatype.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << initialvalue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_rzs_mess_prop::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_rzs_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_rzs_mess_prop (& typeid (cPtr_rzs_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_rzs_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__rzs_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_rzs_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_rzs_mess_prop::
GGS_rzs_mess_prop (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_rzs_mess_prop::
GGS_rzs_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_rzs_mess_prop GGS_rzs_mess_prop::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_rzs_mess_prop _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_rzs_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_rzs_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_rzs_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_rzs_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_rzs_mess_prop GGS_rzs_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_basic_type & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_rzs_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_rzs_mess_prop (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_rzs_mess_prop::
reader_cdatatype (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rzs_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rzs_mess_prop *) mPointer)->cdatatype ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_rzs_mess_prop::
reader_initialvalue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rzs_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rzs_mess_prop *) mPointer)->initialvalue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_rzs_mess_prop::actualTypeName (void) const {
  return "rzs_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__rzs_mess_prop ("rzs_mess_prop", gClassInfoFor__mess_prop_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_void_link'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_void_link::
cPtr_void_link (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_link_obj (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_void_link * GGS_void_link::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_void_link *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_void_link *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_void_link::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_void_link * _p = dynamic_cast <const cPtr_void_link *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = loc._operator_isEqual (_p->loc).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_void_link::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@void_link:"
           << loc.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_void_link::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_void_link::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_void_link (& typeid (cPtr_void_link), & typeid (cPtr_link_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_void_link::galgasRTTI (void) const {
  return & gClassInfoFor__void_link ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_void_link'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_void_link::
GGS_void_link (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_void_link::
GGS_void_link (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_void_link GGS_void_link::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_void_link _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_void_link *> (inPointer) != NULL)
      : (typeid (cPtr_void_link) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_void_link (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_void_link),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_void_link GGS_void_link::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_void_link result ;
  macroMyNew (result.mPointer, cPtr_void_link (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_void_link::actualTypeName (void) const {
  return "void_link" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__void_link ("void_link", gClassInfoFor__link_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_true_link'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_true_link::
cPtr_true_link (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_link_obj (argument_0 COMMA_THERE),
receivemessage (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_true_link * GGS_true_link::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_true_link *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_true_link *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_true_link::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_true_link * _p = dynamic_cast <const cPtr_true_link *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = loc._operator_isEqual (_p->loc).boolValue ()
         && receivemessage._operator_isEqual (_p->receivemessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_true_link::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@true_link:"
           << loc.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << receivemessage.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_true_link::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_true_link::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_true_link (& typeid (cPtr_true_link), & typeid (cPtr_link_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_true_link::galgasRTTI (void) const {
  return & gClassInfoFor__true_link ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_true_link'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_true_link::
GGS_true_link (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_true_link::
GGS_true_link (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_true_link GGS_true_link::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_true_link _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_true_link *> (inPointer) != NULL)
      : (typeid (cPtr_true_link) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_true_link (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_true_link),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_true_link GGS_true_link::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_true_link result ;
  macroMyNew (result.mPointer, cPtr_true_link (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_true_link::
reader_receivemessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_true_link *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_true_link *) mPointer)->receivemessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_true_link::actualTypeName (void) const {
  return "true_link" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__true_link ("true_link", gClassInfoFor__link_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_false_link'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_false_link::
cPtr_false_link (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_link_obj (argument_0 COMMA_THERE),
networkmessage (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_false_link * GGS_false_link::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_false_link *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_false_link *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_false_link::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_false_link * _p = dynamic_cast <const cPtr_false_link *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = loc._operator_isEqual (_p->loc).boolValue ()
         && networkmessage._operator_isEqual (_p->networkmessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_false_link::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@false_link:"
           << loc.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << networkmessage.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_false_link::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_false_link::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_false_link (& typeid (cPtr_false_link), & typeid (cPtr_link_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_false_link::galgasRTTI (void) const {
  return & gClassInfoFor__false_link ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_false_link'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_false_link::
GGS_false_link (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_false_link::
GGS_false_link (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_false_link GGS_false_link::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_false_link _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_false_link *> (inPointer) != NULL)
      : (typeid (cPtr_false_link) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_false_link (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_false_link),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_false_link GGS_false_link::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_false_link result ;
  macroMyNew (result.mPointer, cPtr_false_link (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_false_link::
reader_networkmessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_false_link *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_false_link *) mPointer)->networkmessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_false_link::actualTypeName (void) const {
  return "false_link" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__false_link ("false_link", gClassInfoFor__link_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_nmcallback_action'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_nmcallback_action::
cPtr_nmcallback_action (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_luint64 & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_action_obj (argument_0 COMMA_THERE),
function_name (argument_1),
ipdu (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_nmcallback_action * GGS_nmcallback_action::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_nmcallback_action *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_nmcallback_action *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_nmcallback_action::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_nmcallback_action * _p = dynamic_cast <const cPtr_nmcallback_action *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = location._operator_isEqual (_p->location).boolValue ()
         && function_name._operator_isEqual (_p->function_name).boolValue ()
         && ipdu._operator_isEqual (_p->ipdu).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_nmcallback_action::
method_generate (C_Compiler & _inLexique,
                                GGS_lstring  /* var_cas_name */,
                                GGS_string /* var_cas_err */,
                                GGS_string var_cas_key,
                                GGS_string& /* var_cas_h_res */,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  ::routine_doReplace (_inLexique,  var_cas_i_res,  var_cas_key,  GGS_string (true, "NULL_PTR") COMMA_SOURCE_FILE_AT_LINE (838)) ;
}

//---------------------------------------------------------------------------*

void cPtr_nmcallback_action::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@nmcallback_action:"
           << location.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << function_name.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << ipdu.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_nmcallback_action::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_nmcallback_action::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_nmcallback_action (& typeid (cPtr_nmcallback_action), & typeid (cPtr_action_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_nmcallback_action::galgasRTTI (void) const {
  return & gClassInfoFor__nmcallback_action ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_nmcallback_action'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_nmcallback_action::
GGS_nmcallback_action (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_nmcallback_action::
GGS_nmcallback_action (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_nmcallback_action GGS_nmcallback_action::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_nmcallback_action _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_nmcallback_action *> (inPointer) != NULL)
      : (typeid (cPtr_nmcallback_action) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_nmcallback_action (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_nmcallback_action),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_nmcallback_action GGS_nmcallback_action::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_luint64 & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_nmcallback_action result ;
  macroMyNew (result.mPointer, cPtr_nmcallback_action (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_nmcallback_action::
reader_function_name (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_nmcallback_action *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_nmcallback_action *) mPointer)->function_name ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_nmcallback_action::
reader_ipdu (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_nmcallback_action *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_nmcallback_action *) mPointer)->ipdu ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_nmcallback_action::actualTypeName (void) const {
  return "nmcallback_action" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__nmcallback_action ("nmcallback_action", gClassInfoFor__action_obj) ;

//---------------------------------------------------------------------------*

