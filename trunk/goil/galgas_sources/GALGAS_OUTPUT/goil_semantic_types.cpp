//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'goil_semantic_types.cpp'                       *
//                        Generated by version 1.9.6                         *
//                    november 30th, 2009, at 10h42'11"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != 621
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "goil_semantic_types.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "goil_semantic_types.ggs", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'e_implementation_spec'                        *
//                                                                           *
//---------------------------------------------------------------------------*

e_implementation_spec::e_implementation_spec (void) :
type () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map '@implementation_spec'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_implementation_spec ("implementation_spec", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_implementation_spec::
elementOf_GGS_implementation_spec (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_implementation_spec & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_implementation_spec::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.type.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_implementation_spec::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_implementation_spec * ptr = dynamic_cast <const elementOf_GGS_implementation_spec *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.type.operator_isEqual (ptr->mInfo.type)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_implementation_spec::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_implementation_spec *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_implementation_spec * info = (e_implementation_spec *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_implementation_spec::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_implementation_spec *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_implementation_spec * info = (e_implementation_spec *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_implementation_spec GGS_implementation_spec::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_implementation_spec result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_implementation_spec::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_implementation_spec info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_implementation_spec::
operator_isEqual (const GGS_implementation_spec & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_implementation_spec::
operator_isNotEqual (const GGS_implementation_spec & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_implementation_spec::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_implementation_spec::
removeElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_imp_type & outParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  AC_galgas_map_element * removedElement = NULL ;
  PMSInt32 elementID = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    removedElement = internalRemove (inKey) ;
    if (removedElement == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
      outParameter0.drop () ;
    }else{
      cElement * ptr = (cElement *) removedElement ;
      elementID = ptr->mID ;
      outParameter0 = ptr->mInfo.type ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
  macroMyDelete (removedElement, cElement) ;
}

//---------------------------------------------------------------------------*

void GGS_implementation_spec::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_imp_type & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_implementation_spec info  ;
    info.type = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_implementation_spec::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_imp_type   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.type ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_implementation_spec::kSearchMessage_get [] = {
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('o'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('x'),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('s'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_implementation_spec::
method_get (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_imp_type   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_get,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_implementation_spec::kRemoveMessage_del [] = {
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('o'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('x'),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('s'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_implementation_spec::
modifier_del (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_imp_type & outParameter0 COMMA_LOCATION_ARGS) {
  removeElement (inLexique,
                  kRemoveMessage_del,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_implementation_spec::kInsertMessage_put [] = {
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('u'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_implementation_spec::
modifier_put (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_imp_type & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_put,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_implementation_spec GGS_implementation_spec::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_implementation_spec & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_implementation_spec result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_implementation_spec GGS_implementation_spec::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_implementation_spec result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_implementation_spec::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @implementation_spec " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    PMSInt32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (elementID, s, inIndentation) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_imp_type  & GGS_implementation_spec::cEnumerator::_type (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.type ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_implementation_spec::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_implementation_spec * p = NULL ;
    macroMyNew (p, GGS_implementation_spec (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_implementation_spec GGS_implementation_spec::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_implementation_spec result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_implementation_spec * p = dynamic_cast <const GGS_implementation_spec *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_implementation_spec, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_implementation_spec::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_implementation_spec ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_implementation'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_implementation::e_implementation (void) :
spec () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@implementation'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_implementation ("implementation", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_implementation::
elementOf_GGS_implementation (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_implementation & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_implementation::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.spec.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_implementation::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_implementation * ptr = dynamic_cast <const elementOf_GGS_implementation *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.spec.operator_isEqual (ptr->mInfo.spec)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_implementation::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_implementation *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_implementation * info = (e_implementation *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_implementation::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_implementation *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_implementation * info = (e_implementation *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_implementation GGS_implementation::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_implementation result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_implementation::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_implementation info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_implementation::
operator_isEqual (const GGS_implementation & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_implementation::
operator_isNotEqual (const GGS_implementation & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_implementation::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_implementation::
removeElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_implementation_spec & outParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  AC_galgas_map_element * removedElement = NULL ;
  PMSInt32 elementID = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    removedElement = internalRemove (inKey) ;
    if (removedElement == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
      outParameter0.drop () ;
    }else{
      cElement * ptr = (cElement *) removedElement ;
      elementID = ptr->mID ;
      outParameter0 = ptr->mInfo.spec ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
  macroMyDelete (removedElement, cElement) ;
}

//---------------------------------------------------------------------------*

void GGS_implementation::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_implementation_spec & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_implementation info  ;
    info.spec = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_implementation::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_implementation_spec   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.spec ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_implementation::kSearchMessage_get [] = {
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('o'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('x'),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('s'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_implementation::
method_get (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_implementation_spec   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_get,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_implementation::kRemoveMessage_del [] = {
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('o'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('x'),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('s'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_implementation::
modifier_del (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_implementation_spec & outParameter0 COMMA_LOCATION_ARGS) {
  removeElement (inLexique,
                  kRemoveMessage_del,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_implementation::kInsertMessage_put [] = {
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('u'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_implementation::
modifier_put (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_implementation_spec & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_put,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_implementation GGS_implementation::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_implementation & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_implementation result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_implementation GGS_implementation::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_implementation result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_implementation::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @implementation " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    PMSInt32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (elementID, s, inIndentation) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_implementation_spec  & GGS_implementation::cEnumerator::_spec (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.spec ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_implementation::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_implementation * p = NULL ;
    macroMyNew (p, GGS_implementation (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_implementation GGS_implementation::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_implementation result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_implementation * p = dynamic_cast <const GGS_implementation *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_implementation, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_implementation::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_implementation ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                             class 'e_os_imp'                              *
//                                                                           *
//---------------------------------------------------------------------------*

e_os_imp::e_os_imp (void) :
type () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class map '@os_imp'                             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_os_imp ("os_imp", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_os_imp::
elementOf_GGS_os_imp (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_os_imp & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_os_imp::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.type.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_os_imp::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_os_imp * ptr = dynamic_cast <const elementOf_GGS_os_imp *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.type.operator_isEqual (ptr->mInfo.type)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_os_imp::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_os_imp *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_os_imp * info = (e_os_imp *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_os_imp::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_os_imp *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_os_imp * info = (e_os_imp *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_os_imp GGS_os_imp::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_os_imp result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_os_imp::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_os_imp info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_os_imp::
operator_isEqual (const GGS_os_imp & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_os_imp::
operator_isNotEqual (const GGS_os_imp & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_os_imp::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_os_imp::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lstring & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_os_imp info  ;
    info.type = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_imp::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.type ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_os_imp GGS_os_imp::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_os_imp & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_os_imp result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_os_imp GGS_os_imp::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_os_imp result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_os_imp::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @os_imp " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    PMSInt32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (elementID, s, inIndentation) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_os_imp::cEnumerator::_type (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.type ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_os_imp::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_os_imp * p = NULL ;
    macroMyNew (p, GGS_os_imp (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_os_imp GGS_os_imp::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_os_imp result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_os_imp * p = dynamic_cast <const GGS_os_imp *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_os_imp, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_os_imp::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_os_imp ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_event_mask_obj'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_event_mask_obj::
cPtr_event_mask_obj (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
location (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_event_mask_obj * GGS_event_mask_obj::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_event_mask_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_event_mask_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_event_mask_obj::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@event_mask_obj:"
           << location.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_event_mask_obj::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_event_mask_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_event_mask_obj (& typeid (cPtr_event_mask_obj), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_event_mask_obj::galgasRTTI (void) const {
  return & gClassInfoFor__event_mask_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_event_mask_obj'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_event_mask_obj ("event_mask_obj", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_event_mask_obj::
GGS_event_mask_obj (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_event_mask_obj::
GGS_event_mask_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_event_mask_obj GGS_event_mask_obj::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_event_mask_obj result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_event_mask_obj *> (inPointer) != NULL)
      : (typeid (cPtr_event_mask_obj) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_event_mask_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_event_mask_obj),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_event_mask_obj::
reader_location (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_event_mask_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_event_mask_obj *) mPointer)->location ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_event_mask_obj::actualTypeName (void) const {
  return "event_mask_obj" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_event_mask_obj::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__event_mask_obj ("event_mask_obj", & kTypeDescriptor_GGS_event_mask_obj) ;

//---------------------------------------------------------------------------*

GGS_object GGS_event_mask_obj::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_event_mask_obj * p = NULL ;
    macroMyNew (p, GGS_event_mask_obj (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_event_mask_obj GGS_event_mask_obj::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_event_mask_obj result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_event_mask_obj * p = dynamic_cast <const GGS_event_mask_obj *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_event_mask_obj, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_event_mask_obj::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_event_mask_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_event_mask_void_obj'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_event_mask_void_obj::
cPtr_event_mask_void_obj (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_event_mask_obj (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_event_mask_void_obj * GGS_event_mask_void_obj::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_event_mask_void_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_event_mask_void_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_event_mask_void_obj::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_event_mask_void_obj * ptr = dynamic_cast <const cPtr_event_mask_void_obj *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_event_mask_void_obj::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@event_mask_void_obj:"
           << location.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_event_mask_void_obj::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_event_mask_void_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_event_mask_void_obj (& typeid (cPtr_event_mask_void_obj), & typeid (cPtr_event_mask_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_event_mask_void_obj::galgasRTTI (void) const {
  return & gClassInfoFor__event_mask_void_obj ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_event_mask_void_obj::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_event_mask_void_obj (location COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_event_mask_void_obj'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_event_mask_void_obj ("event_mask_void_obj", true, & kTypeDescriptor_GGS_event_mask_obj) ;

//---------------------------------------------------------------------------*

GGS_event_mask_void_obj::
GGS_event_mask_void_obj (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_event_mask_void_obj::
GGS_event_mask_void_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_event_mask_void_obj GGS_event_mask_void_obj::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_event_mask_void_obj result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_event_mask_void_obj *> (inPointer) != NULL)
      : (typeid (cPtr_event_mask_void_obj) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_event_mask_void_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_event_mask_void_obj),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_event_mask_void_obj GGS_event_mask_void_obj::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_event_mask_void_obj result ;
  macroMyNew (result.mPointer, cPtr_event_mask_void_obj (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_event_mask_void_obj::actualTypeName (void) const {
  return "event_mask_void_obj" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__event_mask_void_obj ("event_mask_void_obj", gClassInfoFor__event_mask_obj, & kTypeDescriptor_GGS_event_mask_void_obj) ;

//---------------------------------------------------------------------------*

GGS_object GGS_event_mask_void_obj::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_event_mask_void_obj * p = NULL ;
    macroMyNew (p, GGS_event_mask_void_obj (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_event_mask_void_obj GGS_event_mask_void_obj::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_event_mask_void_obj result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_event_mask_void_obj * p = dynamic_cast <const GGS_event_mask_void_obj *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_event_mask_void_obj, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_event_mask_void_obj::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_event_mask_void_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_event_mask_user_obj'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_event_mask_user_obj::
cPtr_event_mask_user_obj (const GGS_location & argument_0,
                                const GGS_luint64 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_event_mask_obj (argument_0 COMMA_THERE),
mask (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_event_mask_user_obj * GGS_event_mask_user_obj::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_event_mask_user_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_event_mask_user_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_event_mask_user_obj::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_event_mask_user_obj * ptr = dynamic_cast <const cPtr_event_mask_user_obj *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && mask.operator_isEqual (ptr->mask).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_event_mask_user_obj::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@event_mask_user_obj:"
           << location.reader_description (inIndentation + 1)
           << mask.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_event_mask_user_obj::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_event_mask_user_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_event_mask_user_obj (& typeid (cPtr_event_mask_user_obj), & typeid (cPtr_event_mask_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_event_mask_user_obj::galgasRTTI (void) const {
  return & gClassInfoFor__event_mask_user_obj ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_event_mask_user_obj::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_event_mask_user_obj (location, mask COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_event_mask_user_obj'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_event_mask_user_obj ("event_mask_user_obj", true, & kTypeDescriptor_GGS_event_mask_obj) ;

//---------------------------------------------------------------------------*

GGS_event_mask_user_obj::
GGS_event_mask_user_obj (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_event_mask_user_obj::
GGS_event_mask_user_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_event_mask_user_obj GGS_event_mask_user_obj::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_event_mask_user_obj result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_event_mask_user_obj *> (inPointer) != NULL)
      : (typeid (cPtr_event_mask_user_obj) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_event_mask_user_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_event_mask_user_obj),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_event_mask_user_obj GGS_event_mask_user_obj::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint64 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_event_mask_user_obj result ;
  macroMyNew (result.mPointer, cPtr_event_mask_user_obj (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_event_mask_user_obj::
reader_mask (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_event_mask_user_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_event_mask_user_obj *) mPointer)->mask ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_event_mask_user_obj::actualTypeName (void) const {
  return "event_mask_user_obj" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__event_mask_user_obj ("event_mask_user_obj", gClassInfoFor__event_mask_obj, & kTypeDescriptor_GGS_event_mask_user_obj) ;

//---------------------------------------------------------------------------*

GGS_object GGS_event_mask_user_obj::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_event_mask_user_obj * p = NULL ;
    macroMyNew (p, GGS_event_mask_user_obj (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_event_mask_user_obj GGS_event_mask_user_obj::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_event_mask_user_obj result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_event_mask_user_obj * p = dynamic_cast <const GGS_event_mask_user_obj *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_event_mask_user_obj, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_event_mask_user_obj::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_event_mask_user_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_event_mask_auto_obj'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_event_mask_auto_obj::
cPtr_event_mask_auto_obj (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_event_mask_obj (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_event_mask_auto_obj * GGS_event_mask_auto_obj::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_event_mask_auto_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_event_mask_auto_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_event_mask_auto_obj::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_event_mask_auto_obj * ptr = dynamic_cast <const cPtr_event_mask_auto_obj *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_event_mask_auto_obj::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@event_mask_auto_obj:"
           << location.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_event_mask_auto_obj::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_event_mask_auto_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_event_mask_auto_obj (& typeid (cPtr_event_mask_auto_obj), & typeid (cPtr_event_mask_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_event_mask_auto_obj::galgasRTTI (void) const {
  return & gClassInfoFor__event_mask_auto_obj ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_event_mask_auto_obj::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_event_mask_auto_obj (location COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_event_mask_auto_obj'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_event_mask_auto_obj ("event_mask_auto_obj", true, & kTypeDescriptor_GGS_event_mask_obj) ;

//---------------------------------------------------------------------------*

GGS_event_mask_auto_obj::
GGS_event_mask_auto_obj (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_event_mask_auto_obj::
GGS_event_mask_auto_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_event_mask_auto_obj GGS_event_mask_auto_obj::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_event_mask_auto_obj result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_event_mask_auto_obj *> (inPointer) != NULL)
      : (typeid (cPtr_event_mask_auto_obj) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_event_mask_auto_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_event_mask_auto_obj),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_event_mask_auto_obj GGS_event_mask_auto_obj::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_event_mask_auto_obj result ;
  macroMyNew (result.mPointer, cPtr_event_mask_auto_obj (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_event_mask_auto_obj::actualTypeName (void) const {
  return "event_mask_auto_obj" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__event_mask_auto_obj ("event_mask_auto_obj", gClassInfoFor__event_mask_obj, & kTypeDescriptor_GGS_event_mask_auto_obj) ;

//---------------------------------------------------------------------------*

GGS_object GGS_event_mask_auto_obj::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_event_mask_auto_obj * p = NULL ;
    macroMyNew (p, GGS_event_mask_auto_obj (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_event_mask_auto_obj GGS_event_mask_auto_obj::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_event_mask_auto_obj result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_event_mask_auto_obj * p = dynamic_cast <const GGS_event_mask_auto_obj *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_event_mask_auto_obj, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_event_mask_auto_obj::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_event_mask_auto_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_event_obj'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_event_obj::
cPtr_event_obj (const GGS_lstring & argument_0,
                                const GGS_event_mask_obj & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_oil_obj (argument_0 COMMA_THERE),
mask (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_event_obj * GGS_event_obj::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_event_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_event_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_event_obj::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_event_obj * ptr = dynamic_cast <const cPtr_event_obj *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = desc.operator_isEqual (ptr->desc).boolValue ()
         && mask.operator_isEqual (ptr->mask).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_event_obj::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@event_obj:"
           << desc.reader_description (inIndentation + 1)
           << mask.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_event_obj::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_event_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_event_obj (& typeid (cPtr_event_obj), & typeid (cPtr_oil_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_event_obj::galgasRTTI (void) const {
  return & gClassInfoFor__event_obj ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_event_obj::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_event_obj (desc, mask COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_event_obj'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_event_obj ("event_obj", true, & kTypeDescriptor_GGS_oil_obj) ;

//---------------------------------------------------------------------------*

GGS_event_obj::
GGS_event_obj (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_event_obj::
GGS_event_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_event_obj GGS_event_obj::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_event_obj result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_event_obj *> (inPointer) != NULL)
      : (typeid (cPtr_event_obj) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_event_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_event_obj),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_event_obj GGS_event_obj::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_event_mask_obj & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_event_obj result ;
  macroMyNew (result.mPointer, cPtr_event_obj (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_event_mask_obj  GGS_event_obj::
reader_mask (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_event_mask_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_event_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_event_obj *) mPointer)->mask ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_event_obj::actualTypeName (void) const {
  return "event_obj" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__event_obj ("event_obj", gClassInfoFor__oil_obj, & kTypeDescriptor_GGS_event_obj) ;

//---------------------------------------------------------------------------*

GGS_object GGS_event_obj::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_event_obj * p = NULL ;
    macroMyNew (p, GGS_event_obj (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_event_obj GGS_event_obj::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_event_obj result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_event_obj * p = dynamic_cast <const GGS_event_obj *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_event_obj, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_event_obj::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_event_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_event_map'                             *
//                                                                           *
//---------------------------------------------------------------------------*

e_event_map::e_event_map (void) :
event () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map '@event_map'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_event_map ("event_map", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_event_map::
elementOf_GGS_event_map (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_event_map & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_event_map::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.event.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_event_map::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_event_map * ptr = dynamic_cast <const elementOf_GGS_event_map *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.event.operator_isEqual (ptr->mInfo.event)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_event_map::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_event_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_event_map * info = (e_event_map *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_event_map::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_event_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_event_map * info = (e_event_map *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_event_map GGS_event_map::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_event_map result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_event_map::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_event_map info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_event_map::
operator_isEqual (const GGS_event_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_event_map::
operator_isNotEqual (const GGS_event_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_event_map::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_event_map::
removeElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_event_obj & outParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  AC_galgas_map_element * removedElement = NULL ;
  PMSInt32 elementID = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    removedElement = internalRemove (inKey) ;
    if (removedElement == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
      outParameter0.drop () ;
    }else{
      cElement * ptr = (cElement *) removedElement ;
      elementID = ptr->mID ;
      outParameter0 = ptr->mInfo.event ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
  macroMyDelete (removedElement, cElement) ;
}

//---------------------------------------------------------------------------*

void GGS_event_map::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_event_obj & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_event_map info  ;
    info.event = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_event_map::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_event_obj   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.event ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_event_map::kSearchMessage_get [] = {
  TO_UNICODE ('E'),
  TO_UNICODE ('v'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_event_map::
method_get (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_event_obj   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_get,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_event_map::kRemoveMessage_del [] = {
  TO_UNICODE ('E'),
  TO_UNICODE ('v'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_event_map::
modifier_del (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_event_obj & outParameter0 COMMA_LOCATION_ARGS) {
  removeElement (inLexique,
                  kRemoveMessage_del,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_event_map::kInsertMessage_put [] = {
  TO_UNICODE ('E'),
  TO_UNICODE ('v'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_event_map::
modifier_put (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_event_obj & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_put,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_event_map GGS_event_map::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_event_map & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_event_map result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_event_map GGS_event_map::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_event_map result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_event_map::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @event_map " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    PMSInt32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (elementID, s, inIndentation) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_event_obj  & GGS_event_map::cEnumerator::_event (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.event ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_event_map::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_event_map * p = NULL ;
    macroMyNew (p, GGS_event_map (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_event_map GGS_event_map::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_event_map result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_event_map * p = dynamic_cast <const GGS_event_map *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_event_map, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_event_map::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_event_map ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'e_event_usage_map'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_event_usage_map::e_event_usage_map (void) :
count () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@event_usage_map'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_event_usage_map ("event_usage_map", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_event_usage_map::
elementOf_GGS_event_usage_map (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_event_usage_map & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_event_usage_map::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.count.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_event_usage_map::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_event_usage_map * ptr = dynamic_cast <const elementOf_GGS_event_usage_map *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.count.operator_isEqual (ptr->mInfo.count)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_event_usage_map::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_event_usage_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_event_usage_map * info = (e_event_usage_map *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_event_usage_map::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_event_usage_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_event_usage_map * info = (e_event_usage_map *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_event_usage_map GGS_event_usage_map::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_event_usage_map result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_event_usage_map::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_event_usage_map info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_event_usage_map::
operator_isEqual (const GGS_event_usage_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_event_usage_map::
operator_isNotEqual (const GGS_event_usage_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_event_usage_map::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_event_usage_map::
removeElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_uint & outParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  AC_galgas_map_element * removedElement = NULL ;
  PMSInt32 elementID = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    removedElement = internalRemove (inKey) ;
    if (removedElement == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
      outParameter0.drop () ;
    }else{
      cElement * ptr = (cElement *) removedElement ;
      elementID = ptr->mID ;
      outParameter0 = ptr->mInfo.count ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
  macroMyDelete (removedElement, cElement) ;
}

//---------------------------------------------------------------------------*

void GGS_event_usage_map::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_uint & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_event_usage_map info  ;
    info.count = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_event_usage_map::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.count ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_event_usage_map::kSearchMessage_get_count [] = {
  TO_UNICODE ('K'),
  TO_UNICODE ('e'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_event_usage_map::
method_get_count (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_get_count,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_event_usage_map::kRemoveMessage_delete [] = {
  TO_UNICODE ('K'),
  TO_UNICODE ('e'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_event_usage_map::
modifier_delete (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint & outParameter0 COMMA_LOCATION_ARGS) {
  removeElement (inLexique,
                  kRemoveMessage_delete,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_event_usage_map::kInsertMessage_insert_count [] = {
  TO_UNICODE ('K'),
  TO_UNICODE ('e'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_event_usage_map::
modifier_insert_count (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insert_count,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_event_usage_map GGS_event_usage_map::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_event_usage_map & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_event_usage_map result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_event_usage_map GGS_event_usage_map::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_event_usage_map result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_event_usage_map::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @event_usage_map " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    PMSInt32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (elementID, s, inIndentation) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_event_usage_map::cEnumerator::_count (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.count ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_event_usage_map::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_event_usage_map * p = NULL ;
    macroMyNew (p, GGS_event_usage_map (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_event_usage_map GGS_event_usage_map::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_event_usage_map result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_event_usage_map * p = dynamic_cast <const GGS_event_usage_map *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_event_usage_map, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_event_usage_map::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_event_usage_map ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@sorted_events'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_sorted_events::
elementOf_GGS_sorted_events (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1):
event_name (argument_0),
count (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_sorted_events::
isEqualToObject (const cSortedListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_sorted_events * ptr = dynamic_cast <const elementOf_GGS_sorted_events *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = event_name.operator_isEqual (ptr->event_name).boolValue ()
         && count.operator_isEqual (ptr->count).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

PMSInt32 elementOf_GGS_sorted_events::
compareForSorting (const cSortedListElement * inOperand) const {
  const elementOf_GGS_sorted_events * operand = (const elementOf_GGS_sorted_events *) inOperand ;
  PMSInt32 result = - count.compareForSortedList (operand->count) ;
  return result ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_sorted_events::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << event_name.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << count.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       Sorted list '@sorted_events'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_sorted_events ("sorted_events", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_sorted_events::GGS_sorted_events (void): AC_galgas_sortedlist () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_sorted_events::
GGS_sorted_events (const GGS_sorted_events & inSource): AC_galgas_sortedlist (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_sorted_events::
operator_isEqual (const GGS_sorted_events & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_sorted_events::
operator_isNotEqual (const GGS_sorted_events & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_sorted_events::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_uint & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_sorted_events::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_sorted_events GGS_sorted_events::
operator_concat (const GGS_sorted_events & inOperand) const {
  GGS_sorted_events result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_sorted_events::
dotAssign_operation (const GGS_sorted_events inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      *this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_sorted_events * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->event_name ;
          GGS_uint  p_1 = p->count ;
          internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_sorted_events::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->event_name,
                                ptr->count) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_sorted_events  GGS_sorted_events::
constructor_emptySortedList (void) {
  GGS_sorted_events result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sorted_events  GGS_sorted_events::
constructor_sortedListWithValue (const GGS_lstring & argument_0,
                           const GGS_uint & argument_1) {
  GGS_sorted_events result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_sorted_events::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@sorted_events", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_sorted_events::
method_smallest (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_uint & _out_1
                 COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->event_name ;
    _out_1 = ptr->count ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sorted_events::
method_greatest (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_uint & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'greatest' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->event_name ;
    _out_1 = ptr->count ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sorted_events::
modifier_popSmallest (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_uint & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popSmallest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->event_name ;
    _out_1 = ptr->count ;
    insulateList () ;
    _internalRemoveSmallest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sorted_events::
modifier_popGreatest (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_uint & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popGreatest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->event_name ;
    _out_1 = ptr->count ;
    insulateList () ;
    _internalRemoveGreatest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_sorted_events::cEnumerator::_event_name (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->event_name ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_sorted_events::cEnumerator::_count (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->count ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_sorted_events::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sorted_events * p = NULL ;
    macroMyNew (p, GGS_sorted_events (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sorted_events GGS_sorted_events::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sorted_events result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sorted_events * p = dynamic_cast <const GGS_sorted_events *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sorted_events, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_sorted_events::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sorted_events ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_alarm_autostart_true'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_alarm_autostart_true::
cPtr_alarm_autostart_true (const GGS_location & argument_0,
                                const GGS_luint64 & argument_1,
                                const GGS_luint64 & argument_2,
                                const GGS_stringset & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_autostart_obj (argument_0 COMMA_THERE),
alarm_time (argument_1),
cycle_time (argument_2),
app_modes (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_alarm_autostart_true * GGS_alarm_autostart_true::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_alarm_autostart_true *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_alarm_autostart_true *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_alarm_autostart_true::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_alarm_autostart_true * ptr = dynamic_cast <const cPtr_alarm_autostart_true *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && alarm_time.operator_isEqual (ptr->alarm_time).boolValue ()
         && cycle_time.operator_isEqual (ptr->cycle_time).boolValue ()
         && app_modes.operator_isEqual (ptr->app_modes).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_alarm_autostart_true::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@alarm_autostart_true:"
           << location.reader_description (inIndentation + 1)
           << alarm_time.reader_description (inIndentation + 1)
           << cycle_time.reader_description (inIndentation + 1)
           << app_modes.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_alarm_autostart_true::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_alarm_autostart_true::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_alarm_autostart_true (& typeid (cPtr_alarm_autostart_true), & typeid (cPtr_autostart_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_alarm_autostart_true::galgasRTTI (void) const {
  return & gClassInfoFor__alarm_autostart_true ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_alarm_autostart_true::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_alarm_autostart_true (location, alarm_time, cycle_time, app_modes COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_alarm_autostart_true'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_alarm_autostart_true ("alarm_autostart_true", true, & kTypeDescriptor_GGS_autostart_obj) ;

//---------------------------------------------------------------------------*

GGS_alarm_autostart_true::
GGS_alarm_autostart_true (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_alarm_autostart_true::
GGS_alarm_autostart_true (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_alarm_autostart_true GGS_alarm_autostart_true::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_alarm_autostart_true result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_alarm_autostart_true *> (inPointer) != NULL)
      : (typeid (cPtr_alarm_autostart_true) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_alarm_autostart_true (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_alarm_autostart_true),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_alarm_autostart_true GGS_alarm_autostart_true::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint64 & argument_1,
                 const GGS_luint64 & argument_2,
                 const GGS_stringset & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_alarm_autostart_true result ;
  macroMyNew (result.mPointer, cPtr_alarm_autostart_true (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_alarm_autostart_true::
reader_alarm_time (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_alarm_autostart_true *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_alarm_autostart_true *) mPointer)->alarm_time ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_alarm_autostart_true::
reader_cycle_time (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_alarm_autostart_true *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_alarm_autostart_true *) mPointer)->cycle_time ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset  GGS_alarm_autostart_true::
reader_app_modes (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_stringset   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_alarm_autostart_true *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_alarm_autostart_true *) mPointer)->app_modes ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_alarm_autostart_true::actualTypeName (void) const {
  return "alarm_autostart_true" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__alarm_autostart_true ("alarm_autostart_true", gClassInfoFor__autostart_obj, & kTypeDescriptor_GGS_alarm_autostart_true) ;

//---------------------------------------------------------------------------*

GGS_object GGS_alarm_autostart_true::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_alarm_autostart_true * p = NULL ;
    macroMyNew (p, GGS_alarm_autostart_true (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_alarm_autostart_true GGS_alarm_autostart_true::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_alarm_autostart_true result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_alarm_autostart_true * p = dynamic_cast <const GGS_alarm_autostart_true *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_alarm_autostart_true, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_alarm_autostart_true::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_alarm_autostart_true ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_alarm_obj'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_alarm_obj::
cPtr_alarm_obj (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_action_obj & argument_2,
                                const GGS_autostart_obj & argument_3,
                                const GGS_lstringlist & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_oil_obj (argument_0 COMMA_THERE),
counter_name (argument_1),
action_params (argument_2),
autostart_params (argument_3),
acc_apps (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_alarm_obj * GGS_alarm_obj::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_alarm_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_alarm_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_alarm_obj::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_alarm_obj * ptr = dynamic_cast <const cPtr_alarm_obj *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = desc.operator_isEqual (ptr->desc).boolValue ()
         && counter_name.operator_isEqual (ptr->counter_name).boolValue ()
         && action_params.operator_isEqual (ptr->action_params).boolValue ()
         && autostart_params.operator_isEqual (ptr->autostart_params).boolValue ()
         && acc_apps.operator_isEqual (ptr->acc_apps).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_alarm_obj::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@alarm_obj:"
           << desc.reader_description (inIndentation + 1)
           << counter_name.reader_description (inIndentation + 1)
           << action_params.reader_description (inIndentation + 1)
           << autostart_params.reader_description (inIndentation + 1)
           << acc_apps.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_alarm_obj::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_alarm_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_alarm_obj (& typeid (cPtr_alarm_obj), & typeid (cPtr_oil_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_alarm_obj::galgasRTTI (void) const {
  return & gClassInfoFor__alarm_obj ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_alarm_obj::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_alarm_obj (desc, counter_name, action_params, autostart_params, acc_apps COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_alarm_obj'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_alarm_obj ("alarm_obj", true, & kTypeDescriptor_GGS_oil_obj) ;

//---------------------------------------------------------------------------*

GGS_alarm_obj::
GGS_alarm_obj (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_alarm_obj::
GGS_alarm_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_alarm_obj GGS_alarm_obj::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_alarm_obj result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_alarm_obj *> (inPointer) != NULL)
      : (typeid (cPtr_alarm_obj) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_alarm_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_alarm_obj),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_alarm_obj GGS_alarm_obj::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_action_obj & argument_2,
                 const GGS_autostart_obj & argument_3,
                 const GGS_lstringlist & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_alarm_obj result ;
  macroMyNew (result.mPointer, cPtr_alarm_obj (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_alarm_obj::
reader_counter_name (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_alarm_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_alarm_obj *) mPointer)->counter_name ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_action_obj  GGS_alarm_obj::
reader_action_params (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_action_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_alarm_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_alarm_obj *) mPointer)->action_params ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_autostart_obj  GGS_alarm_obj::
reader_autostart_params (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_autostart_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_alarm_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_alarm_obj *) mPointer)->autostart_params ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_alarm_obj::
reader_acc_apps (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_alarm_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_alarm_obj *) mPointer)->acc_apps ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_alarm_obj::actualTypeName (void) const {
  return "alarm_obj" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__alarm_obj ("alarm_obj", gClassInfoFor__oil_obj, & kTypeDescriptor_GGS_alarm_obj) ;

//---------------------------------------------------------------------------*

GGS_object GGS_alarm_obj::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_alarm_obj * p = NULL ;
    macroMyNew (p, GGS_alarm_obj (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_alarm_obj GGS_alarm_obj::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_alarm_obj result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_alarm_obj * p = dynamic_cast <const GGS_alarm_obj *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_alarm_obj, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_alarm_obj::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_alarm_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_alarm_map'                             *
//                                                                           *
//---------------------------------------------------------------------------*

e_alarm_map::e_alarm_map (void) :
alarm () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map '@alarm_map'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_alarm_map ("alarm_map", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_alarm_map::
elementOf_GGS_alarm_map (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_alarm_map & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_alarm_map::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.alarm.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_alarm_map::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_alarm_map * ptr = dynamic_cast <const elementOf_GGS_alarm_map *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.alarm.operator_isEqual (ptr->mInfo.alarm)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_alarm_map::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_alarm_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_alarm_map * info = (e_alarm_map *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_alarm_map::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_alarm_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_alarm_map * info = (e_alarm_map *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_alarm_map GGS_alarm_map::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_alarm_map result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_alarm_map::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_alarm_map info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_alarm_map::
operator_isEqual (const GGS_alarm_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_alarm_map::
operator_isNotEqual (const GGS_alarm_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_alarm_map::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_alarm_map::
removeElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_alarm_obj & outParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  AC_galgas_map_element * removedElement = NULL ;
  PMSInt32 elementID = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    removedElement = internalRemove (inKey) ;
    if (removedElement == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
      outParameter0.drop () ;
    }else{
      cElement * ptr = (cElement *) removedElement ;
      elementID = ptr->mID ;
      outParameter0 = ptr->mInfo.alarm ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
  macroMyDelete (removedElement, cElement) ;
}

//---------------------------------------------------------------------------*

void GGS_alarm_map::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_alarm_obj & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_alarm_map info  ;
    info.alarm = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_alarm_map::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_alarm_obj   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.alarm ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_alarm_map::kSearchMessage_get [] = {
  TO_UNICODE ('A'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('m'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_alarm_map::
method_get (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_alarm_obj   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_get,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_alarm_map::kRemoveMessage_del [] = {
  TO_UNICODE ('A'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('m'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_alarm_map::
modifier_del (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_alarm_obj & outParameter0 COMMA_LOCATION_ARGS) {
  removeElement (inLexique,
                  kRemoveMessage_del,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_alarm_map::kInsertMessage_put [] = {
  TO_UNICODE ('A'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('m'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('u'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_alarm_map::
modifier_put (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_alarm_obj & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_put,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_alarm_map GGS_alarm_map::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_alarm_map & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_alarm_map result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_alarm_map GGS_alarm_map::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_alarm_map result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_alarm_map::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @alarm_map " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    PMSInt32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (elementID, s, inIndentation) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_alarm_obj  & GGS_alarm_map::cEnumerator::_alarm (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.alarm ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_alarm_map::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_alarm_map * p = NULL ;
    macroMyNew (p, GGS_alarm_map (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_alarm_map GGS_alarm_map::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_alarm_map result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_alarm_map * p = dynamic_cast <const GGS_alarm_map *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_alarm_map, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_alarm_map::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_alarm_map ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_base_mess'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_base_mess::
cPtr_base_mess (const GGS_lstring & argument_0,
                                const GGS_action_obj & argument_1,
                                const GGS_action_obj & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_ident_map & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_oil_obj (argument_0 COMMA_THERE),
notification (argument_1),
notificationerror (argument_2),
acc_apps (argument_3),
other_fields (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_base_mess * GGS_base_mess::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_base_mess *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_base_mess *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_base_mess::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@base_mess:"
           << desc.reader_description (inIndentation + 1)
           << notification.reader_description (inIndentation + 1)
           << notificationerror.reader_description (inIndentation + 1)
           << acc_apps.reader_description (inIndentation + 1)
           << other_fields.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_base_mess::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_base_mess::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_base_mess (& typeid (cPtr_base_mess), & typeid (cPtr_oil_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_base_mess::galgasRTTI (void) const {
  return & gClassInfoFor__base_mess ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_base_mess'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_base_mess ("base_mess", true, & kTypeDescriptor_GGS_oil_obj) ;

//---------------------------------------------------------------------------*

GGS_base_mess::
GGS_base_mess (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_base_mess::
GGS_base_mess (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_base_mess GGS_base_mess::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_base_mess result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_base_mess *> (inPointer) != NULL)
      : (typeid (cPtr_base_mess) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_base_mess (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_base_mess),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_action_obj  GGS_base_mess::
reader_notification (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_action_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_base_mess *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_base_mess *) mPointer)->notification ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_action_obj  GGS_base_mess::
reader_notificationerror (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_action_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_base_mess *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_base_mess *) mPointer)->notificationerror ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_base_mess::
reader_acc_apps (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_base_mess *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_base_mess *) mPointer)->acc_apps ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ident_map  GGS_base_mess::
reader_other_fields (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ident_map   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_base_mess *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_base_mess *) mPointer)->other_fields ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_base_mess::actualTypeName (void) const {
  return "base_mess" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__base_mess ("base_mess", gClassInfoFor__oil_obj, & kTypeDescriptor_GGS_base_mess) ;

//---------------------------------------------------------------------------*

GGS_object GGS_base_mess::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_base_mess * p = NULL ;
    macroMyNew (p, GGS_base_mess (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_base_mess GGS_base_mess::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_base_mess result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_base_mess * p = dynamic_cast <const GGS_base_mess *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_base_mess, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_base_mess::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_base_mess ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_mess_prop_obj'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_mess_prop_obj::
cPtr_mess_prop_obj (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
location (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_mess_prop_obj * GGS_mess_prop_obj::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mess_prop_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_mess_prop_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_mess_prop_obj::
method_generate_notif (C_Compiler & inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_base_mess  var_cas_mess,
                                GGS_string& var_cas_h_res,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_action_obj  var_cas_notif ;
  var_cas_notif = var_cas_mess.reader_notification (inLexique COMMA_SOURCE_FILE_AT_LINE (131)) ;
  const GGS_action_obj  temp_3102 = var_cas_notif ;
  if (temp_3102.isBuilt ()) {
    temp_3102 (HERE)->method_generate (inLexique, var_cas_name, GGS_string (""), GGS_string ("$NOTIFICATION_PTR$"), var_cas_h_res, var_cas_i_res COMMA_SOURCE_FILE_AT_LINE (132)) ;
  }
  var_cas_notif = var_cas_mess.reader_notificationerror (inLexique COMMA_SOURCE_FILE_AT_LINE (135)) ;
  const GGS_action_obj  temp_3259 = var_cas_notif ;
  if (temp_3259.isBuilt ()) {
    temp_3259 (HERE)->method_generate (inLexique, var_cas_name, GGS_string ("_error"), GGS_string ("$NOTIFICATION_PTR$"), var_cas_h_res, var_cas_i_res COMMA_SOURCE_FILE_AT_LINE (136)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_mess_prop_obj::
method_generate_dest_list (C_Compiler & inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_lstring  var_cas_sendingmessage,
                                GGS_ident_list_map  var_cas_dests,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_next_mo ;
  GGS_ident_list  var_cas_dest_list ;
  GGS_bool var_cas_notfound = GGS_bool (true) ;
  GGS_bool var_cas_nextone = GGS_bool (false) ;
  const GGS_ident_list_map  temp_3671 = var_cas_dests ;
  if (temp_3671.isBuilt ()) {
    temp_3671 (HERE)->method_get (inLexique, var_cas_sendingmessage, var_cas_dest_list COMMA_SOURCE_FILE_AT_LINE (150)) ;
  }
  {
    GGS_ident_list::cEnumerator enumerator_3728 (var_cas_dest_list, true) ;
    const GGS_ident_list::cElement * operand_3728 = NULL ;
    while (((operand_3728 = enumerator_3728.nextObject ()))
        && (var_cas_notfound.isBuiltAndTrue ())) {
      macroValidPointer (operand_3728) ;
      const GGS_bool cond_3961 = var_cas_nextone ;
      if (cond_3961.isBuiltAndTrue ()) {
        ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$TARGET_PTR$"),  ((GGS_string ("&")).operator_concat (operand_3728->obj_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (155)))).operator_concat (GGS_string ("_message")) COMMA_SOURCE_FILE_AT_LINE (155)) ;
        var_cas_notfound = GGS_bool (false) ;
      }
      const GGS_bool cond_4066 = (operand_3728->obj_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (158))).operator_isEqual (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (158))) ;
      if (cond_4066.isBuiltAndTrue ()) {
        var_cas_nextone = GGS_bool (true) ;
      }
    }
  }
  const GGS_bool cond_4189 = var_cas_notfound ;
  if (cond_4189.isBuiltAndTrue ()) {
    ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$TARGET_PTR$"),  GGS_string ("NULL_PTR") COMMA_SOURCE_FILE_AT_LINE (163)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_mess_prop_obj::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@mess_prop_obj:"
           << location.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_mess_prop_obj::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mess_prop_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_mess_prop_obj (& typeid (cPtr_mess_prop_obj), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_mess_prop_obj::galgasRTTI (void) const {
  return & gClassInfoFor__mess_prop_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_mess_prop_obj'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_mess_prop_obj ("mess_prop_obj", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_mess_prop_obj::
GGS_mess_prop_obj (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_mess_prop_obj::
GGS_mess_prop_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_mess_prop_obj GGS_mess_prop_obj::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_mess_prop_obj result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_mess_prop_obj *> (inPointer) != NULL)
      : (typeid (cPtr_mess_prop_obj) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_mess_prop_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_mess_prop_obj),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_mess_prop_obj::
reader_location (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mess_prop_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mess_prop_obj *) mPointer)->location ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_mess_prop_obj::actualTypeName (void) const {
  return "mess_prop_obj" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_mess_prop_obj::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__mess_prop_obj ("mess_prop_obj", & kTypeDescriptor_GGS_mess_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_object GGS_mess_prop_obj::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mess_prop_obj * p = NULL ;
    macroMyNew (p, GGS_mess_prop_obj (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mess_prop_obj GGS_mess_prop_obj::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mess_prop_obj result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mess_prop_obj * p = dynamic_cast <const GGS_mess_prop_obj *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mess_prop_obj, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_mess_prop_obj::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mess_prop_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_message_obj'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_message_obj::
cPtr_message_obj (const GGS_lstring & argument_0,
                                const GGS_action_obj & argument_1,
                                const GGS_action_obj & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_ident_map & argument_4,
                                const GGS_mess_prop_obj & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_base_mess (argument_0, argument_1, argument_2, argument_3, argument_4 COMMA_THERE),
messageproperty (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_message_obj * GGS_message_obj::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_message_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_message_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_message_obj::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_message_obj * ptr = dynamic_cast <const cPtr_message_obj *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = desc.operator_isEqual (ptr->desc).boolValue ()
         && notification.operator_isEqual (ptr->notification).boolValue ()
         && notificationerror.operator_isEqual (ptr->notificationerror).boolValue ()
         && acc_apps.operator_isEqual (ptr->acc_apps).boolValue ()
         && other_fields.operator_isEqual (ptr->other_fields).boolValue ()
         && messageproperty.operator_isEqual (ptr->messageproperty).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_message_obj::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@message_obj:"
           << desc.reader_description (inIndentation + 1)
           << notification.reader_description (inIndentation + 1)
           << notificationerror.reader_description (inIndentation + 1)
           << acc_apps.reader_description (inIndentation + 1)
           << other_fields.reader_description (inIndentation + 1)
           << messageproperty.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_message_obj::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_message_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_message_obj (& typeid (cPtr_message_obj), & typeid (cPtr_base_mess), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_message_obj::galgasRTTI (void) const {
  return & gClassInfoFor__message_obj ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_message_obj::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_message_obj (desc, notification, notificationerror, acc_apps, other_fields, messageproperty COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_message_obj'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_message_obj ("message_obj", true, & kTypeDescriptor_GGS_base_mess) ;

//---------------------------------------------------------------------------*

GGS_message_obj::
GGS_message_obj (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_message_obj::
GGS_message_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_message_obj GGS_message_obj::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_message_obj result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_message_obj *> (inPointer) != NULL)
      : (typeid (cPtr_message_obj) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_message_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_message_obj),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_message_obj GGS_message_obj::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_action_obj & argument_1,
                 const GGS_action_obj & argument_2,
                 const GGS_lstringlist & argument_3,
                 const GGS_ident_map & argument_4,
                 const GGS_mess_prop_obj & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_message_obj result ;
  macroMyNew (result.mPointer, cPtr_message_obj (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mess_prop_obj  GGS_message_obj::
reader_messageproperty (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mess_prop_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_message_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_message_obj *) mPointer)->messageproperty ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_message_obj::actualTypeName (void) const {
  return "message_obj" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__message_obj ("message_obj", gClassInfoFor__base_mess, & kTypeDescriptor_GGS_message_obj) ;

//---------------------------------------------------------------------------*

GGS_object GGS_message_obj::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_message_obj * p = NULL ;
    macroMyNew (p, GGS_message_obj (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_message_obj GGS_message_obj::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_message_obj result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_message_obj * p = dynamic_cast <const GGS_message_obj *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_message_obj, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_message_obj::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_message_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'e_message_map'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_message_map::e_message_map (void) :
mess () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@message_map'                          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_message_map ("message_map", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_message_map::
elementOf_GGS_message_map (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_message_map & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_message_map::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mess.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_message_map::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_message_map * ptr = dynamic_cast <const elementOf_GGS_message_map *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mess.operator_isEqual (ptr->mInfo.mess)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_message_map::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_message_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_message_map * info = (e_message_map *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_message_map::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_message_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_message_map * info = (e_message_map *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_message_map GGS_message_map::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_message_map result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_message_map::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_message_map info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_message_map::
operator_isEqual (const GGS_message_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_message_map::
operator_isNotEqual (const GGS_message_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_message_map::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_message_map::
removeElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_message_obj & outParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  AC_galgas_map_element * removedElement = NULL ;
  PMSInt32 elementID = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    removedElement = internalRemove (inKey) ;
    if (removedElement == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
      outParameter0.drop () ;
    }else{
      cElement * ptr = (cElement *) removedElement ;
      elementID = ptr->mID ;
      outParameter0 = ptr->mInfo.mess ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
  macroMyDelete (removedElement, cElement) ;
}

//---------------------------------------------------------------------------*

void GGS_message_map::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_message_obj & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_message_map info  ;
    info.mess = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_message_map::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_message_obj   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mess ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_message_map::kSearchMessage_get [] = {
  TO_UNICODE ('M'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('a'),
  TO_UNICODE ('g'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('o'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('x'),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_message_map::
method_get (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_message_obj   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_get,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_message_map::kRemoveMessage_del [] = {
  TO_UNICODE ('M'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('a'),
  TO_UNICODE ('g'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('o'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('x'),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_message_map::
modifier_del (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_message_obj & outParameter0 COMMA_LOCATION_ARGS) {
  removeElement (inLexique,
                  kRemoveMessage_del,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_message_map::kInsertMessage_put [] = {
  TO_UNICODE ('M'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('a'),
  TO_UNICODE ('g'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('u'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_message_map::
modifier_put (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_message_obj & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_put,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_message_map GGS_message_map::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_message_map & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_message_map result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_message_map GGS_message_map::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_message_map result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_message_map::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @message_map " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    PMSInt32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (elementID, s, inIndentation) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_message_obj  & GGS_message_map::cEnumerator::_mess (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mess ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_message_map::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_message_map * p = NULL ;
    macroMyNew (p, GGS_message_map (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_message_map GGS_message_map::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_message_map result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_message_map * p = dynamic_cast <const GGS_message_map *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_message_map, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_message_map::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_message_map ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_filter_prop_obj'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_filter_prop_obj::
cPtr_filter_prop_obj (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_filter_prop_obj * GGS_filter_prop_obj::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filter_prop_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_filter_prop_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_filter_prop_obj::
method_base_generate (C_Compiler & inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$MESSAGE_NAME$"),  var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (187)) COMMA_SOURCE_FILE_AT_LINE (187)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FILTER$"),  (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (188))).operator_concat (GGS_string ("_filter")) COMMA_SOURCE_FILE_AT_LINE (188)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FILTER_PTR$"),  ((GGS_string ("&")).operator_concat (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (189)))).operator_concat (GGS_string ("_filter")) COMMA_SOURCE_FILE_AT_LINE (189)) ;
}

//---------------------------------------------------------------------------*

void cPtr_filter_prop_obj::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@filter_prop_obj:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_filter_prop_obj::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_filter_prop_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_filter_prop_obj (& typeid (cPtr_filter_prop_obj), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_filter_prop_obj::galgasRTTI (void) const {
  return & gClassInfoFor__filter_prop_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_filter_prop_obj'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_filter_prop_obj ("filter_prop_obj", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_filter_prop_obj::
GGS_filter_prop_obj (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_filter_prop_obj::
GGS_filter_prop_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_filter_prop_obj GGS_filter_prop_obj::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_filter_prop_obj result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_filter_prop_obj *> (inPointer) != NULL)
      : (typeid (cPtr_filter_prop_obj) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_filter_prop_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_filter_prop_obj),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_filter_prop_obj::actualTypeName (void) const {
  return "filter_prop_obj" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_filter_prop_obj::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__filter_prop_obj ("filter_prop_obj", & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_object GGS_filter_prop_obj::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filter_prop_obj * p = NULL ;
    macroMyNew (p, GGS_filter_prop_obj (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filter_prop_obj GGS_filter_prop_obj::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filter_prop_obj result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filter_prop_obj * p = dynamic_cast <const GGS_filter_prop_obj *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filter_prop_obj, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_filter_prop_obj::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filter_prop_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_void_filter'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_void_filter::
cPtr_void_filter (LOCATION_ARGS)
:cPtr_filter_prop_obj (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_void_filter * GGS_void_filter::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_void_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_void_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_void_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_void_filter::
method_generate (C_Compiler & inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FILTER_PTR$"),  GGS_string ("NULL_PTR") COMMA_SOURCE_FILE_AT_LINE (198)) ;
  method_base_generate (inLexique, var_cas_name, var_cas_res COMMA_SOURCE_FILE_AT_LINE (199)) ;
}

//---------------------------------------------------------------------------*

void cPtr_void_filter::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@void_filter:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_void_filter::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_void_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_void_filter (& typeid (cPtr_void_filter), & typeid (cPtr_filter_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_void_filter::galgasRTTI (void) const {
  return & gClassInfoFor__void_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_void_filter'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_void_filter ("void_filter", true, & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_void_filter::
GGS_void_filter (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_void_filter::
GGS_void_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_void_filter GGS_void_filter::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_void_filter result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_void_filter *> (inPointer) != NULL)
      : (typeid (cPtr_void_filter) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_void_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_void_filter),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_void_filter * gSingleton_void_filter = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_void_filter (void) {
  macroDetachPointer (gSingleton_void_filter, cPtr_void_filter) ;
}

//---------------------------------------------------------------------------*

GGS_void_filter GGS_void_filter::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_void_filter result ;
  if (NULL == gSingleton_void_filter) {
    macroMyNew (gSingleton_void_filter, cPtr_void_filter (THERE)) ;
    registerReleaseRoutine (cleanUp_void_filter) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_void_filter) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_void_filter::actualTypeName (void) const {
  return "void_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__void_filter ("void_filter", gClassInfoFor__filter_prop_obj, & kTypeDescriptor_GGS_void_filter) ;

//---------------------------------------------------------------------------*

GGS_object GGS_void_filter::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_void_filter * p = NULL ;
    macroMyNew (p, GGS_void_filter (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_filter GGS_void_filter::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_void_filter result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_void_filter * p = dynamic_cast <const GGS_void_filter *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_void_filter, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_void_filter::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_void_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_always_filter'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_always_filter::
cPtr_always_filter (LOCATION_ARGS)
:cPtr_filter_prop_obj (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_always_filter * GGS_always_filter::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_always_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_always_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_always_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_always_filter::
method_generate (C_Compiler & inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_f_res = function_template_string (inLexique, GGS_string ("code"), GGS_string ("filter_noparam") COMMA_SOURCE_FILE_AT_LINE (208)) ;
  var_cas_res = (var_cas_f_res).operator_concat (var_cas_res) ;
  method_base_generate (inLexique, var_cas_name, var_cas_res COMMA_SOURCE_FILE_AT_LINE (210)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FILTERING_FUNC$"),  GGS_string ("tpl_filter_always") COMMA_SOURCE_FILE_AT_LINE (211)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FILTER_KIND$"),  GGS_string ("Always") COMMA_SOURCE_FILE_AT_LINE (212)) ;
}

//---------------------------------------------------------------------------*

void cPtr_always_filter::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@always_filter:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_always_filter::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_always_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_always_filter (& typeid (cPtr_always_filter), & typeid (cPtr_filter_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_always_filter::galgasRTTI (void) const {
  return & gClassInfoFor__always_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_always_filter'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_always_filter ("always_filter", true, & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_always_filter::
GGS_always_filter (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_always_filter::
GGS_always_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_always_filter GGS_always_filter::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_always_filter result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_always_filter *> (inPointer) != NULL)
      : (typeid (cPtr_always_filter) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_always_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_always_filter),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_always_filter * gSingleton_always_filter = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_always_filter (void) {
  macroDetachPointer (gSingleton_always_filter, cPtr_always_filter) ;
}

//---------------------------------------------------------------------------*

GGS_always_filter GGS_always_filter::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_always_filter result ;
  if (NULL == gSingleton_always_filter) {
    macroMyNew (gSingleton_always_filter, cPtr_always_filter (THERE)) ;
    registerReleaseRoutine (cleanUp_always_filter) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_always_filter) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_always_filter::actualTypeName (void) const {
  return "always_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__always_filter ("always_filter", gClassInfoFor__filter_prop_obj, & kTypeDescriptor_GGS_always_filter) ;

//---------------------------------------------------------------------------*

GGS_object GGS_always_filter::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_always_filter * p = NULL ;
    macroMyNew (p, GGS_always_filter (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_always_filter GGS_always_filter::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_always_filter result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_always_filter * p = dynamic_cast <const GGS_always_filter *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_always_filter, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_always_filter::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_always_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_never_filter'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_never_filter::
cPtr_never_filter (LOCATION_ARGS)
:cPtr_filter_prop_obj (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_never_filter * GGS_never_filter::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_never_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_never_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_never_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_never_filter::
method_generate (C_Compiler & inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_f_res = function_template_string (inLexique, GGS_string ("code"), GGS_string ("filter_noparam") COMMA_SOURCE_FILE_AT_LINE (221)) ;
  var_cas_res = (var_cas_f_res).operator_concat (var_cas_res) ;
  method_base_generate (inLexique, var_cas_name, var_cas_res COMMA_SOURCE_FILE_AT_LINE (223)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FILTERING_FUNC$"),  GGS_string ("tpl_filter_never") COMMA_SOURCE_FILE_AT_LINE (224)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FILTER_KIND$"),  GGS_string ("Never") COMMA_SOURCE_FILE_AT_LINE (225)) ;
}

//---------------------------------------------------------------------------*

void cPtr_never_filter::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@never_filter:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_never_filter::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_never_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_never_filter (& typeid (cPtr_never_filter), & typeid (cPtr_filter_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_never_filter::galgasRTTI (void) const {
  return & gClassInfoFor__never_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_never_filter'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_never_filter ("never_filter", true, & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_never_filter::
GGS_never_filter (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_never_filter::
GGS_never_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_never_filter GGS_never_filter::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_never_filter result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_never_filter *> (inPointer) != NULL)
      : (typeid (cPtr_never_filter) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_never_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_never_filter),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_never_filter * gSingleton_never_filter = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_never_filter (void) {
  macroDetachPointer (gSingleton_never_filter, cPtr_never_filter) ;
}

//---------------------------------------------------------------------------*

GGS_never_filter GGS_never_filter::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_never_filter result ;
  if (NULL == gSingleton_never_filter) {
    macroMyNew (gSingleton_never_filter, cPtr_never_filter (THERE)) ;
    registerReleaseRoutine (cleanUp_never_filter) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_never_filter) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_never_filter::actualTypeName (void) const {
  return "never_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__never_filter ("never_filter", gClassInfoFor__filter_prop_obj, & kTypeDescriptor_GGS_never_filter) ;

//---------------------------------------------------------------------------*

GGS_object GGS_never_filter::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_never_filter * p = NULL ;
    macroMyNew (p, GGS_never_filter (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_never_filter GGS_never_filter::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_never_filter result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_never_filter * p = dynamic_cast <const GGS_never_filter *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_never_filter, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_never_filter::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_never_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_maskednewequalsx_filter'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_maskednewequalsx_filter::
cPtr_maskednewequalsx_filter (const GGS_luint64 & argument_0,
                                const GGS_luint64 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_filter_prop_obj (THERE),
mask (argument_0),
x (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_maskednewequalsx_filter * GGS_maskednewequalsx_filter::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_maskednewequalsx_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_maskednewequalsx_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_maskednewequalsx_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_maskednewequalsx_filter * ptr = dynamic_cast <const cPtr_maskednewequalsx_filter *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mask.operator_isEqual (ptr->mask).boolValue ()
         && x.operator_isEqual (ptr->x).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_maskednewequalsx_filter::
method_generate (C_Compiler & inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_f_res = function_template_string (inLexique, GGS_string ("code"), GGS_string ("filter_mask_x") COMMA_SOURCE_FILE_AT_LINE (236)) ;
  var_cas_res = (var_cas_f_res).operator_concat (var_cas_res) ;
  method_base_generate (inLexique, var_cas_name, var_cas_res COMMA_SOURCE_FILE_AT_LINE (238)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FILTERING_FUNC$"),  GGS_string ("tpl_filter_masked_new_equals_x") COMMA_SOURCE_FILE_AT_LINE (239)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FILTER_KIND$"),  GGS_string ("Masked New Equals X") COMMA_SOURCE_FILE_AT_LINE (240)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$MASK$"),  mask.reader_uint64 (inLexique COMMA_SOURCE_FILE_AT_LINE (241)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (241)) COMMA_SOURCE_FILE_AT_LINE (241)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$X$"),  x.reader_uint64 (inLexique COMMA_SOURCE_FILE_AT_LINE (242)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (242)) COMMA_SOURCE_FILE_AT_LINE (242)) ;
}

//---------------------------------------------------------------------------*

void cPtr_maskednewequalsx_filter::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@maskednewequalsx_filter:"
           << mask.reader_description (inIndentation + 1)
           << x.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_maskednewequalsx_filter::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_maskednewequalsx_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_maskednewequalsx_filter (& typeid (cPtr_maskednewequalsx_filter), & typeid (cPtr_filter_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_maskednewequalsx_filter::galgasRTTI (void) const {
  return & gClassInfoFor__maskednewequalsx_filter ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_maskednewequalsx_filter::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_maskednewequalsx_filter (mask, x COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_maskednewequalsx_filter'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_maskednewequalsx_filter ("maskednewequalsx_filter", true, & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_maskednewequalsx_filter::
GGS_maskednewequalsx_filter (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_maskednewequalsx_filter::
GGS_maskednewequalsx_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_maskednewequalsx_filter GGS_maskednewequalsx_filter::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_maskednewequalsx_filter result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_maskednewequalsx_filter *> (inPointer) != NULL)
      : (typeid (cPtr_maskednewequalsx_filter) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_maskednewequalsx_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_maskednewequalsx_filter),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_maskednewequalsx_filter GGS_maskednewequalsx_filter::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint64 & argument_0,
                 const GGS_luint64 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_maskednewequalsx_filter result ;
  macroMyNew (result.mPointer, cPtr_maskednewequalsx_filter (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_maskednewequalsx_filter::
reader_mask (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_maskednewequalsx_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_maskednewequalsx_filter *) mPointer)->mask ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_maskednewequalsx_filter::
reader_x (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_maskednewequalsx_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_maskednewequalsx_filter *) mPointer)->x ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_maskednewequalsx_filter::actualTypeName (void) const {
  return "maskednewequalsx_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__maskednewequalsx_filter ("maskednewequalsx_filter", gClassInfoFor__filter_prop_obj, & kTypeDescriptor_GGS_maskednewequalsx_filter) ;

//---------------------------------------------------------------------------*

GGS_object GGS_maskednewequalsx_filter::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_maskednewequalsx_filter * p = NULL ;
    macroMyNew (p, GGS_maskednewequalsx_filter (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_maskednewequalsx_filter GGS_maskednewequalsx_filter::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_maskednewequalsx_filter result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_maskednewequalsx_filter * p = dynamic_cast <const GGS_maskednewequalsx_filter *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_maskednewequalsx_filter, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_maskednewequalsx_filter::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_maskednewequalsx_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_maskednewdiffersx_filter'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_maskednewdiffersx_filter::
cPtr_maskednewdiffersx_filter (const GGS_luint64 & argument_0,
                                const GGS_luint64 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_filter_prop_obj (THERE),
mask (argument_0),
x (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_maskednewdiffersx_filter * GGS_maskednewdiffersx_filter::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_maskednewdiffersx_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_maskednewdiffersx_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_maskednewdiffersx_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_maskednewdiffersx_filter * ptr = dynamic_cast <const cPtr_maskednewdiffersx_filter *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mask.operator_isEqual (ptr->mask).boolValue ()
         && x.operator_isEqual (ptr->x).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_maskednewdiffersx_filter::
method_generate (C_Compiler & inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_f_res = function_template_string (inLexique, GGS_string ("code"), GGS_string ("filter_mask_x") COMMA_SOURCE_FILE_AT_LINE (253)) ;
  var_cas_res = (var_cas_f_res).operator_concat (var_cas_res) ;
  method_base_generate (inLexique, var_cas_name, var_cas_res COMMA_SOURCE_FILE_AT_LINE (255)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FILTERING_FUNC$"),  GGS_string ("tpl_filter_masked_new_differs_x") COMMA_SOURCE_FILE_AT_LINE (256)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FILTER_KIND$"),  GGS_string ("Masked New Differs X") COMMA_SOURCE_FILE_AT_LINE (257)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$MASK$"),  mask.reader_uint64 (inLexique COMMA_SOURCE_FILE_AT_LINE (258)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (258)) COMMA_SOURCE_FILE_AT_LINE (258)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$X$"),  x.reader_uint64 (inLexique COMMA_SOURCE_FILE_AT_LINE (259)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (259)) COMMA_SOURCE_FILE_AT_LINE (259)) ;
}

//---------------------------------------------------------------------------*

void cPtr_maskednewdiffersx_filter::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@maskednewdiffersx_filter:"
           << mask.reader_description (inIndentation + 1)
           << x.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_maskednewdiffersx_filter::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_maskednewdiffersx_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_maskednewdiffersx_filter (& typeid (cPtr_maskednewdiffersx_filter), & typeid (cPtr_filter_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_maskednewdiffersx_filter::galgasRTTI (void) const {
  return & gClassInfoFor__maskednewdiffersx_filter ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_maskednewdiffersx_filter::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_maskednewdiffersx_filter (mask, x COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_maskednewdiffersx_filter'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_maskednewdiffersx_filter ("maskednewdiffersx_filter", true, & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_maskednewdiffersx_filter::
GGS_maskednewdiffersx_filter (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_maskednewdiffersx_filter::
GGS_maskednewdiffersx_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_maskednewdiffersx_filter GGS_maskednewdiffersx_filter::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_maskednewdiffersx_filter result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_maskednewdiffersx_filter *> (inPointer) != NULL)
      : (typeid (cPtr_maskednewdiffersx_filter) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_maskednewdiffersx_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_maskednewdiffersx_filter),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_maskednewdiffersx_filter GGS_maskednewdiffersx_filter::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint64 & argument_0,
                 const GGS_luint64 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_maskednewdiffersx_filter result ;
  macroMyNew (result.mPointer, cPtr_maskednewdiffersx_filter (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_maskednewdiffersx_filter::
reader_mask (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_maskednewdiffersx_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_maskednewdiffersx_filter *) mPointer)->mask ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_maskednewdiffersx_filter::
reader_x (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_maskednewdiffersx_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_maskednewdiffersx_filter *) mPointer)->x ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_maskednewdiffersx_filter::actualTypeName (void) const {
  return "maskednewdiffersx_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__maskednewdiffersx_filter ("maskednewdiffersx_filter", gClassInfoFor__filter_prop_obj, & kTypeDescriptor_GGS_maskednewdiffersx_filter) ;

//---------------------------------------------------------------------------*

GGS_object GGS_maskednewdiffersx_filter::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_maskednewdiffersx_filter * p = NULL ;
    macroMyNew (p, GGS_maskednewdiffersx_filter (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_maskednewdiffersx_filter GGS_maskednewdiffersx_filter::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_maskednewdiffersx_filter result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_maskednewdiffersx_filter * p = dynamic_cast <const GGS_maskednewdiffersx_filter *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_maskednewdiffersx_filter, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_maskednewdiffersx_filter::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_maskednewdiffersx_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_newisequal_filter'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_newisequal_filter::
cPtr_newisequal_filter (LOCATION_ARGS)
:cPtr_filter_prop_obj (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_newisequal_filter * GGS_newisequal_filter::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_newisequal_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_newisequal_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_newisequal_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_newisequal_filter::
method_generate (C_Compiler & inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_f_res = function_template_string (inLexique, GGS_string ("code"), GGS_string ("filter_noparam") COMMA_SOURCE_FILE_AT_LINE (268)) ;
  var_cas_res = (var_cas_f_res).operator_concat (var_cas_res) ;
  method_base_generate (inLexique, var_cas_name, var_cas_res COMMA_SOURCE_FILE_AT_LINE (270)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FILTERING_FUNC$"),  GGS_string ("tpl_filter_new_is_equal") COMMA_SOURCE_FILE_AT_LINE (271)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FILTER_KIND$"),  GGS_string ("New is Equal") COMMA_SOURCE_FILE_AT_LINE (272)) ;
}

//---------------------------------------------------------------------------*

void cPtr_newisequal_filter::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@newisequal_filter:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_newisequal_filter::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_newisequal_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_newisequal_filter (& typeid (cPtr_newisequal_filter), & typeid (cPtr_filter_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_newisequal_filter::galgasRTTI (void) const {
  return & gClassInfoFor__newisequal_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_newisequal_filter'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_newisequal_filter ("newisequal_filter", true, & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_newisequal_filter::
GGS_newisequal_filter (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_newisequal_filter::
GGS_newisequal_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_newisequal_filter GGS_newisequal_filter::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_newisequal_filter result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_newisequal_filter *> (inPointer) != NULL)
      : (typeid (cPtr_newisequal_filter) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_newisequal_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_newisequal_filter),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_newisequal_filter * gSingleton_newisequal_filter = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_newisequal_filter (void) {
  macroDetachPointer (gSingleton_newisequal_filter, cPtr_newisequal_filter) ;
}

//---------------------------------------------------------------------------*

GGS_newisequal_filter GGS_newisequal_filter::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_newisequal_filter result ;
  if (NULL == gSingleton_newisequal_filter) {
    macroMyNew (gSingleton_newisequal_filter, cPtr_newisequal_filter (THERE)) ;
    registerReleaseRoutine (cleanUp_newisequal_filter) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_newisequal_filter) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_newisequal_filter::actualTypeName (void) const {
  return "newisequal_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__newisequal_filter ("newisequal_filter", gClassInfoFor__filter_prop_obj, & kTypeDescriptor_GGS_newisequal_filter) ;

//---------------------------------------------------------------------------*

GGS_object GGS_newisequal_filter::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_newisequal_filter * p = NULL ;
    macroMyNew (p, GGS_newisequal_filter (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_newisequal_filter GGS_newisequal_filter::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_newisequal_filter result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_newisequal_filter * p = dynamic_cast <const GGS_newisequal_filter *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_newisequal_filter, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_newisequal_filter::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_newisequal_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_newisdifferent_filter'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_newisdifferent_filter::
cPtr_newisdifferent_filter (LOCATION_ARGS)
:cPtr_filter_prop_obj (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_newisdifferent_filter * GGS_newisdifferent_filter::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_newisdifferent_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_newisdifferent_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_newisdifferent_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_newisdifferent_filter::
method_generate (C_Compiler & inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_f_res = function_template_string (inLexique, GGS_string ("code"), GGS_string ("filter_noparam") COMMA_SOURCE_FILE_AT_LINE (281)) ;
  var_cas_res = (var_cas_f_res).operator_concat (var_cas_res) ;
  method_base_generate (inLexique, var_cas_name, var_cas_res COMMA_SOURCE_FILE_AT_LINE (283)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FILTERING_FUNC$"),  GGS_string ("tpl_filter_new_is_different") COMMA_SOURCE_FILE_AT_LINE (284)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FILTER_KIND$"),  GGS_string ("New is Different") COMMA_SOURCE_FILE_AT_LINE (285)) ;
}

//---------------------------------------------------------------------------*

void cPtr_newisdifferent_filter::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@newisdifferent_filter:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_newisdifferent_filter::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_newisdifferent_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_newisdifferent_filter (& typeid (cPtr_newisdifferent_filter), & typeid (cPtr_filter_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_newisdifferent_filter::galgasRTTI (void) const {
  return & gClassInfoFor__newisdifferent_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_newisdifferent_filter'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_newisdifferent_filter ("newisdifferent_filter", true, & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_newisdifferent_filter::
GGS_newisdifferent_filter (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_newisdifferent_filter::
GGS_newisdifferent_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_newisdifferent_filter GGS_newisdifferent_filter::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_newisdifferent_filter result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_newisdifferent_filter *> (inPointer) != NULL)
      : (typeid (cPtr_newisdifferent_filter) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_newisdifferent_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_newisdifferent_filter),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_newisdifferent_filter * gSingleton_newisdifferent_filter = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_newisdifferent_filter (void) {
  macroDetachPointer (gSingleton_newisdifferent_filter, cPtr_newisdifferent_filter) ;
}

//---------------------------------------------------------------------------*

GGS_newisdifferent_filter GGS_newisdifferent_filter::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_newisdifferent_filter result ;
  if (NULL == gSingleton_newisdifferent_filter) {
    macroMyNew (gSingleton_newisdifferent_filter, cPtr_newisdifferent_filter (THERE)) ;
    registerReleaseRoutine (cleanUp_newisdifferent_filter) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_newisdifferent_filter) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_newisdifferent_filter::actualTypeName (void) const {
  return "newisdifferent_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__newisdifferent_filter ("newisdifferent_filter", gClassInfoFor__filter_prop_obj, & kTypeDescriptor_GGS_newisdifferent_filter) ;

//---------------------------------------------------------------------------*

GGS_object GGS_newisdifferent_filter::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_newisdifferent_filter * p = NULL ;
    macroMyNew (p, GGS_newisdifferent_filter (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_newisdifferent_filter GGS_newisdifferent_filter::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_newisdifferent_filter result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_newisdifferent_filter * p = dynamic_cast <const GGS_newisdifferent_filter *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_newisdifferent_filter, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_newisdifferent_filter::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_newisdifferent_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_maskednewequalsmaskedold_filter'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_maskednewequalsmaskedold_filter::
cPtr_maskednewequalsmaskedold_filter (const GGS_luint64 & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_filter_prop_obj (THERE),
mask (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_maskednewequalsmaskedold_filter * GGS_maskednewequalsmaskedold_filter::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_maskednewequalsmaskedold_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_maskednewequalsmaskedold_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_maskednewequalsmaskedold_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_maskednewequalsmaskedold_filter * ptr = dynamic_cast <const cPtr_maskednewequalsmaskedold_filter *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mask.operator_isEqual (ptr->mask).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_maskednewequalsmaskedold_filter::
method_generate (C_Compiler & inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_f_res = function_template_string (inLexique, GGS_string ("code"), GGS_string ("filter_mask") COMMA_SOURCE_FILE_AT_LINE (295)) ;
  var_cas_res = (var_cas_f_res).operator_concat (var_cas_res) ;
  method_base_generate (inLexique, var_cas_name, var_cas_res COMMA_SOURCE_FILE_AT_LINE (297)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FILTERING_FUNC$"),  GGS_string ("tpl_filter_masked_new_equals_masked_old") COMMA_SOURCE_FILE_AT_LINE (298)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FILTER_KIND$"),  GGS_string ("Masked New Equals Masked Old") COMMA_SOURCE_FILE_AT_LINE (299)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$MASK$"),  mask.reader_uint64 (inLexique COMMA_SOURCE_FILE_AT_LINE (300)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (300)) COMMA_SOURCE_FILE_AT_LINE (300)) ;
}

//---------------------------------------------------------------------------*

void cPtr_maskednewequalsmaskedold_filter::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@maskednewequalsmaskedold_filter:"
           << mask.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_maskednewequalsmaskedold_filter::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_maskednewequalsmaskedold_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_maskednewequalsmaskedold_filter (& typeid (cPtr_maskednewequalsmaskedold_filter), & typeid (cPtr_filter_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_maskednewequalsmaskedold_filter::galgasRTTI (void) const {
  return & gClassInfoFor__maskednewequalsmaskedold_filter ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_maskednewequalsmaskedold_filter::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_maskednewequalsmaskedold_filter (mask COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_maskednewequalsmaskedold_filter'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_maskednewequalsmaskedold_filter ("maskednewequalsmaskedold_filter", true, & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_maskednewequalsmaskedold_filter::
GGS_maskednewequalsmaskedold_filter (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_maskednewequalsmaskedold_filter::
GGS_maskednewequalsmaskedold_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_maskednewequalsmaskedold_filter GGS_maskednewequalsmaskedold_filter::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_maskednewequalsmaskedold_filter result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_maskednewequalsmaskedold_filter *> (inPointer) != NULL)
      : (typeid (cPtr_maskednewequalsmaskedold_filter) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_maskednewequalsmaskedold_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_maskednewequalsmaskedold_filter),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_maskednewequalsmaskedold_filter GGS_maskednewequalsmaskedold_filter::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint64 & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_maskednewequalsmaskedold_filter result ;
  macroMyNew (result.mPointer, cPtr_maskednewequalsmaskedold_filter (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_maskednewequalsmaskedold_filter::
reader_mask (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_maskednewequalsmaskedold_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_maskednewequalsmaskedold_filter *) mPointer)->mask ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_maskednewequalsmaskedold_filter::actualTypeName (void) const {
  return "maskednewequalsmaskedold_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__maskednewequalsmaskedold_filter ("maskednewequalsmaskedold_filter", gClassInfoFor__filter_prop_obj, & kTypeDescriptor_GGS_maskednewequalsmaskedold_filter) ;

//---------------------------------------------------------------------------*

GGS_object GGS_maskednewequalsmaskedold_filter::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_maskednewequalsmaskedold_filter * p = NULL ;
    macroMyNew (p, GGS_maskednewequalsmaskedold_filter (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_maskednewequalsmaskedold_filter GGS_maskednewequalsmaskedold_filter::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_maskednewequalsmaskedold_filter result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_maskednewequalsmaskedold_filter * p = dynamic_cast <const GGS_maskednewequalsmaskedold_filter *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_maskednewequalsmaskedold_filter, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_maskednewequalsmaskedold_filter::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_maskednewequalsmaskedold_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_maskednewdiffersmaskedold_filter'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_maskednewdiffersmaskedold_filter::
cPtr_maskednewdiffersmaskedold_filter (const GGS_luint64 & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_filter_prop_obj (THERE),
mask (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_maskednewdiffersmaskedold_filter * GGS_maskednewdiffersmaskedold_filter::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_maskednewdiffersmaskedold_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_maskednewdiffersmaskedold_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_maskednewdiffersmaskedold_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_maskednewdiffersmaskedold_filter * ptr = dynamic_cast <const cPtr_maskednewdiffersmaskedold_filter *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mask.operator_isEqual (ptr->mask).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_maskednewdiffersmaskedold_filter::
method_generate (C_Compiler & inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_f_res = function_template_string (inLexique, GGS_string ("code"), GGS_string ("filter_mask") COMMA_SOURCE_FILE_AT_LINE (310)) ;
  var_cas_res = (var_cas_f_res).operator_concat (var_cas_res) ;
  method_base_generate (inLexique, var_cas_name, var_cas_res COMMA_SOURCE_FILE_AT_LINE (312)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FILTERING_FUNC$"),  GGS_string ("tpl_filter_masked_new_differs_masked_old") COMMA_SOURCE_FILE_AT_LINE (313)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FILTER_KIND$"),  GGS_string ("Masked New Differs Masked Old") COMMA_SOURCE_FILE_AT_LINE (314)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$MASK$"),  mask.reader_uint64 (inLexique COMMA_SOURCE_FILE_AT_LINE (315)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (315)) COMMA_SOURCE_FILE_AT_LINE (315)) ;
}

//---------------------------------------------------------------------------*

void cPtr_maskednewdiffersmaskedold_filter::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@maskednewdiffersmaskedold_filter:"
           << mask.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_maskednewdiffersmaskedold_filter::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_maskednewdiffersmaskedold_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_maskednewdiffersmaskedold_filter (& typeid (cPtr_maskednewdiffersmaskedold_filter), & typeid (cPtr_filter_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_maskednewdiffersmaskedold_filter::galgasRTTI (void) const {
  return & gClassInfoFor__maskednewdiffersmaskedold_filter ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_maskednewdiffersmaskedold_filter::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_maskednewdiffersmaskedold_filter (mask COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_maskednewdiffersmaskedold_filter'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_maskednewdiffersmaskedold_filter ("maskednewdiffersmaskedold_filter", true, & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_maskednewdiffersmaskedold_filter::
GGS_maskednewdiffersmaskedold_filter (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_maskednewdiffersmaskedold_filter::
GGS_maskednewdiffersmaskedold_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_maskednewdiffersmaskedold_filter GGS_maskednewdiffersmaskedold_filter::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_maskednewdiffersmaskedold_filter result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_maskednewdiffersmaskedold_filter *> (inPointer) != NULL)
      : (typeid (cPtr_maskednewdiffersmaskedold_filter) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_maskednewdiffersmaskedold_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_maskednewdiffersmaskedold_filter),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_maskednewdiffersmaskedold_filter GGS_maskednewdiffersmaskedold_filter::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint64 & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_maskednewdiffersmaskedold_filter result ;
  macroMyNew (result.mPointer, cPtr_maskednewdiffersmaskedold_filter (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_maskednewdiffersmaskedold_filter::
reader_mask (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_maskednewdiffersmaskedold_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_maskednewdiffersmaskedold_filter *) mPointer)->mask ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_maskednewdiffersmaskedold_filter::actualTypeName (void) const {
  return "maskednewdiffersmaskedold_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__maskednewdiffersmaskedold_filter ("maskednewdiffersmaskedold_filter", gClassInfoFor__filter_prop_obj, & kTypeDescriptor_GGS_maskednewdiffersmaskedold_filter) ;

//---------------------------------------------------------------------------*

GGS_object GGS_maskednewdiffersmaskedold_filter::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_maskednewdiffersmaskedold_filter * p = NULL ;
    macroMyNew (p, GGS_maskednewdiffersmaskedold_filter (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_maskednewdiffersmaskedold_filter GGS_maskednewdiffersmaskedold_filter::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_maskednewdiffersmaskedold_filter result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_maskednewdiffersmaskedold_filter * p = dynamic_cast <const GGS_maskednewdiffersmaskedold_filter *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_maskednewdiffersmaskedold_filter, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_maskednewdiffersmaskedold_filter::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_maskednewdiffersmaskedold_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_newiswithin'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_newiswithin::
cPtr_newiswithin (const GGS_luint64 & argument_0,
                                const GGS_luint64 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_filter_prop_obj (THERE),
min (argument_0),
max (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_newiswithin * GGS_newiswithin::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_newiswithin *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_newiswithin *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_newiswithin::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_newiswithin * ptr = dynamic_cast <const cPtr_newiswithin *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = min.operator_isEqual (ptr->min).boolValue ()
         && max.operator_isEqual (ptr->max).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_newiswithin::
method_generate (C_Compiler & inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_f_res = function_template_string (inLexique, GGS_string ("code"), GGS_string ("filter_interval") COMMA_SOURCE_FILE_AT_LINE (326)) ;
  var_cas_res = (var_cas_f_res).operator_concat (var_cas_res) ;
  method_base_generate (inLexique, var_cas_name, var_cas_res COMMA_SOURCE_FILE_AT_LINE (328)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FILTERING_FUNC$"),  GGS_string ("tpl_filter_new_is_within") COMMA_SOURCE_FILE_AT_LINE (329)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FILTER_KIND$"),  GGS_string ("New is Within") COMMA_SOURCE_FILE_AT_LINE (330)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$MIN$"),  min.reader_uint64 (inLexique COMMA_SOURCE_FILE_AT_LINE (331)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (331)) COMMA_SOURCE_FILE_AT_LINE (331)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$MAX$"),  max.reader_uint64 (inLexique COMMA_SOURCE_FILE_AT_LINE (332)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (332)) COMMA_SOURCE_FILE_AT_LINE (332)) ;
}

//---------------------------------------------------------------------------*

void cPtr_newiswithin::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@newiswithin:"
           << min.reader_description (inIndentation + 1)
           << max.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_newiswithin::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_newiswithin::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_newiswithin (& typeid (cPtr_newiswithin), & typeid (cPtr_filter_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_newiswithin::galgasRTTI (void) const {
  return & gClassInfoFor__newiswithin ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_newiswithin::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_newiswithin (min, max COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_newiswithin'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_newiswithin ("newiswithin", true, & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_newiswithin::
GGS_newiswithin (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_newiswithin::
GGS_newiswithin (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_newiswithin GGS_newiswithin::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_newiswithin result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_newiswithin *> (inPointer) != NULL)
      : (typeid (cPtr_newiswithin) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_newiswithin (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_newiswithin),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_newiswithin GGS_newiswithin::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint64 & argument_0,
                 const GGS_luint64 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_newiswithin result ;
  macroMyNew (result.mPointer, cPtr_newiswithin (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_newiswithin::
reader_min (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_newiswithin *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_newiswithin *) mPointer)->min ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_newiswithin::
reader_max (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_newiswithin *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_newiswithin *) mPointer)->max ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_newiswithin::actualTypeName (void) const {
  return "newiswithin" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__newiswithin ("newiswithin", gClassInfoFor__filter_prop_obj, & kTypeDescriptor_GGS_newiswithin) ;

//---------------------------------------------------------------------------*

GGS_object GGS_newiswithin::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_newiswithin * p = NULL ;
    macroMyNew (p, GGS_newiswithin (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_newiswithin GGS_newiswithin::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_newiswithin result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_newiswithin * p = dynamic_cast <const GGS_newiswithin *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_newiswithin, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_newiswithin::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_newiswithin ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_newisoutside'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_newisoutside::
cPtr_newisoutside (const GGS_luint64 & argument_0,
                                const GGS_luint64 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_filter_prop_obj (THERE),
min (argument_0),
max (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_newisoutside * GGS_newisoutside::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_newisoutside *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_newisoutside *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_newisoutside::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_newisoutside * ptr = dynamic_cast <const cPtr_newisoutside *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = min.operator_isEqual (ptr->min).boolValue ()
         && max.operator_isEqual (ptr->max).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_newisoutside::
method_generate (C_Compiler & inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_f_res = function_template_string (inLexique, GGS_string ("code"), GGS_string ("filter_interval") COMMA_SOURCE_FILE_AT_LINE (343)) ;
  var_cas_res = (var_cas_f_res).operator_concat (var_cas_res) ;
  method_base_generate (inLexique, var_cas_name, var_cas_res COMMA_SOURCE_FILE_AT_LINE (345)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FILTERING_FUNC$"),  GGS_string ("tpl_filter_new_is_outside") COMMA_SOURCE_FILE_AT_LINE (346)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FILTER_KIND$"),  GGS_string ("New is Outside") COMMA_SOURCE_FILE_AT_LINE (347)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$MIN$"),  min.reader_uint64 (inLexique COMMA_SOURCE_FILE_AT_LINE (348)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (348)) COMMA_SOURCE_FILE_AT_LINE (348)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$MAX$"),  max.reader_uint64 (inLexique COMMA_SOURCE_FILE_AT_LINE (349)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (349)) COMMA_SOURCE_FILE_AT_LINE (349)) ;
}

//---------------------------------------------------------------------------*

void cPtr_newisoutside::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@newisoutside:"
           << min.reader_description (inIndentation + 1)
           << max.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_newisoutside::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_newisoutside::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_newisoutside (& typeid (cPtr_newisoutside), & typeid (cPtr_filter_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_newisoutside::galgasRTTI (void) const {
  return & gClassInfoFor__newisoutside ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_newisoutside::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_newisoutside (min, max COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_newisoutside'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_newisoutside ("newisoutside", true, & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_newisoutside::
GGS_newisoutside (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_newisoutside::
GGS_newisoutside (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_newisoutside GGS_newisoutside::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_newisoutside result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_newisoutside *> (inPointer) != NULL)
      : (typeid (cPtr_newisoutside) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_newisoutside (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_newisoutside),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_newisoutside GGS_newisoutside::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint64 & argument_0,
                 const GGS_luint64 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_newisoutside result ;
  macroMyNew (result.mPointer, cPtr_newisoutside (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_newisoutside::
reader_min (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_newisoutside *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_newisoutside *) mPointer)->min ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_newisoutside::
reader_max (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_newisoutside *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_newisoutside *) mPointer)->max ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_newisoutside::actualTypeName (void) const {
  return "newisoutside" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__newisoutside ("newisoutside", gClassInfoFor__filter_prop_obj, & kTypeDescriptor_GGS_newisoutside) ;

//---------------------------------------------------------------------------*

GGS_object GGS_newisoutside::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_newisoutside * p = NULL ;
    macroMyNew (p, GGS_newisoutside (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_newisoutside GGS_newisoutside::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_newisoutside result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_newisoutside * p = dynamic_cast <const GGS_newisoutside *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_newisoutside, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_newisoutside::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_newisoutside ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_newisgreater_filter'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_newisgreater_filter::
cPtr_newisgreater_filter (LOCATION_ARGS)
:cPtr_filter_prop_obj (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_newisgreater_filter * GGS_newisgreater_filter::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_newisgreater_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_newisgreater_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_newisgreater_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_newisgreater_filter::
method_generate (C_Compiler & inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_f_res = function_template_string (inLexique, GGS_string ("code"), GGS_string ("filter_noparam") COMMA_SOURCE_FILE_AT_LINE (358)) ;
  var_cas_res = (var_cas_f_res).operator_concat (var_cas_res) ;
  method_base_generate (inLexique, var_cas_name, var_cas_res COMMA_SOURCE_FILE_AT_LINE (360)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FILTERING_FUNC$"),  GGS_string ("tpl_filter_new_is_greater") COMMA_SOURCE_FILE_AT_LINE (361)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FILTER_KIND$"),  GGS_string ("New is Greater") COMMA_SOURCE_FILE_AT_LINE (362)) ;
}

//---------------------------------------------------------------------------*

void cPtr_newisgreater_filter::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@newisgreater_filter:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_newisgreater_filter::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_newisgreater_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_newisgreater_filter (& typeid (cPtr_newisgreater_filter), & typeid (cPtr_filter_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_newisgreater_filter::galgasRTTI (void) const {
  return & gClassInfoFor__newisgreater_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_newisgreater_filter'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_newisgreater_filter ("newisgreater_filter", true, & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_newisgreater_filter::
GGS_newisgreater_filter (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_newisgreater_filter::
GGS_newisgreater_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_newisgreater_filter GGS_newisgreater_filter::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_newisgreater_filter result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_newisgreater_filter *> (inPointer) != NULL)
      : (typeid (cPtr_newisgreater_filter) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_newisgreater_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_newisgreater_filter),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_newisgreater_filter * gSingleton_newisgreater_filter = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_newisgreater_filter (void) {
  macroDetachPointer (gSingleton_newisgreater_filter, cPtr_newisgreater_filter) ;
}

//---------------------------------------------------------------------------*

GGS_newisgreater_filter GGS_newisgreater_filter::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_newisgreater_filter result ;
  if (NULL == gSingleton_newisgreater_filter) {
    macroMyNew (gSingleton_newisgreater_filter, cPtr_newisgreater_filter (THERE)) ;
    registerReleaseRoutine (cleanUp_newisgreater_filter) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_newisgreater_filter) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_newisgreater_filter::actualTypeName (void) const {
  return "newisgreater_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__newisgreater_filter ("newisgreater_filter", gClassInfoFor__filter_prop_obj, & kTypeDescriptor_GGS_newisgreater_filter) ;

//---------------------------------------------------------------------------*

GGS_object GGS_newisgreater_filter::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_newisgreater_filter * p = NULL ;
    macroMyNew (p, GGS_newisgreater_filter (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_newisgreater_filter GGS_newisgreater_filter::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_newisgreater_filter result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_newisgreater_filter * p = dynamic_cast <const GGS_newisgreater_filter *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_newisgreater_filter, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_newisgreater_filter::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_newisgreater_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_newislessorequal_filter'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_newislessorequal_filter::
cPtr_newislessorequal_filter (LOCATION_ARGS)
:cPtr_filter_prop_obj (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_newislessorequal_filter * GGS_newislessorequal_filter::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_newislessorequal_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_newislessorequal_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_newislessorequal_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_newislessorequal_filter::
method_generate (C_Compiler & inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_f_res = function_template_string (inLexique, GGS_string ("code"), GGS_string ("filter_noparam") COMMA_SOURCE_FILE_AT_LINE (371)) ;
  var_cas_res = (var_cas_f_res).operator_concat (var_cas_res) ;
  method_base_generate (inLexique, var_cas_name, var_cas_res COMMA_SOURCE_FILE_AT_LINE (373)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FILTERING_FUNC$"),  GGS_string ("tpl_filter_new_is_less_or_equal") COMMA_SOURCE_FILE_AT_LINE (374)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FILTER_KIND$"),  GGS_string ("New is Less or Equal") COMMA_SOURCE_FILE_AT_LINE (375)) ;
}

//---------------------------------------------------------------------------*

void cPtr_newislessorequal_filter::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@newislessorequal_filter:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_newislessorequal_filter::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_newislessorequal_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_newislessorequal_filter (& typeid (cPtr_newislessorequal_filter), & typeid (cPtr_filter_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_newislessorequal_filter::galgasRTTI (void) const {
  return & gClassInfoFor__newislessorequal_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_newislessorequal_filter'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_newislessorequal_filter ("newislessorequal_filter", true, & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_newislessorequal_filter::
GGS_newislessorequal_filter (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_newislessorequal_filter::
GGS_newislessorequal_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_newislessorequal_filter GGS_newislessorequal_filter::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_newislessorequal_filter result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_newislessorequal_filter *> (inPointer) != NULL)
      : (typeid (cPtr_newislessorequal_filter) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_newislessorequal_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_newislessorequal_filter),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_newislessorequal_filter * gSingleton_newislessorequal_filter = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_newislessorequal_filter (void) {
  macroDetachPointer (gSingleton_newislessorequal_filter, cPtr_newislessorequal_filter) ;
}

//---------------------------------------------------------------------------*

GGS_newislessorequal_filter GGS_newislessorequal_filter::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_newislessorequal_filter result ;
  if (NULL == gSingleton_newislessorequal_filter) {
    macroMyNew (gSingleton_newislessorequal_filter, cPtr_newislessorequal_filter (THERE)) ;
    registerReleaseRoutine (cleanUp_newislessorequal_filter) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_newislessorequal_filter) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_newislessorequal_filter::actualTypeName (void) const {
  return "newislessorequal_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__newislessorequal_filter ("newislessorequal_filter", gClassInfoFor__filter_prop_obj, & kTypeDescriptor_GGS_newislessorequal_filter) ;

//---------------------------------------------------------------------------*

GGS_object GGS_newislessorequal_filter::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_newislessorequal_filter * p = NULL ;
    macroMyNew (p, GGS_newislessorequal_filter (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_newislessorequal_filter GGS_newislessorequal_filter::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_newislessorequal_filter result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_newislessorequal_filter * p = dynamic_cast <const GGS_newislessorequal_filter *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_newislessorequal_filter, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_newislessorequal_filter::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_newislessorequal_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_newisless_filter'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_newisless_filter::
cPtr_newisless_filter (LOCATION_ARGS)
:cPtr_filter_prop_obj (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_newisless_filter * GGS_newisless_filter::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_newisless_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_newisless_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_newisless_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_newisless_filter::
method_generate (C_Compiler & inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_f_res = function_template_string (inLexique, GGS_string ("code"), GGS_string ("filter_noparam") COMMA_SOURCE_FILE_AT_LINE (384)) ;
  var_cas_res = (var_cas_f_res).operator_concat (var_cas_res) ;
  method_base_generate (inLexique, var_cas_name, var_cas_res COMMA_SOURCE_FILE_AT_LINE (386)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FILTERING_FUNC$"),  GGS_string ("tpl_filter_new_is_less") COMMA_SOURCE_FILE_AT_LINE (387)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FILTER_KIND$"),  GGS_string ("New is Less") COMMA_SOURCE_FILE_AT_LINE (388)) ;
}

//---------------------------------------------------------------------------*

void cPtr_newisless_filter::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@newisless_filter:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_newisless_filter::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_newisless_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_newisless_filter (& typeid (cPtr_newisless_filter), & typeid (cPtr_filter_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_newisless_filter::galgasRTTI (void) const {
  return & gClassInfoFor__newisless_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_newisless_filter'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_newisless_filter ("newisless_filter", true, & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_newisless_filter::
GGS_newisless_filter (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_newisless_filter::
GGS_newisless_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_newisless_filter GGS_newisless_filter::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_newisless_filter result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_newisless_filter *> (inPointer) != NULL)
      : (typeid (cPtr_newisless_filter) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_newisless_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_newisless_filter),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_newisless_filter * gSingleton_newisless_filter = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_newisless_filter (void) {
  macroDetachPointer (gSingleton_newisless_filter, cPtr_newisless_filter) ;
}

//---------------------------------------------------------------------------*

GGS_newisless_filter GGS_newisless_filter::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_newisless_filter result ;
  if (NULL == gSingleton_newisless_filter) {
    macroMyNew (gSingleton_newisless_filter, cPtr_newisless_filter (THERE)) ;
    registerReleaseRoutine (cleanUp_newisless_filter) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_newisless_filter) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_newisless_filter::actualTypeName (void) const {
  return "newisless_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__newisless_filter ("newisless_filter", gClassInfoFor__filter_prop_obj, & kTypeDescriptor_GGS_newisless_filter) ;

//---------------------------------------------------------------------------*

GGS_object GGS_newisless_filter::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_newisless_filter * p = NULL ;
    macroMyNew (p, GGS_newisless_filter (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_newisless_filter GGS_newisless_filter::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_newisless_filter result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_newisless_filter * p = dynamic_cast <const GGS_newisless_filter *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_newisless_filter, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_newisless_filter::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_newisless_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_newisgreaterorequal_filter'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_newisgreaterorequal_filter::
cPtr_newisgreaterorequal_filter (LOCATION_ARGS)
:cPtr_filter_prop_obj (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_newisgreaterorequal_filter * GGS_newisgreaterorequal_filter::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_newisgreaterorequal_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_newisgreaterorequal_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_newisgreaterorequal_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_newisgreaterorequal_filter::
method_generate (C_Compiler & inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_f_res = function_template_string (inLexique, GGS_string ("code"), GGS_string ("filter_noparam") COMMA_SOURCE_FILE_AT_LINE (397)) ;
  var_cas_res = (var_cas_f_res).operator_concat (var_cas_res) ;
  method_base_generate (inLexique, var_cas_name, var_cas_res COMMA_SOURCE_FILE_AT_LINE (399)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FILTERING_FUNC$"),  GGS_string ("tpl_filter_new_is_greater_or_equal") COMMA_SOURCE_FILE_AT_LINE (400)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FILTER_KIND$"),  GGS_string ("New is Greater or Equal") COMMA_SOURCE_FILE_AT_LINE (401)) ;
}

//---------------------------------------------------------------------------*

void cPtr_newisgreaterorequal_filter::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@newisgreaterorequal_filter:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_newisgreaterorequal_filter::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_newisgreaterorequal_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_newisgreaterorequal_filter (& typeid (cPtr_newisgreaterorequal_filter), & typeid (cPtr_filter_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_newisgreaterorequal_filter::galgasRTTI (void) const {
  return & gClassInfoFor__newisgreaterorequal_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_newisgreaterorequal_filter'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_newisgreaterorequal_filter ("newisgreaterorequal_filter", true, & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_newisgreaterorequal_filter::
GGS_newisgreaterorequal_filter (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_newisgreaterorequal_filter::
GGS_newisgreaterorequal_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_newisgreaterorequal_filter GGS_newisgreaterorequal_filter::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_newisgreaterorequal_filter result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_newisgreaterorequal_filter *> (inPointer) != NULL)
      : (typeid (cPtr_newisgreaterorequal_filter) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_newisgreaterorequal_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_newisgreaterorequal_filter),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_newisgreaterorequal_filter * gSingleton_newisgreaterorequal_filter = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_newisgreaterorequal_filter (void) {
  macroDetachPointer (gSingleton_newisgreaterorequal_filter, cPtr_newisgreaterorequal_filter) ;
}

//---------------------------------------------------------------------------*

GGS_newisgreaterorequal_filter GGS_newisgreaterorequal_filter::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_newisgreaterorequal_filter result ;
  if (NULL == gSingleton_newisgreaterorequal_filter) {
    macroMyNew (gSingleton_newisgreaterorequal_filter, cPtr_newisgreaterorequal_filter (THERE)) ;
    registerReleaseRoutine (cleanUp_newisgreaterorequal_filter) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_newisgreaterorequal_filter) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_newisgreaterorequal_filter::actualTypeName (void) const {
  return "newisgreaterorequal_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__newisgreaterorequal_filter ("newisgreaterorequal_filter", gClassInfoFor__filter_prop_obj, & kTypeDescriptor_GGS_newisgreaterorequal_filter) ;

//---------------------------------------------------------------------------*

GGS_object GGS_newisgreaterorequal_filter::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_newisgreaterorequal_filter * p = NULL ;
    macroMyNew (p, GGS_newisgreaterorequal_filter (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_newisgreaterorequal_filter GGS_newisgreaterorequal_filter::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_newisgreaterorequal_filter result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_newisgreaterorequal_filter * p = dynamic_cast <const GGS_newisgreaterorequal_filter *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_newisgreaterorequal_filter, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_newisgreaterorequal_filter::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_newisgreaterorequal_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_oneeveryn_filter'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_oneeveryn_filter::
cPtr_oneeveryn_filter (const GGS_luint64 & argument_0,
                                const GGS_luint64 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_filter_prop_obj (THERE),
period (argument_0),
offset (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_oneeveryn_filter * GGS_oneeveryn_filter::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_oneeveryn_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_oneeveryn_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_oneeveryn_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_oneeveryn_filter * ptr = dynamic_cast <const cPtr_oneeveryn_filter *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = period.operator_isEqual (ptr->period).boolValue ()
         && offset.operator_isEqual (ptr->offset).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_oneeveryn_filter::
method_generate (C_Compiler & inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_f_res = function_template_string (inLexique, GGS_string ("code"), GGS_string ("filter_occurence") COMMA_SOURCE_FILE_AT_LINE (412)) ;
  var_cas_res = (var_cas_f_res).operator_concat (var_cas_res) ;
  method_base_generate (inLexique, var_cas_name, var_cas_res COMMA_SOURCE_FILE_AT_LINE (414)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FILTERING_FUNC$"),  GGS_string ("tpl_filter_one_every_n") COMMA_SOURCE_FILE_AT_LINE (415)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FILTER_KIND$"),  GGS_string ("One Every N") COMMA_SOURCE_FILE_AT_LINE (416)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$PERIOD$"),  period.reader_uint64 (inLexique COMMA_SOURCE_FILE_AT_LINE (417)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (417)) COMMA_SOURCE_FILE_AT_LINE (417)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$OFFSET$"),  offset.reader_uint64 (inLexique COMMA_SOURCE_FILE_AT_LINE (418)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (418)) COMMA_SOURCE_FILE_AT_LINE (418)) ;
}

//---------------------------------------------------------------------------*

void cPtr_oneeveryn_filter::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@oneeveryn_filter:"
           << period.reader_description (inIndentation + 1)
           << offset.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_oneeveryn_filter::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_oneeveryn_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_oneeveryn_filter (& typeid (cPtr_oneeveryn_filter), & typeid (cPtr_filter_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_oneeveryn_filter::galgasRTTI (void) const {
  return & gClassInfoFor__oneeveryn_filter ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_oneeveryn_filter::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_oneeveryn_filter (period, offset COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_oneeveryn_filter'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_oneeveryn_filter ("oneeveryn_filter", true, & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_oneeveryn_filter::
GGS_oneeveryn_filter (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_oneeveryn_filter::
GGS_oneeveryn_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_oneeveryn_filter GGS_oneeveryn_filter::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_oneeveryn_filter result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_oneeveryn_filter *> (inPointer) != NULL)
      : (typeid (cPtr_oneeveryn_filter) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_oneeveryn_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_oneeveryn_filter),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_oneeveryn_filter GGS_oneeveryn_filter::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint64 & argument_0,
                 const GGS_luint64 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_oneeveryn_filter result ;
  macroMyNew (result.mPointer, cPtr_oneeveryn_filter (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_oneeveryn_filter::
reader_period (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_oneeveryn_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_oneeveryn_filter *) mPointer)->period ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_oneeveryn_filter::
reader_offset (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_oneeveryn_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_oneeveryn_filter *) mPointer)->offset ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_oneeveryn_filter::actualTypeName (void) const {
  return "oneeveryn_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__oneeveryn_filter ("oneeveryn_filter", gClassInfoFor__filter_prop_obj, & kTypeDescriptor_GGS_oneeveryn_filter) ;

//---------------------------------------------------------------------------*

GGS_object GGS_oneeveryn_filter::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_oneeveryn_filter * p = NULL ;
    macroMyNew (p, GGS_oneeveryn_filter (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_oneeveryn_filter GGS_oneeveryn_filter::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_oneeveryn_filter result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_oneeveryn_filter * p = dynamic_cast <const GGS_oneeveryn_filter *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_oneeveryn_filter, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_oneeveryn_filter::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_oneeveryn_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_link_obj'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_link_obj::
cPtr_link_obj (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
loc (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_link_obj * GGS_link_obj::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_link_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_link_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_link_obj::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@link_obj:"
           << loc.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_link_obj::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_link_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_link_obj (& typeid (cPtr_link_obj), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_link_obj::galgasRTTI (void) const {
  return & gClassInfoFor__link_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_link_obj'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_link_obj ("link_obj", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_link_obj::
GGS_link_obj (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_link_obj::
GGS_link_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_link_obj GGS_link_obj::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_link_obj result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_link_obj *> (inPointer) != NULL)
      : (typeid (cPtr_link_obj) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_link_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_link_obj),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_link_obj::
reader_loc (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_link_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_link_obj *) mPointer)->loc ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_link_obj::actualTypeName (void) const {
  return "link_obj" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_link_obj::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__link_obj ("link_obj", & kTypeDescriptor_GGS_link_obj) ;

//---------------------------------------------------------------------------*

GGS_object GGS_link_obj::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_link_obj * p = NULL ;
    macroMyNew (p, GGS_link_obj (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_link_obj GGS_link_obj::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_link_obj result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_link_obj * p = dynamic_cast <const GGS_link_obj *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_link_obj, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_link_obj::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_link_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_void_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_void_mess_prop::
cPtr_void_mess_prop (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_void_mess_prop * GGS_void_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_void_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_void_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_void_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_void_mess_prop * ptr = dynamic_cast <const cPtr_void_mess_prop *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_void_mess_prop::
method_s_mess (C_Compiler & inLexique,
                                GGS_lstring & var_cas_sd COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_sd = GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_void_mess_prop::
method_generate (C_Compiler & /* inLexique */,
                                GGS_lstring  /* var_cas_name */,
                                GGS_base_mess  /* var_cas_mess */,
                                GGS_message_map  /* var_cas_messages */,
                                GGS_ident_list_map  /* var_cas_dests */,
                                GGS_string& var_cas_h_res,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_h_res = GGS_string ("") ;
  var_cas_i_res = GGS_string ("") ;
}

//---------------------------------------------------------------------------*

void cPtr_void_mess_prop::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@void_mess_prop:"
           << location.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_void_mess_prop::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_void_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_void_mess_prop (& typeid (cPtr_void_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_void_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__void_mess_prop ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_void_mess_prop::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_void_mess_prop (location COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_void_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_void_mess_prop ("void_mess_prop", true, & kTypeDescriptor_GGS_mess_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_void_mess_prop::
GGS_void_mess_prop (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_void_mess_prop::
GGS_void_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_void_mess_prop GGS_void_mess_prop::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_void_mess_prop result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_void_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_void_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_void_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_void_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_mess_prop GGS_void_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_void_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_void_mess_prop (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_void_mess_prop::actualTypeName (void) const {
  return "void_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__void_mess_prop ("void_mess_prop", gClassInfoFor__mess_prop_obj, & kTypeDescriptor_GGS_void_mess_prop) ;

//---------------------------------------------------------------------------*

GGS_object GGS_void_mess_prop::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_void_mess_prop * p = NULL ;
    macroMyNew (p, GGS_void_mess_prop (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_mess_prop GGS_void_mess_prop::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_void_mess_prop result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_void_mess_prop * p = dynamic_cast <const GGS_void_mess_prop *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_void_mess_prop, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_void_mess_prop::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_void_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_ssi_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ssi_mess_prop::
cPtr_ssi_mess_prop (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
cdatatype (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ssi_mess_prop * GGS_ssi_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ssi_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ssi_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ssi_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ssi_mess_prop * ptr = dynamic_cast <const cPtr_ssi_mess_prop *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && cdatatype.operator_isEqual (ptr->cdatatype).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ssi_mess_prop::
method_s_mess (C_Compiler & inLexique,
                                GGS_lstring & var_cas_sd COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_sd = GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_ssi_mess_prop::
method_generate (C_Compiler & inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_base_mess  /* var_cas_mess */,
                                GGS_message_map  /* var_cas_messages */,
                                GGS_ident_list_map  var_cas_dests,
                                GGS_string& var_cas_h_res,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_h_res = GGS_string ("") ;
  var_cas_i_res = function_template_string (inLexique, GGS_string ("code"), GGS_string ("message_ssi") COMMA_SOURCE_FILE_AT_LINE (452)) ;
  ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$MESSAGE_NAME$"),  var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (453)) COMMA_SOURCE_FILE_AT_LINE (453)) ;
  ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$MESSAGE$"),  (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (454))).operator_concat (GGS_string ("_message")) COMMA_SOURCE_FILE_AT_LINE (454)) ;
  const GGS_bool cond_14151 = var_cas_dests.reader_hasKey (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (455))) ;
  if (cond_14151.isBuiltAndTrue ()) {
    GGS_ident_list  var_cas_d_mess_list ;
    const GGS_ident_list_map  temp_13973 = var_cas_dests ;
    if (temp_13973.isBuilt ()) {
      temp_13973 (HERE)->method_get (inLexique, var_cas_name, var_cas_d_mess_list COMMA_SOURCE_FILE_AT_LINE (457)) ;
    }
    GGS_lstring  var_cas_target ;
    const GGS_ident_list  temp_14056 = var_cas_d_mess_list ;
    if (temp_14056.isBuilt ()) {
      temp_14056 (HERE)->method_first (inLexique, var_cas_target COMMA_SOURCE_FILE_AT_LINE (459)) ;
    }
    ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$TARGET$"),  (var_cas_target.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (460))).operator_concat (GGS_string ("_message")) COMMA_SOURCE_FILE_AT_LINE (460)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_ssi_mess_prop::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@ssi_mess_prop:"
           << location.reader_description (inIndentation + 1)
           << cdatatype.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ssi_mess_prop::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ssi_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ssi_mess_prop (& typeid (cPtr_ssi_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ssi_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__ssi_mess_prop ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ssi_mess_prop::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ssi_mess_prop (location, cdatatype COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_ssi_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_ssi_mess_prop ("ssi_mess_prop", true, & kTypeDescriptor_GGS_mess_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_ssi_mess_prop::
GGS_ssi_mess_prop (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ssi_mess_prop::
GGS_ssi_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ssi_mess_prop GGS_ssi_mess_prop::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ssi_mess_prop result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ssi_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_ssi_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ssi_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ssi_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ssi_mess_prop GGS_ssi_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_ssi_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_ssi_mess_prop (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_ssi_mess_prop::
reader_cdatatype (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ssi_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ssi_mess_prop *) mPointer)->cdatatype ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ssi_mess_prop::actualTypeName (void) const {
  return "ssi_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ssi_mess_prop ("ssi_mess_prop", gClassInfoFor__mess_prop_obj, & kTypeDescriptor_GGS_ssi_mess_prop) ;

//---------------------------------------------------------------------------*

GGS_object GGS_ssi_mess_prop::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_ssi_mess_prop * p = NULL ;
    macroMyNew (p, GGS_ssi_mess_prop (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ssi_mess_prop GGS_ssi_mess_prop::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_ssi_mess_prop result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_ssi_mess_prop * p = dynamic_cast <const GGS_ssi_mess_prop *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_ssi_mess_prop, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_ssi_mess_prop::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_ssi_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_sse_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sse_mess_prop::
cPtr_sse_mess_prop (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_filter_prop_obj & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_basic_type & argument_6,
                                const GGS_lstring & argument_7
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
cdatatype (argument_1),
tranferproperty (argument_2),
filter (argument_3),
networkordercallout (argument_4),
cpuordercallout (argument_5),
initialvalue (argument_6),
networkmessage (argument_7) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sse_mess_prop * GGS_sse_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sse_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_sse_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sse_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sse_mess_prop * ptr = dynamic_cast <const cPtr_sse_mess_prop *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && cdatatype.operator_isEqual (ptr->cdatatype).boolValue ()
         && tranferproperty.operator_isEqual (ptr->tranferproperty).boolValue ()
         && filter.operator_isEqual (ptr->filter).boolValue ()
         && networkordercallout.operator_isEqual (ptr->networkordercallout).boolValue ()
         && cpuordercallout.operator_isEqual (ptr->cpuordercallout).boolValue ()
         && initialvalue.operator_isEqual (ptr->initialvalue).boolValue ()
         && networkmessage.operator_isEqual (ptr->networkmessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sse_mess_prop::
method_s_mess (C_Compiler & inLexique,
                                GGS_lstring & var_cas_sd COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_sd = GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_sse_mess_prop::
method_generate (C_Compiler & inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_base_mess  /* var_cas_mess */,
                                GGS_message_map  /* var_cas_messages */,
                                GGS_ident_list_map  /* var_cas_dests */,
                                GGS_string& var_cas_h_res,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_h_res = GGS_string ("") ;
  var_cas_i_res = function_template_string (inLexique, GGS_string ("code"), GGS_string ("message_sse") COMMA_SOURCE_FILE_AT_LINE (483)) ;
  ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$MESSAGE_NAME$"),  var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (484)) COMMA_SOURCE_FILE_AT_LINE (484)) ;
  ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$MESSAGE$"),  (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (485))).operator_concat (GGS_string ("_message")) COMMA_SOURCE_FILE_AT_LINE (485)) ;
  ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$NETWORKMESSAGE$"),  (networkmessage.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (486))).operator_concat (GGS_string ("_net_message")) COMMA_SOURCE_FILE_AT_LINE (486)) ;
  ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$BUFFER$"),  (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (487))).operator_concat (GGS_string ("_buffer")) COMMA_SOURCE_FILE_AT_LINE (487)) ;
  const GGS_bool cond_15340 = (tranferproperty.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (488))).operator_isNotEqual (GGS_string ("triggered")) ;
  if (cond_15340.isBuiltAndTrue ()) {
    tranferproperty.reader_location (inLexique COMMA_HERE).signalGGSSemanticWarning (inLexique, GGS_string ("Only TRIGGERED transfer property is supported in this version") COMMA_SOURCE_FILE_AT_LINE (489)) ;
  }
  ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$CTYPE$"),  cdatatype.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (491)) COMMA_SOURCE_FILE_AT_LINE (491)) ;
  GGS_string var_cas_iv ;
  const GGS_basic_type  temp_15600 = initialvalue ;
  if (temp_15600.isBuilt ()) {
    temp_15600 (HERE)->method_string (inLexique, var_cas_iv COMMA_SOURCE_FILE_AT_LINE (497)) ;
  }
  const GGS_bool cond_15653 = (var_cas_iv).operator_isNotEqual (GGS_string ("")) ;
  if (cond_15653.isBuiltAndTrue ()) {
    var_cas_iv = (GGS_string (" = ")).operator_concat (var_cas_iv) ;
  }
  ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$INITIALVALUE$"),  var_cas_iv COMMA_SOURCE_FILE_AT_LINE (499)) ;
}

//---------------------------------------------------------------------------*

void cPtr_sse_mess_prop::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sse_mess_prop:"
           << location.reader_description (inIndentation + 1)
           << cdatatype.reader_description (inIndentation + 1)
           << tranferproperty.reader_description (inIndentation + 1)
           << filter.reader_description (inIndentation + 1)
           << networkordercallout.reader_description (inIndentation + 1)
           << cpuordercallout.reader_description (inIndentation + 1)
           << initialvalue.reader_description (inIndentation + 1)
           << networkmessage.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sse_mess_prop::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sse_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sse_mess_prop (& typeid (cPtr_sse_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_sse_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__sse_mess_prop ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sse_mess_prop::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sse_mess_prop (location, cdatatype, tranferproperty, filter, networkordercallout, cpuordercallout, initialvalue, networkmessage COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_sse_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_sse_mess_prop ("sse_mess_prop", true, & kTypeDescriptor_GGS_mess_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_sse_mess_prop::
GGS_sse_mess_prop (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sse_mess_prop::
GGS_sse_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sse_mess_prop GGS_sse_mess_prop::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sse_mess_prop result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sse_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_sse_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sse_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sse_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sse_mess_prop GGS_sse_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_filter_prop_obj & argument_3,
                 const GGS_lstring & argument_4,
                 const GGS_lstring & argument_5,
                 const GGS_basic_type & argument_6,
                 const GGS_lstring & argument_7
                                COMMA_LOCATION_ARGS) {
  GGS_sse_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_sse_mess_prop (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sse_mess_prop::
reader_cdatatype (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sse_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sse_mess_prop *) mPointer)->cdatatype ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sse_mess_prop::
reader_tranferproperty (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sse_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sse_mess_prop *) mPointer)->tranferproperty ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filter_prop_obj  GGS_sse_mess_prop::
reader_filter (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_filter_prop_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sse_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sse_mess_prop *) mPointer)->filter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sse_mess_prop::
reader_networkordercallout (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sse_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sse_mess_prop *) mPointer)->networkordercallout ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sse_mess_prop::
reader_cpuordercallout (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sse_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sse_mess_prop *) mPointer)->cpuordercallout ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_sse_mess_prop::
reader_initialvalue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sse_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sse_mess_prop *) mPointer)->initialvalue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sse_mess_prop::
reader_networkmessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sse_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sse_mess_prop *) mPointer)->networkmessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sse_mess_prop::actualTypeName (void) const {
  return "sse_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__sse_mess_prop ("sse_mess_prop", gClassInfoFor__mess_prop_obj, & kTypeDescriptor_GGS_sse_mess_prop) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sse_mess_prop::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sse_mess_prop * p = NULL ;
    macroMyNew (p, GGS_sse_mess_prop (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sse_mess_prop GGS_sse_mess_prop::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sse_mess_prop result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sse_mess_prop * p = dynamic_cast <const GGS_sse_mess_prop *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sse_mess_prop, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_sse_mess_prop::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sse_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_sde_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sde_mess_prop::
cPtr_sde_mess_prop (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_basic_type & argument_4,
                                const GGS_lstring & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
tranferproperty (argument_1),
networkordercallout (argument_2),
cpuordercallout (argument_3),
initialvalue (argument_4),
networkmessage (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sde_mess_prop * GGS_sde_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sde_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_sde_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sde_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sde_mess_prop * ptr = dynamic_cast <const cPtr_sde_mess_prop *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && tranferproperty.operator_isEqual (ptr->tranferproperty).boolValue ()
         && networkordercallout.operator_isEqual (ptr->networkordercallout).boolValue ()
         && cpuordercallout.operator_isEqual (ptr->cpuordercallout).boolValue ()
         && initialvalue.operator_isEqual (ptr->initialvalue).boolValue ()
         && networkmessage.operator_isEqual (ptr->networkmessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sde_mess_prop::
method_s_mess (C_Compiler & inLexique,
                                GGS_lstring & var_cas_sd COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_sd = GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_sde_mess_prop::
method_generate (C_Compiler & /* inLexique */,
                                GGS_lstring  /* var_cas_name */,
                                GGS_base_mess  /* var_cas_mess */,
                                GGS_message_map  /* var_cas_messages */,
                                GGS_ident_list_map  /* var_cas_dests */,
                                GGS_string& var_cas_h_res,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_h_res = GGS_string ("") ;
  var_cas_i_res = GGS_string ("") ;
}

//---------------------------------------------------------------------------*

void cPtr_sde_mess_prop::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sde_mess_prop:"
           << location.reader_description (inIndentation + 1)
           << tranferproperty.reader_description (inIndentation + 1)
           << networkordercallout.reader_description (inIndentation + 1)
           << cpuordercallout.reader_description (inIndentation + 1)
           << initialvalue.reader_description (inIndentation + 1)
           << networkmessage.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sde_mess_prop::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sde_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sde_mess_prop (& typeid (cPtr_sde_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_sde_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__sde_mess_prop ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sde_mess_prop::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sde_mess_prop (location, tranferproperty, networkordercallout, cpuordercallout, initialvalue, networkmessage COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_sde_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_sde_mess_prop ("sde_mess_prop", true, & kTypeDescriptor_GGS_mess_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_sde_mess_prop::
GGS_sde_mess_prop (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sde_mess_prop::
GGS_sde_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sde_mess_prop GGS_sde_mess_prop::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sde_mess_prop result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sde_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_sde_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sde_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sde_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sde_mess_prop GGS_sde_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_basic_type & argument_4,
                 const GGS_lstring & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_sde_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_sde_mess_prop (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sde_mess_prop::
reader_tranferproperty (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sde_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sde_mess_prop *) mPointer)->tranferproperty ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sde_mess_prop::
reader_networkordercallout (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sde_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sde_mess_prop *) mPointer)->networkordercallout ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sde_mess_prop::
reader_cpuordercallout (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sde_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sde_mess_prop *) mPointer)->cpuordercallout ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_sde_mess_prop::
reader_initialvalue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sde_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sde_mess_prop *) mPointer)->initialvalue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sde_mess_prop::
reader_networkmessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sde_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sde_mess_prop *) mPointer)->networkmessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sde_mess_prop::actualTypeName (void) const {
  return "sde_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__sde_mess_prop ("sde_mess_prop", gClassInfoFor__mess_prop_obj, & kTypeDescriptor_GGS_sde_mess_prop) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sde_mess_prop::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sde_mess_prop * p = NULL ;
    macroMyNew (p, GGS_sde_mess_prop (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sde_mess_prop GGS_sde_mess_prop::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sde_mess_prop result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sde_mess_prop * p = dynamic_cast <const GGS_sde_mess_prop *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sde_mess_prop, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_sde_mess_prop::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sde_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_szi_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_szi_mess_prop::
cPtr_szi_mess_prop (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_szi_mess_prop * GGS_szi_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_szi_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_szi_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_szi_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_szi_mess_prop * ptr = dynamic_cast <const cPtr_szi_mess_prop *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_szi_mess_prop::
method_s_mess (C_Compiler & inLexique,
                                GGS_lstring & var_cas_sd COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_sd = GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_szi_mess_prop::
method_generate (C_Compiler & inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_base_mess  /* var_cas_mess */,
                                GGS_message_map  /* var_cas_messages */,
                                GGS_ident_list_map  var_cas_dests,
                                GGS_string& var_cas_h_res,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_h_res = GGS_string ("") ;
  var_cas_i_res = function_template_string (inLexique, GGS_string ("code"), GGS_string ("message_szi") COMMA_SOURCE_FILE_AT_LINE (534)) ;
  ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$MESSAGE_NAME$"),  var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (535)) COMMA_SOURCE_FILE_AT_LINE (535)) ;
  ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$MESSAGE$"),  (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (536))).operator_concat (GGS_string ("_message")) COMMA_SOURCE_FILE_AT_LINE (536)) ;
  const GGS_bool cond_17193 = var_cas_dests.reader_hasKey (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (537))) ;
  if (cond_17193.isBuiltAndTrue ()) {
    GGS_ident_list  var_cas_d_mess_list ;
    const GGS_ident_list_map  temp_17015 = var_cas_dests ;
    if (temp_17015.isBuilt ()) {
      temp_17015 (HERE)->method_get (inLexique, var_cas_name, var_cas_d_mess_list COMMA_SOURCE_FILE_AT_LINE (539)) ;
    }
    GGS_lstring  var_cas_target ;
    const GGS_ident_list  temp_17098 = var_cas_d_mess_list ;
    if (temp_17098.isBuilt ()) {
      temp_17098 (HERE)->method_first (inLexique, var_cas_target COMMA_SOURCE_FILE_AT_LINE (541)) ;
    }
    ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$TARGET$"),  (var_cas_target.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (542))).operator_concat (GGS_string ("_message")) COMMA_SOURCE_FILE_AT_LINE (542)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_szi_mess_prop::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@szi_mess_prop:"
           << location.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_szi_mess_prop::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_szi_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_szi_mess_prop (& typeid (cPtr_szi_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_szi_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__szi_mess_prop ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_szi_mess_prop::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_szi_mess_prop (location COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_szi_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_szi_mess_prop ("szi_mess_prop", true, & kTypeDescriptor_GGS_mess_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_szi_mess_prop::
GGS_szi_mess_prop (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_szi_mess_prop::
GGS_szi_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_szi_mess_prop GGS_szi_mess_prop::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_szi_mess_prop result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_szi_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_szi_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_szi_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_szi_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_szi_mess_prop GGS_szi_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_szi_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_szi_mess_prop (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_szi_mess_prop::actualTypeName (void) const {
  return "szi_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__szi_mess_prop ("szi_mess_prop", gClassInfoFor__mess_prop_obj, & kTypeDescriptor_GGS_szi_mess_prop) ;

//---------------------------------------------------------------------------*

GGS_object GGS_szi_mess_prop::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_szi_mess_prop * p = NULL ;
    macroMyNew (p, GGS_szi_mess_prop (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_szi_mess_prop GGS_szi_mess_prop::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_szi_mess_prop result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_szi_mess_prop * p = dynamic_cast <const GGS_szi_mess_prop *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_szi_mess_prop, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_szi_mess_prop::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_szi_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_sze_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sze_mess_prop::
cPtr_sze_mess_prop (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
networkordercallout (argument_1),
cpuordercallout (argument_2),
networkmessage (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sze_mess_prop * GGS_sze_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sze_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_sze_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sze_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sze_mess_prop * ptr = dynamic_cast <const cPtr_sze_mess_prop *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && networkordercallout.operator_isEqual (ptr->networkordercallout).boolValue ()
         && cpuordercallout.operator_isEqual (ptr->cpuordercallout).boolValue ()
         && networkmessage.operator_isEqual (ptr->networkmessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sze_mess_prop::
method_s_mess (C_Compiler & inLexique,
                                GGS_lstring & var_cas_sd COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_sd = GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_sze_mess_prop::
method_generate (C_Compiler & inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_base_mess  /* var_cas_mess */,
                                GGS_message_map  /* var_cas_messages */,
                                GGS_ident_list_map  /* var_cas_dests */,
                                GGS_string& var_cas_h_res,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_h_res = GGS_string ("") ;
  var_cas_i_res = function_template_string (inLexique, GGS_string ("code"), GGS_string ("message_sze") COMMA_SOURCE_FILE_AT_LINE (561)) ;
  ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$MESSAGE_NAME$"),  var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (562)) COMMA_SOURCE_FILE_AT_LINE (562)) ;
  ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$MESSAGE$"),  (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (563))).operator_concat (GGS_string ("_message")) COMMA_SOURCE_FILE_AT_LINE (563)) ;
  ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$NETWORKMESSAGE$"),  (networkmessage.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (564))).operator_concat (GGS_string ("_net_message")) COMMA_SOURCE_FILE_AT_LINE (564)) ;
}

//---------------------------------------------------------------------------*

void cPtr_sze_mess_prop::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sze_mess_prop:"
           << location.reader_description (inIndentation + 1)
           << networkordercallout.reader_description (inIndentation + 1)
           << cpuordercallout.reader_description (inIndentation + 1)
           << networkmessage.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sze_mess_prop::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sze_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sze_mess_prop (& typeid (cPtr_sze_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_sze_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__sze_mess_prop ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sze_mess_prop::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sze_mess_prop (location, networkordercallout, cpuordercallout, networkmessage COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_sze_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_sze_mess_prop ("sze_mess_prop", true, & kTypeDescriptor_GGS_mess_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_sze_mess_prop::
GGS_sze_mess_prop (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sze_mess_prop::
GGS_sze_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sze_mess_prop GGS_sze_mess_prop::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sze_mess_prop result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sze_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_sze_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sze_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sze_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sze_mess_prop GGS_sze_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_sze_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_sze_mess_prop (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sze_mess_prop::
reader_networkordercallout (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sze_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sze_mess_prop *) mPointer)->networkordercallout ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sze_mess_prop::
reader_cpuordercallout (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sze_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sze_mess_prop *) mPointer)->cpuordercallout ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sze_mess_prop::
reader_networkmessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sze_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sze_mess_prop *) mPointer)->networkmessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sze_mess_prop::actualTypeName (void) const {
  return "sze_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__sze_mess_prop ("sze_mess_prop", gClassInfoFor__mess_prop_obj, & kTypeDescriptor_GGS_sze_mess_prop) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sze_mess_prop::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sze_mess_prop * p = NULL ;
    macroMyNew (p, GGS_sze_mess_prop (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sze_mess_prop GGS_sze_mess_prop::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sze_mess_prop result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sze_mess_prop * p = dynamic_cast <const GGS_sze_mess_prop *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sze_mess_prop, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_sze_mess_prop::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sze_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_rzi_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_rzi_mess_prop::
cPtr_rzi_mess_prop (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
sendingmessage (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_rzi_mess_prop * GGS_rzi_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rzi_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_rzi_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_rzi_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_rzi_mess_prop * ptr = dynamic_cast <const cPtr_rzi_mess_prop *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && sendingmessage.operator_isEqual (ptr->sendingmessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_rzi_mess_prop::
method_s_mess (C_Compiler & /* inLexique */,
                                GGS_lstring & var_cas_sd COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_sd = sendingmessage ;
}

//---------------------------------------------------------------------------*

void cPtr_rzi_mess_prop::
method_generate (C_Compiler & inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_base_mess  var_cas_mess,
                                GGS_message_map  /* var_cas_messages */,
                                GGS_ident_list_map  var_cas_dests,
                                GGS_string& var_cas_h_res,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_h_res = GGS_string ("") ;
  var_cas_i_res = function_template_string (inLexique, GGS_string ("code"), GGS_string ("message_rzi") COMMA_SOURCE_FILE_AT_LINE (580)) ;
  ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$MESSAGE_NAME$"),  var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (581)) COMMA_SOURCE_FILE_AT_LINE (581)) ;
  ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$MESSAGE$"),  (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (582))).operator_concat (GGS_string ("_message")) COMMA_SOURCE_FILE_AT_LINE (582)) ;
  method_generate_notif (inLexique, var_cas_name, var_cas_mess, var_cas_h_res, var_cas_i_res COMMA_SOURCE_FILE_AT_LINE (585)) ;
  method_generate_dest_list (inLexique, var_cas_name, sendingmessage, var_cas_dests, var_cas_i_res COMMA_SOURCE_FILE_AT_LINE (588)) ;
}

//---------------------------------------------------------------------------*

void cPtr_rzi_mess_prop::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@rzi_mess_prop:"
           << location.reader_description (inIndentation + 1)
           << sendingmessage.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_rzi_mess_prop::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_rzi_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_rzi_mess_prop (& typeid (cPtr_rzi_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_rzi_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__rzi_mess_prop ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_rzi_mess_prop::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_rzi_mess_prop (location, sendingmessage COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_rzi_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_rzi_mess_prop ("rzi_mess_prop", true, & kTypeDescriptor_GGS_mess_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_rzi_mess_prop::
GGS_rzi_mess_prop (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_rzi_mess_prop::
GGS_rzi_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_rzi_mess_prop GGS_rzi_mess_prop::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_rzi_mess_prop result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_rzi_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_rzi_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_rzi_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_rzi_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rzi_mess_prop GGS_rzi_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_rzi_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_rzi_mess_prop (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_rzi_mess_prop::
reader_sendingmessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rzi_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rzi_mess_prop *) mPointer)->sendingmessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_rzi_mess_prop::actualTypeName (void) const {
  return "rzi_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__rzi_mess_prop ("rzi_mess_prop", gClassInfoFor__mess_prop_obj, & kTypeDescriptor_GGS_rzi_mess_prop) ;

//---------------------------------------------------------------------------*

GGS_object GGS_rzi_mess_prop::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_rzi_mess_prop * p = NULL ;
    macroMyNew (p, GGS_rzi_mess_prop (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rzi_mess_prop GGS_rzi_mess_prop::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_rzi_mess_prop result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_rzi_mess_prop * p = dynamic_cast <const GGS_rzi_mess_prop *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_rzi_mess_prop, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_rzi_mess_prop::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_rzi_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_rze_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_rze_mess_prop::
cPtr_rze_mess_prop (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
networkordercallout (argument_1),
cpuordercallout (argument_2),
networkmessage (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_rze_mess_prop * GGS_rze_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rze_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_rze_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_rze_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_rze_mess_prop * ptr = dynamic_cast <const cPtr_rze_mess_prop *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && networkordercallout.operator_isEqual (ptr->networkordercallout).boolValue ()
         && cpuordercallout.operator_isEqual (ptr->cpuordercallout).boolValue ()
         && networkmessage.operator_isEqual (ptr->networkmessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_rze_mess_prop::
method_s_mess (C_Compiler & inLexique,
                                GGS_lstring & var_cas_sd COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_sd = GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_rze_mess_prop::
method_generate (C_Compiler & /* inLexique */,
                                GGS_lstring  /* var_cas_name */,
                                GGS_base_mess  /* var_cas_mess */,
                                GGS_message_map  /* var_cas_messages */,
                                GGS_ident_list_map  /* var_cas_dests */,
                                GGS_string& var_cas_h_res,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_h_res = GGS_string ("") ;
  var_cas_i_res = GGS_string ("") ;
}

//---------------------------------------------------------------------------*

void cPtr_rze_mess_prop::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@rze_mess_prop:"
           << location.reader_description (inIndentation + 1)
           << networkordercallout.reader_description (inIndentation + 1)
           << cpuordercallout.reader_description (inIndentation + 1)
           << networkmessage.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_rze_mess_prop::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_rze_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_rze_mess_prop (& typeid (cPtr_rze_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_rze_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__rze_mess_prop ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_rze_mess_prop::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_rze_mess_prop (location, networkordercallout, cpuordercallout, networkmessage COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_rze_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_rze_mess_prop ("rze_mess_prop", true, & kTypeDescriptor_GGS_mess_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_rze_mess_prop::
GGS_rze_mess_prop (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_rze_mess_prop::
GGS_rze_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_rze_mess_prop GGS_rze_mess_prop::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_rze_mess_prop result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_rze_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_rze_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_rze_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_rze_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rze_mess_prop GGS_rze_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_rze_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_rze_mess_prop (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_rze_mess_prop::
reader_networkordercallout (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rze_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rze_mess_prop *) mPointer)->networkordercallout ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_rze_mess_prop::
reader_cpuordercallout (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rze_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rze_mess_prop *) mPointer)->cpuordercallout ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_rze_mess_prop::
reader_networkmessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rze_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rze_mess_prop *) mPointer)->networkmessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_rze_mess_prop::actualTypeName (void) const {
  return "rze_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__rze_mess_prop ("rze_mess_prop", gClassInfoFor__mess_prop_obj, & kTypeDescriptor_GGS_rze_mess_prop) ;

//---------------------------------------------------------------------------*

GGS_object GGS_rze_mess_prop::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_rze_mess_prop * p = NULL ;
    macroMyNew (p, GGS_rze_mess_prop (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rze_mess_prop GGS_rze_mess_prop::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_rze_mess_prop result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_rze_mess_prop * p = dynamic_cast <const GGS_rze_mess_prop *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_rze_mess_prop, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_rze_mess_prop::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_rze_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_rui_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_rui_mess_prop::
cPtr_rui_mess_prop (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_filter_prop_obj & argument_2,
                                const GGS_basic_type & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
sendingmessage (argument_1),
filter (argument_2),
initialvalue (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_rui_mess_prop * GGS_rui_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rui_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_rui_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_rui_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_rui_mess_prop * ptr = dynamic_cast <const cPtr_rui_mess_prop *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && sendingmessage.operator_isEqual (ptr->sendingmessage).boolValue ()
         && filter.operator_isEqual (ptr->filter).boolValue ()
         && initialvalue.operator_isEqual (ptr->initialvalue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_rui_mess_prop::
method_s_mess (C_Compiler & /* inLexique */,
                                GGS_lstring & var_cas_sd COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_sd = sendingmessage ;
}

//---------------------------------------------------------------------------*

void cPtr_rui_mess_prop::
method_generate (C_Compiler & inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_base_mess  var_cas_mess,
                                GGS_message_map  var_cas_messages,
                                GGS_ident_list_map  var_cas_dests,
                                GGS_string& var_cas_h_res,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_h_res = GGS_string ("") ;
  var_cas_i_res = function_template_string (inLexique, GGS_string ("code"), GGS_string ("message_rui") COMMA_SOURCE_FILE_AT_LINE (625)) ;
  ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$MESSAGE_NAME$"),  var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (626)) COMMA_SOURCE_FILE_AT_LINE (626)) ;
  ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$MESSAGE$"),  (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (627))).operator_concat (GGS_string ("_message")) COMMA_SOURCE_FILE_AT_LINE (627)) ;
  ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$BUFFER$"),  (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (628))).operator_concat (GGS_string ("_buffer")) COMMA_SOURCE_FILE_AT_LINE (628)) ;
  const GGS_filter_prop_obj  temp_20166 = filter ;
  if (temp_20166.isBuilt ()) {
    temp_20166 (HERE)->method_generate (inLexique, var_cas_name, var_cas_i_res COMMA_SOURCE_FILE_AT_LINE (631)) ;
  }
  method_generate_notif (inLexique, var_cas_name, var_cas_mess, var_cas_h_res, var_cas_i_res COMMA_SOURCE_FILE_AT_LINE (634)) ;
  method_generate_dest_list (inLexique, var_cas_name, sendingmessage, var_cas_dests, var_cas_i_res COMMA_SOURCE_FILE_AT_LINE (637)) ;
  GGS_message_obj  var_cas_sender ;
  const GGS_message_map  temp_20519 = var_cas_messages ;
  if (temp_20519.isBuilt ()) {
    temp_20519 (HERE)->method_get (inLexique, sendingmessage, var_cas_sender COMMA_SOURCE_FILE_AT_LINE (641)) ;
  }
  GGS_mess_prop_obj  var_cas_prop = var_cas_sender.reader_messageproperty (inLexique COMMA_SOURCE_FILE_AT_LINE (642)) ;
  { const GGS_mess_prop_obj _var_21076 = var_cas_prop ; // CAST instruction
    if (_var_21076.getPtr () != NULL) {
      macroValidPointer (_var_21076.getPtr ()) ;
      if (typeid (cPtr_ssi_mess_prop) == typeid (* (_var_21076.getPtr ()))) {
        const GGS_ssi_mess_prop var_cas_ssi (_var_21076.getPtr ()) ;
        ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$CTYPE$"),  var_cas_ssi.reader_cdatatype (inLexique COMMA_SOURCE_FILE_AT_LINE (645)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (645)) COMMA_SOURCE_FILE_AT_LINE (645)) ;
        ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$SIZE$"),  ((GGS_string ("sizeof(")).operator_concat (var_cas_ssi.reader_cdatatype (inLexique COMMA_SOURCE_FILE_AT_LINE (646)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (646)))).operator_concat (GGS_string (")")) COMMA_SOURCE_FILE_AT_LINE (646)) ;
        GGS_string var_cas_iv ;
        const GGS_basic_type  temp_20870 = initialvalue ;
        if (temp_20870.isBuilt ()) {
          temp_20870 (HERE)->method_string (inLexique, var_cas_iv COMMA_SOURCE_FILE_AT_LINE (648)) ;
        }
        const GGS_bool cond_20927 = (var_cas_iv).operator_isNotEqual (GGS_string ("")) ;
        if (cond_20927.isBuiltAndTrue ()) {
          var_cas_iv = (GGS_string (" = ")).operator_concat (var_cas_iv) ;
        }
        ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$INITIALVALUE$"),  var_cas_iv COMMA_SOURCE_FILE_AT_LINE (650)) ;
      }else{
        GGS_location (inLexique).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("Incompatible sending message object") COMMA_SOURCE_FILE_AT_LINE (653)) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_rui_mess_prop::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@rui_mess_prop:"
           << location.reader_description (inIndentation + 1)
           << sendingmessage.reader_description (inIndentation + 1)
           << filter.reader_description (inIndentation + 1)
           << initialvalue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_rui_mess_prop::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_rui_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_rui_mess_prop (& typeid (cPtr_rui_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_rui_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__rui_mess_prop ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_rui_mess_prop::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_rui_mess_prop (location, sendingmessage, filter, initialvalue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_rui_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_rui_mess_prop ("rui_mess_prop", true, & kTypeDescriptor_GGS_mess_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_rui_mess_prop::
GGS_rui_mess_prop (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_rui_mess_prop::
GGS_rui_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_rui_mess_prop GGS_rui_mess_prop::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_rui_mess_prop result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_rui_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_rui_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_rui_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_rui_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rui_mess_prop GGS_rui_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_filter_prop_obj & argument_2,
                 const GGS_basic_type & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_rui_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_rui_mess_prop (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_rui_mess_prop::
reader_sendingmessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rui_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rui_mess_prop *) mPointer)->sendingmessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filter_prop_obj  GGS_rui_mess_prop::
reader_filter (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_filter_prop_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rui_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rui_mess_prop *) mPointer)->filter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_rui_mess_prop::
reader_initialvalue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rui_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rui_mess_prop *) mPointer)->initialvalue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_rui_mess_prop::actualTypeName (void) const {
  return "rui_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__rui_mess_prop ("rui_mess_prop", gClassInfoFor__mess_prop_obj, & kTypeDescriptor_GGS_rui_mess_prop) ;

//---------------------------------------------------------------------------*

GGS_object GGS_rui_mess_prop::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_rui_mess_prop * p = NULL ;
    macroMyNew (p, GGS_rui_mess_prop (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rui_mess_prop GGS_rui_mess_prop::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_rui_mess_prop result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_rui_mess_prop * p = dynamic_cast <const GGS_rui_mess_prop *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_rui_mess_prop, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_rui_mess_prop::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_rui_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_rqi_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_rqi_mess_prop::
cPtr_rqi_mess_prop (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_filter_prop_obj & argument_2,
                                const GGS_basic_type & argument_3,
                                const GGS_luint64 & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
sendingmessage (argument_1),
filter (argument_2),
initialvalue (argument_3),
queuesize (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_rqi_mess_prop * GGS_rqi_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rqi_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_rqi_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_rqi_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_rqi_mess_prop * ptr = dynamic_cast <const cPtr_rqi_mess_prop *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && sendingmessage.operator_isEqual (ptr->sendingmessage).boolValue ()
         && filter.operator_isEqual (ptr->filter).boolValue ()
         && initialvalue.operator_isEqual (ptr->initialvalue).boolValue ()
         && queuesize.operator_isEqual (ptr->queuesize).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_rqi_mess_prop::
method_s_mess (C_Compiler & /* inLexique */,
                                GGS_lstring & var_cas_sd COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_sd = sendingmessage ;
}

//---------------------------------------------------------------------------*

void cPtr_rqi_mess_prop::
method_generate (C_Compiler & inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_base_mess  var_cas_mess,
                                GGS_message_map  var_cas_messages,
                                GGS_ident_list_map  var_cas_dests,
                                GGS_string& var_cas_h_res,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_h_res = GGS_string ("") ;
  var_cas_i_res = function_template_string (inLexique, GGS_string ("code"), GGS_string ("message_rqi") COMMA_SOURCE_FILE_AT_LINE (672)) ;
  ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$MESSAGE_NAME$"),  var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (673)) COMMA_SOURCE_FILE_AT_LINE (673)) ;
  ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$MESSAGE$"),  (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (674))).operator_concat (GGS_string ("_message")) COMMA_SOURCE_FILE_AT_LINE (674)) ;
  ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$BUFFER$"),  (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (675))).operator_concat (GGS_string ("_buffer")) COMMA_SOURCE_FILE_AT_LINE (675)) ;
  const GGS_filter_prop_obj  temp_21905 = filter ;
  if (temp_21905.isBuilt ()) {
    temp_21905 (HERE)->method_generate (inLexique, var_cas_name, var_cas_i_res COMMA_SOURCE_FILE_AT_LINE (678)) ;
  }
  method_generate_notif (inLexique, var_cas_name, var_cas_mess, var_cas_h_res, var_cas_i_res COMMA_SOURCE_FILE_AT_LINE (681)) ;
  method_generate_dest_list (inLexique, var_cas_name, sendingmessage, var_cas_dests, var_cas_i_res COMMA_SOURCE_FILE_AT_LINE (684)) ;
  GGS_message_obj  var_cas_sender ;
  const GGS_message_map  temp_22258 = var_cas_messages ;
  if (temp_22258.isBuilt ()) {
    temp_22258 (HERE)->method_get (inLexique, sendingmessage, var_cas_sender COMMA_SOURCE_FILE_AT_LINE (688)) ;
  }
  GGS_mess_prop_obj  var_cas_prop = var_cas_sender.reader_messageproperty (inLexique COMMA_SOURCE_FILE_AT_LINE (689)) ;
  { const GGS_mess_prop_obj _var_22560 = var_cas_prop ; // CAST instruction
    if (_var_22560.getPtr () != NULL) {
      macroValidPointer (_var_22560.getPtr ()) ;
      if (typeid (cPtr_ssi_mess_prop) == typeid (* (_var_22560.getPtr ()))) {
        const GGS_ssi_mess_prop var_cas_ssi (_var_22560.getPtr ()) ;
        ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$CTYPE$"),  var_cas_ssi.reader_cdatatype (inLexique COMMA_SOURCE_FILE_AT_LINE (692)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (692)) COMMA_SOURCE_FILE_AT_LINE (692)) ;
      }else{
        GGS_location (inLexique).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("Incompatible sending message object") COMMA_SOURCE_FILE_AT_LINE (695)) ;
      }
    }
  }
  ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$QUEUE_SIZE$"),  queuesize.reader_uint64 (inLexique COMMA_SOURCE_FILE_AT_LINE (698)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (698)) COMMA_SOURCE_FILE_AT_LINE (698)) ;
  ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$DYN_QUEUE$"),  (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (701))).operator_concat (GGS_string ("_dyn_queue")) COMMA_SOURCE_FILE_AT_LINE (701)) ;
}

//---------------------------------------------------------------------------*

void cPtr_rqi_mess_prop::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@rqi_mess_prop:"
           << location.reader_description (inIndentation + 1)
           << sendingmessage.reader_description (inIndentation + 1)
           << filter.reader_description (inIndentation + 1)
           << initialvalue.reader_description (inIndentation + 1)
           << queuesize.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_rqi_mess_prop::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_rqi_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_rqi_mess_prop (& typeid (cPtr_rqi_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_rqi_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__rqi_mess_prop ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_rqi_mess_prop::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_rqi_mess_prop (location, sendingmessage, filter, initialvalue, queuesize COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_rqi_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_rqi_mess_prop ("rqi_mess_prop", true, & kTypeDescriptor_GGS_mess_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_rqi_mess_prop::
GGS_rqi_mess_prop (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_rqi_mess_prop::
GGS_rqi_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_rqi_mess_prop GGS_rqi_mess_prop::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_rqi_mess_prop result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_rqi_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_rqi_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_rqi_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_rqi_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rqi_mess_prop GGS_rqi_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_filter_prop_obj & argument_2,
                 const GGS_basic_type & argument_3,
                 const GGS_luint64 & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_rqi_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_rqi_mess_prop (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_rqi_mess_prop::
reader_sendingmessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rqi_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rqi_mess_prop *) mPointer)->sendingmessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filter_prop_obj  GGS_rqi_mess_prop::
reader_filter (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_filter_prop_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rqi_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rqi_mess_prop *) mPointer)->filter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_rqi_mess_prop::
reader_initialvalue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rqi_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rqi_mess_prop *) mPointer)->initialvalue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_rqi_mess_prop::
reader_queuesize (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rqi_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rqi_mess_prop *) mPointer)->queuesize ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_rqi_mess_prop::actualTypeName (void) const {
  return "rqi_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__rqi_mess_prop ("rqi_mess_prop", gClassInfoFor__mess_prop_obj, & kTypeDescriptor_GGS_rqi_mess_prop) ;

//---------------------------------------------------------------------------*

GGS_object GGS_rqi_mess_prop::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_rqi_mess_prop * p = NULL ;
    macroMyNew (p, GGS_rqi_mess_prop (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rqi_mess_prop GGS_rqi_mess_prop::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_rqi_mess_prop result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_rqi_mess_prop * p = dynamic_cast <const GGS_rqi_mess_prop *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_rqi_mess_prop, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_rqi_mess_prop::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_rqi_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_rue_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_rue_mess_prop::
cPtr_rue_mess_prop (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_filter_prop_obj & argument_2,
                                const GGS_link_obj & argument_3,
                                const GGS_basic_type & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
cdatatype (argument_1),
filter (argument_2),
link (argument_3),
initialvalue (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_rue_mess_prop * GGS_rue_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rue_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_rue_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_rue_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_rue_mess_prop * ptr = dynamic_cast <const cPtr_rue_mess_prop *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && cdatatype.operator_isEqual (ptr->cdatatype).boolValue ()
         && filter.operator_isEqual (ptr->filter).boolValue ()
         && link.operator_isEqual (ptr->link).boolValue ()
         && initialvalue.operator_isEqual (ptr->initialvalue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_rue_mess_prop::
method_s_mess (C_Compiler & inLexique,
                                GGS_lstring & var_cas_sd COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_sd = GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_rue_mess_prop::
method_generate (C_Compiler & inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_base_mess  var_cas_mess,
                                GGS_message_map  /* var_cas_messages */,
                                GGS_ident_list_map  /* var_cas_dests */,
                                GGS_string& var_cas_h_res,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_h_res = GGS_string ("") ;
  var_cas_i_res = function_template_string (inLexique, GGS_string ("code"), GGS_string ("message_rue") COMMA_SOURCE_FILE_AT_LINE (721)) ;
  ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$MESSAGE_NAME$"),  var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (722)) COMMA_SOURCE_FILE_AT_LINE (722)) ;
  ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$MESSAGE$"),  (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (723))).operator_concat (GGS_string ("_message")) COMMA_SOURCE_FILE_AT_LINE (723)) ;
  ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$BUFFER$"),  (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (724))).operator_concat (GGS_string ("_buffer")) COMMA_SOURCE_FILE_AT_LINE (724)) ;
  const GGS_filter_prop_obj  temp_23622 = filter ;
  if (temp_23622.isBuilt ()) {
    temp_23622 (HERE)->method_generate (inLexique, var_cas_name, var_cas_i_res COMMA_SOURCE_FILE_AT_LINE (727)) ;
  }
  method_generate_notif (inLexique, var_cas_name, var_cas_mess, var_cas_h_res, var_cas_i_res COMMA_SOURCE_FILE_AT_LINE (730)) ;
  ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$CTYPE$"),  cdatatype.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (736)) COMMA_SOURCE_FILE_AT_LINE (736)) ;
  ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$SIZE$"),  ((GGS_string ("sizeof(")).operator_concat (cdatatype.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (737)))).operator_concat (GGS_string (")")) COMMA_SOURCE_FILE_AT_LINE (737)) ;
  GGS_string var_cas_iv ;
  const GGS_basic_type  temp_24116 = initialvalue ;
  if (temp_24116.isBuilt ()) {
    temp_24116 (HERE)->method_string (inLexique, var_cas_iv COMMA_SOURCE_FILE_AT_LINE (739)) ;
  }
  const GGS_bool cond_24169 = (var_cas_iv).operator_isNotEqual (GGS_string ("")) ;
  if (cond_24169.isBuiltAndTrue ()) {
    var_cas_iv = (GGS_string (" = ")).operator_concat (var_cas_iv) ;
  }
  ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$INITIALVALUE$"),  var_cas_iv COMMA_SOURCE_FILE_AT_LINE (741)) ;
  ::routine_doReplace (inLexique,  var_cas_i_res,  GGS_string ("$TARGET_PTR$"),  GGS_string ("NULL_PTR") COMMA_SOURCE_FILE_AT_LINE (742)) ;
}

//---------------------------------------------------------------------------*

void cPtr_rue_mess_prop::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@rue_mess_prop:"
           << location.reader_description (inIndentation + 1)
           << cdatatype.reader_description (inIndentation + 1)
           << filter.reader_description (inIndentation + 1)
           << link.reader_description (inIndentation + 1)
           << initialvalue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_rue_mess_prop::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_rue_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_rue_mess_prop (& typeid (cPtr_rue_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_rue_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__rue_mess_prop ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_rue_mess_prop::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_rue_mess_prop (location, cdatatype, filter, link, initialvalue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_rue_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_rue_mess_prop ("rue_mess_prop", true, & kTypeDescriptor_GGS_mess_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_rue_mess_prop::
GGS_rue_mess_prop (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_rue_mess_prop::
GGS_rue_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_rue_mess_prop GGS_rue_mess_prop::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_rue_mess_prop result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_rue_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_rue_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_rue_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_rue_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rue_mess_prop GGS_rue_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_filter_prop_obj & argument_2,
                 const GGS_link_obj & argument_3,
                 const GGS_basic_type & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_rue_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_rue_mess_prop (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_rue_mess_prop::
reader_cdatatype (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rue_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rue_mess_prop *) mPointer)->cdatatype ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filter_prop_obj  GGS_rue_mess_prop::
reader_filter (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_filter_prop_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rue_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rue_mess_prop *) mPointer)->filter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_link_obj  GGS_rue_mess_prop::
reader_link (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_link_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rue_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rue_mess_prop *) mPointer)->link ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_rue_mess_prop::
reader_initialvalue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rue_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rue_mess_prop *) mPointer)->initialvalue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_rue_mess_prop::actualTypeName (void) const {
  return "rue_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__rue_mess_prop ("rue_mess_prop", gClassInfoFor__mess_prop_obj, & kTypeDescriptor_GGS_rue_mess_prop) ;

//---------------------------------------------------------------------------*

GGS_object GGS_rue_mess_prop::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_rue_mess_prop * p = NULL ;
    macroMyNew (p, GGS_rue_mess_prop (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rue_mess_prop GGS_rue_mess_prop::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_rue_mess_prop result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_rue_mess_prop * p = dynamic_cast <const GGS_rue_mess_prop *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_rue_mess_prop, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_rue_mess_prop::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_rue_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_rqe_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_rqe_mess_prop::
cPtr_rqe_mess_prop (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_luint64 & argument_2,
                                const GGS_filter_prop_obj & argument_3,
                                const GGS_link_obj & argument_4,
                                const GGS_basic_type & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
cdatatype (argument_1),
queuesize (argument_2),
filter (argument_3),
link (argument_4),
initialvalue (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_rqe_mess_prop * GGS_rqe_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rqe_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_rqe_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_rqe_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_rqe_mess_prop * ptr = dynamic_cast <const cPtr_rqe_mess_prop *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && cdatatype.operator_isEqual (ptr->cdatatype).boolValue ()
         && queuesize.operator_isEqual (ptr->queuesize).boolValue ()
         && filter.operator_isEqual (ptr->filter).boolValue ()
         && link.operator_isEqual (ptr->link).boolValue ()
         && initialvalue.operator_isEqual (ptr->initialvalue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_rqe_mess_prop::
method_s_mess (C_Compiler & inLexique,
                                GGS_lstring & var_cas_sd COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_sd = GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_rqe_mess_prop::
method_generate (C_Compiler & /* inLexique */,
                                GGS_lstring  /* var_cas_name */,
                                GGS_base_mess  /* var_cas_mess */,
                                GGS_message_map  /* var_cas_messages */,
                                GGS_ident_list_map  /* var_cas_dests */,
                                GGS_string& var_cas_h_res,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_h_res = GGS_string ("") ;
  var_cas_i_res = GGS_string ("") ;
}

//---------------------------------------------------------------------------*

void cPtr_rqe_mess_prop::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@rqe_mess_prop:"
           << location.reader_description (inIndentation + 1)
           << cdatatype.reader_description (inIndentation + 1)
           << queuesize.reader_description (inIndentation + 1)
           << filter.reader_description (inIndentation + 1)
           << link.reader_description (inIndentation + 1)
           << initialvalue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_rqe_mess_prop::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_rqe_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_rqe_mess_prop (& typeid (cPtr_rqe_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_rqe_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__rqe_mess_prop ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_rqe_mess_prop::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_rqe_mess_prop (location, cdatatype, queuesize, filter, link, initialvalue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_rqe_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_rqe_mess_prop ("rqe_mess_prop", true, & kTypeDescriptor_GGS_mess_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_rqe_mess_prop::
GGS_rqe_mess_prop (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_rqe_mess_prop::
GGS_rqe_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_rqe_mess_prop GGS_rqe_mess_prop::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_rqe_mess_prop result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_rqe_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_rqe_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_rqe_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_rqe_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rqe_mess_prop GGS_rqe_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_luint64 & argument_2,
                 const GGS_filter_prop_obj & argument_3,
                 const GGS_link_obj & argument_4,
                 const GGS_basic_type & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_rqe_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_rqe_mess_prop (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_rqe_mess_prop::
reader_cdatatype (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rqe_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rqe_mess_prop *) mPointer)->cdatatype ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_rqe_mess_prop::
reader_queuesize (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rqe_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rqe_mess_prop *) mPointer)->queuesize ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filter_prop_obj  GGS_rqe_mess_prop::
reader_filter (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_filter_prop_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rqe_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rqe_mess_prop *) mPointer)->filter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_link_obj  GGS_rqe_mess_prop::
reader_link (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_link_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rqe_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rqe_mess_prop *) mPointer)->link ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_rqe_mess_prop::
reader_initialvalue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rqe_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rqe_mess_prop *) mPointer)->initialvalue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_rqe_mess_prop::actualTypeName (void) const {
  return "rqe_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__rqe_mess_prop ("rqe_mess_prop", gClassInfoFor__mess_prop_obj, & kTypeDescriptor_GGS_rqe_mess_prop) ;

//---------------------------------------------------------------------------*

GGS_object GGS_rqe_mess_prop::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_rqe_mess_prop * p = NULL ;
    macroMyNew (p, GGS_rqe_mess_prop (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rqe_mess_prop GGS_rqe_mess_prop::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_rqe_mess_prop result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_rqe_mess_prop * p = dynamic_cast <const GGS_rqe_mess_prop *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_rqe_mess_prop, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_rqe_mess_prop::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_rqe_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_rde_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_rde_mess_prop::
cPtr_rde_mess_prop (const GGS_location & argument_0,
                                const GGS_link_obj & argument_1,
                                const GGS_basic_type & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
link (argument_1),
initialvalue (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_rde_mess_prop * GGS_rde_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rde_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_rde_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_rde_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_rde_mess_prop * ptr = dynamic_cast <const cPtr_rde_mess_prop *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && link.operator_isEqual (ptr->link).boolValue ()
         && initialvalue.operator_isEqual (ptr->initialvalue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_rde_mess_prop::
method_s_mess (C_Compiler & inLexique,
                                GGS_lstring & var_cas_sd COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_sd = GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_rde_mess_prop::
method_generate (C_Compiler & /* inLexique */,
                                GGS_lstring  /* var_cas_name */,
                                GGS_base_mess  /* var_cas_mess */,
                                GGS_message_map  /* var_cas_messages */,
                                GGS_ident_list_map  /* var_cas_dests */,
                                GGS_string& var_cas_h_res,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_h_res = GGS_string ("") ;
  var_cas_i_res = GGS_string ("") ;
}

//---------------------------------------------------------------------------*

void cPtr_rde_mess_prop::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@rde_mess_prop:"
           << location.reader_description (inIndentation + 1)
           << link.reader_description (inIndentation + 1)
           << initialvalue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_rde_mess_prop::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_rde_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_rde_mess_prop (& typeid (cPtr_rde_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_rde_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__rde_mess_prop ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_rde_mess_prop::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_rde_mess_prop (location, link, initialvalue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_rde_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_rde_mess_prop ("rde_mess_prop", true, & kTypeDescriptor_GGS_mess_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_rde_mess_prop::
GGS_rde_mess_prop (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_rde_mess_prop::
GGS_rde_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_rde_mess_prop GGS_rde_mess_prop::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_rde_mess_prop result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_rde_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_rde_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_rde_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_rde_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rde_mess_prop GGS_rde_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_link_obj & argument_1,
                 const GGS_basic_type & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_rde_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_rde_mess_prop (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_link_obj  GGS_rde_mess_prop::
reader_link (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_link_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rde_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rde_mess_prop *) mPointer)->link ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_rde_mess_prop::
reader_initialvalue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rde_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rde_mess_prop *) mPointer)->initialvalue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_rde_mess_prop::actualTypeName (void) const {
  return "rde_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__rde_mess_prop ("rde_mess_prop", gClassInfoFor__mess_prop_obj, & kTypeDescriptor_GGS_rde_mess_prop) ;

//---------------------------------------------------------------------------*

GGS_object GGS_rde_mess_prop::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_rde_mess_prop * p = NULL ;
    macroMyNew (p, GGS_rde_mess_prop (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rde_mess_prop GGS_rde_mess_prop::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_rde_mess_prop result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_rde_mess_prop * p = dynamic_cast <const GGS_rde_mess_prop *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_rde_mess_prop, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_rde_mess_prop::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_rde_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_rzs_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_rzs_mess_prop::
cPtr_rzs_mess_prop (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_basic_type & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
cdatatype (argument_1),
initialvalue (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_rzs_mess_prop * GGS_rzs_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rzs_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_rzs_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_rzs_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_rzs_mess_prop * ptr = dynamic_cast <const cPtr_rzs_mess_prop *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && cdatatype.operator_isEqual (ptr->cdatatype).boolValue ()
         && initialvalue.operator_isEqual (ptr->initialvalue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_rzs_mess_prop::
method_s_mess (C_Compiler & inLexique,
                                GGS_lstring & var_cas_sd COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_sd = GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_rzs_mess_prop::
method_generate (C_Compiler & /* inLexique */,
                                GGS_lstring  /* var_cas_name */,
                                GGS_base_mess  /* var_cas_mess */,
                                GGS_message_map  /* var_cas_messages */,
                                GGS_ident_list_map  /* var_cas_dests */,
                                GGS_string& var_cas_h_res,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_h_res = GGS_string ("") ;
  var_cas_i_res = GGS_string ("") ;
}

//---------------------------------------------------------------------------*

void cPtr_rzs_mess_prop::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@rzs_mess_prop:"
           << location.reader_description (inIndentation + 1)
           << cdatatype.reader_description (inIndentation + 1)
           << initialvalue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_rzs_mess_prop::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_rzs_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_rzs_mess_prop (& typeid (cPtr_rzs_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_rzs_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__rzs_mess_prop ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_rzs_mess_prop::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_rzs_mess_prop (location, cdatatype, initialvalue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_rzs_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_rzs_mess_prop ("rzs_mess_prop", true, & kTypeDescriptor_GGS_mess_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_rzs_mess_prop::
GGS_rzs_mess_prop (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_rzs_mess_prop::
GGS_rzs_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_rzs_mess_prop GGS_rzs_mess_prop::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_rzs_mess_prop result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_rzs_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_rzs_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_rzs_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_rzs_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rzs_mess_prop GGS_rzs_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_basic_type & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_rzs_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_rzs_mess_prop (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_rzs_mess_prop::
reader_cdatatype (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rzs_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rzs_mess_prop *) mPointer)->cdatatype ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_rzs_mess_prop::
reader_initialvalue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rzs_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rzs_mess_prop *) mPointer)->initialvalue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_rzs_mess_prop::actualTypeName (void) const {
  return "rzs_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__rzs_mess_prop ("rzs_mess_prop", gClassInfoFor__mess_prop_obj, & kTypeDescriptor_GGS_rzs_mess_prop) ;

//---------------------------------------------------------------------------*

GGS_object GGS_rzs_mess_prop::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_rzs_mess_prop * p = NULL ;
    macroMyNew (p, GGS_rzs_mess_prop (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rzs_mess_prop GGS_rzs_mess_prop::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_rzs_mess_prop result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_rzs_mess_prop * p = dynamic_cast <const GGS_rzs_mess_prop *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_rzs_mess_prop, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_rzs_mess_prop::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_rzs_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_void_link'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_void_link::
cPtr_void_link (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_link_obj (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_void_link * GGS_void_link::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_void_link *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_void_link *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_void_link::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_void_link * ptr = dynamic_cast <const cPtr_void_link *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_void_link::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@void_link:"
           << loc.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_void_link::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_void_link::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_void_link (& typeid (cPtr_void_link), & typeid (cPtr_link_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_void_link::galgasRTTI (void) const {
  return & gClassInfoFor__void_link ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_void_link::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_void_link (loc COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_void_link'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_void_link ("void_link", true, & kTypeDescriptor_GGS_link_obj) ;

//---------------------------------------------------------------------------*

GGS_void_link::
GGS_void_link (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_void_link::
GGS_void_link (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_void_link GGS_void_link::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_void_link result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_void_link *> (inPointer) != NULL)
      : (typeid (cPtr_void_link) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_void_link (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_void_link),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_link GGS_void_link::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_void_link result ;
  macroMyNew (result.mPointer, cPtr_void_link (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_void_link::actualTypeName (void) const {
  return "void_link" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__void_link ("void_link", gClassInfoFor__link_obj, & kTypeDescriptor_GGS_void_link) ;

//---------------------------------------------------------------------------*

GGS_object GGS_void_link::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_void_link * p = NULL ;
    macroMyNew (p, GGS_void_link (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_link GGS_void_link::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_void_link result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_void_link * p = dynamic_cast <const GGS_void_link *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_void_link, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_void_link::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_void_link ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_true_link'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_true_link::
cPtr_true_link (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_link_obj (argument_0 COMMA_THERE),
receivemessage (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_true_link * GGS_true_link::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_true_link *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_true_link *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_true_link::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_true_link * ptr = dynamic_cast <const cPtr_true_link *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && receivemessage.operator_isEqual (ptr->receivemessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_true_link::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@true_link:"
           << loc.reader_description (inIndentation + 1)
           << receivemessage.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_true_link::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_true_link::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_true_link (& typeid (cPtr_true_link), & typeid (cPtr_link_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_true_link::galgasRTTI (void) const {
  return & gClassInfoFor__true_link ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_true_link::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_true_link (loc, receivemessage COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_true_link'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_true_link ("true_link", true, & kTypeDescriptor_GGS_link_obj) ;

//---------------------------------------------------------------------------*

GGS_true_link::
GGS_true_link (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_true_link::
GGS_true_link (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_true_link GGS_true_link::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_true_link result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_true_link *> (inPointer) != NULL)
      : (typeid (cPtr_true_link) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_true_link (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_true_link),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_true_link GGS_true_link::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_true_link result ;
  macroMyNew (result.mPointer, cPtr_true_link (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_true_link::
reader_receivemessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_true_link *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_true_link *) mPointer)->receivemessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_true_link::actualTypeName (void) const {
  return "true_link" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__true_link ("true_link", gClassInfoFor__link_obj, & kTypeDescriptor_GGS_true_link) ;

//---------------------------------------------------------------------------*

GGS_object GGS_true_link::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_true_link * p = NULL ;
    macroMyNew (p, GGS_true_link (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_true_link GGS_true_link::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_true_link result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_true_link * p = dynamic_cast <const GGS_true_link *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_true_link, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_true_link::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_true_link ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_false_link'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_false_link::
cPtr_false_link (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_link_obj (argument_0 COMMA_THERE),
networkmessage (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_false_link * GGS_false_link::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_false_link *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_false_link *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_false_link::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_false_link * ptr = dynamic_cast <const cPtr_false_link *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && networkmessage.operator_isEqual (ptr->networkmessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_false_link::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@false_link:"
           << loc.reader_description (inIndentation + 1)
           << networkmessage.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_false_link::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_false_link::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_false_link (& typeid (cPtr_false_link), & typeid (cPtr_link_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_false_link::galgasRTTI (void) const {
  return & gClassInfoFor__false_link ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_false_link::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_false_link (loc, networkmessage COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_false_link'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_false_link ("false_link", true, & kTypeDescriptor_GGS_link_obj) ;

//---------------------------------------------------------------------------*

GGS_false_link::
GGS_false_link (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_false_link::
GGS_false_link (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_false_link GGS_false_link::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_false_link result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_false_link *> (inPointer) != NULL)
      : (typeid (cPtr_false_link) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_false_link (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_false_link),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_false_link GGS_false_link::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_false_link result ;
  macroMyNew (result.mPointer, cPtr_false_link (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_false_link::
reader_networkmessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_false_link *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_false_link *) mPointer)->networkmessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_false_link::actualTypeName (void) const {
  return "false_link" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__false_link ("false_link", gClassInfoFor__link_obj, & kTypeDescriptor_GGS_false_link) ;

//---------------------------------------------------------------------------*

GGS_object GGS_false_link::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_false_link * p = NULL ;
    macroMyNew (p, GGS_false_link (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_false_link GGS_false_link::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_false_link result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_false_link * p = dynamic_cast <const GGS_false_link *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_false_link, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_false_link::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_false_link ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_nmcallback_action'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_nmcallback_action::
cPtr_nmcallback_action (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_luint64 & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_action_obj (argument_0 COMMA_THERE),
function_name (argument_1),
ipdu (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_nmcallback_action * GGS_nmcallback_action::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_nmcallback_action *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_nmcallback_action *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_nmcallback_action::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_nmcallback_action * ptr = dynamic_cast <const cPtr_nmcallback_action *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && function_name.operator_isEqual (ptr->function_name).boolValue ()
         && ipdu.operator_isEqual (ptr->ipdu).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_nmcallback_action::
method_generate (C_Compiler & inLexique,
                                GGS_lstring  /* var_cas_name */,
                                GGS_string /* var_cas_err */,
                                GGS_string var_cas_key,
                                GGS_string& /* var_cas_h_res */,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  ::routine_doReplace (inLexique,  var_cas_i_res,  var_cas_key,  GGS_string ("NULL_PTR") COMMA_SOURCE_FILE_AT_LINE (823)) ;
}

//---------------------------------------------------------------------------*

void cPtr_nmcallback_action::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@nmcallback_action:"
           << location.reader_description (inIndentation + 1)
           << function_name.reader_description (inIndentation + 1)
           << ipdu.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_nmcallback_action::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_nmcallback_action::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_nmcallback_action (& typeid (cPtr_nmcallback_action), & typeid (cPtr_action_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_nmcallback_action::galgasRTTI (void) const {
  return & gClassInfoFor__nmcallback_action ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_nmcallback_action::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_nmcallback_action (location, function_name, ipdu COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_nmcallback_action'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_nmcallback_action ("nmcallback_action", true, & kTypeDescriptor_GGS_action_obj) ;

//---------------------------------------------------------------------------*

GGS_nmcallback_action::
GGS_nmcallback_action (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_nmcallback_action::
GGS_nmcallback_action (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_nmcallback_action GGS_nmcallback_action::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_nmcallback_action result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_nmcallback_action *> (inPointer) != NULL)
      : (typeid (cPtr_nmcallback_action) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_nmcallback_action (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_nmcallback_action),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nmcallback_action GGS_nmcallback_action::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_luint64 & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_nmcallback_action result ;
  macroMyNew (result.mPointer, cPtr_nmcallback_action (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_nmcallback_action::
reader_function_name (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_nmcallback_action *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_nmcallback_action *) mPointer)->function_name ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_nmcallback_action::
reader_ipdu (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_nmcallback_action *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_nmcallback_action *) mPointer)->ipdu ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_nmcallback_action::actualTypeName (void) const {
  return "nmcallback_action" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__nmcallback_action ("nmcallback_action", gClassInfoFor__action_obj, & kTypeDescriptor_GGS_nmcallback_action) ;

//---------------------------------------------------------------------------*

GGS_object GGS_nmcallback_action::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_nmcallback_action * p = NULL ;
    macroMyNew (p, GGS_nmcallback_action (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nmcallback_action GGS_nmcallback_action::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_nmcallback_action result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_nmcallback_action * p = dynamic_cast <const GGS_nmcallback_action *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_nmcallback_action, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_nmcallback_action::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_nmcallback_action ;
}

//---------------------------------------------------------------------------*

