//---------------------------------------------------------------------------*
//                                                                           *
//                   File 'goil_template_invocation.cpp'                     *
//                        Generated by version 1.9.4                         *
//                    november 14th, 2009, at 15h19'28"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != 599
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "goil_template_invocation.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "goil_template_invocation.ggs", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Include directives generated by grammar includes              *
//                                                                           *
//---------------------------------------------------------------------------*

#include "goil_template_grammar.h"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                 Implementation of routine "addBoolValue"                  *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_addBoolValue (C_Compiler & inLexique,
                                GGS_goilTemplateVariableMap  & var_cas_ioTemplateVariableMap,
                                const GGS_lstring   var_cas_inVariableName,
                                const GGS_bool  var_cas_inValue COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_addBoolValue at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_ioTemplateVariableMap.modifier_insertKey (inLexique, var_cas_inVariableName, GGS_goilTemplateType::constructor_boolType (inLexique COMMA_HERE), GGS_goilTemplateValue::constructor_new (((var_cas_inValue).isBuiltAndTrue () ? (GGS_uint64 (1ULL)) : (GGS_uint64 (0ULL))), GGS_string (""), GGS_goilTemplateFieldMapList ::constructor_emptyList ()) COMMA_SOURCE_FILE_AT_LINE (32)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_addBoolValue\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Implementation of routine "addUnsignedValue"                *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_addUnsignedValue (C_Compiler & inLexique,
                                GGS_goilTemplateVariableMap  & var_cas_ioTemplateVariableMap,
                                const GGS_lstring   var_cas_inVariableName,
                                const GGS_uint64   var_cas_inValue COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_addUnsignedValue at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_ioTemplateVariableMap.modifier_insertKey (inLexique, var_cas_inVariableName, GGS_goilTemplateType::constructor_unsignedType (inLexique COMMA_HERE), GGS_goilTemplateValue::constructor_new (var_cas_inValue, GGS_string (""), GGS_goilTemplateFieldMapList ::constructor_emptyList ()) COMMA_SOURCE_FILE_AT_LINE (46)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_addUnsignedValue\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Implementation of routine "addStringValue"                 *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_addStringValue (C_Compiler & inLexique,
                                GGS_goilTemplateVariableMap  & var_cas_ioTemplateVariableMap,
                                const GGS_lstring   var_cas_inVariableName,
                                const GGS_string  var_cas_inValue COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_addStringValue at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_ioTemplateVariableMap.modifier_insertKey (inLexique, var_cas_inVariableName, GGS_goilTemplateType::constructor_stringType (inLexique COMMA_HERE), GGS_goilTemplateValue::constructor_new (GGS_uint64 (0ULL), var_cas_inValue, GGS_goilTemplateFieldMapList ::constructor_emptyList ()) COMMA_SOURCE_FILE_AT_LINE (60)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_addStringValue\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Implementation of routine "addListValue"                  *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_addListValue (C_Compiler & inLexique,
                                GGS_goilTemplateVariableMap  & var_cas_ioTemplateVariableMap,
                                const GGS_lstring   var_cas_inVariableName,
                                const GGS_goilTemplateFieldMapList   var_cas_inValue COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_addListValue at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_ioTemplateVariableMap.modifier_insertKey (inLexique, var_cas_inVariableName, GGS_goilTemplateType::constructor_listType (inLexique COMMA_HERE), GGS_goilTemplateValue::constructor_new (GGS_uint64 (0ULL), GGS_string (""), var_cas_inValue) COMMA_SOURCE_FILE_AT_LINE (74)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_addListValue\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of routine "addBoolFieldValue"                *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_addBoolFieldValue (C_Compiler & inLexique,
                                GGS_goilTemplateFieldMap  & var_cas_ioTemplateFieldMap,
                                const GGS_lstring   var_cas_inVariableName,
                                const GGS_bool  var_cas_inValue COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_addBoolFieldValue at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_ioTemplateFieldMap.modifier_insertKey (inLexique, var_cas_inVariableName, GGS_goilTemplateType::constructor_boolType (inLexique COMMA_HERE), ((var_cas_inValue).isBuiltAndTrue () ? (GGS_uint64 (1ULL)) : (GGS_uint64 (0ULL))), GGS_string ("") COMMA_SOURCE_FILE_AT_LINE (92)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_addBoolFieldValue\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of routine "addUnsignedFieldValue"              *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_addUnsignedFieldValue (C_Compiler & inLexique,
                                GGS_goilTemplateFieldMap  & var_cas_ioTemplateFieldMap,
                                const GGS_lstring   var_cas_inVariableName,
                                const GGS_uint64   var_cas_inValue COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_addUnsignedFieldValue at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_ioTemplateFieldMap.modifier_insertKey (inLexique, var_cas_inVariableName, GGS_goilTemplateType::constructor_unsignedType (inLexique COMMA_HERE), var_cas_inValue, GGS_string ("") COMMA_SOURCE_FILE_AT_LINE (107)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_addUnsignedFieldValue\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "addStringFieldValue"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_addStringFieldValue (C_Compiler & inLexique,
                                GGS_goilTemplateFieldMap  & var_cas_ioTemplateFieldMap,
                                const GGS_lstring   var_cas_inVariableName,
                                const GGS_string  var_cas_inValue COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_addStringFieldValue at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_ioTemplateFieldMap.modifier_insertKey (inLexique, var_cas_inVariableName, GGS_goilTemplateType::constructor_stringType (inLexique COMMA_HERE), GGS_uint64 (0ULL), var_cas_inValue COMMA_SOURCE_FILE_AT_LINE (122)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_addStringFieldValue\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of function "displayTypeAndValue"              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string function_displayTypeAndValue (C_Compiler & inLexique,
                                const GGS_goilTemplateType  var_cas_inType,
                                const GGS_goilTemplateValue  var_cas_inValue COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_displayTypeAndValue at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_string var_cas_outResult ;
  switch (var_cas_inType.enumValue ()) {
  case GGS_goilTemplateType::enum_boolType:
    {
    var_cas_outResult = (GGS_string ("bool: ")).operator_concat ((((var_cas_inValue.reader_mUnsigned64Value (inLexique COMMA_SOURCE_FILE_AT_LINE (143))).operator_isEqual (GGS_uint64 (1ULL))).isBuiltAndTrue () ? (GGS_string ("yes")) : (GGS_string ("no")))) ;
    }
    break ;
  case GGS_goilTemplateType::enum_unsignedType:
    {
    var_cas_outResult = (GGS_string ("unsigned: ")).operator_concat (var_cas_inValue.reader_mUnsigned64Value (inLexique COMMA_SOURCE_FILE_AT_LINE (145)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (145))) ;
    }
    break ;
  case GGS_goilTemplateType::enum_stringType:
    {
    var_cas_outResult = ((GGS_string ("string: '")).operator_concat (var_cas_inValue.reader_mStringValue (inLexique COMMA_SOURCE_FILE_AT_LINE (147)))).operator_concat (GGS_string ("'")) ;
    }
    break ;
  case GGS_goilTemplateType::enum_listType:
    {
    var_cas_outResult = ((((GGS_string ("list, ")).operator_concat (var_cas_inValue.reader_mMapListValue (inLexique COMMA_SOURCE_FILE_AT_LINE (149)).reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (149)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (149)))).operator_concat (GGS_string (" element"))).operator_concat ((((var_cas_inValue.reader_mMapListValue (inLexique COMMA_SOURCE_FILE_AT_LINE (149)).reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (149))).operator_strictSup (GGS_uint (1U))).isBuiltAndTrue () ? (GGS_string ("s")) : (GGS_string (""))))).operator_concat (GGS_string (":")) ;
    {
        GGS_uint var_cas_idx (true, 0) ;
      GGS_goilTemplateFieldMapList::cEnumerator enumerator_5616 (var_cas_inValue.reader_mMapListValue (inLexique COMMA_SOURCE_FILE_AT_LINE (150)), true) ;
      const GGS_goilTemplateFieldMapList::cElement * operand_5616 = NULL ;
      while (((operand_5616 = enumerator_5616.nextObject ()))) {
        macroValidPointer (operand_5616) ;
        var_cas_outResult.appendCString ("\n"
          "  #") ;
        var_cas_outResult.dotAssign_operation (var_cas_idx.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (151))) ;
        var_cas_outResult.appendCString (":") ;
        {
          GGS_goilTemplateFieldMap::cEnumerator enumerator_5720 (operand_5616->mMap, true) ;
          const GGS_goilTemplateFieldMap::cElement * operand_5720 = enumerator_5720.nextObject () ;
          if ((operand_5720 != NULL)) {
            bool _foreach_loop_5720 ;
            do{
              macroValidPointer (operand_5720) ;
              var_cas_outResult.appendCString ("'") ;
              var_cas_outResult.dotAssign_operation (operand_5720->mKey) ;
              var_cas_outResult.appendCString ("' ") ;
              switch (operand_5720->mInfo.mType.enumValue ()) {
              case GGS_goilTemplateType::enum_boolType:
                {
                var_cas_outResult.appendCString ("bool: ") ;
                var_cas_outResult.dotAssign_operation ((((operand_5720->mInfo.mUnsigned64Value).operator_isEqual (GGS_uint64 (1ULL))).isBuiltAndTrue () ? (GGS_string ("yes")) : (GGS_string ("no")))) ;
                }
                break ;
              case GGS_goilTemplateType::enum_unsignedType:
                {
                var_cas_outResult.appendCString ("unsigned: ") ;
                var_cas_outResult.dotAssign_operation (operand_5720->mInfo.mUnsigned64Value.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (158))) ;
                }
                break ;
              case GGS_goilTemplateType::enum_stringType:
                {
                var_cas_outResult.appendCString ("string: '") ;
                var_cas_outResult.dotAssign_operation (operand_5720->mInfo.mStringValue) ;
                var_cas_outResult.appendCString ("'") ;
                }
                break ;
              case GGS_goilTemplateType::enum_listType:
                {
                }
                break ;
              case GGS_goilTemplateType::kNotBuilt:
                break ;
              }
              operand_5720 = enumerator_5720.nextObject () ;
              _foreach_loop_5720 = ((operand_5720 != NULL)) ;
              if (_foreach_loop_5720) {
                var_cas_outResult.appendCString (", ") ;
              }
            }while (_foreach_loop_5720) ;
          }
        }
        var_cas_idx.mValue ++ ;
      }
    }
    }
    break ;
  case GGS_goilTemplateType::kNotBuilt:
    break ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_displayTypeAndValue\n") ;
  #endif
  return var_cas_outResult ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "displayTemplateVariableMap"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_displayTemplateVariableMap (C_Compiler & inLexique,
                                const GGS_goilTemplateVariableMap   var_cas_inTemplateVariableMap COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_displayTemplateVariableMap at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_goilTemplateVariableMap::cEnumerator enumerator_6423 (var_cas_inTemplateVariableMap, true) ;
    const GGS_goilTemplateVariableMap::cElement * operand_6423 = NULL ;
    while (((operand_6423 = enumerator_6423.nextObject ()))) {
      macroValidPointer (operand_6423) ;
      inLexique.printMessage (((((GGS_string ("'")).operator_concat (operand_6423->mKey)).operator_concat (GGS_string ("' "))).operator_concat (function_displayTypeAndValue (inLexique, operand_6423->mInfo.mType, operand_6423->mInfo.mValue COMMA_SOURCE_FILE_AT_LINE (175)))).operator_concat (GGS_string ("\n")) COMMA_SOURCE_FILE_AT_LINE (175)) ;
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_displayTemplateVariableMap\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of routine "goilTemplateInvocation"             *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_goilTemplateInvocation (C_Compiler & inLexique,
                                const GGS_lstring   var_cas_inTemplateName,
                                const GGS_string  var_cas_inPath,
                                const GGS_goilTemplateVariableMap   var_cas_inTemplateVariableMap,
                                GGS_string & var_cas_ioResultingString COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_goilTemplateInvocation at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  const GGS_bool cond_9265 = (GGS_uint ::constructor_errorCount (inLexique COMMA_HERE)).operator_isEqual (GGS_uint (0U)) ;
  if (cond_9265.isBuiltAndTrue ()) {
    const GGS_string var_cas_templateDir = gOption_goil_5F_options_goil_5F_template_5F_dir.value () ;
    const GGS_bool cond_7028 = (var_cas_templateDir.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (190))).operator_isEqual (GGS_uint (0U)) ;
    if (cond_7028.isBuiltAndTrue ()) {
      var_cas_inTemplateName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the '--goil-templates' option is required for generating code") COMMA_SOURCE_FILE_AT_LINE (192)) ;
    }else if (cond_7028.isBuiltAndFalse ()) {
      const GGS_bool cond_7203 = (var_cas_templateDir.reader_directoryExists (inLexique COMMA_SOURCE_FILE_AT_LINE (192))).operator_not () ;
      if (cond_7203.isBuiltAndTrue ()) {
        var_cas_inTemplateName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '--goil-templates' option value is '")).operator_concat (var_cas_templateDir)).operator_concat (GGS_string ("', but is not a valid directory path")) COMMA_SOURCE_FILE_AT_LINE (194)) ;
      }else if (cond_7203.isBuiltAndFalse ()) {
        const GGS_string var_cas_targetDir = gOption_goil_5F_options_target_5F_platform.value () ;
        const GGS_bool cond_7423 = (var_cas_targetDir.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (196))).operator_isEqual (GGS_uint (0U)) ;
        if (cond_7423.isBuiltAndTrue ()) {
          var_cas_inTemplateName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the '--target' (or '-t') option is required for generating code") COMMA_SOURCE_FILE_AT_LINE (198)) ;
        }else if (cond_7423.isBuiltAndFalse ()) {
          const GGS_bool cond_7743 = (((var_cas_templateDir).operator_concat (GGS_string ("/"))).operator_concat (var_cas_targetDir).reader_directoryExists (inLexique COMMA_SOURCE_FILE_AT_LINE (198))).operator_not () ;
          if (cond_7743.isBuiltAndTrue ()) {
            var_cas_inTemplateName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((((GGS_string ("the '--target' (or '-t') option value is '")).operator_concat (var_cas_templateDir)).operator_concat (GGS_string ("', so the path formed with '--goil-templates' option is '"))).operator_concat (var_cas_templateDir)).operator_concat (GGS_string ("/"))).operator_concat (var_cas_targetDir)).operator_concat (GGS_string ("', but it is not a valid directory path")) COMMA_SOURCE_FILE_AT_LINE (203)) ;
          }else if (cond_7743.isBuiltAndFalse ()) {
            GGS_stringlist  var_cas_pathList = GGS_stringlist ::constructor_emptyList () ;
            GGS_bool var_cas_found = GGS_bool (false) ;
            const GGS_bool cond_8225 = (var_cas_inPath).operator_isNotEqual (GGS_string ("")) ;
            if (cond_8225.isBuiltAndTrue ()) {
              const GGS_string var_cas_fullTemplatePath = (((var_cas_inPath).operator_concat (GGS_string ("/"))).operator_concat (var_cas_inTemplateName)).operator_concat (GGS_string (".goilTemplate")) ;
              var_cas_pathList.addAssign_operation (var_cas_fullTemplatePath) ;
              var_cas_found = var_cas_fullTemplatePath.reader_fileExists (inLexique COMMA_SOURCE_FILE_AT_LINE (209)) ;
              const GGS_bool cond_8208 = var_cas_found ;
              if (cond_8208.isBuiltAndTrue ()) {
                const GGS_string _depExtension = GGS_string ("") ;
                const GGS_string _depPath = GGS_string ("") ;
                if (_depExtension.isBuilt () && _depPath.isBuilt ()) {
                  goil_template_grammar::_performSourceFileParsing_ (inLexique,
                                                _depExtension.string (),
                                                _depPath.string (),
                                                NULL,
                                                GGS_lstring ::constructor_new (inLexique, var_cas_fullTemplatePath, GGS_location (inLexique) COMMA_HERE),
                                                var_cas_inPath,
                                                var_cas_inTemplateVariableMap,
                                                var_cas_ioResultingString
                                                COMMA_SOURCE_FILE_AT_LINE (211)) ;
                }
              }
            }
            GGS_string var_cas_targetTemplatePartialPath = var_cas_targetDir ;
            GGS_uint _variant_8937 = var_cas_targetDir.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (215)) ;
            GGS_bool _condition_8937 (_variant_8937.isBuilt (), true) ;
            while (_condition_8937.isBuiltAndTrue ()) {
              _condition_8937 = ((var_cas_targetTemplatePartialPath.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (216))).operator_strictSup (GGS_uint (0U))).operator_and ((var_cas_found).operator_not ()) ;
              if (_condition_8937.isBuiltAndTrue ()) {
                if (_variant_8937.uintValue () == 0) {
                  inLexique.onTheFlyRunTimeError ("loop variant error" COMMA_SOURCE_FILE_AT_LINE (226)) ;
                  _condition_8937 = GGS_bool (false) ;
                }else{
                  _variant_8937.decrement_operation (inLexique COMMA_HERE) ;
                  const GGS_string var_cas_fullTemplatePath = (((((var_cas_templateDir).operator_concat (GGS_string ("/"))).operator_concat (var_cas_targetTemplatePartialPath)).operator_concat (GGS_string ("/"))).operator_concat (var_cas_inTemplateName)).operator_concat (GGS_string (".goilTemplate")) ;
                  var_cas_pathList.addAssign_operation (var_cas_fullTemplatePath) ;
                  var_cas_found = var_cas_fullTemplatePath.reader_fileExists (inLexique COMMA_SOURCE_FILE_AT_LINE (220)) ;
                  const GGS_bool cond_8801 = var_cas_found ;
                  if (cond_8801.isBuiltAndTrue ()) {
                    const GGS_string _depExtension = GGS_string ("") ;
                    const GGS_string _depPath = GGS_string ("") ;
                    if (_depExtension.isBuilt () && _depPath.isBuilt ()) {
                      goil_template_grammar::_performSourceFileParsing_ (inLexique,
                                                    _depExtension.string (),
                                                    _depPath.string (),
                                                    NULL,
                                                    GGS_lstring ::constructor_new (inLexique, var_cas_fullTemplatePath, GGS_location (inLexique) COMMA_HERE),
                                                    var_cas_inPath,
                                                    var_cas_inTemplateVariableMap,
                                                    var_cas_ioResultingString
                                                    COMMA_SOURCE_FILE_AT_LINE (222)) ;
                    }
                  }else if (cond_8801.isBuiltAndFalse ()) {
                    var_cas_targetTemplatePartialPath = var_cas_targetTemplatePartialPath.reader_stringByDeletingLastPathComponent (inLexique COMMA_SOURCE_FILE_AT_LINE (224)) ;
                  }
                }
              }
            }
            const GGS_bool cond_9226 = (var_cas_found).operator_not () ;
            if (cond_9226.isBuiltAndTrue ()) {
              GGS_string var_cas_m = ((GGS_string ("cannot find a valid path for the '")).operator_concat (var_cas_inTemplateName)).operator_concat (GGS_string ("' template; I have tried:")) ;
              {
                GGS_stringlist::cEnumerator enumerator_9106 (var_cas_pathList, true) ;
                const GGS_stringlist::cElement * operand_9106 = NULL ;
                while (((operand_9106 = enumerator_9106.nextObject ()))) {
                  macroValidPointer (operand_9106) ;
                  var_cas_m.appendCString ("\n"
                    "  - '") ;
                  var_cas_m.dotAssign_operation (operand_9106->mValue) ;
                  var_cas_m.appendCString ("';") ;
                }
              }
              var_cas_inTemplateName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, var_cas_m COMMA_SOURCE_FILE_AT_LINE (233)) ;
            }
          }
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_goilTemplateInvocation\n") ;
  #endif
}

//---------------------------------------------------------------------------*

