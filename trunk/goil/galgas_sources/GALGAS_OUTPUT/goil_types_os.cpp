//---------------------------------------------------------------------------*
//                                                                           *
//                         File 'goil_types_os.cpp'                          *
//                        Generated by version 1.8.2                         *
//                       may 14th, 2009, at 14h35'23"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != 463
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "goil_types_os.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "goil_types_os.ggs", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_trace_method'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_trace_method::
cPtr_trace_method (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
loc (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_trace_method * GGS_trace_method::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_method *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_trace_method *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_trace_method::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@trace_method:"
           << loc.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_trace_method::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_trace_method::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_trace_method (& typeid (cPtr_trace_method), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_trace_method::galgasRTTI (void) const {
  return & gClassInfoFor__trace_method ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_trace_method'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_trace_method::
GGS_trace_method (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_trace_method::
GGS_trace_method (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_trace_method GGS_trace_method::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_trace_method _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_trace_method *> (inPointer) != NULL)
      : (typeid (cPtr_trace_method) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_trace_method (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_trace_method),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_trace_method::
reader_loc (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_method *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace_method *) mPointer)->loc ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_trace_method::actualTypeName (void) const {
  return "trace_method" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_trace_method::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__trace_method ("trace_method") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_trace_void'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_trace_void::
cPtr_trace_void (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_trace_method (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_trace_void * GGS_trace_void::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_void *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_trace_void *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_trace_void::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_trace_void * _p = dynamic_cast <const cPtr_trace_void *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = loc._operator_isEqual (_p->loc).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_trace_void::
method_generate_c (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_res = GGS_string (true, "#error \"TRACE_METHOD is not defined\"\n") ;
}

//---------------------------------------------------------------------------*

void cPtr_trace_void::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@trace_void:"
           << loc.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_trace_void::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_trace_void::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_trace_void (& typeid (cPtr_trace_void), & typeid (cPtr_trace_method), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_trace_void::galgasRTTI (void) const {
  return & gClassInfoFor__trace_void ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_trace_void'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_trace_void::
GGS_trace_void (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_trace_void::
GGS_trace_void (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_trace_void GGS_trace_void::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_trace_void _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_trace_void *> (inPointer) != NULL)
      : (typeid (cPtr_trace_void) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_trace_void (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_trace_void),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_trace_void GGS_trace_void::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_trace_void result ;
  macroMyNew (result.mPointer, cPtr_trace_void (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_trace_void::actualTypeName (void) const {
  return "trace_void" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__trace_void ("trace_void", gClassInfoFor__trace_method) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_trace_file'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_trace_file::
cPtr_trace_file (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_trace_method (argument_0 COMMA_THERE),
name (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_trace_file * GGS_trace_file::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_file *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_trace_file *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_trace_file::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_trace_file * _p = dynamic_cast <const cPtr_trace_file *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = loc._operator_isEqual (_p->loc).boolValue ()
         && name._operator_isEqual (_p->name).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_trace_file::
method_generate_c (C_Compiler & _inLexique,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_res = ((GGS_string (true, "#define    TRACE_FILE             \""))._operator_concat (name.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (43))))._operator_concat (GGS_string (true, "\"\n")) ;
}

//---------------------------------------------------------------------------*

void cPtr_trace_file::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@trace_file:"
           << loc.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << name.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_trace_file::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_trace_file::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_trace_file (& typeid (cPtr_trace_file), & typeid (cPtr_trace_method), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_trace_file::galgasRTTI (void) const {
  return & gClassInfoFor__trace_file ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_trace_file'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_trace_file::
GGS_trace_file (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_trace_file::
GGS_trace_file (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_trace_file GGS_trace_file::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_trace_file _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_trace_file *> (inPointer) != NULL)
      : (typeid (cPtr_trace_file) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_trace_file (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_trace_file),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_trace_file GGS_trace_file::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_trace_file result ;
  macroMyNew (result.mPointer, cPtr_trace_file (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_trace_file::
reader_name (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_file *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace_file *) mPointer)->name ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_trace_file::actualTypeName (void) const {
  return "trace_file" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__trace_file ("trace_file", gClassInfoFor__trace_method) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'cPtr_trace'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_trace::
cPtr_trace (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
loc (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_trace * GGS_trace::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_trace *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_trace::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_trace * _p = dynamic_cast <const cPtr_trace *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = loc._operator_isEqual (_p->loc).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_trace::
method_generate_c (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_res = GGS_string (true, "#define    WITH_TRACE             NO\n") ;
}

//---------------------------------------------------------------------------*

void cPtr_trace::
method_generate_make (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_res = GGS_string (true, "WITH_TRACE=false\n") ;
}

//---------------------------------------------------------------------------*

void cPtr_trace::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@trace:"
           << loc.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_trace::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_trace::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_trace (& typeid (cPtr_trace), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_trace::galgasRTTI (void) const {
  return & gClassInfoFor__trace ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         GALGAS class 'GGS_trace'                          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_trace::
GGS_trace (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_trace::
GGS_trace (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_trace GGS_trace::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_trace _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_trace *> (inPointer) != NULL)
      : (typeid (cPtr_trace) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_trace (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_trace),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_trace GGS_trace::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_trace result ;
  macroMyNew (result.mPointer, cPtr_trace (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_trace::
reader_loc (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace *) mPointer)->loc ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_trace::actualTypeName (void) const {
  return "trace" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_trace::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__trace ("trace") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_trace_off'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_trace_off::
cPtr_trace_off (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_trace (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_trace_off * GGS_trace_off::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_off *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_trace_off *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_trace_off::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_trace_off * _p = dynamic_cast <const cPtr_trace_off *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = loc._operator_isEqual (_p->loc).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_trace_off::
method_generate_c (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_res = GGS_string (true, "#define    WITH_TRACE             NO\n") ;
}

//---------------------------------------------------------------------------*

void cPtr_trace_off::
method_generate_make (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_res = GGS_string (true, "WITH_TRACE=false\n") ;
}

//---------------------------------------------------------------------------*

void cPtr_trace_off::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@trace_off:"
           << loc.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_trace_off::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_trace_off::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_trace_off (& typeid (cPtr_trace_off), & typeid (cPtr_trace), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_trace_off::galgasRTTI (void) const {
  return & gClassInfoFor__trace_off ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_trace_off'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_trace_off::
GGS_trace_off (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_trace_off::
GGS_trace_off (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_trace_off GGS_trace_off::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_trace_off _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_trace_off *> (inPointer) != NULL)
      : (typeid (cPtr_trace_off) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_trace_off (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_trace_off),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_trace_off GGS_trace_off::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_trace_off result ;
  macroMyNew (result.mPointer, cPtr_trace_off (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_trace_off::actualTypeName (void) const {
  return "trace_off" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__trace_off ("trace_off", gClassInfoFor__trace) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_trace_on'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_trace_on::
cPtr_trace_on (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_trace_method & argument_2,
                                const GGS_basic_type & argument_3,
                                const GGS_basic_type & argument_4,
                                const GGS_basic_type & argument_5,
                                const GGS_basic_type & argument_6,
                                const GGS_basic_type & argument_7
                                COMMA_LOCATION_ARGS)
:cPtr_trace (argument_0 COMMA_THERE),
form (argument_1),
meth (argument_2),
trace_task (argument_3),
trace_isr (argument_4),
trace_resource (argument_5),
trace_alarm (argument_6),
trace_user_event (argument_7) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_trace_on * GGS_trace_on::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_on *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_trace_on *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_trace_on::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_trace_on * _p = dynamic_cast <const cPtr_trace_on *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = loc._operator_isEqual (_p->loc).boolValue ()
         && form._operator_isEqual (_p->form).boolValue ()
         && meth._operator_isEqual (_p->meth).boolValue ()
         && trace_task._operator_isEqual (_p->trace_task).boolValue ()
         && trace_isr._operator_isEqual (_p->trace_isr).boolValue ()
         && trace_resource._operator_isEqual (_p->trace_resource).boolValue ()
         && trace_alarm._operator_isEqual (_p->trace_alarm).boolValue ()
         && trace_user_event._operator_isEqual (_p->trace_user_event).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_trace_on::
method_generate_c (C_Compiler & _inLexique,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_res = GGS_string (true, "#define    WITH_TRACE             YES\n") ;
  var_cas_res._dotAssign_operation (function_bool_define (_inLexique, GGS_string (true, "TRACE_TASK"), trace_task, GGS_bool (true, true) COMMA_SOURCE_FILE_AT_LINE (76))) ;
  var_cas_res._dotAssign_operation (function_bool_define (_inLexique, GGS_string (true, "TRACE_ISR"), trace_isr, GGS_bool (true, true) COMMA_SOURCE_FILE_AT_LINE (77))) ;
  var_cas_res._dotAssign_operation (function_bool_define (_inLexique, GGS_string (true, "TRACE_RES"), trace_resource, GGS_bool (true, true) COMMA_SOURCE_FILE_AT_LINE (78))) ;
  var_cas_res._dotAssign_operation (function_bool_define (_inLexique, GGS_string (true, "TRACE_ALARM"), trace_alarm, GGS_bool (true, true) COMMA_SOURCE_FILE_AT_LINE (79))) ;
  var_cas_res._dotAssign_operation (function_bool_define (_inLexique, GGS_string (true, "TRACE_U_EVENT"), trace_user_event, GGS_bool (true, true) COMMA_SOURCE_FILE_AT_LINE (80))) ;
  var_cas_res.appendCstring ("#define    TRACE_FORMAT()         tpl_trace_format_") ;
  var_cas_res._dotAssign_operation (form.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (81))) ;
  var_cas_res.appendCstring ("();\n") ;
  GGS_string var_cas_m ;
  const GGS_trace_method  _temp_2170 = meth ;
  if (_temp_2170._isBuilt ()) {
    _temp_2170 (HERE)->method_generate_c (_inLexique, var_cas_m COMMA_SOURCE_FILE_AT_LINE (83)) ;
  }
  var_cas_res._dotAssign_operation (var_cas_m) ;
}

//---------------------------------------------------------------------------*

void cPtr_trace_on::
method_generate_make (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_res = GGS_string (true, "WITH_TRACE=true\n") ;
}

//---------------------------------------------------------------------------*

void cPtr_trace_on::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@trace_on:"
           << loc.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << form.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << meth.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << trace_task.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << trace_isr.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << trace_resource.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << trace_alarm.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << trace_user_event.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_trace_on::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_trace_on::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_trace_on (& typeid (cPtr_trace_on), & typeid (cPtr_trace), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_trace_on::galgasRTTI (void) const {
  return & gClassInfoFor__trace_on ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_trace_on'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_trace_on::
GGS_trace_on (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_trace_on::
GGS_trace_on (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_trace_on GGS_trace_on::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_trace_on _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_trace_on *> (inPointer) != NULL)
      : (typeid (cPtr_trace_on) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_trace_on (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_trace_on),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_trace_on GGS_trace_on::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_trace_method & argument_2,
                 const GGS_basic_type & argument_3,
                 const GGS_basic_type & argument_4,
                 const GGS_basic_type & argument_5,
                 const GGS_basic_type & argument_6,
                 const GGS_basic_type & argument_7
                                COMMA_LOCATION_ARGS) {
  GGS_trace_on result ;
  macroMyNew (result.mPointer, cPtr_trace_on (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_trace_on::
reader_form (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_on *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace_on *) mPointer)->form ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_trace_method  GGS_trace_on::
reader_meth (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_trace_method   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_on *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace_on *) mPointer)->meth ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_trace_on::
reader_trace_task (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_on *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace_on *) mPointer)->trace_task ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_trace_on::
reader_trace_isr (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_on *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace_on *) mPointer)->trace_isr ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_trace_on::
reader_trace_resource (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_on *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace_on *) mPointer)->trace_resource ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_trace_on::
reader_trace_alarm (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_on *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace_on *) mPointer)->trace_alarm ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_trace_on::
reader_trace_user_event (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_on *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace_on *) mPointer)->trace_user_event ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_trace_on::actualTypeName (void) const {
  return "trace_on" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__trace_on ("trace_on", gClassInfoFor__trace) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'cPtr_os_obj'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_os_obj::
cPtr_os_obj (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_basic_type & argument_2,
                                const GGS_basic_type & argument_3,
                                const GGS_basic_type & argument_4,
                                const GGS_basic_type & argument_5,
                                const GGS_basic_type & argument_6,
                                const GGS_basic_type & argument_7,
                                const GGS_lstring & argument_8,
                                const GGS_basic_type & argument_9,
                                const GGS_basic_type & argument_10,
                                const GGS_basic_type & argument_11,
                                const GGS_basic_type & argument_12,
                                const GGS_basic_type & argument_13,
                                const GGS_lstringlist & argument_14,
                                const GGS_lstringlist & argument_15,
                                const GGS_lstringlist & argument_16,
                                const GGS_lstringlist & argument_17,
                                const GGS_lstring & argument_18,
                                const GGS_lstring & argument_19,
                                const GGS_trace & argument_20,
                                const GGS_ident_map & argument_21
                                COMMA_LOCATION_ARGS)
:cPtr_oil_obj (argument_0 COMMA_THERE),
status (argument_1),
startuphook (argument_2),
shutdownhook (argument_3),
errorhook (argument_4),
pretaskhook (argument_5),
posttaskhook (argument_6),
protectionhook (argument_7),
scalabilityclass (argument_8),
stackmonitoring (argument_9),
usegetserviceid (argument_10),
useparameteraccess (argument_11),
useresscheduler (argument_12),
systemcall (argument_13),
app_src (argument_14),
cflags (argument_15),
asflags (argument_16),
ldflags (argument_17),
app_name (argument_18),
tpl_base_path (argument_19),
trace (argument_20),
others (argument_21) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_os_obj * GGS_os_obj::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_os_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_os_obj::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_os_obj * _p = dynamic_cast <const cPtr_os_obj *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = desc._operator_isEqual (_p->desc).boolValue ()
         && status._operator_isEqual (_p->status).boolValue ()
         && startuphook._operator_isEqual (_p->startuphook).boolValue ()
         && shutdownhook._operator_isEqual (_p->shutdownhook).boolValue ()
         && errorhook._operator_isEqual (_p->errorhook).boolValue ()
         && pretaskhook._operator_isEqual (_p->pretaskhook).boolValue ()
         && posttaskhook._operator_isEqual (_p->posttaskhook).boolValue ()
         && protectionhook._operator_isEqual (_p->protectionhook).boolValue ()
         && scalabilityclass._operator_isEqual (_p->scalabilityclass).boolValue ()
         && stackmonitoring._operator_isEqual (_p->stackmonitoring).boolValue ()
         && usegetserviceid._operator_isEqual (_p->usegetserviceid).boolValue ()
         && useparameteraccess._operator_isEqual (_p->useparameteraccess).boolValue ()
         && useresscheduler._operator_isEqual (_p->useresscheduler).boolValue ()
         && systemcall._operator_isEqual (_p->systemcall).boolValue ()
         && app_src._operator_isEqual (_p->app_src).boolValue ()
         && cflags._operator_isEqual (_p->cflags).boolValue ()
         && asflags._operator_isEqual (_p->asflags).boolValue ()
         && ldflags._operator_isEqual (_p->ldflags).boolValue ()
         && app_name._operator_isEqual (_p->app_name).boolValue ()
         && tpl_base_path._operator_isEqual (_p->tpl_base_path).boolValue ()
         && trace._operator_isEqual (_p->trace).boolValue ()
         && others._operator_isEqual (_p->others).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_os_obj::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@os_obj:"
           << desc.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << status.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << startuphook.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << shutdownhook.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << errorhook.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << pretaskhook.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << posttaskhook.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << protectionhook.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << scalabilityclass.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << stackmonitoring.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << usegetserviceid.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << useparameteraccess.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << useresscheduler.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << systemcall.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << app_src.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << cflags.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << asflags.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << ldflags.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << app_name.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << tpl_base_path.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << trace.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << others.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_os_obj::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_os_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_os_obj (& typeid (cPtr_os_obj), & typeid (cPtr_oil_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_os_obj::galgasRTTI (void) const {
  return & gClassInfoFor__os_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        GALGAS class 'GGS_os_obj'                          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_os_obj::
GGS_os_obj (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_os_obj::
GGS_os_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_os_obj GGS_os_obj::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_os_obj _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_os_obj *> (inPointer) != NULL)
      : (typeid (cPtr_os_obj) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_os_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_os_obj),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_os_obj GGS_os_obj::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_basic_type & argument_2,
                 const GGS_basic_type & argument_3,
                 const GGS_basic_type & argument_4,
                 const GGS_basic_type & argument_5,
                 const GGS_basic_type & argument_6,
                 const GGS_basic_type & argument_7,
                 const GGS_lstring & argument_8,
                 const GGS_basic_type & argument_9,
                 const GGS_basic_type & argument_10,
                 const GGS_basic_type & argument_11,
                 const GGS_basic_type & argument_12,
                 const GGS_basic_type & argument_13,
                 const GGS_lstringlist & argument_14,
                 const GGS_lstringlist & argument_15,
                 const GGS_lstringlist & argument_16,
                 const GGS_lstringlist & argument_17,
                 const GGS_lstring & argument_18,
                 const GGS_lstring & argument_19,
                 const GGS_trace & argument_20,
                 const GGS_ident_map & argument_21
                                COMMA_LOCATION_ARGS) {
  GGS_os_obj result ;
  macroMyNew (result.mPointer, cPtr_os_obj (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8,
                                argument_9,
                                argument_10,
                                argument_11,
                                argument_12,
                                argument_13,
                                argument_14,
                                argument_15,
                                argument_16,
                                argument_17,
                                argument_18,
                                argument_19,
                                argument_20,
                                argument_21 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_os_obj::
reader_status (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->status ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_startuphook (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->startuphook ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_shutdownhook (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->shutdownhook ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_errorhook (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->errorhook ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_pretaskhook (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->pretaskhook ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_posttaskhook (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->posttaskhook ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_protectionhook (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->protectionhook ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_os_obj::
reader_scalabilityclass (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->scalabilityclass ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_stackmonitoring (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->stackmonitoring ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_usegetserviceid (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->usegetserviceid ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_useparameteraccess (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->useparameteraccess ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_useresscheduler (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->useresscheduler ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_systemcall (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->systemcall ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_os_obj::
reader_app_src (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->app_src ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_os_obj::
reader_cflags (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->cflags ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_os_obj::
reader_asflags (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->asflags ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_os_obj::
reader_ldflags (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->ldflags ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_os_obj::
reader_app_name (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->app_name ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_os_obj::
reader_tpl_base_path (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->tpl_base_path ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_trace  GGS_os_obj::
reader_trace (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_trace   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->trace ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ident_map  GGS_os_obj::
reader_others (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ident_map   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->others ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_os_obj::actualTypeName (void) const {
  return "os_obj" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__os_obj ("os_obj", gClassInfoFor__oil_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  Implementation of routine "set_method"                   *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_set_method (C_Compiler & _inLexique,
                                GGS_trace_method  & var_cas_t,
                                GGS_trace_method   var_cas_s,
                                GGS_string  var_cas_att COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_set_method at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  { const GGS_trace_method _var_3486 = var_cas_t ; // CAST instruction
    if (_var_3486.getPtr () != NULL) {
      macroValidPointer (_var_3486.getPtr ()) ;
      if (typeid (cPtr_trace_void) == typeid (* (_var_3486.getPtr ()))) {
        var_cas_t = var_cas_s ;
      }else{
        var_cas_s.reader_loc (_inLexique COMMA_SOURCE_FILE_AT_LINE (134)).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, (GGS_string (true, "Redefinition of "))._operator_concat (var_cas_att) COMMA_SOURCE_FILE_AT_LINE (135)) ;
        var_cas_t.reader_loc (_inLexique COMMA_SOURCE_FILE_AT_LINE (135)).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "was defined here") COMMA_SOURCE_FILE_AT_LINE (136)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_set_method\n") ;
  #endif
}

//---------------------------------------------------------------------------*

