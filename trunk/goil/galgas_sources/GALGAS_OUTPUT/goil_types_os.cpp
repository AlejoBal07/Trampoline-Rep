//---------------------------------------------------------------------------*
//                                                                           *
//                         File 'goil_types_os.cpp'                          *
//                        Generated by version 1.9.3                         *
//                     november 10th, 2009, at 15h2'21"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != 598
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "goil_types_os.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "goil_types_os.ggs", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_trace_method'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_trace_method::
cPtr_trace_method (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
loc (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_trace_method * GGS_trace_method::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_method *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_trace_method *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_trace_method::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@trace_method:"
           << loc.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_trace_method::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_trace_method::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_trace_method (& typeid (cPtr_trace_method), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_trace_method::galgasRTTI (void) const {
  return & gClassInfoFor__trace_method ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_trace_method'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_trace_method::
GGS_trace_method (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_trace_method::
GGS_trace_method (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_trace_method GGS_trace_method::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_trace_method result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_trace_method *> (inPointer) != NULL)
      : (typeid (cPtr_trace_method) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_trace_method (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_trace_method),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_trace_method::
reader_loc (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_method *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace_method *) mPointer)->loc ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_trace_method::actualTypeName (void) const {
  return "trace_method" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_trace_method::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__trace_method ("trace_method") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_trace_void'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_trace_void::
cPtr_trace_void (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_trace_method (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_trace_void * GGS_trace_void::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_void *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_trace_void *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_trace_void::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_trace_void * ptr = dynamic_cast <const cPtr_trace_void *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_trace_void::
method_generate_c (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_res = GGS_string ("#error \"TRACE_METHOD is not defined\"\n") ;
}

//---------------------------------------------------------------------------*

void cPtr_trace_void::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@trace_void:"
           << loc.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_trace_void::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_trace_void::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_trace_void (& typeid (cPtr_trace_void), & typeid (cPtr_trace_method), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_trace_void::galgasRTTI (void) const {
  return & gClassInfoFor__trace_void ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_trace_void::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_trace_void (loc COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_trace_void'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_trace_void::
GGS_trace_void (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_trace_void::
GGS_trace_void (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_trace_void GGS_trace_void::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_trace_void result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_trace_void *> (inPointer) != NULL)
      : (typeid (cPtr_trace_void) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_trace_void (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_trace_void),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_trace_void GGS_trace_void::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_trace_void result ;
  macroMyNew (result.mPointer, cPtr_trace_void (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_trace_void::actualTypeName (void) const {
  return "trace_void" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__trace_void ("trace_void", gClassInfoFor__trace_method) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_trace_file'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_trace_file::
cPtr_trace_file (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_trace_method (argument_0 COMMA_THERE),
name (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_trace_file * GGS_trace_file::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_file *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_trace_file *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_trace_file::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_trace_file * ptr = dynamic_cast <const cPtr_trace_file *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && name.operator_isEqual (ptr->name).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_trace_file::
method_generate_c (C_Compiler & inLexique,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_res = ((GGS_string ("#define    TRACE_FILE             \"")).operator_concat (name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (44)))).operator_concat (GGS_string ("\"\n")) ;
}

//---------------------------------------------------------------------------*

void cPtr_trace_file::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@trace_file:"
           << loc.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << name.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_trace_file::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_trace_file::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_trace_file (& typeid (cPtr_trace_file), & typeid (cPtr_trace_method), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_trace_file::galgasRTTI (void) const {
  return & gClassInfoFor__trace_file ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_trace_file::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_trace_file (loc, name COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_trace_file'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_trace_file::
GGS_trace_file (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_trace_file::
GGS_trace_file (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_trace_file GGS_trace_file::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_trace_file result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_trace_file *> (inPointer) != NULL)
      : (typeid (cPtr_trace_file) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_trace_file (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_trace_file),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_trace_file GGS_trace_file::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_trace_file result ;
  macroMyNew (result.mPointer, cPtr_trace_file (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_trace_file::
reader_name (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_file *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace_file *) mPointer)->name ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_trace_file::actualTypeName (void) const {
  return "trace_file" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__trace_file ("trace_file", gClassInfoFor__trace_method) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'cPtr_trace'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_trace::
cPtr_trace (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
loc (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_trace * GGS_trace::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_trace *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_trace::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_trace * ptr = dynamic_cast <const cPtr_trace *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_trace::
method_generate_c (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_res = GGS_string ("#define    WITH_TRACE             NO\n") ;
}

//---------------------------------------------------------------------------*

void cPtr_trace::
method_generate_make (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_res = GGS_string ("WITH_TRACE=false\n") ;
}

//---------------------------------------------------------------------------*

void cPtr_trace::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@trace:"
           << loc.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_trace::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_trace::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_trace (& typeid (cPtr_trace), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_trace::galgasRTTI (void) const {
  return & gClassInfoFor__trace ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_trace::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_trace (loc COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         GALGAS class 'GGS_trace'                          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_trace::
GGS_trace (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_trace::
GGS_trace (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_trace GGS_trace::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_trace result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_trace *> (inPointer) != NULL)
      : (typeid (cPtr_trace) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_trace (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_trace),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_trace GGS_trace::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_trace result ;
  macroMyNew (result.mPointer, cPtr_trace (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_trace::
reader_loc (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace *) mPointer)->loc ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_trace::actualTypeName (void) const {
  return "trace" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_trace::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__trace ("trace") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_trace_off'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_trace_off::
cPtr_trace_off (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_trace (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_trace_off * GGS_trace_off::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_off *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_trace_off *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_trace_off::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_trace_off * ptr = dynamic_cast <const cPtr_trace_off *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_trace_off::
method_generate_c (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_res = GGS_string ("#define    WITH_TRACE             NO\n") ;
}

//---------------------------------------------------------------------------*

void cPtr_trace_off::
method_generate_make (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_res = GGS_string ("WITH_TRACE=false\n") ;
}

//---------------------------------------------------------------------------*

void cPtr_trace_off::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@trace_off:"
           << loc.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_trace_off::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_trace_off::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_trace_off (& typeid (cPtr_trace_off), & typeid (cPtr_trace), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_trace_off::galgasRTTI (void) const {
  return & gClassInfoFor__trace_off ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_trace_off::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_trace_off (loc COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_trace_off'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_trace_off::
GGS_trace_off (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_trace_off::
GGS_trace_off (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_trace_off GGS_trace_off::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_trace_off result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_trace_off *> (inPointer) != NULL)
      : (typeid (cPtr_trace_off) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_trace_off (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_trace_off),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_trace_off GGS_trace_off::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_trace_off result ;
  macroMyNew (result.mPointer, cPtr_trace_off (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_trace_off::actualTypeName (void) const {
  return "trace_off" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__trace_off ("trace_off", gClassInfoFor__trace) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_trace_on'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_trace_on::
cPtr_trace_on (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_trace_method & argument_2,
                                const GGS_basic_type & argument_3,
                                const GGS_basic_type & argument_4,
                                const GGS_basic_type & argument_5,
                                const GGS_basic_type & argument_6,
                                const GGS_basic_type & argument_7,
                                const GGS_basic_type & argument_8
                                COMMA_LOCATION_ARGS)
:cPtr_trace (argument_0 COMMA_THERE),
form (argument_1),
meth (argument_2),
trace_task (argument_3),
trace_isr (argument_4),
trace_resource (argument_5),
trace_alarm (argument_6),
trace_user_event (argument_7),
desc (argument_8) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_trace_on * GGS_trace_on::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_on *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_trace_on *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_trace_on::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_trace_on * ptr = dynamic_cast <const cPtr_trace_on *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && form.operator_isEqual (ptr->form).boolValue ()
         && meth.operator_isEqual (ptr->meth).boolValue ()
         && trace_task.operator_isEqual (ptr->trace_task).boolValue ()
         && trace_isr.operator_isEqual (ptr->trace_isr).boolValue ()
         && trace_resource.operator_isEqual (ptr->trace_resource).boolValue ()
         && trace_alarm.operator_isEqual (ptr->trace_alarm).boolValue ()
         && trace_user_event.operator_isEqual (ptr->trace_user_event).boolValue ()
         && desc.operator_isEqual (ptr->desc).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_trace_on::
method_generate_c (C_Compiler & inLexique,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_res = GGS_string ("#define    WITH_TRACE             YES\n") ;
  var_cas_res.dotAssign_operation (function_bool_class_define (inLexique, GGS_string ("TRACE_TASK"), trace_task, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (78))) ;
  var_cas_res.dotAssign_operation (function_bool_class_define (inLexique, GGS_string ("TRACE_ISR"), trace_isr, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (79))) ;
  var_cas_res.dotAssign_operation (function_bool_class_define (inLexique, GGS_string ("TRACE_RES"), trace_resource, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (80))) ;
  var_cas_res.dotAssign_operation (function_bool_class_define (inLexique, GGS_string ("TRACE_ALARM"), trace_alarm, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (81))) ;
  var_cas_res.dotAssign_operation (function_bool_class_define (inLexique, GGS_string ("TRACE_U_EVENT"), trace_user_event, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (82))) ;
  var_cas_res.appendCString ("#define    TRACE_FORMAT()         tpl_trace_format_") ;
  var_cas_res.dotAssign_operation (form.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (83))) ;
  var_cas_res.appendCString ("();\n") ;
  GGS_string var_cas_m ;
  const GGS_trace_method  temp_2250 = meth ;
  if (temp_2250.isBuilt ()) {
    temp_2250 (HERE)->method_generate_c (inLexique, var_cas_m COMMA_SOURCE_FILE_AT_LINE (85)) ;
  }
  var_cas_res.dotAssign_operation (var_cas_m) ;
}

//---------------------------------------------------------------------------*

void cPtr_trace_on::
method_generate_make (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_res = GGS_string ("WITH_TRACE=true\n") ;
}

//---------------------------------------------------------------------------*

void cPtr_trace_on::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@trace_on:"
           << loc.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << form.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << meth.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << trace_task.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << trace_isr.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << trace_resource.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << trace_alarm.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << trace_user_event.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << desc.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_trace_on::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_trace_on::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_trace_on (& typeid (cPtr_trace_on), & typeid (cPtr_trace), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_trace_on::galgasRTTI (void) const {
  return & gClassInfoFor__trace_on ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_trace_on::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_trace_on (loc, form, meth, trace_task, trace_isr, trace_resource, trace_alarm, trace_user_event, desc COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_trace_on'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_trace_on::
GGS_trace_on (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_trace_on::
GGS_trace_on (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_trace_on GGS_trace_on::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_trace_on result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_trace_on *> (inPointer) != NULL)
      : (typeid (cPtr_trace_on) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_trace_on (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_trace_on),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_trace_on GGS_trace_on::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_trace_method & argument_2,
                 const GGS_basic_type & argument_3,
                 const GGS_basic_type & argument_4,
                 const GGS_basic_type & argument_5,
                 const GGS_basic_type & argument_6,
                 const GGS_basic_type & argument_7,
                 const GGS_basic_type & argument_8
                                COMMA_LOCATION_ARGS) {
  GGS_trace_on result ;
  macroMyNew (result.mPointer, cPtr_trace_on (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_trace_on::
reader_form (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_on *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace_on *) mPointer)->form ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_trace_method  GGS_trace_on::
reader_meth (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_trace_method   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_on *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace_on *) mPointer)->meth ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_trace_on::
reader_trace_task (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_on *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace_on *) mPointer)->trace_task ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_trace_on::
reader_trace_isr (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_on *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace_on *) mPointer)->trace_isr ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_trace_on::
reader_trace_resource (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_on *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace_on *) mPointer)->trace_resource ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_trace_on::
reader_trace_alarm (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_on *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace_on *) mPointer)->trace_alarm ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_trace_on::
reader_trace_user_event (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_on *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace_on *) mPointer)->trace_user_event ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_trace_on::
reader_desc (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_on *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace_on *) mPointer)->desc ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_trace_on::actualTypeName (void) const {
  return "trace_on" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__trace_on ("trace_on", gClassInfoFor__trace) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  Implementation of routine "set_method"                   *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_set_method (C_Compiler & inLexique,
                                GGS_trace_method  & var_cas_t,
                                GGS_trace_method   var_cas_s,
                                GGS_string  var_cas_att COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_set_method at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  { const GGS_trace_method _var_2890 = var_cas_t ; // CAST instruction
    if (_var_2890.getPtr () != NULL) {
      macroValidPointer (_var_2890.getPtr ()) ;
      if (typeid (cPtr_trace_void) == typeid (* (_var_2890.getPtr ()))) {
        var_cas_t = var_cas_s ;
      }else{
        var_cas_s.reader_loc (inLexique COMMA_SOURCE_FILE_AT_LINE (112)).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (GGS_string ("Redefinition of ")).operator_concat (var_cas_att) COMMA_SOURCE_FILE_AT_LINE (113)) ;
        var_cas_t.reader_loc (inLexique COMMA_SOURCE_FILE_AT_LINE (113)).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("was defined here") COMMA_SOURCE_FILE_AT_LINE (114)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_set_method\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_memmap_false'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_memmap_false::
cPtr_memmap_false (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_basic_type (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_memmap_false * GGS_memmap_false::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_memmap_false *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_memmap_false *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_memmap_false::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_memmap_false * ptr = dynamic_cast <const cPtr_memmap_false *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_memmap_false::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@memmap_false:"
           << location.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_memmap_false::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_memmap_false::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_memmap_false (& typeid (cPtr_memmap_false), & typeid (cPtr_basic_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_memmap_false::galgasRTTI (void) const {
  return & gClassInfoFor__memmap_false ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_memmap_false::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_memmap_false (location COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_memmap_false'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_memmap_false::
GGS_memmap_false (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_memmap_false::
GGS_memmap_false (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_memmap_false GGS_memmap_false::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_memmap_false result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_memmap_false *> (inPointer) != NULL)
      : (typeid (cPtr_memmap_false) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_memmap_false (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_memmap_false),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_memmap_false GGS_memmap_false::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_memmap_false result ;
  macroMyNew (result.mPointer, cPtr_memmap_false (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_memmap_false::actualTypeName (void) const {
  return "memmap_false" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__memmap_false ("memmap_false", gClassInfoFor__basic_type) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_memmap_true'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_memmap_true::
cPtr_memmap_true (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_basic_type & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_basic_type (argument_0 COMMA_THERE),
compiler (argument_1),
linker (argument_2),
memory_prot (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_memmap_true * GGS_memmap_true::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_memmap_true *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_memmap_true *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_memmap_true::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_memmap_true * ptr = dynamic_cast <const cPtr_memmap_true *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && compiler.operator_isEqual (ptr->compiler).boolValue ()
         && linker.operator_isEqual (ptr->linker).boolValue ()
         && memory_prot.operator_isEqual (ptr->memory_prot).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_memmap_true::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@memmap_true:"
           << location.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << compiler.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << linker.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << memory_prot.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_memmap_true::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_memmap_true::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_memmap_true (& typeid (cPtr_memmap_true), & typeid (cPtr_basic_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_memmap_true::galgasRTTI (void) const {
  return & gClassInfoFor__memmap_true ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_memmap_true::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_memmap_true (location, compiler, linker, memory_prot COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_memmap_true'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_memmap_true::
GGS_memmap_true (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_memmap_true::
GGS_memmap_true (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_memmap_true GGS_memmap_true::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_memmap_true result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_memmap_true *> (inPointer) != NULL)
      : (typeid (cPtr_memmap_true) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_memmap_true (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_memmap_true),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_memmap_true GGS_memmap_true::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_basic_type & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_memmap_true result ;
  macroMyNew (result.mPointer, cPtr_memmap_true (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_memmap_true::
reader_compiler (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_memmap_true *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_memmap_true *) mPointer)->compiler ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_memmap_true::
reader_linker (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_memmap_true *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_memmap_true *) mPointer)->linker ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_memmap_true::
reader_memory_prot (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_memmap_true *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_memmap_true *) mPointer)->memory_prot ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_memmap_true::actualTypeName (void) const {
  return "memmap_true" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__memmap_true ("memmap_true", gClassInfoFor__basic_type) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  Implementation of routine "set_memmap"                   *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_set_memmap (C_Compiler & inLexique,
                                GGS_basic_type  & var_cas_m,
                                GGS_basic_type   var_cas_nm,
                                GGS_string  var_cas_att COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_set_memmap at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  { const GGS_basic_type _var_3310 = var_cas_m ; // CAST instruction
    if (_var_3310.getPtr () != NULL) {
      macroValidPointer (_var_3310.getPtr ()) ;
      if (typeid (cPtr_void) == typeid (* (_var_3310.getPtr ()))) {
        var_cas_m = var_cas_nm ;
      }else{
        var_cas_nm.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (135)).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (GGS_string ("Redefinition of ")).operator_concat (var_cas_att) COMMA_SOURCE_FILE_AT_LINE (136)) ;
        var_cas_m.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (136)).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("was defined here") COMMA_SOURCE_FILE_AT_LINE (137)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_set_memmap\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'cPtr_os_obj'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_os_obj::
cPtr_os_obj (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_basic_type & argument_2,
                                const GGS_basic_type & argument_3,
                                const GGS_basic_type & argument_4,
                                const GGS_basic_type & argument_5,
                                const GGS_basic_type & argument_6,
                                const GGS_basic_type & argument_7,
                                const GGS_lstring & argument_8,
                                const GGS_basic_type & argument_9,
                                const GGS_basic_type & argument_10,
                                const GGS_basic_type & argument_11,
                                const GGS_basic_type & argument_12,
                                const GGS_basic_type & argument_13,
                                const GGS_basic_type & argument_14,
                                const GGS_lstringlist & argument_15,
                                const GGS_lstring & argument_16,
                                const GGS_lstring & argument_17,
                                const GGS_lstring & argument_18,
                                const GGS_lstringlist & argument_19,
                                const GGS_lstringlist & argument_20,
                                const GGS_lstringlist & argument_21,
                                const GGS_lstring & argument_22,
                                const GGS_lstring & argument_23,
                                const GGS_trace & argument_24,
                                const GGS_ident_map & argument_25
                                COMMA_LOCATION_ARGS)
:cPtr_oil_obj (argument_0 COMMA_THERE),
status (argument_1),
startuphook (argument_2),
shutdownhook (argument_3),
errorhook (argument_4),
pretaskhook (argument_5),
posttaskhook (argument_6),
protectionhook (argument_7),
scalabilityclass (argument_8),
stackmonitoring (argument_9),
usegetserviceid (argument_10),
useparameteraccess (argument_11),
useresscheduler (argument_12),
systemcall (argument_13),
memmap (argument_14),
app_src (argument_15),
compiler (argument_16),
assembler (argument_17),
linker (argument_18),
cflags (argument_19),
asflags (argument_20),
ldflags (argument_21),
app_name (argument_22),
tpl_base_path (argument_23),
trace (argument_24),
others (argument_25) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_os_obj * GGS_os_obj::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_os_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_os_obj::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_os_obj * ptr = dynamic_cast <const cPtr_os_obj *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = desc.operator_isEqual (ptr->desc).boolValue ()
         && status.operator_isEqual (ptr->status).boolValue ()
         && startuphook.operator_isEqual (ptr->startuphook).boolValue ()
         && shutdownhook.operator_isEqual (ptr->shutdownhook).boolValue ()
         && errorhook.operator_isEqual (ptr->errorhook).boolValue ()
         && pretaskhook.operator_isEqual (ptr->pretaskhook).boolValue ()
         && posttaskhook.operator_isEqual (ptr->posttaskhook).boolValue ()
         && protectionhook.operator_isEqual (ptr->protectionhook).boolValue ()
         && scalabilityclass.operator_isEqual (ptr->scalabilityclass).boolValue ()
         && stackmonitoring.operator_isEqual (ptr->stackmonitoring).boolValue ()
         && usegetserviceid.operator_isEqual (ptr->usegetserviceid).boolValue ()
         && useparameteraccess.operator_isEqual (ptr->useparameteraccess).boolValue ()
         && useresscheduler.operator_isEqual (ptr->useresscheduler).boolValue ()
         && systemcall.operator_isEqual (ptr->systemcall).boolValue ()
         && memmap.operator_isEqual (ptr->memmap).boolValue ()
         && app_src.operator_isEqual (ptr->app_src).boolValue ()
         && compiler.operator_isEqual (ptr->compiler).boolValue ()
         && assembler.operator_isEqual (ptr->assembler).boolValue ()
         && linker.operator_isEqual (ptr->linker).boolValue ()
         && cflags.operator_isEqual (ptr->cflags).boolValue ()
         && asflags.operator_isEqual (ptr->asflags).boolValue ()
         && ldflags.operator_isEqual (ptr->ldflags).boolValue ()
         && app_name.operator_isEqual (ptr->app_name).boolValue ()
         && tpl_base_path.operator_isEqual (ptr->tpl_base_path).boolValue ()
         && trace.operator_isEqual (ptr->trace).boolValue ()
         && others.operator_isEqual (ptr->others).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_os_obj::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@os_obj:"
           << desc.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << status.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << startuphook.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << shutdownhook.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << errorhook.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << pretaskhook.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << posttaskhook.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << protectionhook.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << scalabilityclass.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << stackmonitoring.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << usegetserviceid.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << useparameteraccess.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << useresscheduler.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << systemcall.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << memmap.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << app_src.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << compiler.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << assembler.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << linker.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << cflags.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << asflags.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << ldflags.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << app_name.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << tpl_base_path.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << trace.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << others.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_os_obj::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_os_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_os_obj (& typeid (cPtr_os_obj), & typeid (cPtr_oil_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_os_obj::galgasRTTI (void) const {
  return & gClassInfoFor__os_obj ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_os_obj::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_os_obj (desc, status, startuphook, shutdownhook, errorhook, pretaskhook, posttaskhook, protectionhook, scalabilityclass, stackmonitoring, usegetserviceid, useparameteraccess, useresscheduler, systemcall, memmap, app_src, compiler, assembler, linker, cflags, asflags, ldflags, app_name, tpl_base_path, trace, others COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        GALGAS class 'GGS_os_obj'                          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_os_obj::
GGS_os_obj (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_os_obj::
GGS_os_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_os_obj GGS_os_obj::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_os_obj result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_os_obj *> (inPointer) != NULL)
      : (typeid (cPtr_os_obj) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_os_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_os_obj),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_os_obj GGS_os_obj::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_basic_type & argument_2,
                 const GGS_basic_type & argument_3,
                 const GGS_basic_type & argument_4,
                 const GGS_basic_type & argument_5,
                 const GGS_basic_type & argument_6,
                 const GGS_basic_type & argument_7,
                 const GGS_lstring & argument_8,
                 const GGS_basic_type & argument_9,
                 const GGS_basic_type & argument_10,
                 const GGS_basic_type & argument_11,
                 const GGS_basic_type & argument_12,
                 const GGS_basic_type & argument_13,
                 const GGS_basic_type & argument_14,
                 const GGS_lstringlist & argument_15,
                 const GGS_lstring & argument_16,
                 const GGS_lstring & argument_17,
                 const GGS_lstring & argument_18,
                 const GGS_lstringlist & argument_19,
                 const GGS_lstringlist & argument_20,
                 const GGS_lstringlist & argument_21,
                 const GGS_lstring & argument_22,
                 const GGS_lstring & argument_23,
                 const GGS_trace & argument_24,
                 const GGS_ident_map & argument_25
                                COMMA_LOCATION_ARGS) {
  GGS_os_obj result ;
  macroMyNew (result.mPointer, cPtr_os_obj (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8,
                                argument_9,
                                argument_10,
                                argument_11,
                                argument_12,
                                argument_13,
                                argument_14,
                                argument_15,
                                argument_16,
                                argument_17,
                                argument_18,
                                argument_19,
                                argument_20,
                                argument_21,
                                argument_22,
                                argument_23,
                                argument_24,
                                argument_25 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_os_obj::
reader_status (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->status ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_startuphook (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->startuphook ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_shutdownhook (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->shutdownhook ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_errorhook (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->errorhook ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_pretaskhook (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->pretaskhook ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_posttaskhook (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->posttaskhook ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_protectionhook (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->protectionhook ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_os_obj::
reader_scalabilityclass (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->scalabilityclass ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_stackmonitoring (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->stackmonitoring ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_usegetserviceid (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->usegetserviceid ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_useparameteraccess (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->useparameteraccess ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_useresscheduler (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->useresscheduler ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_systemcall (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->systemcall ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_memmap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->memmap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_os_obj::
reader_app_src (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->app_src ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_os_obj::
reader_compiler (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->compiler ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_os_obj::
reader_assembler (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->assembler ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_os_obj::
reader_linker (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->linker ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_os_obj::
reader_cflags (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->cflags ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_os_obj::
reader_asflags (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->asflags ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_os_obj::
reader_ldflags (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->ldflags ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_os_obj::
reader_app_name (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->app_name ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_os_obj::
reader_tpl_base_path (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->tpl_base_path ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_trace  GGS_os_obj::
reader_trace (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_trace   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->trace ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ident_map  GGS_os_obj::
reader_others (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ident_map   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->others ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setStatus (C_Compiler & /* inLexique */, const GGS_lstring & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroAssignPointer (mPointer, clone) ;
      macroDetachPointer (clone, cPtr_os_obj) ;
    }
    ((cPtr_os_obj *) mPointer)->status = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setStartuphook (C_Compiler & /* inLexique */, const GGS_basic_type & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroAssignPointer (mPointer, clone) ;
      macroDetachPointer (clone, cPtr_os_obj) ;
    }
    ((cPtr_os_obj *) mPointer)->startuphook = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setShutdownhook (C_Compiler & /* inLexique */, const GGS_basic_type & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroAssignPointer (mPointer, clone) ;
      macroDetachPointer (clone, cPtr_os_obj) ;
    }
    ((cPtr_os_obj *) mPointer)->shutdownhook = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setErrorhook (C_Compiler & /* inLexique */, const GGS_basic_type & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroAssignPointer (mPointer, clone) ;
      macroDetachPointer (clone, cPtr_os_obj) ;
    }
    ((cPtr_os_obj *) mPointer)->errorhook = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setPretaskhook (C_Compiler & /* inLexique */, const GGS_basic_type & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroAssignPointer (mPointer, clone) ;
      macroDetachPointer (clone, cPtr_os_obj) ;
    }
    ((cPtr_os_obj *) mPointer)->pretaskhook = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setPosttaskhook (C_Compiler & /* inLexique */, const GGS_basic_type & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroAssignPointer (mPointer, clone) ;
      macroDetachPointer (clone, cPtr_os_obj) ;
    }
    ((cPtr_os_obj *) mPointer)->posttaskhook = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setProtectionhook (C_Compiler & /* inLexique */, const GGS_basic_type & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroAssignPointer (mPointer, clone) ;
      macroDetachPointer (clone, cPtr_os_obj) ;
    }
    ((cPtr_os_obj *) mPointer)->protectionhook = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setScalabilityclass (C_Compiler & /* inLexique */, const GGS_lstring & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroAssignPointer (mPointer, clone) ;
      macroDetachPointer (clone, cPtr_os_obj) ;
    }
    ((cPtr_os_obj *) mPointer)->scalabilityclass = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setStackmonitoring (C_Compiler & /* inLexique */, const GGS_basic_type & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroAssignPointer (mPointer, clone) ;
      macroDetachPointer (clone, cPtr_os_obj) ;
    }
    ((cPtr_os_obj *) mPointer)->stackmonitoring = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setUsegetserviceid (C_Compiler & /* inLexique */, const GGS_basic_type & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroAssignPointer (mPointer, clone) ;
      macroDetachPointer (clone, cPtr_os_obj) ;
    }
    ((cPtr_os_obj *) mPointer)->usegetserviceid = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setUseparameteraccess (C_Compiler & /* inLexique */, const GGS_basic_type & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroAssignPointer (mPointer, clone) ;
      macroDetachPointer (clone, cPtr_os_obj) ;
    }
    ((cPtr_os_obj *) mPointer)->useparameteraccess = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setUseresscheduler (C_Compiler & /* inLexique */, const GGS_basic_type & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroAssignPointer (mPointer, clone) ;
      macroDetachPointer (clone, cPtr_os_obj) ;
    }
    ((cPtr_os_obj *) mPointer)->useresscheduler = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setSystemcall (C_Compiler & /* inLexique */, const GGS_basic_type & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroAssignPointer (mPointer, clone) ;
      macroDetachPointer (clone, cPtr_os_obj) ;
    }
    ((cPtr_os_obj *) mPointer)->systemcall = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setMemmap (C_Compiler & /* inLexique */, const GGS_basic_type & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroAssignPointer (mPointer, clone) ;
      macroDetachPointer (clone, cPtr_os_obj) ;
    }
    ((cPtr_os_obj *) mPointer)->memmap = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setApp_src (C_Compiler & /* inLexique */, const GGS_lstringlist & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroAssignPointer (mPointer, clone) ;
      macroDetachPointer (clone, cPtr_os_obj) ;
    }
    ((cPtr_os_obj *) mPointer)->app_src = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setCompiler (C_Compiler & /* inLexique */, const GGS_lstring & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroAssignPointer (mPointer, clone) ;
      macroDetachPointer (clone, cPtr_os_obj) ;
    }
    ((cPtr_os_obj *) mPointer)->compiler = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setAssembler (C_Compiler & /* inLexique */, const GGS_lstring & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroAssignPointer (mPointer, clone) ;
      macroDetachPointer (clone, cPtr_os_obj) ;
    }
    ((cPtr_os_obj *) mPointer)->assembler = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setLinker (C_Compiler & /* inLexique */, const GGS_lstring & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroAssignPointer (mPointer, clone) ;
      macroDetachPointer (clone, cPtr_os_obj) ;
    }
    ((cPtr_os_obj *) mPointer)->linker = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setCflags (C_Compiler & /* inLexique */, const GGS_lstringlist & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroAssignPointer (mPointer, clone) ;
      macroDetachPointer (clone, cPtr_os_obj) ;
    }
    ((cPtr_os_obj *) mPointer)->cflags = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setAsflags (C_Compiler & /* inLexique */, const GGS_lstringlist & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroAssignPointer (mPointer, clone) ;
      macroDetachPointer (clone, cPtr_os_obj) ;
    }
    ((cPtr_os_obj *) mPointer)->asflags = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setLdflags (C_Compiler & /* inLexique */, const GGS_lstringlist & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroAssignPointer (mPointer, clone) ;
      macroDetachPointer (clone, cPtr_os_obj) ;
    }
    ((cPtr_os_obj *) mPointer)->ldflags = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setApp_name (C_Compiler & /* inLexique */, const GGS_lstring & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroAssignPointer (mPointer, clone) ;
      macroDetachPointer (clone, cPtr_os_obj) ;
    }
    ((cPtr_os_obj *) mPointer)->app_name = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setTpl_base_path (C_Compiler & /* inLexique */, const GGS_lstring & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroAssignPointer (mPointer, clone) ;
      macroDetachPointer (clone, cPtr_os_obj) ;
    }
    ((cPtr_os_obj *) mPointer)->tpl_base_path = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setTrace (C_Compiler & /* inLexique */, const GGS_trace & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroAssignPointer (mPointer, clone) ;
      macroDetachPointer (clone, cPtr_os_obj) ;
    }
    ((cPtr_os_obj *) mPointer)->trace = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setOthers (C_Compiler & /* inLexique */, const GGS_ident_map & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroAssignPointer (mPointer, clone) ;
      macroDetachPointer (clone, cPtr_os_obj) ;
    }
    ((cPtr_os_obj *) mPointer)->others = inValue ;
  }
}

//---------------------------------------------------------------------------*

const char * GGS_os_obj::actualTypeName (void) const {
  return "os_obj" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__os_obj ("os_obj", gClassInfoFor__oil_obj) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of function "memory_protection"               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_basic_type  function_memory_protection (C_Compiler & inLexique,
                                GGS_os_obj   var_cas_os COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_memory_protection at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_basic_type  var_cas_mp ;
  { const GGS_basic_type _var_4845 = var_cas_os.reader_memmap (inLexique COMMA_SOURCE_FILE_AT_LINE (172)) ; // CAST instruction
    if (_var_4845.getPtr () != NULL) {
      macroValidPointer (_var_4845.getPtr ()) ;
      if (typeid (cPtr_memmap_true) == typeid (* (_var_4845.getPtr ()))) {
        const GGS_memmap_true var_cas_mm (_var_4845.getPtr ()) ;
        var_cas_mp = var_cas_mm.reader_memory_prot (inLexique COMMA_SOURCE_FILE_AT_LINE (174)) ;
      }else{
        var_cas_mp = GGS_bool_class ::constructor_new (inLexique, GGS_location (inLexique), GGS_bool (false) COMMA_HERE) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_memory_protection\n") ;
  #endif
  return var_cas_mp ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of function "memory_protection_on"              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bool function_memory_protection_on (C_Compiler & inLexique,
                                GGS_os_obj   var_cas_os COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_memory_protection_on at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_bool var_cas_mp ;
  { const GGS_basic_type _var_5127 = var_cas_os.reader_memmap (inLexique COMMA_SOURCE_FILE_AT_LINE (184)) ; // CAST instruction
    if (_var_5127.getPtr () != NULL) {
      macroValidPointer (_var_5127.getPtr ()) ;
      if (typeid (cPtr_memmap_true) == typeid (* (_var_5127.getPtr ()))) {
        const GGS_memmap_true var_cas_mm (_var_5127.getPtr ()) ;
        { const GGS_basic_type _var_5091 = var_cas_mm.reader_memory_prot (inLexique COMMA_SOURCE_FILE_AT_LINE (186)) ; // CAST instruction
          if (_var_5091.getPtr () != NULL) {
            macroValidPointer (_var_5091.getPtr ()) ;
            if (typeid (cPtr_bool_class) == typeid (* (_var_5091.getPtr ()))) {
              const GGS_bool_class var_cas_b (_var_5091.getPtr ()) ;
              var_cas_mp = var_cas_b.reader_value (inLexique COMMA_SOURCE_FILE_AT_LINE (188)) ;
            }else{
              var_cas_mp = GGS_bool (false) ;
            }
          }
        }
      }else{
        var_cas_mp = GGS_bool (false) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_memory_protection_on\n") ;
  #endif
  return var_cas_mp ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Implementation of function "memory_mapping"                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bool function_memory_mapping (C_Compiler & inLexique,
                                GGS_os_obj   var_cas_os COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_memory_mapping at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_bool var_cas_mm ;
  { const GGS_basic_type _var_5294 = var_cas_os.reader_memmap (inLexique COMMA_SOURCE_FILE_AT_LINE (201)) ; // CAST instruction
    if (_var_5294.getPtr () != NULL) {
      macroValidPointer (_var_5294.getPtr ()) ;
      if (typeid (cPtr_memmap_true) == typeid (* (_var_5294.getPtr ()))) {
        var_cas_mm = GGS_bool (true) ;
      }else{
        var_cas_mm = GGS_bool (false) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_memory_mapping\n") ;
  #endif
  return var_cas_mm ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Implementation of function "compiler"                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string function_compiler (C_Compiler & inLexique,
                                const GGS_basic_type   var_cas_os_memmap COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_compiler at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_string var_cas_cc ;
  { const GGS_basic_type _var_5575 = var_cas_os_memmap ; // CAST instruction
    if (_var_5575.getPtr () != NULL) {
      macroValidPointer (_var_5575.getPtr ()) ;
      if (typeid (cPtr_memmap_true) == typeid (* (_var_5575.getPtr ()))) {
        const GGS_memmap_true var_cas_s (_var_5575.getPtr ()) ;
        var_cas_cc = var_cas_s.reader_compiler (inLexique COMMA_SOURCE_FILE_AT_LINE (218)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (218)) ;
      }else{
        var_cas_cc = GGS_string ("") ;
      }
    }
  }
  const GGS_bool cond_5843 = (var_cas_cc).operator_isNotEqual (GGS_string ("")) ;
  if (cond_5843.isBuiltAndTrue ()) {
    var_cas_cc = (GGS_string ("memmap/")).operator_concat (var_cas_cc) ;
    GGS_string var_cas_rtd = function_root_templates_directory (inLexique COMMA_SOURCE_FILE_AT_LINE (223)) ;
    const GGS_bool cond_5809 = (var_cas_rtd).operator_isNotEqual (GGS_string ("")) ;
    if (cond_5809.isBuiltAndTrue ()) {
      GGS_string var_cas_path = ((var_cas_rtd).operator_concat (GGS_string ("/"))).operator_concat (var_cas_cc) ;
      const GGS_bool cond_5796 = (var_cas_path.reader_directoryExists (inLexique COMMA_SOURCE_FILE_AT_LINE (226))).operator_not () ;
      if (cond_5796.isBuiltAndTrue ()) {
        var_cas_cc = GGS_string ("") ;
      }
    }else if (cond_5809.isBuiltAndFalse ()) {
      var_cas_cc = GGS_string ("") ;
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_compiler\n") ;
  #endif
  return var_cas_cc ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Implementation of function "linker"                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string function_linker (C_Compiler & inLexique,
                                const GGS_basic_type   var_cas_os_memmap COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_linker at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_string var_cas_lk ;
  { const GGS_basic_type _var_6114 = var_cas_os_memmap ; // CAST instruction
    if (_var_6114.getPtr () != NULL) {
      macroValidPointer (_var_6114.getPtr ()) ;
      if (typeid (cPtr_memmap_true) == typeid (* (_var_6114.getPtr ()))) {
        const GGS_memmap_true var_cas_s (_var_6114.getPtr ()) ;
        var_cas_lk = var_cas_s.reader_linker (inLexique COMMA_SOURCE_FILE_AT_LINE (244)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (244)) ;
      }else{
        var_cas_lk = GGS_string ("") ;
      }
    }
  }
  const GGS_bool cond_6382 = (var_cas_lk).operator_isNotEqual (GGS_string ("")) ;
  if (cond_6382.isBuiltAndTrue ()) {
    var_cas_lk = (GGS_string ("linker/")).operator_concat (var_cas_lk) ;
    GGS_string var_cas_rtd = function_root_templates_directory (inLexique COMMA_SOURCE_FILE_AT_LINE (249)) ;
    const GGS_bool cond_6348 = (var_cas_rtd).operator_isNotEqual (GGS_string ("")) ;
    if (cond_6348.isBuiltAndTrue ()) {
      GGS_string var_cas_path = ((var_cas_rtd).operator_concat (GGS_string ("/"))).operator_concat (var_cas_lk) ;
      const GGS_bool cond_6335 = (var_cas_path.reader_directoryExists (inLexique COMMA_SOURCE_FILE_AT_LINE (252))).operator_not () ;
      if (cond_6335.isBuiltAndTrue ()) {
        var_cas_lk = GGS_string ("") ;
      }
    }else if (cond_6348.isBuiltAndFalse ()) {
      var_cas_lk = GGS_string ("") ;
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_linker\n") ;
  #endif
  return var_cas_lk ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Implementation of function "void_os_obj"                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_os_obj  function_void_os_obj (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_void_os_obj at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_os_obj  var_cas_os ;
  GGS_void  var_cas_void_obj = GGS_void ::constructor_new (inLexique, GGS_location (inLexique) COMMA_HERE) ;
  GGS_lstring  var_cas_emptyString = GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE) ;
  var_cas_os = GGS_os_obj ::constructor_new (inLexique, var_cas_emptyString, var_cas_emptyString, var_cas_void_obj, var_cas_void_obj, var_cas_void_obj, var_cas_void_obj, var_cas_void_obj, var_cas_void_obj, var_cas_emptyString, var_cas_void_obj, var_cas_void_obj, var_cas_void_obj, var_cas_void_obj, var_cas_void_obj, var_cas_void_obj, GGS_lstringlist ::constructor_emptyList (), var_cas_emptyString, var_cas_emptyString, var_cas_emptyString, GGS_lstringlist ::constructor_emptyList (), GGS_lstringlist ::constructor_emptyList (), GGS_lstringlist ::constructor_emptyList (), var_cas_emptyString, var_cas_emptyString, GGS_trace ::constructor_new (inLexique, GGS_location (inLexique) COMMA_HERE), GGS_ident_map ::constructor_emptyMap (inLexique COMMA_HERE) COMMA_HERE) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_void_os_obj\n") ;
  #endif
  return var_cas_os ;
}

//---------------------------------------------------------------------------*

