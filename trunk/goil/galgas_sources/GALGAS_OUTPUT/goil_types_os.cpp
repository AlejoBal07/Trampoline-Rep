//---------------------------------------------------------------------------*
//                                                                           *
//                         File 'goil_types_os.cpp'                          *
//                        Generated by version 1.8.1                         *
//                      april 20th, 2009, at 16h34'54"                       *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != 456
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "goil_types_os.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "goil_types_os.ggs", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'cPtr_trace'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_trace::
cPtr_trace (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
loc (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_trace * GGS_trace::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_trace *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_trace::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_trace * _p = dynamic_cast <const cPtr_trace *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = loc._operator_isEqual (_p->loc).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_trace::
method_generate (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_res = GGS_string (true, "#define TRACE         NO\n") ;
}

//---------------------------------------------------------------------------*

void cPtr_trace::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@trace:"
           << loc.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_trace::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_trace::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_trace (& typeid (cPtr_trace), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_trace::galgasRTTI (void) const {
  return & gClassInfoFor__trace ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         GALGAS class 'GGS_trace'                          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_trace::
GGS_trace (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_trace::
GGS_trace (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_trace GGS_trace::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_trace _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_trace *> (inPointer) != NULL)
      : (typeid (cPtr_trace) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_trace (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_trace),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_trace GGS_trace::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_trace result ;
  macroMyNew (result.mPointer, cPtr_trace (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_trace::
reader_loc (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace *) mPointer)->loc ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_trace::actualTypeName (void) const {
  return "trace" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_trace::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__trace ("trace") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_trace_off'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_trace_off::
cPtr_trace_off (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_trace (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_trace_off * GGS_trace_off::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_off *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_trace_off *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_trace_off::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_trace_off * _p = dynamic_cast <const cPtr_trace_off *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = loc._operator_isEqual (_p->loc).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_trace_off::
method_generate (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_res = GGS_string (true, "#define TRACE         NO\n") ;
}

//---------------------------------------------------------------------------*

void cPtr_trace_off::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@trace_off:"
           << loc.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_trace_off::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_trace_off::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_trace_off (& typeid (cPtr_trace_off), & typeid (cPtr_trace), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_trace_off::galgasRTTI (void) const {
  return & gClassInfoFor__trace_off ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_trace_off'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_trace_off::
GGS_trace_off (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_trace_off::
GGS_trace_off (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_trace_off GGS_trace_off::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_trace_off _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_trace_off *> (inPointer) != NULL)
      : (typeid (cPtr_trace_off) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_trace_off (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_trace_off),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_trace_off GGS_trace_off::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_trace_off result ;
  macroMyNew (result.mPointer, cPtr_trace_off (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_trace_off::actualTypeName (void) const {
  return "trace_off" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__trace_off ("trace_off", gClassInfoFor__trace) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_trace_on'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_trace_on::
cPtr_trace_on (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_trace (argument_0 COMMA_THERE),
file (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_trace_on * GGS_trace_on::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_on *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_trace_on *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_trace_on::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_trace_on * _p = dynamic_cast <const cPtr_trace_on *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = loc._operator_isEqual (_p->loc).boolValue ()
         && file._operator_isEqual (_p->file).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_trace_on::
method_generate (C_Compiler & _inLexique,
                                GGS_string& var_cas_res COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_res = GGS_string (true, "#define TRACE         YES\n") ;
  var_cas_res.appendCstring ("#define TRACE_FILE    \"") ;
  var_cas_res._dotAssign_operation (file.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (46))) ;
  var_cas_res.appendCstring ("\"\n") ;
}

//---------------------------------------------------------------------------*

void cPtr_trace_on::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@trace_on:"
           << loc.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << file.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_trace_on::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_trace_on::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_trace_on (& typeid (cPtr_trace_on), & typeid (cPtr_trace), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_trace_on::galgasRTTI (void) const {
  return & gClassInfoFor__trace_on ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_trace_on'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_trace_on::
GGS_trace_on (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_trace_on::
GGS_trace_on (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_trace_on GGS_trace_on::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_trace_on _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_trace_on *> (inPointer) != NULL)
      : (typeid (cPtr_trace_on) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_trace_on (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_trace_on),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_trace_on GGS_trace_on::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_trace_on result ;
  macroMyNew (result.mPointer, cPtr_trace_on (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_trace_on::
reader_file (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_on *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace_on *) mPointer)->file ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_trace_on::actualTypeName (void) const {
  return "trace_on" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__trace_on ("trace_on", gClassInfoFor__trace) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'cPtr_os_obj'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_os_obj::
cPtr_os_obj (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_basic_type & argument_2,
                                const GGS_basic_type & argument_3,
                                const GGS_basic_type & argument_4,
                                const GGS_basic_type & argument_5,
                                const GGS_basic_type & argument_6,
                                const GGS_basic_type & argument_7,
                                const GGS_lstring & argument_8,
                                const GGS_basic_type & argument_9,
                                const GGS_basic_type & argument_10,
                                const GGS_basic_type & argument_11,
                                const GGS_basic_type & argument_12,
                                const GGS_basic_type & argument_13,
                                const GGS_lstringlist & argument_14,
                                const GGS_lstringlist & argument_15,
                                const GGS_lstringlist & argument_16,
                                const GGS_lstringlist & argument_17,
                                const GGS_lstring & argument_18,
                                const GGS_lstring & argument_19,
                                const GGS_trace & argument_20,
                                const GGS_ident_map & argument_21
                                COMMA_LOCATION_ARGS)
:cPtr_oil_obj (argument_0 COMMA_THERE),
status (argument_1),
startuphook (argument_2),
shutdownhook (argument_3),
errorhook (argument_4),
pretaskhook (argument_5),
posttaskhook (argument_6),
protectionhook (argument_7),
scalabilityclass (argument_8),
stackmonitoring (argument_9),
usegetserviceid (argument_10),
useparameteraccess (argument_11),
useresscheduler (argument_12),
systemcall (argument_13),
app_src (argument_14),
cflags (argument_15),
asflags (argument_16),
ldflags (argument_17),
app_name (argument_18),
tpl_base_path (argument_19),
trace (argument_20),
others (argument_21) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_os_obj * GGS_os_obj::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_os_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_os_obj::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_os_obj * _p = dynamic_cast <const cPtr_os_obj *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = desc._operator_isEqual (_p->desc).boolValue ()
         && status._operator_isEqual (_p->status).boolValue ()
         && startuphook._operator_isEqual (_p->startuphook).boolValue ()
         && shutdownhook._operator_isEqual (_p->shutdownhook).boolValue ()
         && errorhook._operator_isEqual (_p->errorhook).boolValue ()
         && pretaskhook._operator_isEqual (_p->pretaskhook).boolValue ()
         && posttaskhook._operator_isEqual (_p->posttaskhook).boolValue ()
         && protectionhook._operator_isEqual (_p->protectionhook).boolValue ()
         && scalabilityclass._operator_isEqual (_p->scalabilityclass).boolValue ()
         && stackmonitoring._operator_isEqual (_p->stackmonitoring).boolValue ()
         && usegetserviceid._operator_isEqual (_p->usegetserviceid).boolValue ()
         && useparameteraccess._operator_isEqual (_p->useparameteraccess).boolValue ()
         && useresscheduler._operator_isEqual (_p->useresscheduler).boolValue ()
         && systemcall._operator_isEqual (_p->systemcall).boolValue ()
         && app_src._operator_isEqual (_p->app_src).boolValue ()
         && cflags._operator_isEqual (_p->cflags).boolValue ()
         && asflags._operator_isEqual (_p->asflags).boolValue ()
         && ldflags._operator_isEqual (_p->ldflags).boolValue ()
         && app_name._operator_isEqual (_p->app_name).boolValue ()
         && tpl_base_path._operator_isEqual (_p->tpl_base_path).boolValue ()
         && trace._operator_isEqual (_p->trace).boolValue ()
         && others._operator_isEqual (_p->others).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_os_obj::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@os_obj:"
           << desc.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << status.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << startuphook.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << shutdownhook.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << errorhook.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << pretaskhook.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << posttaskhook.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << protectionhook.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << scalabilityclass.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << stackmonitoring.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << usegetserviceid.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << useparameteraccess.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << useresscheduler.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << systemcall.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << app_src.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << cflags.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << asflags.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << ldflags.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << app_name.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << tpl_base_path.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << trace.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << others.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_os_obj::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_os_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_os_obj (& typeid (cPtr_os_obj), & typeid (cPtr_oil_obj), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_os_obj::galgasRTTI (void) const {
  return & gClassInfoFor__os_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        GALGAS class 'GGS_os_obj'                          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_os_obj::
GGS_os_obj (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_os_obj::
GGS_os_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_os_obj GGS_os_obj::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_os_obj _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_os_obj *> (inPointer) != NULL)
      : (typeid (cPtr_os_obj) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_os_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_os_obj),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_os_obj GGS_os_obj::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_basic_type & argument_2,
                 const GGS_basic_type & argument_3,
                 const GGS_basic_type & argument_4,
                 const GGS_basic_type & argument_5,
                 const GGS_basic_type & argument_6,
                 const GGS_basic_type & argument_7,
                 const GGS_lstring & argument_8,
                 const GGS_basic_type & argument_9,
                 const GGS_basic_type & argument_10,
                 const GGS_basic_type & argument_11,
                 const GGS_basic_type & argument_12,
                 const GGS_basic_type & argument_13,
                 const GGS_lstringlist & argument_14,
                 const GGS_lstringlist & argument_15,
                 const GGS_lstringlist & argument_16,
                 const GGS_lstringlist & argument_17,
                 const GGS_lstring & argument_18,
                 const GGS_lstring & argument_19,
                 const GGS_trace & argument_20,
                 const GGS_ident_map & argument_21
                                COMMA_LOCATION_ARGS) {
  GGS_os_obj result ;
  macroMyNew (result.mPointer, cPtr_os_obj (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8,
                                argument_9,
                                argument_10,
                                argument_11,
                                argument_12,
                                argument_13,
                                argument_14,
                                argument_15,
                                argument_16,
                                argument_17,
                                argument_18,
                                argument_19,
                                argument_20,
                                argument_21 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_os_obj::
reader_status (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->status ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_startuphook (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->startuphook ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_shutdownhook (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->shutdownhook ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_errorhook (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->errorhook ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_pretaskhook (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->pretaskhook ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_posttaskhook (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->posttaskhook ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_protectionhook (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->protectionhook ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_os_obj::
reader_scalabilityclass (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->scalabilityclass ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_stackmonitoring (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->stackmonitoring ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_usegetserviceid (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->usegetserviceid ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_useparameteraccess (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->useparameteraccess ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_useresscheduler (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->useresscheduler ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_systemcall (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->systemcall ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_os_obj::
reader_app_src (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->app_src ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_os_obj::
reader_cflags (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->cflags ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_os_obj::
reader_asflags (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->asflags ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_os_obj::
reader_ldflags (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->ldflags ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_os_obj::
reader_app_name (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->app_name ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_os_obj::
reader_tpl_base_path (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->tpl_base_path ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_trace  GGS_os_obj::
reader_trace (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_trace   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->trace ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ident_map  GGS_os_obj::
reader_others (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ident_map   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->others ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_os_obj::actualTypeName (void) const {
  return "os_obj" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__os_obj ("os_obj", gClassInfoFor__oil_obj) ;

//---------------------------------------------------------------------------*

