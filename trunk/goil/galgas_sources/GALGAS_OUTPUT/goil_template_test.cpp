//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'goil_template_test.cpp'                        *
//                        Generated by version 1.9.4                         *
//                    november 12th, 2009, at 11h40'57"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != 599
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "goil_template_test.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "goil_template_test.ggs", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Include directives generated by grammar includes              *
//                                                                           *
//---------------------------------------------------------------------------*

#include "goil_template_grammar.h"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                 Implementation of routine "testTemplate"                  *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_testTemplate (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_testTemplate at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  const GGS_bool cond_5127 = gOption_goil_5F_options_run_5F_goil_5F_template_5F_test.value () ;
  if (cond_5127.isBuiltAndTrue ()) {
    const GGS_string var_cas_templateSourceString = GGS_string ("ceci est%!CHAINE1 %un template.\n"
      "Test if vrai:%if TRUE_VAR then !CHAINE1%1re branche%!CHAINE1 else !CHAINE2 %2e branche% !CHAINE2 end if %.\n"
      "Test if false:%if FALSE_VAR then !CHAINE1%1re branche%!CHAINE1 else !CHAINE2 %2e branche% !CHAINE2 end if %.\n"
      "Test if false, true:%if FALSE_VAR then !CHAINE1%1re branche%!CHAINE1 elsif TRUE_VAR then !CHAINE2 %2e branche% !CHAINE2  else !CHAINE3 %3e branche% !CH"
      "AINE3 end if %.\n"
      "Test if false, false:%if FALSE_VAR then !CHAINE1%1re branche%!CHAINE1 elsif FALSE_VAR then !CHAINE2 %2e branche% !CHAINE2  else !CHAINE3 %3e branche% !"
      "CHAINE3 end if %.\n"
      "Test indentation %\?COL%.\n"
      "%!COL%^ (le ^ doit \xC3""\xAA""tre juste au dessous du point)\n"
      "La liste a %![[UNE_LISTE length] string]% element% if [UNE_LISTE length] > 1 then %s% end if%.\n"
      "Enumeration de la liste:\n"
      "%"
      "foreach UNE_LISTE\n"
      "before %<before>%\n"
      "do %<do>'%!STR_FIELD%', %![UINT_FIELD string]%</do>%\n"
      "between %<between>%\n"
      "after %<after>%\n"
      "end foreach\n"
      "%Fin enumeration.\n"
      "Enumeration d'une liste vide:%foreach LISTE_VIDE\n"
      "before %<before>%\n"
      "do %<do>%\n"
      "between %<between>%\n"
      "after %<after>%\n"
      "end foreach\n"
      "%Fin enumeration.\n") ;
    GGS_goilTemplateVariableMap  var_cas_sampleMap = GGS_goilTemplateVariableMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    ::routine_addBoolValue (inLexique,  var_cas_sampleMap,  GGS_lstring ::constructor_new (inLexique, GGS_string ("TRUE_VAR"), GGS_location (inLexique) COMMA_HERE),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (56)) ;
    ::routine_addBoolValue (inLexique,  var_cas_sampleMap,  GGS_lstring ::constructor_new (inLexique, GGS_string ("FALSE_VAR"), GGS_location (inLexique) COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (57)) ;
    ::routine_addStringValue (inLexique,  var_cas_sampleMap,  GGS_lstring ::constructor_new (inLexique, GGS_string ("CHAINE1"), GGS_location (inLexique) COMMA_HERE),  GGS_string ("<ch1>") COMMA_SOURCE_FILE_AT_LINE (58)) ;
    ::routine_addStringValue (inLexique,  var_cas_sampleMap,  GGS_lstring ::constructor_new (inLexique, GGS_string ("CHAINE2"), GGS_location (inLexique) COMMA_HERE),  GGS_string ("<ch2>") COMMA_SOURCE_FILE_AT_LINE (59)) ;
    ::routine_addStringValue (inLexique,  var_cas_sampleMap,  GGS_lstring ::constructor_new (inLexique, GGS_string ("CHAINE3"), GGS_location (inLexique) COMMA_HERE),  GGS_string ("<ch3>") COMMA_SOURCE_FILE_AT_LINE (60)) ;
    ::routine_addUnsignedValue (inLexique,  var_cas_sampleMap,  GGS_lstring ::constructor_new (inLexique, GGS_string ("UINT0"), GGS_location (inLexique) COMMA_HERE),  GGS_uint64 (123ULL) COMMA_SOURCE_FILE_AT_LINE (61)) ;
    GGS_goilTemplateFieldMap  var_cas_fieldMap = GGS_goilTemplateFieldMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    ::routine_addBoolFieldValue (inLexique,  var_cas_fieldMap,  GGS_lstring ::constructor_new (inLexique, GGS_string ("BOOL_FIELD"), GGS_location (inLexique) COMMA_HERE),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (64)) ;
    ::routine_addUnsignedFieldValue (inLexique,  var_cas_fieldMap,  GGS_lstring ::constructor_new (inLexique, GGS_string ("UINT_FIELD"), GGS_location (inLexique) COMMA_HERE),  GGS_uint64 (14ULL) COMMA_SOURCE_FILE_AT_LINE (65)) ;
    ::routine_addStringFieldValue (inLexique,  var_cas_fieldMap,  GGS_lstring ::constructor_new (inLexique, GGS_string ("STR_FIELD"), GGS_location (inLexique) COMMA_HERE),  GGS_string ("<toto>") COMMA_SOURCE_FILE_AT_LINE (66)) ;
    GGS_goilTemplateFieldMapList  var_cas_fieldMapList = GGS_goilTemplateFieldMapList ::constructor_listWithValue (var_cas_fieldMap) ;
    var_cas_fieldMap = GGS_goilTemplateFieldMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    ::routine_addBoolFieldValue (inLexique,  var_cas_fieldMap,  GGS_lstring ::constructor_new (inLexique, GGS_string ("BOOL_FIELD"), GGS_location (inLexique) COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (69)) ;
    ::routine_addUnsignedFieldValue (inLexique,  var_cas_fieldMap,  GGS_lstring ::constructor_new (inLexique, GGS_string ("UINT_FIELD"), GGS_location (inLexique) COMMA_HERE),  GGS_uint64 (23ULL) COMMA_SOURCE_FILE_AT_LINE (70)) ;
    ::routine_addStringFieldValue (inLexique,  var_cas_fieldMap,  GGS_lstring ::constructor_new (inLexique, GGS_string ("STR_FIELD"), GGS_location (inLexique) COMMA_HERE),  GGS_string ("<tutu>") COMMA_SOURCE_FILE_AT_LINE (71)) ;
    var_cas_fieldMapList.addAssign_operation (var_cas_fieldMap) ;
    ::routine_addListValue (inLexique,  var_cas_sampleMap,  GGS_lstring ::constructor_new (inLexique, GGS_string ("UNE_LISTE"), GGS_location (inLexique) COMMA_HERE),  var_cas_fieldMapList COMMA_SOURCE_FILE_AT_LINE (73)) ;
    ::routine_addListValue (inLexique,  var_cas_sampleMap,  GGS_lstring ::constructor_new (inLexique, GGS_string ("LISTE_VIDE"), GGS_location (inLexique) COMMA_HERE),  GGS_goilTemplateFieldMapList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (75)) ;
    GGS_string var_cas_resutingString = GGS_string ("") ;
    goil_template_grammar::_performSourceStringParsing_ (inLexique,
                                    NULL,
                                    var_cas_templateSourceString,
                                    var_cas_sampleMap,
                                    var_cas_resutingString
                                    COMMA_SOURCE_FILE_AT_LINE (78)) ;
    inLexique.printMessage (GGS_string ("------------------- TEMPLATE SOURCE STRING ----------------------\n") COMMA_SOURCE_FILE_AT_LINE (82)) ;
    inLexique.printMessage (var_cas_templateSourceString COMMA_SOURCE_FILE_AT_LINE (83)) ;
    inLexique.printMessage (GGS_string ("------------------- DUMP TEMPLATE VARIABLE MAP ------------------\n") COMMA_SOURCE_FILE_AT_LINE (84)) ;
    ::routine_displayTemplateVariableMap (inLexique,  var_cas_sampleMap COMMA_SOURCE_FILE_AT_LINE (85)) ;
    inLexique.printMessage (GGS_string ("------------------- RESULT STRING -------------------------------\n") COMMA_SOURCE_FILE_AT_LINE (86)) ;
    inLexique.printMessage (var_cas_resutingString COMMA_SOURCE_FILE_AT_LINE (87)) ;
    inLexique.printMessage (GGS_string ("------------------- END -----------------------------------------\n") COMMA_SOURCE_FILE_AT_LINE (88)) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_testTemplate\n") ;
  #endif
}

//---------------------------------------------------------------------------*

