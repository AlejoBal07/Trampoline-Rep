//---------------------------------------------------------------------------*
//                                                                           *
//                          File 'xml_to_goil.cpp'                           *
//                        Generated by version 1.8.3                         *
//                       june 2nd, 2009, at 10h33'25"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != 491
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "xml_to_goil.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "xml_to_goil.ggs", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of function "transform_xml_to_goil"             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_root_obj  function_transform_xml_to_goil (C_Compiler & _inLexique,
                                const GGS_xmlNodeList   var_cas_nodes COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_transform_xml_to_goil at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_root_obj  var_cas_cpu ;
  GGS_void  var_cas_void_obj ;
  var_cas_void_obj = GGS_void ::constructor_new (_inLexique, GGS_location (_inLexique) COMMA_HERE) ;
  var_cas_cpu = GGS_root_obj ::constructor_new (_inLexique, GGS_os_obj ::constructor_new (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (""), GGS_location (_inLexique) COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (""), GGS_location (_inLexique) COMMA_HERE), var_cas_void_obj, var_cas_void_obj, var_cas_void_obj, var_cas_void_obj, var_cas_void_obj, var_cas_void_obj, GGS_lstring ::constructor_new (_inLexique, GGS_string (""), GGS_location (_inLexique) COMMA_HERE), var_cas_void_obj, var_cas_void_obj, var_cas_void_obj, var_cas_void_obj, var_cas_void_obj, GGS_lstringlist ::constructor_emptyList (), GGS_lstringlist ::constructor_emptyList (), GGS_lstringlist ::constructor_emptyList (), GGS_lstringlist ::constructor_emptyList (), GGS_lstring ::constructor_new (_inLexique, GGS_string (""), GGS_location (_inLexique) COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (""), GGS_location (_inLexique) COMMA_HERE), GGS_trace ::constructor_new (_inLexique, GGS_location (_inLexique) COMMA_HERE), GGS_ident_map ::constructor_emptyMap (_inLexique COMMA_HERE) COMMA_HERE), GGS_com ::constructor_new (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (""), GGS_location (_inLexique) COMMA_HERE), GGS_bool (false), var_cas_void_obj, var_cas_void_obj, var_cas_void_obj, var_cas_void_obj, var_cas_void_obj, GGS_lstringlist ::constructor_emptyList (), GGS_lstring ::constructor_new (_inLexique, GGS_string (""), GGS_location (_inLexique) COMMA_HERE), GGS_lstringlist ::constructor_emptyList () COMMA_HERE), GGS_task_map ::constructor_emptyMap (_inLexique COMMA_HERE), GGS_counter_map ::constructor_emptyMap (_inLexique COMMA_HERE), GGS_alarm_map ::constructor_emptyMap (_inLexique COMMA_HERE), GGS_resource_map ::constructor_emptyMap (_inLexique COMMA_HERE), GGS_event_map ::constructor_emptyMap (_inLexique COMMA_HERE), GGS_isr_map ::constructor_emptyMap (_inLexique COMMA_HERE), GGS_message_map ::constructor_emptyMap (_inLexique COMMA_HERE), GGS_netmess_map ::constructor_emptyMap (_inLexique COMMA_HERE), GGS_scheduletable_map ::constructor_emptyMap (_inLexique COMMA_HERE), GGS_app_map ::constructor_emptyMap (_inLexique COMMA_HERE) COMMA_HERE) ;
  if (((var_cas_nodes.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (86)))._operator_isEqual (GGS_uint (0U))).isBuiltAndTrue ()) {
    GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string ("Empty epc file") COMMA_SOURCE_FILE_AT_LINE (88)) ;
  }else{
    GGS_bool var_cas_root_found ;
    var_cas_root_found = GGS_bool (false) ;
    {
      GGS_xmlNodeList::cEnumerator enumerator_1971 (var_cas_nodes, true) ;
      const GGS_xmlNodeList::cElement * operand_1971 = NULL ;
      while (((operand_1971 = enumerator_1971.nextObject ()))) {
        macroValidPointer (operand_1971) ;
        if (((operand_1971->node.reader_type (_inLexique COMMA_SOURCE_FILE_AT_LINE (91)))._operator_isEqual (GGS_xmlNodeType::constructor_element (_inLexique COMMA_HERE))).isBuiltAndTrue ()) {
          if ((((operand_1971->node.reader_name (_inLexique COMMA_SOURCE_FILE_AT_LINE (92)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (92)))._operator_isEqual (GGS_string ("AUTOSAR")))._operator_and ((var_cas_root_found)._operator_isEqual (GGS_bool (false)))).isBuiltAndTrue ()) {
            var_cas_root_found = GGS_bool (true) ;
          }
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_transform_xml_to_goil\n") ;
  #endif
  return var_cas_cpu ;
}

//---------------------------------------------------------------------------*

