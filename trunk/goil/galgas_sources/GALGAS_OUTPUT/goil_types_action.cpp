//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'goil_types_action.cpp'                        *
//                        Generated by version 1.9.7                         *
//                     december 17th, 2009, at 9h52'48"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != 629
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "goil_types_action.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "goil_types_action.ggs", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_action_obj'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_action_obj::
cPtr_action_obj (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
location (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_action_obj * GGS_action_obj::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_action_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_action_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_action_obj::
method_flag (C_Compiler & /* inLexique */,
                                GGS_stringset & /* var_cas_f */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_action_obj::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@action_obj:"
           << location.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_action_obj::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_action_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_action_obj (& typeid (cPtr_action_obj), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_action_obj::galgasRTTI (void) const {
  return & gClassInfoFor__action_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_action_obj'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_action_obj ("action_obj", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_action_obj::
GGS_action_obj (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_action_obj::
GGS_action_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_action_obj GGS_action_obj::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_action_obj result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_action_obj *> (inPointer) != NULL)
      : (typeid (cPtr_action_obj) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_action_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_action_obj),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_action_obj::
reader_location (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_action_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_action_obj *) mPointer)->location ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_action_obj::actualTypeName (void) const {
  return "action_obj" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_action_obj::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__action_obj ("action_obj", & kTypeDescriptor_GGS_action_obj) ;

//---------------------------------------------------------------------------*

GGS_object GGS_action_obj::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_action_obj * p = NULL ;
    macroMyNew (p, GGS_action_obj (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_action_obj GGS_action_obj::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_action_obj result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_action_obj * p = dynamic_cast <const GGS_action_obj *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_action_obj, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_action_obj::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_action_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_void_action'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_void_action::
cPtr_void_action (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_action_obj (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_void_action * GGS_void_action::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_void_action *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_void_action *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_void_action::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_void_action * ptr = dynamic_cast <const cPtr_void_action *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_void_action::
method_generate (C_Compiler & inLexique,
                                GGS_lstring  /* var_cas_name */,
                                GGS_string /* var_cas_err */,
                                GGS_string var_cas_key,
                                GGS_string& /* var_cas_h_res */,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  ::routine_doReplace (inLexique,  var_cas_i_res,  var_cas_key,  GGS_string ("NULL_PTR") COMMA_SOURCE_FILE_AT_LINE (28)) ;
}

//---------------------------------------------------------------------------*

void cPtr_void_action::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@void_action:"
           << location.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_void_action::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_void_action::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_void_action (& typeid (cPtr_void_action), & typeid (cPtr_action_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_void_action::galgasRTTI (void) const {
  return & gClassInfoFor__void_action ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_void_action::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_void_action (location COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_void_action'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_void_action ("void_action", true, & kTypeDescriptor_GGS_action_obj) ;

//---------------------------------------------------------------------------*

GGS_void_action::
GGS_void_action (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_void_action::
GGS_void_action (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_void_action GGS_void_action::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_void_action result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_void_action *> (inPointer) != NULL)
      : (typeid (cPtr_void_action) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_void_action (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_void_action),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_action GGS_void_action::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_void_action result ;
  macroMyNew (result.mPointer, cPtr_void_action (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_void_action::actualTypeName (void) const {
  return "void_action" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__void_action ("void_action", gClassInfoFor__action_obj, & kTypeDescriptor_GGS_void_action) ;

//---------------------------------------------------------------------------*

GGS_object GGS_void_action::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_void_action * p = NULL ;
    macroMyNew (p, GGS_void_action (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_action GGS_void_action::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_void_action result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_void_action * p = dynamic_cast <const GGS_void_action *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_void_action, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_void_action::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_void_action ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_setevent_action'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_setevent_action::
cPtr_setevent_action (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_action_obj (argument_0 COMMA_THERE),
task_name (argument_1),
event_name (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_setevent_action * GGS_setevent_action::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_setevent_action *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_setevent_action *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_setevent_action::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_setevent_action * ptr = dynamic_cast <const cPtr_setevent_action *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && task_name.operator_isEqual (ptr->task_name).boolValue ()
         && event_name.operator_isEqual (ptr->event_name).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_setevent_action::
method_generate (C_Compiler & inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string var_cas_err,
                                GGS_string var_cas_key,
                                GGS_string& /* var_cas_h_res */,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_res = function_template_string (inLexique, GGS_string ("code"), GGS_string ("notification_setevent") COMMA_SOURCE_FILE_AT_LINE (43)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$NOTIFICATION_NAME$"),  ((var_cas_err).operator_concat (GGS_string (" of message "))).operator_concat (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (45))) COMMA_SOURCE_FILE_AT_LINE (45)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$NOTIFICATION$"),  (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (46))).operator_concat (GGS_string ("_notification")) COMMA_SOURCE_FILE_AT_LINE (46)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$TASK$"),  (task_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (47))).operator_concat (GGS_string ("_id")) COMMA_SOURCE_FILE_AT_LINE (47)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$EVENT$"),  (event_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (48))).operator_concat (GGS_string ("_mask")) COMMA_SOURCE_FILE_AT_LINE (48)) ;
  ::routine_doReplace (inLexique,  var_cas_i_res,  var_cas_key,  ((GGS_string ("&")).operator_concat (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (50)))).operator_concat (GGS_string ("_notification")) COMMA_SOURCE_FILE_AT_LINE (50)) ;
  var_cas_i_res = ((var_cas_res).operator_concat (GGS_string ("\n"))).operator_concat (var_cas_i_res) ;
}

//---------------------------------------------------------------------------*

void cPtr_setevent_action::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@setevent_action:"
           << location.reader_description (inIndentation + 1)
           << task_name.reader_description (inIndentation + 1)
           << event_name.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_setevent_action::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_setevent_action::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_setevent_action (& typeid (cPtr_setevent_action), & typeid (cPtr_action_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_setevent_action::galgasRTTI (void) const {
  return & gClassInfoFor__setevent_action ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_setevent_action::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_setevent_action (location, task_name, event_name COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_setevent_action'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_setevent_action ("setevent_action", true, & kTypeDescriptor_GGS_action_obj) ;

//---------------------------------------------------------------------------*

GGS_setevent_action::
GGS_setevent_action (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_setevent_action::
GGS_setevent_action (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_setevent_action GGS_setevent_action::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_setevent_action result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_setevent_action *> (inPointer) != NULL)
      : (typeid (cPtr_setevent_action) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_setevent_action (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_setevent_action),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_setevent_action GGS_setevent_action::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_setevent_action result ;
  macroMyNew (result.mPointer, cPtr_setevent_action (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_setevent_action::
reader_task_name (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_setevent_action *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_setevent_action *) mPointer)->task_name ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_setevent_action::
reader_event_name (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_setevent_action *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_setevent_action *) mPointer)->event_name ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_setevent_action::actualTypeName (void) const {
  return "setevent_action" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__setevent_action ("setevent_action", gClassInfoFor__action_obj, & kTypeDescriptor_GGS_setevent_action) ;

//---------------------------------------------------------------------------*

GGS_object GGS_setevent_action::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_setevent_action * p = NULL ;
    macroMyNew (p, GGS_setevent_action (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_setevent_action GGS_setevent_action::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_setevent_action result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_setevent_action * p = dynamic_cast <const GGS_setevent_action *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_setevent_action, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_setevent_action::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_setevent_action ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_activatetask_action'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_activatetask_action::
cPtr_activatetask_action (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_action_obj (argument_0 COMMA_THERE),
task_name (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_activatetask_action * GGS_activatetask_action::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_activatetask_action *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_activatetask_action *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_activatetask_action::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_activatetask_action * ptr = dynamic_cast <const cPtr_activatetask_action *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && task_name.operator_isEqual (ptr->task_name).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_activatetask_action::
method_generate (C_Compiler & inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string var_cas_err,
                                GGS_string var_cas_key,
                                GGS_string& /* var_cas_h_res */,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_res = function_template_string (inLexique, GGS_string ("code"), GGS_string ("notification_activatetask") COMMA_SOURCE_FILE_AT_LINE (66)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$NOTIFICATION_NAME$"),  ((var_cas_err).operator_concat (GGS_string (" of message "))).operator_concat (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (68))) COMMA_SOURCE_FILE_AT_LINE (68)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$NOTIFICATION$"),  (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (69))).operator_concat (GGS_string ("_notification")) COMMA_SOURCE_FILE_AT_LINE (69)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$TASK$"),  (task_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (70))).operator_concat (GGS_string ("_id")) COMMA_SOURCE_FILE_AT_LINE (70)) ;
  ::routine_doReplace (inLexique,  var_cas_i_res,  var_cas_key,  ((GGS_string ("&")).operator_concat (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (72)))).operator_concat (GGS_string ("_notification")) COMMA_SOURCE_FILE_AT_LINE (72)) ;
  var_cas_i_res = ((var_cas_res).operator_concat (GGS_string ("\n"))).operator_concat (var_cas_i_res) ;
}

//---------------------------------------------------------------------------*

void cPtr_activatetask_action::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@activatetask_action:"
           << location.reader_description (inIndentation + 1)
           << task_name.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_activatetask_action::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_activatetask_action::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_activatetask_action (& typeid (cPtr_activatetask_action), & typeid (cPtr_action_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_activatetask_action::galgasRTTI (void) const {
  return & gClassInfoFor__activatetask_action ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_activatetask_action::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_activatetask_action (location, task_name COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_activatetask_action'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_activatetask_action ("activatetask_action", true, & kTypeDescriptor_GGS_action_obj) ;

//---------------------------------------------------------------------------*

GGS_activatetask_action::
GGS_activatetask_action (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_activatetask_action::
GGS_activatetask_action (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_activatetask_action GGS_activatetask_action::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_activatetask_action result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_activatetask_action *> (inPointer) != NULL)
      : (typeid (cPtr_activatetask_action) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_activatetask_action (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_activatetask_action),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_activatetask_action GGS_activatetask_action::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_activatetask_action result ;
  macroMyNew (result.mPointer, cPtr_activatetask_action (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_activatetask_action::
reader_task_name (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_activatetask_action *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_activatetask_action *) mPointer)->task_name ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_activatetask_action::actualTypeName (void) const {
  return "activatetask_action" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__activatetask_action ("activatetask_action", gClassInfoFor__action_obj, & kTypeDescriptor_GGS_activatetask_action) ;

//---------------------------------------------------------------------------*

GGS_object GGS_activatetask_action::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_activatetask_action * p = NULL ;
    macroMyNew (p, GGS_activatetask_action (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_activatetask_action GGS_activatetask_action::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_activatetask_action result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_activatetask_action * p = dynamic_cast <const GGS_activatetask_action *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_activatetask_action, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_activatetask_action::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_activatetask_action ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_callback_action'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_callback_action::
cPtr_callback_action (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_action_obj (argument_0 COMMA_THERE),
function_name (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_callback_action * GGS_callback_action::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_callback_action *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_callback_action *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_callback_action::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_callback_action * ptr = dynamic_cast <const cPtr_callback_action *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && function_name.operator_isEqual (ptr->function_name).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_callback_action::
method_generate (C_Compiler & inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string var_cas_err,
                                GGS_string var_cas_key,
                                GGS_string& /* var_cas_h_res */,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_res = function_template_string (inLexique, GGS_string ("code"), GGS_string ("notification_callback") COMMA_SOURCE_FILE_AT_LINE (88)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$NOTIFICATION_NAME$"),  ((var_cas_err).operator_concat (GGS_string (" of message "))).operator_concat (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (90))) COMMA_SOURCE_FILE_AT_LINE (90)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$NOTIFICATION$"),  (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (91))).operator_concat (GGS_string ("_notification")) COMMA_SOURCE_FILE_AT_LINE (91)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$CALLBACK$"),  (function_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (92))).operator_concat (GGS_string ("_callback")) COMMA_SOURCE_FILE_AT_LINE (92)) ;
  ::routine_doReplace (inLexique,  var_cas_i_res,  var_cas_key,  ((GGS_string ("&")).operator_concat (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (94)))).operator_concat (GGS_string ("_notification")) COMMA_SOURCE_FILE_AT_LINE (94)) ;
  var_cas_i_res = ((var_cas_res).operator_concat (GGS_string ("\n"))).operator_concat (var_cas_i_res) ;
}

//---------------------------------------------------------------------------*

void cPtr_callback_action::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@callback_action:"
           << location.reader_description (inIndentation + 1)
           << function_name.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_callback_action::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_callback_action::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_callback_action (& typeid (cPtr_callback_action), & typeid (cPtr_action_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_callback_action::galgasRTTI (void) const {
  return & gClassInfoFor__callback_action ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_callback_action::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_callback_action (location, function_name COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_callback_action'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_callback_action ("callback_action", true, & kTypeDescriptor_GGS_action_obj) ;

//---------------------------------------------------------------------------*

GGS_callback_action::
GGS_callback_action (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_callback_action::
GGS_callback_action (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_callback_action GGS_callback_action::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_callback_action result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_callback_action *> (inPointer) != NULL)
      : (typeid (cPtr_callback_action) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_callback_action (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_callback_action),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_callback_action GGS_callback_action::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_callback_action result ;
  macroMyNew (result.mPointer, cPtr_callback_action (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_callback_action::
reader_function_name (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_callback_action *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_callback_action *) mPointer)->function_name ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_callback_action::actualTypeName (void) const {
  return "callback_action" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__callback_action ("callback_action", gClassInfoFor__action_obj, & kTypeDescriptor_GGS_callback_action) ;

//---------------------------------------------------------------------------*

GGS_object GGS_callback_action::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_callback_action * p = NULL ;
    macroMyNew (p, GGS_callback_action (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_callback_action GGS_callback_action::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_callback_action result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_callback_action * p = dynamic_cast <const GGS_callback_action *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_callback_action, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_callback_action::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_callback_action ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_flag_action'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_flag_action::
cPtr_flag_action (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_action_obj (argument_0 COMMA_THERE),
flag_name (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_flag_action * GGS_flag_action::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_flag_action *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_flag_action *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_flag_action::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_flag_action * ptr = dynamic_cast <const cPtr_flag_action *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && flag_name.operator_isEqual (ptr->flag_name).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_flag_action::
method_generate (C_Compiler & inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string var_cas_err,
                                GGS_string var_cas_key,
                                GGS_string& /* var_cas_h_res */,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_res = function_template_string (inLexique, GGS_string ("code"), GGS_string ("notification_flag") COMMA_SOURCE_FILE_AT_LINE (109)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$NOTIFICATION_NAME$"),  ((var_cas_err).operator_concat (GGS_string (" of message "))).operator_concat (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (111))) COMMA_SOURCE_FILE_AT_LINE (111)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$NOTIFICATION$"),  (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (112))).operator_concat (GGS_string ("_notification")) COMMA_SOURCE_FILE_AT_LINE (112)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$FLAGFUNCTION$"),  (GGS_string ("tpl_set_flag_")).operator_concat (flag_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (113))) COMMA_SOURCE_FILE_AT_LINE (113)) ;
  ::routine_doReplace (inLexique,  var_cas_i_res,  var_cas_key,  ((GGS_string ("&")).operator_concat (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (115)))).operator_concat (GGS_string ("_notification")) COMMA_SOURCE_FILE_AT_LINE (115)) ;
  var_cas_i_res = ((var_cas_res).operator_concat (GGS_string ("\n"))).operator_concat (var_cas_i_res) ;
}

//---------------------------------------------------------------------------*

void cPtr_flag_action::
method_flag (C_Compiler & inLexique,
                                GGS_stringset & var_cas_f COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_f.addAssign_operation (flag_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (121))) ;
}

//---------------------------------------------------------------------------*

void cPtr_flag_action::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@flag_action:"
           << location.reader_description (inIndentation + 1)
           << flag_name.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_flag_action::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_flag_action::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_flag_action (& typeid (cPtr_flag_action), & typeid (cPtr_action_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_flag_action::galgasRTTI (void) const {
  return & gClassInfoFor__flag_action ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_flag_action::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_flag_action (location, flag_name COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_flag_action'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_flag_action ("flag_action", true, & kTypeDescriptor_GGS_action_obj) ;

//---------------------------------------------------------------------------*

GGS_flag_action::
GGS_flag_action (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_flag_action::
GGS_flag_action (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_flag_action GGS_flag_action::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_flag_action result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_flag_action *> (inPointer) != NULL)
      : (typeid (cPtr_flag_action) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_flag_action (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_flag_action),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_flag_action GGS_flag_action::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_flag_action result ;
  macroMyNew (result.mPointer, cPtr_flag_action (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_flag_action::
reader_flag_name (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_flag_action *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_flag_action *) mPointer)->flag_name ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_flag_action::actualTypeName (void) const {
  return "flag_action" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__flag_action ("flag_action", gClassInfoFor__action_obj, & kTypeDescriptor_GGS_flag_action) ;

//---------------------------------------------------------------------------*

GGS_object GGS_flag_action::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_flag_action * p = NULL ;
    macroMyNew (p, GGS_flag_action (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_flag_action GGS_flag_action::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_flag_action result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_flag_action * p = dynamic_cast <const GGS_flag_action *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_flag_action, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_flag_action::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_flag_action ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_incrementcounter_action'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_incrementcounter_action::
cPtr_incrementcounter_action (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_action_obj (argument_0 COMMA_THERE),
counter_name (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_incrementcounter_action * GGS_incrementcounter_action::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_incrementcounter_action *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_incrementcounter_action *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_incrementcounter_action::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_incrementcounter_action * ptr = dynamic_cast <const cPtr_incrementcounter_action *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && counter_name.operator_isEqual (ptr->counter_name).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_incrementcounter_action::
method_generate (C_Compiler & inLexique,
                                GGS_lstring  var_cas_name,
                                GGS_string var_cas_err,
                                GGS_string var_cas_key,
                                GGS_string& /* var_cas_h_res */,
                                GGS_string& var_cas_i_res COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string var_cas_res = function_template_string (inLexique, GGS_string ("code"), GGS_string ("notification_incrementcounter") COMMA_SOURCE_FILE_AT_LINE (134)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$NOTIFICATION_NAME$"),  ((var_cas_err).operator_concat (GGS_string (" of message "))).operator_concat (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (136))) COMMA_SOURCE_FILE_AT_LINE (136)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$NOTIFICATION$"),  (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (137))).operator_concat (GGS_string ("_notification")) COMMA_SOURCE_FILE_AT_LINE (137)) ;
  ::routine_doReplace (inLexique,  var_cas_res,  GGS_string ("$COUNTER$"),  (counter_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (138))).operator_concat (GGS_string ("_id")) COMMA_SOURCE_FILE_AT_LINE (138)) ;
  ::routine_doReplace (inLexique,  var_cas_i_res,  var_cas_key,  ((GGS_string ("&")).operator_concat (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (140)))).operator_concat (GGS_string ("_notification")) COMMA_SOURCE_FILE_AT_LINE (140)) ;
  var_cas_i_res = ((var_cas_res).operator_concat (GGS_string ("\n"))).operator_concat (var_cas_i_res) ;
}

//---------------------------------------------------------------------------*

void cPtr_incrementcounter_action::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@incrementcounter_action:"
           << location.reader_description (inIndentation + 1)
           << counter_name.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_incrementcounter_action::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_incrementcounter_action::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_incrementcounter_action (& typeid (cPtr_incrementcounter_action), & typeid (cPtr_action_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_incrementcounter_action::galgasRTTI (void) const {
  return & gClassInfoFor__incrementcounter_action ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_incrementcounter_action::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_incrementcounter_action (location, counter_name COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_incrementcounter_action'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_incrementcounter_action ("incrementcounter_action", true, & kTypeDescriptor_GGS_action_obj) ;

//---------------------------------------------------------------------------*

GGS_incrementcounter_action::
GGS_incrementcounter_action (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_incrementcounter_action::
GGS_incrementcounter_action (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_incrementcounter_action GGS_incrementcounter_action::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_incrementcounter_action result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_incrementcounter_action *> (inPointer) != NULL)
      : (typeid (cPtr_incrementcounter_action) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_incrementcounter_action (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_incrementcounter_action),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_incrementcounter_action GGS_incrementcounter_action::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_incrementcounter_action result ;
  macroMyNew (result.mPointer, cPtr_incrementcounter_action (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_incrementcounter_action::
reader_counter_name (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_incrementcounter_action *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_incrementcounter_action *) mPointer)->counter_name ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_incrementcounter_action::actualTypeName (void) const {
  return "incrementcounter_action" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__incrementcounter_action ("incrementcounter_action", gClassInfoFor__action_obj, & kTypeDescriptor_GGS_incrementcounter_action) ;

//---------------------------------------------------------------------------*

GGS_object GGS_incrementcounter_action::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_incrementcounter_action * p = NULL ;
    macroMyNew (p, GGS_incrementcounter_action (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_incrementcounter_action GGS_incrementcounter_action::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_incrementcounter_action result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_incrementcounter_action * p = dynamic_cast <const GGS_incrementcounter_action *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_incrementcounter_action, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_incrementcounter_action::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_incrementcounter_action ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_finalize_st_action'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_finalize_st_action::
cPtr_finalize_st_action (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_action_obj (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_finalize_st_action * GGS_finalize_st_action::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_finalize_st_action *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_finalize_st_action *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_finalize_st_action::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_finalize_st_action * ptr = dynamic_cast <const cPtr_finalize_st_action *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_finalize_st_action::
method_generate (C_Compiler & /* inLexique */,
                                GGS_lstring  /* var_cas_name */,
                                GGS_string /* var_cas_err */,
                                GGS_string /* var_cas_key */,
                                GGS_string& /* var_cas_h_res */,
                                GGS_string& /* var_cas_i_res */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_finalize_st_action::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@finalize_st_action:"
           << location.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_finalize_st_action::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_finalize_st_action::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_finalize_st_action (& typeid (cPtr_finalize_st_action), & typeid (cPtr_action_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_finalize_st_action::galgasRTTI (void) const {
  return & gClassInfoFor__finalize_st_action ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_finalize_st_action::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_finalize_st_action (location COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_finalize_st_action'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor kTypeDescriptor_GGS_finalize_st_action ("finalize_st_action", true, & kTypeDescriptor_GGS_action_obj) ;

//---------------------------------------------------------------------------*

GGS_finalize_st_action::
GGS_finalize_st_action (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_finalize_st_action::
GGS_finalize_st_action (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_finalize_st_action GGS_finalize_st_action::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_finalize_st_action result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_finalize_st_action *> (inPointer) != NULL)
      : (typeid (cPtr_finalize_st_action) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_finalize_st_action (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_finalize_st_action),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_finalize_st_action GGS_finalize_st_action::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_finalize_st_action result ;
  macroMyNew (result.mPointer, cPtr_finalize_st_action (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_finalize_st_action::actualTypeName (void) const {
  return "finalize_st_action" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__finalize_st_action ("finalize_st_action", gClassInfoFor__action_obj, & kTypeDescriptor_GGS_finalize_st_action) ;

//---------------------------------------------------------------------------*

GGS_object GGS_finalize_st_action::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_finalize_st_action * p = NULL ;
    macroMyNew (p, GGS_finalize_st_action (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_finalize_st_action GGS_finalize_st_action::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_finalize_st_action result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_finalize_st_action * p = dynamic_cast <const GGS_finalize_st_action *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_finalize_st_action, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GGS_finalize_st_action::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_finalize_st_action ;
}

//---------------------------------------------------------------------------*

