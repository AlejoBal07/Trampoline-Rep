//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'goil_semantics.cpp'                          *
//             Generated by version 1.4.6 (SLR grammar) [debug]              *
//                     october 19th, 2006, at 11h11'58"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "goil_semantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  static const char gGGSsourceFile [] = "goil_semantics.ggs" ;
  #define SOURCE_FILE_AT_LINE(line) , gGGSsourceFile, line
#else
  #define SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                      Element of list '@number_list'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_number_list::
elementOf_GGS_number_list (const GGS_luint64 & argument_0):
mNextItem (NULL),
number (argument_0) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_number_list::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << number.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           List '@number_list'                             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_number_list::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_number_list::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_number_list::GGS_number_list (void) { // Default Constructor
  _mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_number_list::~GGS_number_list (void) {
  _drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_number_list::
GGS_number_list (const GGS_number_list & inSource) {
  _mRoot = inSource._mRoot ;
  if (_mRoot != NULL) {
    macroValidPointer (_mRoot) ;
    _mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_number_list::
operator = (const GGS_number_list & inSource) {
  if (this != & inSource) {
    _drop_operation () ;
    _mRoot = inSource._mRoot ;
    if (_mRoot != NULL) {
      macroValidPointer (_mRoot) ;
      _mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_number_list::element_type * GGS_number_list::
firstObject (void) const {
  return (_mRoot == NULL) ? NULL : _mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_number_list::
_internalAppendItem (const GGS_luint64 & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (_mRoot->mLastItem == NULL) {
      _mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (_mRoot->mLastItem) ;
      _mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    _mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    _mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_number_list::
_addAssign_operation (const GGS_luint64 & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_number_list::
_insulateList (void) {
  if (_mRoot != NULL) {
    macroValidPointer (_mRoot) ;
    if (_mRoot->mCountReference > 1) {
      element_type * p = _mRoot->mFirstItem ;
      _mRoot->mCountReference -- ;
      _mRoot = NULL ;
      macroMyNew (_mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        _internalAppendItem (p->number) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_number_list  GGS_number_list::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_number_list result ;
  macroMyNew (result._mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_number_list::
count (void) const {
  return (_mRoot == NULL) ? 0 : _mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_number_list::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<list @number_list" ;
  if (_isBuilt ()) {
    s << " " << _mRoot->mListLength << " object" << ((_mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = _mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      s << "\n" ;
      s.writeSpaces (inIndentation + 1) ;
      p->appendForListDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << "not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_number_list::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (_mRoot != NULL,
                   (_mRoot == NULL) ? 0 : (uint32) _mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_number_list::
_drop_operation (void) {
  if (_mRoot != NULL) {
    macroValidPointer (_mRoot) ;
    if (_mRoot->mCountReference == 1) {
      macroMyDelete (_mRoot, cRootList) ;
    }else{
      _mRoot->mCountReference -- ;
      _mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_number_set'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_number_set::
cPtr_number_set (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_number_set::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@number_set:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_number_set'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_number_set::
GGS_number_set (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_number_set::
GGS_number_set (const GGS_number_set & inOperand) {
  mPointer = (cPtr_number_set *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_number_set::
~GGS_number_set (void) {
  macroDetachPointer (mPointer, cPtr_number_set) ;
}

//---------------------------------------------------------------------------*

void GGS_number_set::
operator = (const GGS_number_set & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_number_set * GGS_number_set::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;  }
#endif

//---------------------------------------------------------------------------*

void GGS_number_set::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_number_set) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_number_set::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @number_set" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'uint_range'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint_range::cPtr_uint_range (const GGS_luint64 & argument_0,
                                const GGS_luint64 & argument_1 COMMA_LOCATION_ARGS)
:cPtr_number_set (THERE),
first (argument_0),
last (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_uint_range::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@uint_range:"
           << first.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << last.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_uint_range'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint_range::
GGS_uint_range (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_uint_range GGS_uint_range::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint64 & argument_0,
                 const GGS_luint64 & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_uint_range * _ptr = (cPtr_uint_range *) NULL ;
  macroMyNew (_ptr, cPtr_uint_range (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_uint_range result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint_range * GGS_uint_range::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint_range *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_uint_range *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_uint_range::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @uint_range" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'uint_list'                              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint_list::cPtr_uint_list (const GGS_number_list & argument_0 COMMA_LOCATION_ARGS)
:cPtr_number_set (THERE),
numbers (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_uint_list::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@uint_list:"
           << numbers.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_uint_list'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint_list::
GGS_uint_list (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_uint_list GGS_uint_list::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_number_list & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_uint_list * _ptr = (cPtr_uint_list *) NULL ;
  macroMyNew (_ptr, cPtr_uint_list (argument_0 COMMA_THERE)) ;
  GGS_uint_list result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint_list * GGS_uint_list::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint_list *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_uint_list *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_uint_list::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @uint_list" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map 'implementationSpec'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_implementationSpec::
elementOf_GGS_implementationSpec (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_implementationSpec & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_implementationSpec::
appendForMapDescription (C_Lexique & _inLexique,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "->" ;
  ioString << mInfo.type.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_implementationSpec::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_implementationSpec *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_implementationSpec * info = (e_implementationSpec *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_implementationSpec GGS_implementationSpec::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_implementationSpec result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_implementationSpec::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_implementationSpec::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_implementationSpec info  ;
    info.type = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_implementationSpec::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.type ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_implementationSpec GGS_implementationSpec::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_implementationSpec & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_implementationSpec result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_implementationSpec GGS_implementationSpec::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_implementationSpec result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_implementationSpec::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @implementationSpec " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      s << "\n" ;
      s.writeSpaces (inIndentation + 1) ;
      p->appendForMapDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << "not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'implementation'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_implementation::
elementOf_GGS_implementation (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_implementation & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_implementation::
appendForMapDescription (C_Lexique & _inLexique,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "->" ;
  ioString << mInfo.spec.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_implementation::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_implementation *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_implementation * info = (e_implementation *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_implementation GGS_implementation::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_implementation result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_implementation::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_implementation::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_implementationSpec &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_implementation info  ;
    info.spec = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_implementation::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_implementationSpec   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.spec ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_implementation::
method_insertSpec (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_implementationSpec & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "%K is duplicated in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_implementation GGS_implementation::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_implementation & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_implementation result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_implementation GGS_implementation::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_implementation result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_implementation::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @implementation " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      s << "\n" ;
      s.writeSpaces (inIndentation + 1) ;
      p->appendForMapDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << "not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            class map 'os_imp'                             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_os_imp::
elementOf_GGS_os_imp (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_os_imp & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_os_imp::
appendForMapDescription (C_Lexique & _inLexique,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "->" ;
  ioString << mInfo.type.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_os_imp::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_os_imp *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_os_imp * info = (e_os_imp *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_os_imp GGS_os_imp::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_os_imp result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_os_imp::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_os_imp::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_os_imp info  ;
    info.type = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_imp::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.type ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_os_imp GGS_os_imp::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_os_imp & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_os_imp result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_os_imp GGS_os_imp::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_os_imp result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_os_imp::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @os_imp " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      s << "\n" ;
      s.writeSpaces (inIndentation + 1) ;
      p->appendForMapDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << "not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

