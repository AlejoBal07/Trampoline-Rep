//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'goil_semantics.cpp'                          *
//                Generated by version 1.3.1 (LL(1) grammar)                 *
//                       june 7th, 2006, at 20h13'22"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "goil_semantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  static const char gGGSsourceFile [] = "goil_semantics.ggs" ;
  #define SOURCE_FILE_AT_LINE(line) , gGGSsourceFile, line
#else
  #define SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                      Element of list '@number_list'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_number_list::
elementOf_GGS_number_list (const GGS_luint & argument_0):
mNextItem (NULL),
number (argument_0) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_number_list::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << number.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           List '@number_list'                             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_number_list::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_number_list::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_number_list::GGS_number_list (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_number_list::~GGS_number_list (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_number_list::
GGS_number_list (const GGS_number_list & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_number_list::
operator = (const GGS_number_list & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_number_list::element_type * GGS_number_list::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_number_list::
internalAppendItem (const GGS_luint & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_number_list::
addAssign_operation (const GGS_luint & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_number_list::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->number) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_number_list  GGS_number_list::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_number_list result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_number_list::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_number_list::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @number_list" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_number_list::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_number_list::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_number_set'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_number_set::
cPtr_number_set (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_number_set'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_number_set::
GGS_number_set (void) {
  mPointer = (cPtr_number_set *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_number_set::
GGS_number_set (const GGS_number_set & inOperand) {
  mPointer = (cPtr_number_set *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_number_set::
~GGS_number_set (void) {
  macroDetachPointer (mPointer, cPtr_number_set) ;
}

//---------------------------------------------------------------------------*

void GGS_number_set::
operator = (const GGS_number_set & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_number_set::
operator = (cPtr_number_set * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_number_set::
GGS_number_set (cPtr_number_set * inSource) {
  mPointer = (cPtr_number_set *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_number_set * GGS_number_set
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_number_set
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_number_set) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_number_set
::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @number_set" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'uint_range'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint_range::cPtr_uint_range (const GGS_luint & argument_0,
                                const GGS_luint & argument_1 COMMA_LOCATION_ARGS)
:cPtr_number_set (THERE),
first (argument_0),
last (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_uint_range::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@uint_range:" ;
first.reader_description  (_inLexique COMMA_THERE) ;
last.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_uint_range'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint_range * GGS_uint_range::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_luint & argument_0,
                                const GGS_luint & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_uint_range * ptr_ = (cPtr_uint_range *) NULL ;
    macroMyNew (ptr_, cPtr_uint_range (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'uint_list'                              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint_list::cPtr_uint_list (const GGS_number_list & argument_0 COMMA_LOCATION_ARGS)
:cPtr_number_set (THERE),
numbers (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_uint_list::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@uint_list:" ;
numbers.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_uint_list'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint_list * GGS_uint_list::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_number_list & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_uint_list * ptr_ = (cPtr_uint_list *) NULL ;
    macroMyNew (ptr_, cPtr_uint_list (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map 'implementationSpec'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_implementationSpec::
elementOf_GGS_implementationSpec (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_implementationSpec & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_implementationSpec::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.type.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_implementationSpec::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_implementationSpec *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_implementationSpec * info = (e_implementationSpec *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_implementationSpec GGS_implementationSpec::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_implementationSpec result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_implementationSpec::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_implementationSpec::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_implementationSpec info  ;
    info.type = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_implementationSpec::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.type ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_implementationSpec GGS_implementationSpec::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_implementationSpec & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_implementationSpec result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_implementationSpec GGS_implementationSpec::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_implementationSpec result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_implementationSpec::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @implementationSpec " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'implementation'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_implementation::
elementOf_GGS_implementation (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_implementation & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_implementation::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.spec.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_implementation::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_implementation *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_implementation * info = (e_implementation *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_implementation GGS_implementation::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_implementation result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_implementation::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_implementation::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_implementationSpec &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_implementation info  ;
    info.spec = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_implementation::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_implementationSpec   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.spec ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_implementation::
method_insertSpec (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_implementationSpec & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "%K is duplicated in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_implementation GGS_implementation::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_implementation & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_implementation result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_implementation GGS_implementation::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_implementation result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_implementation::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @implementation " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            class map 'os_imp'                             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_os_imp::
elementOf_GGS_os_imp (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_os_imp & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_os_imp::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.type.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_os_imp::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_os_imp *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_os_imp * info = (e_os_imp *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_os_imp GGS_os_imp::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_os_imp result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_os_imp::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_os_imp::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_os_imp info  ;
    info.type = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_imp::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.type ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_os_imp GGS_os_imp::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_os_imp & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_os_imp result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_os_imp GGS_os_imp::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_os_imp result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_os_imp::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @os_imp " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

