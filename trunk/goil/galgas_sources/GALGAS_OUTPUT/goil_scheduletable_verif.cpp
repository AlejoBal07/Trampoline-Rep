//---------------------------------------------------------------------------*
//                                                                           *
//                   File 'goil_scheduletable_verif.cpp'                     *
//                        Generated by version 1.8.2                         *
//                      april 27th, 2009, at 22h44'31"                       *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != 463
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "goil_scheduletable_verif.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "goil_scheduletable_verif.ggs", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//         Implementation of routine "schedule_tables_well_formed"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_schedule_tables_well_formed (C_Compiler & _inLexique,
                                GGS_scheduletable_map   var_cas_sts COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_schedule_tables_well_formed at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_scheduletable_map::cEnumerator enumerator_432 (var_cas_sts, true) ;
    const GGS_scheduletable_map::cElement * operand_432 = NULL ;
    while (((operand_432 = enumerator_432.nextObject ()))) {
      macroValidPointer (operand_432) ;
      GGS_uint64  var_cas_len ;
      var_cas_len = GGS_uint64 (true, 0LLU) ;
      { const GGS_basic_type _var_930 = operand_432->mInfo.st.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (20)) ; // CAST instruction
        if (_var_930.getPtr () != NULL) {
          macroValidPointer (_var_930.getPtr ()) ;
          if (typeid (cPtr_uint64_class) == typeid (* (_var_930.getPtr ()))) {
            const GGS_uint64_class var_cas_ui (_var_930.getPtr ()) ;
            var_cas_len = var_cas_ui.reader_value (_inLexique COMMA_SOURCE_FILE_AT_LINE (21)) ;
          }else{
            GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, (GGS_string (true, "Internal error, incorrect datatype for LENGTH attribute of Schedule Table "))._operator_concat (operand_432->mKey.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (22))) COMMA_SOURCE_FILE_AT_LINE (23)) ;
          }
        }
      }
      if (((var_cas_len)._operator_isEqual (GGS_uint64 (true, 0LLU))).isBuiltAndTrue ()) {
        operand_432->mInfo.st.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (27)).reader_location (_inLexique COMMA_SOURCE_FILE_AT_LINE (27)).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "The LENGTH attribute should not be 0") COMMA_SOURCE_FILE_AT_LINE (28)) ;
      }
      GGS_action_list  var_cas_actions ;
      var_cas_actions = operand_432->mInfo.st.reader_actions (_inLexique COMMA_SOURCE_FILE_AT_LINE (30)) ;
      {
        GGS_action_list::cEnumerator enumerator_1248 (var_cas_actions, true) ;
        const GGS_action_list::cElement * operand_1248 = NULL ;
        while (((operand_1248 = enumerator_1248.nextObject ()))) {
          macroValidPointer (operand_1248) ;
          if (((operand_1248->offset)._operator_strictSup (var_cas_len)).isBuiltAndTrue ()) {
            operand_1248->act.reader_location (_inLexique COMMA_SOURCE_FILE_AT_LINE (35)).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, (GGS_string (true, "Offset of action is greater than the LENGTH attribute of Schedule Table "))._operator_concat (operand_432->mKey.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (35))) COMMA_SOURCE_FILE_AT_LINE (36)) ;
          }
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_schedule_tables_well_formed\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//Implementation of routine "schedule_tables_counters_exist_and_compatible"  *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_schedule_tables_counters_exist_and_compatible (C_Compiler & _inLexique,
                                GGS_scheduletable_map   var_cas_sts,
                                GGS_counter_map   var_cas_cnts COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_schedule_tables_counters_exist_and_compatible at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_scheduletable_map::cEnumerator enumerator_1891 (var_cas_sts, true) ;
    const GGS_scheduletable_map::cElement * operand_1891 = NULL ;
    while (((operand_1891 = enumerator_1891.nextObject ()))) {
      macroValidPointer (operand_1891) ;
      GGS_lstring  var_cas_cnt ;
      var_cas_cnt = operand_1891->mInfo.st.reader_counter (_inLexique COMMA_SOURCE_FILE_AT_LINE (49)) ;
      if ((((var_cas_cnts.reader_hasKey (_inLexique, var_cas_cnt.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (51)) COMMA_SOURCE_FILE_AT_LINE (51)))._operator_not ())._operator_and ((var_cas_cnt.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (51)))._operator_isNotEqual (GGS_string (true, "SystemCounter")))).isBuiltAndTrue ()) {
        var_cas_cnt.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((GGS_string (true, "counter "))._operator_concat (var_cas_cnt.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (52))))._operator_concat (GGS_string (true, " is not defined !")) COMMA_SOURCE_FILE_AT_LINE (53)) ;
      }else{
        GGS_uint64  var_cas_len ;
        var_cas_len = GGS_uint64 (true, 0LLU) ;
        GGS_location  var_cas_loc ;
        var_cas_loc = GGS_location (_inLexique) ;
        { const GGS_basic_type _var_2411 = operand_1891->mInfo.st.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (56)) ; // CAST instruction
          if (_var_2411.getPtr () != NULL) {
            macroValidPointer (_var_2411.getPtr ()) ;
            if (typeid (cPtr_uint64_class) == typeid (* (_var_2411.getPtr ()))) {
              const GGS_uint64_class var_cas_ui (_var_2411.getPtr ()) ;
              var_cas_len = var_cas_ui.reader_value (_inLexique COMMA_SOURCE_FILE_AT_LINE (57)) ;
              var_cas_loc = var_cas_ui.reader_location (_inLexique COMMA_SOURCE_FILE_AT_LINE (57)) ;
            }else{
              GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, (GGS_string (true, "Internal error, incorrect datatype for LENGTH attribute of schedule table "))._operator_concat (operand_1891->mKey.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (58))) COMMA_SOURCE_FILE_AT_LINE (59)) ;
            }
          }
        }
        if (((var_cas_cnt.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (61)))._operator_isEqual (GGS_string (true, "SystemCounter"))).isBuiltAndTrue ()) {
          if (((var_cas_len)._operator_strictSup (GGS_uint64 (true, 32767LLU))).isBuiltAndTrue ()) {
            var_cas_loc.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, (((GGS_string (true, "LENGTH of schedule table "))._operator_concat (operand_1891->mKey.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (63))))._operator_concat (GGS_string (true, " is greater than MAXALLOWEDVALUE of counter ")))._operator_concat (var_cas_cnt.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (63))) COMMA_SOURCE_FILE_AT_LINE (64)) ;
          }
        }else{
          GGS_counter_obj  var_cas_cpt ;
          const GGS_counter_map  _temp_2809 = var_cas_cnts ;
          if (_temp_2809._isBuilt ()) {
            _temp_2809 (HERE)->method_get (_inLexique, var_cas_cnt, var_cas_cpt COMMA_SOURCE_FILE_AT_LINE (69)) ;
          }
          GGS_uint64  var_cas_max ;
          var_cas_max = GGS_uint64 (true, 0LLU) ;
          { const GGS_basic_type _var_3087 = var_cas_cpt.reader_max_allowed_value (_inLexique COMMA_SOURCE_FILE_AT_LINE (72)) ; // CAST instruction
            if (_var_3087.getPtr () != NULL) {
              macroValidPointer (_var_3087.getPtr ()) ;
              if (typeid (cPtr_uint32_class) == typeid (* (_var_3087.getPtr ()))) {
                const GGS_uint32_class var_cas_ui (_var_3087.getPtr ()) ;
                var_cas_max = var_cas_ui.reader_value (_inLexique COMMA_SOURCE_FILE_AT_LINE (73)).reader_uint64 (_inLexique COMMA_SOURCE_FILE_AT_LINE (73)) ;
              }else{
                GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, (GGS_string (true, "Internal error, incorrect datatype for MAXALLOWEDVALUE attribute of counter "))._operator_concat (var_cas_cnt.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (74))) COMMA_SOURCE_FILE_AT_LINE (75)) ;
              }
            }
          }
          if (((var_cas_len)._operator_strictSup (var_cas_max)).isBuiltAndTrue ()) {
            var_cas_loc.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, (((GGS_string (true, "LENGTH of schedule table "))._operator_concat (operand_1891->mKey.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (78))))._operator_concat (GGS_string (true, " is greater than MAXALLOWEDVALUE of counter ")))._operator_concat (var_cas_cnt.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (78))) COMMA_SOURCE_FILE_AT_LINE (79)) ;
          }
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_schedule_tables_counters_exist_and_compatible\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Implementation of routine "schedule_tables_tasks_and_events_exist"     *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_schedule_tables_tasks_and_events_exist (C_Compiler & _inLexique,
                                GGS_scheduletable_map   var_cas_sts,
                                GGS_task_map   var_cas_tasks,
                                GGS_event_map   var_cas_events COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_schedule_tables_tasks_and_events_exist at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_scheduletable_map::cEnumerator enumerator_3479 (var_cas_sts, true) ;
    const GGS_scheduletable_map::cElement * operand_3479 = NULL ;
    while (((operand_3479 = enumerator_3479.nextObject ()))) {
      macroValidPointer (operand_3479) ;
      {
        GGS_action_list::cEnumerator enumerator_3540 (operand_3479->mInfo.st.reader_actions (_inLexique COMMA_SOURCE_FILE_AT_LINE (91)), true) ;
        const GGS_action_list::cElement * operand_3540 = NULL ;
        while (((operand_3540 = enumerator_3540.nextObject ()))) {
          macroValidPointer (operand_3540) ;
          { const GGS_action_obj _var_4444 = operand_3540->act ; // CAST instruction
            if (_var_4444.getPtr () != NULL) {
              macroValidPointer (_var_4444.getPtr ()) ;
              if (typeid (cPtr_activatetask_action) == typeid (* (_var_4444.getPtr ()))) {
                const GGS_activatetask_action var_cas_ata (_var_4444.getPtr ()) ;
                if (((var_cas_tasks.reader_hasKey (_inLexique, var_cas_ata.reader_task_name (_inLexique COMMA_SOURCE_FILE_AT_LINE (94)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (94)) COMMA_SOURCE_FILE_AT_LINE (94)))._operator_not ()).isBuiltAndTrue ()) {
                  operand_3540->act.reader_location (_inLexique COMMA_SOURCE_FILE_AT_LINE (95)).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "TASK attribute of action does not reference an existing task") COMMA_SOURCE_FILE_AT_LINE (96)) ;
                }
              }else if (typeid (cPtr_setevent_action) == typeid (* (_var_4444.getPtr ()))) {
                const GGS_setevent_action var_cas_sea (_var_4444.getPtr ()) ;
                if (((var_cas_tasks.reader_hasKey (_inLexique, var_cas_sea.reader_task_name (_inLexique COMMA_SOURCE_FILE_AT_LINE (98)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (98)) COMMA_SOURCE_FILE_AT_LINE (98)))._operator_not ()).isBuiltAndTrue ()) {
                  operand_3540->act.reader_location (_inLexique COMMA_SOURCE_FILE_AT_LINE (99)).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "TASK attribute of action does not reference an existing task") COMMA_SOURCE_FILE_AT_LINE (100)) ;
                }
                if (((var_cas_events.reader_hasKey (_inLexique, var_cas_sea.reader_event_name (_inLexique COMMA_SOURCE_FILE_AT_LINE (101)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (101)) COMMA_SOURCE_FILE_AT_LINE (101)))._operator_not ()).isBuiltAndTrue ()) {
                  operand_3540->act.reader_location (_inLexique COMMA_SOURCE_FILE_AT_LINE (102)).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "EVENT attribute of action does not reference an existing event") COMMA_SOURCE_FILE_AT_LINE (103)) ;
                }
              }else{
                operand_3479->mKey.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, (((GGS_string (true, "Internal error, incorrect datatype for ACTION attribute at offset "))._operator_concat (operand_3540->offset.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (104))))._operator_concat (GGS_string (true, " of schedule table ")))._operator_concat (operand_3479->mKey.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (104))) COMMA_SOURCE_FILE_AT_LINE (105)) ;
              }
            }
          }
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_schedule_tables_tasks_and_events_exist\n") ;
  #endif
}

//---------------------------------------------------------------------------*

