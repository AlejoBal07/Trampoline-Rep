//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'scheduletable_verif.cpp'                       *
//                        Generated by version 1.8.5                         *
//                       july 2nd, 2009, at 8h17'56"                         *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != 515
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "scheduletable_verif.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "scheduletable_verif.ggs", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//         Implementation of routine "schedule_tables_well_formed"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_schedule_tables_well_formed (C_Compiler & inLexique,
                                const GGS_scheduletable_map   var_cas_sts,
                                const GGS_root_obj   var_cas_cpu COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_schedule_tables_well_formed at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_scheduletable_map::cEnumerator enumerator_502 (var_cas_sts, true) ;
    const GGS_scheduletable_map::cElement * operand_502 = NULL ;
    while (((operand_502 = enumerator_502.nextObject ()))) {
      macroValidPointer (operand_502) ;
      GGS_bool var_cas_perio ;
      var_cas_perio = function_get_bool (inLexique, operand_502->mInfo.st.reader_periodic (inLexique COMMA_SOURCE_FILE_AT_LINE (18)), GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (18)) ;
      if (((var_cas_perio).operator_isEqual (GGS_bool (false))).isBuiltAndTrue ()) {
        { const GGS_ltgt_sync_obj _var_877 = operand_502->mInfo.st.reader_ltgt_sync (inLexique COMMA_SOURCE_FILE_AT_LINE (21)) ; // CAST instruction
          if (_var_877.getPtr () != NULL) {
            macroValidPointer (_var_877.getPtr ()) ;
            if (typeid (cPtr_ltgt_sync_true) == typeid (* (_var_877.getPtr ()))) {
              operand_502->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (GGS_string ("An implicit schedule table shall be repeating otherwise, synchronisation can't be done. See ")).operator_concat (operand_502->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (23))) COMMA_SOURCE_FILE_AT_LINE (24)) ;
            }else{
            }
          }
        }
      }
      GGS_uint64  var_cas_len ;
      var_cas_len = function_uint64_or_error (inLexique, operand_502->mInfo.st.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (27)), GGS_string ("LENGTH") COMMA_SOURCE_FILE_AT_LINE (27)) ;
      if (((var_cas_len).operator_isEqual (GGS_uint64 (0U))).isBuiltAndTrue ()) {
        operand_502->mInfo.st.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (31)).reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (31)).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("The LENGTH attribute should not be 0") COMMA_SOURCE_FILE_AT_LINE (32)) ;
      }
      GGS_expiry_point_list  var_cas_eps ;
      var_cas_eps = operand_502->mInfo.st.reader_exp_points (inLexique COMMA_SOURCE_FILE_AT_LINE (34)) ;
      if (((var_cas_eps.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (37))).operator_isEqual (GGS_uint (0U))).isBuiltAndTrue ()) {
        operand_502->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (GGS_string ("OS401 - no EXPIRY_POINT found for SCHEDULETABLE ")).operator_concat (operand_502->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (38))) COMMA_SOURCE_FILE_AT_LINE (39)) ;
      }
      {
        GGS_expiry_point_list::cEnumerator enumerator_1497 (var_cas_eps, true) ;
        const GGS_expiry_point_list::cElement * operand_1497 = NULL ;
        while (((operand_1497 = enumerator_1497.nextObject ()))) {
          macroValidPointer (operand_1497) ;
          if (((operand_1497->point.reader_actions (inLexique COMMA_SOURCE_FILE_AT_LINE (43)).reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (43))).operator_isEqual (GGS_uint (0U))).isBuiltAndTrue ()) {
            operand_1497->point.reader_name (inLexique COMMA_SOURCE_FILE_AT_LINE (44)).reader_location (inLexique COMMA_HERE).signalGGSSemanticWarning (inLexique, (GGS_string ("OS407 - no ACTION found for EXPIRY_POINT ")).operator_concat (operand_1497->point.reader_name (inLexique COMMA_SOURCE_FILE_AT_LINE (44)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (44))) COMMA_SOURCE_FILE_AT_LINE (44)) ;
          }
        }
      }
      GGS_uint64  var_cas_cur_offset ;
      var_cas_cur_offset = GGS_uint64 (0U) ;
      GGS_uint64  var_cas_previous_offset ;
      var_cas_previous_offset = GGS_uint64 (0U) ;
      GGS_uint64  var_cas_diff_offset ;
      var_cas_diff_offset = GGS_uint64 (0U) ;
      GGS_bool var_cas_first_time ;
      var_cas_first_time = GGS_bool (true) ;
      GGS_counter_map  var_cas_counters ;
      var_cas_counters = var_cas_cpu.reader_counters (inLexique COMMA_SOURCE_FILE_AT_LINE (58)) ;
      if ((var_cas_counters.reader_hasKey (inLexique, operand_502->mInfo.st.reader_counter (inLexique COMMA_SOURCE_FILE_AT_LINE (59)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (59)) COMMA_SOURCE_FILE_AT_LINE (59))).isBuiltAndTrue ()) {
        GGS_counter_obj  var_cas_cnt ;
        const GGS_counter_map  temp_2215 = var_cas_counters ;
        if (temp_2215.isBuilt ()) {
          temp_2215 (HERE)->method_getCounter (inLexique, operand_502->mInfo.st.reader_counter (inLexique COMMA_SOURCE_FILE_AT_LINE (61)), var_cas_cnt COMMA_SOURCE_FILE_AT_LINE (61)) ;
        }
        GGS_uint64  var_cas_mav ;
        var_cas_mav = function_uint32_or_error (inLexique, var_cas_cnt.reader_max_allowed_value (inLexique COMMA_SOURCE_FILE_AT_LINE (62)), GGS_string ("MAXALLOWEDVALUE") COMMA_SOURCE_FILE_AT_LINE (62)).reader_uint64 (inLexique COMMA_SOURCE_FILE_AT_LINE (62)) ;
        GGS_uint64  var_cas_mc ;
        var_cas_mc = function_uint32_or_error (inLexique, var_cas_cnt.reader_min_cycle (inLexique COMMA_SOURCE_FILE_AT_LINE (63)), GGS_string ("MINCYCLE") COMMA_SOURCE_FILE_AT_LINE (63)).reader_uint64 (inLexique COMMA_SOURCE_FILE_AT_LINE (63)) ;
        GGS_bool var_cas_first_ep ;
        var_cas_first_ep = GGS_bool (true) ;
        GGS_uint64  var_cas_previous_offset ;
        var_cas_previous_offset = GGS_uint64 (0U) ;
        {
          GGS_expiry_point_list::cEnumerator enumerator_2493 (var_cas_eps, true) ;
          const GGS_expiry_point_list::cElement * operand_2493 = NULL ;
          while (((operand_2493 = enumerator_2493.nextObject ()))) {
            macroValidPointer (operand_2493) ;
            GGS_uint64  var_cas_offset ;
            var_cas_offset = function_uint64_or_error (inLexique, operand_2493->point.reader_offset (inLexique COMMA_SOURCE_FILE_AT_LINE (70)), GGS_string ("OFFSET") COMMA_SOURCE_FILE_AT_LINE (70)) ;
            GGS_location  var_cas_off_loc ;
            var_cas_off_loc = operand_2493->point.reader_offset (inLexique COMMA_SOURCE_FILE_AT_LINE (71)).reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (71)) ;
            if ((var_cas_perio).isBuiltAndTrue ()) {
              if (((var_cas_offset).operator_supOrEqual (var_cas_len)).isBuiltAndTrue ()) {
                var_cas_off_loc.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (GGS_string ("OFFSET of expiry point is greater or equal to the LENGTH of the Schedule Table ")).operator_concat (operand_502->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (74))) COMMA_SOURCE_FILE_AT_LINE (75)) ;
              }
            }else{
              if (((var_cas_offset).operator_strictSup (var_cas_len)).isBuiltAndTrue ()) {
                var_cas_off_loc.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (GGS_string ("OFFSET of expiry point is greater than the LENGTH of the Schedule Table ")).operator_concat (operand_502->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (78))) COMMA_SOURCE_FILE_AT_LINE (79)) ;
              }
            }
            if (((var_cas_offset.substract_operation (inLexique, var_cas_previous_offset COMMA_SOURCE_FILE_AT_LINE (84))).operator_strictInf (var_cas_mc)).isBuiltAndTrue ()) {
              if ((var_cas_first_ep).isBuiltAndTrue ()) {
                if (((var_cas_offset).operator_isNotEqual (GGS_uint64 (0U))).isBuiltAndTrue ()) {
                  var_cas_off_loc.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("OFFSET of first expiry point is lower than MINCYCLE and not equal to 0") COMMA_SOURCE_FILE_AT_LINE (88)) ;
                }
              }else{
                var_cas_off_loc.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("Delay is lower than MINCYCLE") COMMA_SOURCE_FILE_AT_LINE (91)) ;
              }
            }
            if (((var_cas_offset).operator_strictSup (var_cas_mav)).isBuiltAndTrue ()) {
              var_cas_off_loc.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("Delay is greater than MAXALLOWEDVALUE") COMMA_SOURCE_FILE_AT_LINE (95)) ;
            }
            var_cas_first_ep = GGS_bool (false) ;
            var_cas_previous_offset = var_cas_offset ;
          }
        }
        GGS_uint64  var_cas_final_delay ;
        var_cas_final_delay = var_cas_len.substract_operation (inLexique, var_cas_previous_offset COMMA_SOURCE_FILE_AT_LINE (100)) ;
        if ((var_cas_perio).isBuiltAndTrue ()) {
          if (((var_cas_final_delay).operator_isEqual (GGS_uint64 (0U))).isBuiltAndTrue ()) {
            operand_502->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("OS427 - Final delay can be equal to LENGTH only for single-shot schedule table and ")).operator_concat (operand_502->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (106)))).operator_concat (GGS_string (" is a repeating one")) COMMA_SOURCE_FILE_AT_LINE (107)) ;
          }else if ((((var_cas_final_delay).operator_strictInf (var_cas_mc)).operator_and ((var_cas_final_delay).operator_strictSup (var_cas_mav))).isBuiltAndTrue ()) {
            operand_502->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("OS444 - Final delay should be within MINCYCLE and MAXALLOWEDVALUE of the driving counter") COMMA_SOURCE_FILE_AT_LINE (109)) ;
          }
        }else if ((((var_cas_final_delay).operator_strictInf (var_cas_mc)).operator_and ((var_cas_final_delay).operator_strictSup (var_cas_mav))).isBuiltAndTrue ()) {
          operand_502->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("OS444 - Final delay should be within MINCYCLE and MAXALLOWEDVALUE of the driving counter") COMMA_SOURCE_FILE_AT_LINE (112)) ;
        }
        { const GGS_ltgt_sync_obj _var_5524 = operand_502->mInfo.st.reader_ltgt_sync (inLexique COMMA_SOURCE_FILE_AT_LINE (116)) ; // CAST instruction
          if (_var_5524.getPtr () != NULL) {
            macroValidPointer (_var_5524.getPtr ()) ;
            if (typeid (cPtr_ltgt_sync_true) == typeid (* (_var_5524.getPtr ()))) {
              const GGS_ltgt_sync_true var_cas_sst (_var_5524.getPtr ()) ;
              if (((var_cas_sst.reader_strategy (inLexique COMMA_SOURCE_FILE_AT_LINE (118)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (118))).operator_isEqual (GGS_string ("IMPLICIT"))).isBuiltAndTrue ()) {
                { const GGS_autostart_obj _var_5288 = operand_502->mInfo.st.reader_autostart (inLexique COMMA_SOURCE_FILE_AT_LINE (119)) ; // CAST instruction
                  if (_var_5288.getPtr () != NULL) {
                    macroValidPointer (_var_5288.getPtr ()) ;
                    if (typeid (cPtr_sd_autostart_relative) == typeid (* (_var_5288.getPtr ()))) {
                      operand_502->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("OS430 - ")).operator_concat (operand_502->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (121)))).operator_concat (GGS_string (" should be started in Absolute mode only")) COMMA_SOURCE_FILE_AT_LINE (122)) ;
                    }else if (typeid (cPtr_sd_autostart_synchron) == typeid (* (_var_5288.getPtr ()))) {
                      operand_502->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("OS430 - ")).operator_concat (operand_502->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (123)))).operator_concat (GGS_string (" should be started in Absolute mode only")) COMMA_SOURCE_FILE_AT_LINE (124)) ;
                    }else{
                    }
                  }
                }
                if (((var_cas_len).operator_isNotEqual (var_cas_mav.add_operation (inLexique, GGS_uint64 (1U) COMMA_SOURCE_FILE_AT_LINE (126)))).isBuiltAndTrue ()) {
                  operand_502->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("OS429 - LENGTH of ")).operator_concat (operand_502->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (127)))).operator_concat (GGS_string (" should be equal to OSMAXALLOWEDVALUE + 1 ("))).operator_concat (var_cas_mav.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (127)))).operator_concat (GGS_string (")")) COMMA_SOURCE_FILE_AT_LINE (128)) ;
                }
              }
            }else{
            }
          }
        }
        { const GGS_autostart_obj _var_6375 = operand_502->mInfo.st.reader_autostart (inLexique COMMA_SOURCE_FILE_AT_LINE (134)) ; // CAST instruction
          if (_var_6375.getPtr () != NULL) {
            macroValidPointer (_var_6375.getPtr ()) ;
            if (typeid (cPtr_sd_autostart_relative) == typeid (* (_var_6375.getPtr ()))) {
              const GGS_sd_autostart_relative var_cas_relative_data (_var_6375.getPtr ()) ;
              if (((((var_cas_relative_data.reader_offset (inLexique COMMA_SOURCE_FILE_AT_LINE (136)).reader_uint64 (inLexique COMMA_SOURCE_FILE_AT_LINE (136))).operator_isEqual (GGS_uint64 (0U))).operator_or ((var_cas_relative_data.reader_offset (inLexique COMMA_SOURCE_FILE_AT_LINE (136)).reader_uint64 (inLexique COMMA_SOURCE_FILE_AT_LINE (136))).operator_strictSup (var_cas_mav))).operator_or ((var_cas_relative_data.reader_offset (inLexique COMMA_SOURCE_FILE_AT_LINE (136)).reader_uint64 (inLexique COMMA_SOURCE_FILE_AT_LINE (136))).operator_strictInf (var_cas_mc))).isBuiltAndTrue ()) {
                operand_502->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (((((operand_502->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (137))).operator_concat (GGS_string (" autostart's offset out of range ["))).operator_concat (var_cas_mc.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (137)))).operator_concat (GGS_string (" "))).operator_concat (var_cas_mav.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (137)))).operator_concat (GGS_string ("] and not 0")) COMMA_SOURCE_FILE_AT_LINE (138)) ;
              }
            }else if (typeid (cPtr_sd_autostart_absolute) == typeid (* (_var_6375.getPtr ()))) {
              const GGS_sd_autostart_absolute var_cas_absolute_data (_var_6375.getPtr ()) ;
              if ((((var_cas_absolute_data.reader_value (inLexique COMMA_SOURCE_FILE_AT_LINE (140)).reader_uint64 (inLexique COMMA_SOURCE_FILE_AT_LINE (140))).operator_strictSup (var_cas_mav)).operator_or ((var_cas_absolute_data.reader_value (inLexique COMMA_SOURCE_FILE_AT_LINE (140)).reader_uint64 (inLexique COMMA_SOURCE_FILE_AT_LINE (140))).operator_strictInf (var_cas_mc))).isBuiltAndTrue ()) {
                operand_502->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (((((operand_502->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (141))).operator_concat (GGS_string (" autostart's offset out of range ["))).operator_concat (var_cas_mc.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (141)))).operator_concat (GGS_string (" "))).operator_concat (var_cas_mav.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (141)))).operator_concat (GGS_string ("]")) COMMA_SOURCE_FILE_AT_LINE (142)) ;
              }
            }else{
            }
          }
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_schedule_tables_well_formed\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//Implementation of routine "schedule_tables_counters_exist_and_compatible"  *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_schedule_tables_counters_exist_and_compatible (C_Compiler & inLexique,
                                const GGS_scheduletable_map   var_cas_sts,
                                const GGS_counter_map   var_cas_cnts COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_schedule_tables_counters_exist_and_compatible at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_scheduletable_map::cEnumerator enumerator_6552 (var_cas_sts, true) ;
    const GGS_scheduletable_map::cElement * operand_6552 = NULL ;
    while (((operand_6552 = enumerator_6552.nextObject ()))) {
      macroValidPointer (operand_6552) ;
      GGS_lstring  var_cas_cnt ;
      var_cas_cnt = operand_6552->mInfo.st.reader_counter (inLexique COMMA_SOURCE_FILE_AT_LINE (154)) ;
      if ((((var_cas_cnts.reader_hasKey (inLexique, var_cas_cnt.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (156)) COMMA_SOURCE_FILE_AT_LINE (156))).operator_not ()).operator_and ((var_cas_cnt.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (156))).operator_isNotEqual (GGS_string ("SystemCounter")))).isBuiltAndTrue ()) {
        var_cas_cnt.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("counter ")).operator_concat (var_cas_cnt.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (157)))).operator_concat (GGS_string (" is not defined !")) COMMA_SOURCE_FILE_AT_LINE (158)) ;
      }else{
        GGS_uint64  var_cas_len ;
        var_cas_len = GGS_uint64 (0U) ;
        GGS_location  var_cas_loc ;
        var_cas_loc = GGS_location (inLexique) ;
        { const GGS_basic_type _var_7058 = operand_6552->mInfo.st.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (161)) ; // CAST instruction
          if (_var_7058.getPtr () != NULL) {
            macroValidPointer (_var_7058.getPtr ()) ;
            if (typeid (cPtr_uint64_class) == typeid (* (_var_7058.getPtr ()))) {
              const GGS_uint64_class var_cas_ui (_var_7058.getPtr ()) ;
              var_cas_len = var_cas_ui.reader_value (inLexique COMMA_SOURCE_FILE_AT_LINE (162)) ;
              var_cas_loc = var_cas_ui.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (162)) ;
            }else{
              GGS_location (inLexique).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (GGS_string ("Internal error, incorrect datatype for LENGTH attribute of schedule table ")).operator_concat (operand_6552->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (163))) COMMA_SOURCE_FILE_AT_LINE (164)) ;
            }
          }
        }
        GGS_counter_obj  var_cas_cpt ;
        const GGS_counter_map  temp_7223 = var_cas_cnts ;
        if (temp_7223.isBuilt ()) {
          temp_7223 (HERE)->method_getCounter (inLexique, var_cas_cnt, var_cas_cpt COMMA_SOURCE_FILE_AT_LINE (169)) ;
        }
        GGS_uint64  var_cas_max ;
        var_cas_max = GGS_uint64 (0U) ;
        { const GGS_basic_type _var_7507 = var_cas_cpt.reader_max_allowed_value (inLexique COMMA_SOURCE_FILE_AT_LINE (172)) ; // CAST instruction
          if (_var_7507.getPtr () != NULL) {
            macroValidPointer (_var_7507.getPtr ()) ;
            if (typeid (cPtr_uint32_class) == typeid (* (_var_7507.getPtr ()))) {
              const GGS_uint32_class var_cas_ui (_var_7507.getPtr ()) ;
              var_cas_max = var_cas_ui.reader_value (inLexique COMMA_SOURCE_FILE_AT_LINE (174)).reader_uint64 (inLexique COMMA_SOURCE_FILE_AT_LINE (174)) ;
            }else{
              GGS_location (inLexique).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (GGS_string ("Internal error, incorrect datatype for MAXALLOWEDVALUE attribute of counter ")).operator_concat (var_cas_cnt.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (176))) COMMA_SOURCE_FILE_AT_LINE (177)) ;
            }
          }
        }
        if (((var_cas_len).operator_strictSup (var_cas_max.add_operation (inLexique, GGS_uint64 (1U) COMMA_SOURCE_FILE_AT_LINE (179)))).isBuiltAndTrue ()) {
          var_cas_loc.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (((GGS_string ("LENGTH of schedule table ")).operator_concat (operand_6552->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (180)))).operator_concat (GGS_string (" is greater than MAXALLOWEDVALUE of counter "))).operator_concat (var_cas_cnt.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (180))) COMMA_SOURCE_FILE_AT_LINE (181)) ;
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_schedule_tables_counters_exist_and_compatible\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Implementation of routine "schedule_tables_tasks_and_events_exist"     *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_schedule_tables_tasks_and_events_exist (C_Compiler & inLexique,
                                const GGS_root_obj   var_cas_cpu COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_schedule_tables_tasks_and_events_exist at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_scheduletable_map::cEnumerator enumerator_7891 (var_cas_cpu.reader_scheduletables (inLexique COMMA_SOURCE_FILE_AT_LINE (193)), true) ;
    const GGS_scheduletable_map::cElement * operand_7891 = NULL ;
    while (((operand_7891 = enumerator_7891.nextObject ()))) {
      macroValidPointer (operand_7891) ;
      {
        GGS_expiry_point_list::cEnumerator enumerator_7967 (operand_7891->mInfo.st.reader_exp_points (inLexique COMMA_SOURCE_FILE_AT_LINE (194)), true) ;
        const GGS_expiry_point_list::cElement * operand_7967 = NULL ;
        while (((operand_7967 = enumerator_7967.nextObject ()))) {
          macroValidPointer (operand_7967) ;
          GGS_lstring  var_cas_ep_name ;
          var_cas_ep_name = operand_7967->point.reader_name (inLexique COMMA_SOURCE_FILE_AT_LINE (195)) ;
          {
            GGS_action_list::cEnumerator enumerator_8040 (operand_7967->point.reader_actions (inLexique COMMA_SOURCE_FILE_AT_LINE (196)), true) ;
            const GGS_action_list::cElement * operand_8040 = NULL ;
            while (((operand_8040 = enumerator_8040.nextObject ()))) {
              macroValidPointer (operand_8040) ;
              { const GGS_action_obj _var_8873 = operand_8040->action ; // CAST instruction
                if (_var_8873.getPtr () != NULL) {
                  macroValidPointer (_var_8873.getPtr ()) ;
                  if (typeid (cPtr_activatetask_action) == typeid (* (_var_8873.getPtr ()))) {
                    const GGS_activatetask_action var_cas_ata (_var_8873.getPtr ()) ;
                    if (((var_cas_cpu.reader_tasks (inLexique COMMA_SOURCE_FILE_AT_LINE (199)).reader_hasKey (inLexique, var_cas_ata.reader_task_name (inLexique COMMA_SOURCE_FILE_AT_LINE (199)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (199)) COMMA_SOURCE_FILE_AT_LINE (199))).operator_not ()).isBuiltAndTrue ()) {
                      operand_8040->action.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (200)).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("TASK attribute of action does not reference an existing task") COMMA_SOURCE_FILE_AT_LINE (201)) ;
                    }
                  }else if (typeid (cPtr_setevent_action) == typeid (* (_var_8873.getPtr ()))) {
                    const GGS_setevent_action var_cas_sea (_var_8873.getPtr ()) ;
                    if (((var_cas_cpu.reader_tasks (inLexique COMMA_SOURCE_FILE_AT_LINE (203)).reader_hasKey (inLexique, var_cas_sea.reader_task_name (inLexique COMMA_SOURCE_FILE_AT_LINE (203)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (203)) COMMA_SOURCE_FILE_AT_LINE (203))).operator_not ()).isBuiltAndTrue ()) {
                      operand_8040->action.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (204)).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("TASK attribute of action does not reference an existing task") COMMA_SOURCE_FILE_AT_LINE (205)) ;
                    }
                    if (((var_cas_cpu.reader_events (inLexique COMMA_SOURCE_FILE_AT_LINE (206)).reader_hasKey (inLexique, var_cas_sea.reader_event_name (inLexique COMMA_SOURCE_FILE_AT_LINE (206)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (206)) COMMA_SOURCE_FILE_AT_LINE (206))).operator_not ()).isBuiltAndTrue ()) {
                      operand_8040->action.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (207)).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("EVENT attribute of action does not reference an existing event") COMMA_SOURCE_FILE_AT_LINE (208)) ;
                    }
                  }else{
                    var_cas_ep_name.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (GGS_string ("Internal error, incorrect datatype for ACTION attribute of expiry point ")).operator_concat (var_cas_ep_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (210))) COMMA_SOURCE_FILE_AT_LINE (211)) ;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_schedule_tables_tasks_and_events_exist\n") ;
  #endif
}

//---------------------------------------------------------------------------*

