//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'scheduletable_verif.cpp'                       *
//                    Generated by version 1.8.3 [debug]                     *
//                      june 10th, 2009, at 16h55'34"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != 491
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "scheduletable_verif.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "scheduletable_verif.ggs", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//         Implementation of routine "schedule_tables_well_formed"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_schedule_tables_well_formed (C_Compiler & _inLexique,
                                const GGS_scheduletable_map   var_cas_sts,
                                const GGS_root_obj   var_cas_cpu COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_schedule_tables_well_formed at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_scheduletable_map::cEnumerator enumerator_502 (var_cas_sts, true) ;
    const GGS_scheduletable_map::cElement * operand_502 = NULL ;
    while (((operand_502 = enumerator_502.nextObject ()))) {
      macroValidPointer (operand_502) ;
      GGS_string var_cas_perio ;
      var_cas_perio = GGS_string ("") ;
      { const GGS_basic_type _var_916 = operand_502->mInfo.st.reader_periodic (_inLexique COMMA_SOURCE_FILE_AT_LINE (19)) ; // CAST instruction
        if (_var_916.getPtr () != NULL) {
          macroValidPointer (_var_916.getPtr ()) ;
          if (typeid (cPtr_bool_class) == typeid (* (_var_916.getPtr ()))) {
            const GGS_bool_class var_cas_b (_var_916.getPtr ()) ;
            if (((var_cas_b.reader_value (_inLexique COMMA_SOURCE_FILE_AT_LINE (21)))._operator_isEqual (GGS_bool (true))).isBuiltAndTrue ()) {
              var_cas_perio = GGS_string ("TRUE") ;
            }else{
              var_cas_perio = GGS_string ("FALSE") ;
            }
          }else{
            operand_502->mKey.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, (GGS_string ("Internal error, unexpected type for PERIODIC attribute of schedule table "))._operator_concat (operand_502->mKey.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (26))) COMMA_SOURCE_FILE_AT_LINE (27)) ;
          }
        }
      }
      GGS_uint64  var_cas_len ;
      var_cas_len = GGS_uint64 (0U) ;
      { const GGS_basic_type _var_1186 = operand_502->mInfo.st.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (31)) ; // CAST instruction
        if (_var_1186.getPtr () != NULL) {
          macroValidPointer (_var_1186.getPtr ()) ;
          if (typeid (cPtr_uint64_class) == typeid (* (_var_1186.getPtr ()))) {
            const GGS_uint64_class var_cas_ui (_var_1186.getPtr ()) ;
            var_cas_len = var_cas_ui.reader_value (_inLexique COMMA_SOURCE_FILE_AT_LINE (33)) ;
          }else{
            GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, (GGS_string ("Internal error, incorrect datatype for LENGTH attribute of Schedule Table "))._operator_concat (operand_502->mKey.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (35))) COMMA_SOURCE_FILE_AT_LINE (36)) ;
          }
        }
      }
      if (((var_cas_len)._operator_isEqual (GGS_uint64 (0U))).isBuiltAndTrue ()) {
        operand_502->mInfo.st.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (40)).reader_location (_inLexique COMMA_SOURCE_FILE_AT_LINE (40)).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string ("The LENGTH attribute should not be 0") COMMA_SOURCE_FILE_AT_LINE (41)) ;
      }
      GGS_action_list  var_cas_actions ;
      var_cas_actions = operand_502->mInfo.st.reader_actions (_inLexique COMMA_SOURCE_FILE_AT_LINE (43)) ;
      if (((var_cas_actions.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (46)))._operator_isEqual (GGS_uint (0U))).isBuiltAndTrue ()) {
        operand_502->mKey.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, (GGS_string ("OS401-OS407 - ACTION attribute not defined for SCHEDULETABLE "))._operator_concat (operand_502->mKey.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (47))) COMMA_SOURCE_FILE_AT_LINE (48)) ;
      }
      GGS_uint64  var_cas_cur_offset ;
      var_cas_cur_offset = GGS_uint64 (0U) ;
      GGS_uint64  var_cas_previous_offset ;
      var_cas_previous_offset = GGS_uint64 (0U) ;
      GGS_uint64  var_cas_diff_offset ;
      var_cas_diff_offset = GGS_uint64 (0U) ;
      GGS_counter_map  var_cas_counters ;
      var_cas_counters = var_cas_cpu.reader_counters (_inLexique COMMA_SOURCE_FILE_AT_LINE (53)) ;
      GGS_bool var_cas_first_time ;
      var_cas_first_time = GGS_bool (true) ;
      {
        GGS_action_list::cEnumerator enumerator_1947 (var_cas_actions, true) ;
        const GGS_action_list::cElement * operand_1947 = NULL ;
        while (((operand_1947 = enumerator_1947.nextObject ()))) {
          macroValidPointer (operand_1947) ;
          if (((operand_1947->offset)._operator_strictSup (var_cas_len)).isBuiltAndTrue ()) {
            operand_1947->act.reader_location (_inLexique COMMA_SOURCE_FILE_AT_LINE (62)).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, (GGS_string ("Offset of action is greater than the LENGTH attribute of Schedule Table "))._operator_concat (operand_502->mKey.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (62))) COMMA_SOURCE_FILE_AT_LINE (63)) ;
          }
          var_cas_diff_offset = operand_1947->offset._substract_operation (_inLexique, var_cas_cur_offset COMMA_SOURCE_FILE_AT_LINE (65)) ;
          GGS_string var_cas_OS ;
          if (((var_cas_cur_offset)._operator_isEqual (GGS_uint64 (0U))).isBuiltAndTrue ()) {
            var_cas_OS = GGS_string ("OS443") ;
          }else{
            var_cas_OS = GGS_string ("OS408") ;
          }
          if (((var_cas_diff_offset)._operator_isNotEqual (GGS_uint64 (0U))).isBuiltAndTrue ()) {
            if ((var_cas_counters.reader_hasKey (_inLexique, operand_502->mInfo.st.reader_counter (_inLexique COMMA_SOURCE_FILE_AT_LINE (77)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (77)) COMMA_SOURCE_FILE_AT_LINE (77))).isBuiltAndTrue ()) {
              GGS_counter_obj  var_cas_cnt ;
              const GGS_counter_map  _temp_2838 = var_cas_counters ;
              if (_temp_2838.isBuilt ()) {
                _temp_2838 (HERE)->method_getCounter (_inLexique, operand_502->mInfo.st.reader_counter (_inLexique COMMA_SOURCE_FILE_AT_LINE (79)), var_cas_cnt COMMA_SOURCE_FILE_AT_LINE (79)) ;
              }
              { const GGS_basic_type _var_3204 = var_cas_cnt.reader_min_cycle (_inLexique COMMA_SOURCE_FILE_AT_LINE (80)) ; // CAST instruction
                if (_var_3204.getPtr () != NULL) {
                  macroValidPointer (_var_3204.getPtr ()) ;
                  if (typeid (cPtr_uint32_class) == typeid (* (_var_3204.getPtr ()))) {
                    const GGS_uint32_class var_cas_mc (_var_3204.getPtr ()) ;
                    if (((var_cas_diff_offset)._operator_strictInf (var_cas_mc.reader_value (_inLexique COMMA_SOURCE_FILE_AT_LINE (82)).reader_uint64 (_inLexique COMMA_SOURCE_FILE_AT_LINE (82)))).isBuiltAndTrue ()) {
                      operand_502->mKey.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((var_cas_OS)._operator_concat (GGS_string (" - Delay between offset(")))._operator_concat (var_cas_cur_offset.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (83))))._operator_concat (GGS_string (") and offset(")))._operator_concat (operand_1947->offset.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (83))))._operator_concat (GGS_string (") is less than mincyle(")))._operator_concat (var_cas_mc.reader_value (_inLexique COMMA_SOURCE_FILE_AT_LINE (83)).reader_uint64 (_inLexique COMMA_SOURCE_FILE_AT_LINE (83)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (83))))._operator_concat (GGS_string (") of the counter of ")))._operator_concat (operand_502->mKey.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (83))) COMMA_SOURCE_FILE_AT_LINE (84)) ;
                    }
                  }else{
                  }
                }
              }
              { const GGS_basic_type _var_3573 = var_cas_cnt.reader_max_allowed_value (_inLexique COMMA_SOURCE_FILE_AT_LINE (86)) ; // CAST instruction
                if (_var_3573.getPtr () != NULL) {
                  macroValidPointer (_var_3573.getPtr ()) ;
                  if (typeid (cPtr_uint32_class) == typeid (* (_var_3573.getPtr ()))) {
                    const GGS_uint32_class var_cas_mc (_var_3573.getPtr ()) ;
                    if (((var_cas_diff_offset)._operator_strictSup (var_cas_mc.reader_value (_inLexique COMMA_SOURCE_FILE_AT_LINE (88)).reader_uint64 (_inLexique COMMA_SOURCE_FILE_AT_LINE (88)))).isBuiltAndTrue ()) {
                      operand_502->mKey.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((var_cas_OS)._operator_concat (GGS_string (" - Delay between offset(")))._operator_concat (var_cas_cur_offset.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (89))))._operator_concat (GGS_string (") and offset(")))._operator_concat (operand_1947->offset.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (89))))._operator_concat (GGS_string (") is greater than maxallowedvalue(")))._operator_concat (var_cas_mc.reader_value (_inLexique COMMA_SOURCE_FILE_AT_LINE (89)).reader_uint64 (_inLexique COMMA_SOURCE_FILE_AT_LINE (89)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (89))))._operator_concat (GGS_string (") of the counter of ")))._operator_concat (operand_502->mKey.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (89))) COMMA_SOURCE_FILE_AT_LINE (90)) ;
                    }
                  }else{
                  }
                }
              }
            }
          }
          if (((((operand_1947->offset)._operator_isEqual (var_cas_len))._operator_and ((var_cas_first_time)._operator_isEqual (GGS_bool (true))))._operator_and ((var_cas_perio)._operator_isEqual (GGS_string ("TRUE")))).isBuiltAndTrue ()) {
            operand_502->mKey.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((GGS_string ("OS444 - Final delay (final offset) can be equal to LENGTH only for single-shot schedule table and "))._operator_concat (operand_502->mKey.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (99))))._operator_concat (GGS_string (" isn't one")) COMMA_SOURCE_FILE_AT_LINE (100)) ;
          }
          var_cas_cur_offset = operand_1947->offset ;
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_schedule_tables_well_formed\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//Implementation of routine "schedule_tables_counters_exist_and_compatible"  *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_schedule_tables_counters_exist_and_compatible (C_Compiler & _inLexique,
                                const GGS_scheduletable_map   var_cas_sts,
                                const GGS_counter_map   var_cas_cnts COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_schedule_tables_counters_exist_and_compatible at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_scheduletable_map::cEnumerator enumerator_4206 (var_cas_sts, true) ;
    const GGS_scheduletable_map::cElement * operand_4206 = NULL ;
    while (((operand_4206 = enumerator_4206.nextObject ()))) {
      macroValidPointer (operand_4206) ;
      GGS_lstring  var_cas_cnt ;
      var_cas_cnt = operand_4206->mInfo.st.reader_counter (_inLexique COMMA_SOURCE_FILE_AT_LINE (114)) ;
      if ((((var_cas_cnts.reader_hasKey (_inLexique, var_cas_cnt.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (116)) COMMA_SOURCE_FILE_AT_LINE (116)))._operator_not ())._operator_and ((var_cas_cnt.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (116)))._operator_isNotEqual (GGS_string ("SystemCounter")))).isBuiltAndTrue ()) {
        var_cas_cnt.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((GGS_string ("counter "))._operator_concat (var_cas_cnt.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (117))))._operator_concat (GGS_string (" is not defined !")) COMMA_SOURCE_FILE_AT_LINE (118)) ;
      }else{
        GGS_uint64  var_cas_len ;
        var_cas_len = GGS_uint64 (0U) ;
        GGS_location  var_cas_loc ;
        var_cas_loc = GGS_location (_inLexique) ;
        { const GGS_basic_type _var_4712 = operand_4206->mInfo.st.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (121)) ; // CAST instruction
          if (_var_4712.getPtr () != NULL) {
            macroValidPointer (_var_4712.getPtr ()) ;
            if (typeid (cPtr_uint64_class) == typeid (* (_var_4712.getPtr ()))) {
              const GGS_uint64_class var_cas_ui (_var_4712.getPtr ()) ;
              var_cas_len = var_cas_ui.reader_value (_inLexique COMMA_SOURCE_FILE_AT_LINE (122)) ;
              var_cas_loc = var_cas_ui.reader_location (_inLexique COMMA_SOURCE_FILE_AT_LINE (122)) ;
            }else{
              GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, (GGS_string ("Internal error, incorrect datatype for LENGTH attribute of schedule table "))._operator_concat (operand_4206->mKey.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (123))) COMMA_SOURCE_FILE_AT_LINE (124)) ;
            }
          }
        }
        GGS_counter_obj  var_cas_cpt ;
        const GGS_counter_map  _temp_4877 = var_cas_cnts ;
        if (_temp_4877.isBuilt ()) {
          _temp_4877 (HERE)->method_getCounter (_inLexique, var_cas_cnt, var_cas_cpt COMMA_SOURCE_FILE_AT_LINE (129)) ;
        }
        GGS_uint64  var_cas_max ;
        var_cas_max = GGS_uint64 (0U) ;
        { const GGS_basic_type _var_5161 = var_cas_cpt.reader_max_allowed_value (_inLexique COMMA_SOURCE_FILE_AT_LINE (132)) ; // CAST instruction
          if (_var_5161.getPtr () != NULL) {
            macroValidPointer (_var_5161.getPtr ()) ;
            if (typeid (cPtr_uint32_class) == typeid (* (_var_5161.getPtr ()))) {
              const GGS_uint32_class var_cas_ui (_var_5161.getPtr ()) ;
              var_cas_max = var_cas_ui.reader_value (_inLexique COMMA_SOURCE_FILE_AT_LINE (134)).reader_uint64 (_inLexique COMMA_SOURCE_FILE_AT_LINE (134)) ;
            }else{
              GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, (GGS_string ("Internal error, incorrect datatype for MAXALLOWEDVALUE attribute of counter "))._operator_concat (var_cas_cnt.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (136))) COMMA_SOURCE_FILE_AT_LINE (137)) ;
            }
          }
        }
        if (((var_cas_len)._operator_strictSup (var_cas_max)).isBuiltAndTrue ()) {
          var_cas_loc.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, (((GGS_string ("LENGTH of schedule table "))._operator_concat (operand_4206->mKey.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (140))))._operator_concat (GGS_string (" is greater than MAXALLOWEDVALUE of counter ")))._operator_concat (var_cas_cnt.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (140))) COMMA_SOURCE_FILE_AT_LINE (141)) ;
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_schedule_tables_counters_exist_and_compatible\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Implementation of routine "schedule_tables_tasks_and_events_exist"     *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_schedule_tables_tasks_and_events_exist (C_Compiler & _inLexique,
                                const GGS_root_obj   var_cas_cpu COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_schedule_tables_tasks_and_events_exist at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_scheduletable_map::cEnumerator enumerator_5535 (var_cas_cpu.reader_scheduletables (_inLexique COMMA_SOURCE_FILE_AT_LINE (153)), true) ;
    const GGS_scheduletable_map::cElement * operand_5535 = NULL ;
    while (((operand_5535 = enumerator_5535.nextObject ()))) {
      macroValidPointer (operand_5535) ;
      {
        GGS_action_list::cEnumerator enumerator_5611 (operand_5535->mInfo.st.reader_actions (_inLexique COMMA_SOURCE_FILE_AT_LINE (154)), true) ;
        const GGS_action_list::cElement * operand_5611 = NULL ;
        while (((operand_5611 = enumerator_5611.nextObject ()))) {
          macroValidPointer (operand_5611) ;
          { const GGS_action_obj _var_6747 = operand_5611->act ; // CAST instruction
            if (_var_6747.getPtr () != NULL) {
              macroValidPointer (_var_6747.getPtr ()) ;
              if (typeid (cPtr_activatetask_action) == typeid (* (_var_6747.getPtr ()))) {
                const GGS_activatetask_action var_cas_ata (_var_6747.getPtr ()) ;
                if (((var_cas_cpu.reader_tasks (_inLexique COMMA_SOURCE_FILE_AT_LINE (157)).reader_hasKey (_inLexique, var_cas_ata.reader_task_name (_inLexique COMMA_SOURCE_FILE_AT_LINE (157)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (157)) COMMA_SOURCE_FILE_AT_LINE (157)))._operator_not ()).isBuiltAndTrue ()) {
                  operand_5611->act.reader_location (_inLexique COMMA_SOURCE_FILE_AT_LINE (158)).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string ("TASK attribute of action does not reference an existing task") COMMA_SOURCE_FILE_AT_LINE (159)) ;
                }
              }else if (typeid (cPtr_setevent_action) == typeid (* (_var_6747.getPtr ()))) {
                const GGS_setevent_action var_cas_sea (_var_6747.getPtr ()) ;
                if (((var_cas_cpu.reader_tasks (_inLexique COMMA_SOURCE_FILE_AT_LINE (161)).reader_hasKey (_inLexique, var_cas_sea.reader_task_name (_inLexique COMMA_SOURCE_FILE_AT_LINE (161)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (161)) COMMA_SOURCE_FILE_AT_LINE (161)))._operator_not ()).isBuiltAndTrue ()) {
                  operand_5611->act.reader_location (_inLexique COMMA_SOURCE_FILE_AT_LINE (162)).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string ("TASK attribute of action does not reference an existing task") COMMA_SOURCE_FILE_AT_LINE (163)) ;
                }
                if (((var_cas_cpu.reader_events (_inLexique COMMA_SOURCE_FILE_AT_LINE (164)).reader_hasKey (_inLexique, var_cas_sea.reader_event_name (_inLexique COMMA_SOURCE_FILE_AT_LINE (164)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (164)) COMMA_SOURCE_FILE_AT_LINE (164)))._operator_not ()).isBuiltAndTrue ()) {
                  operand_5611->act.reader_location (_inLexique COMMA_SOURCE_FILE_AT_LINE (165)).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string ("EVENT attribute of action does not reference an existing event") COMMA_SOURCE_FILE_AT_LINE (166)) ;
                }
              }else if (typeid (cPtr_incrementcounter_action) == typeid (* (_var_6747.getPtr ()))) {
                const GGS_incrementcounter_action var_cas_ica (_var_6747.getPtr ()) ;
                if (((var_cas_cpu.reader_counters (_inLexique COMMA_SOURCE_FILE_AT_LINE (168)).reader_hasKey (_inLexique, var_cas_ica.reader_counter_name (_inLexique COMMA_SOURCE_FILE_AT_LINE (168)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (168)) COMMA_SOURCE_FILE_AT_LINE (168)))._operator_not ()).isBuiltAndTrue ()) {
                  operand_5611->act.reader_location (_inLexique COMMA_SOURCE_FILE_AT_LINE (169)).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string ("COUNTER attribute of action does not reference an existing counter") COMMA_SOURCE_FILE_AT_LINE (170)) ;
                }
              }else{
                operand_5535->mKey.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, (((GGS_string ("Internal error, incorrect datatype for ACTION attribute at offset "))._operator_concat (operand_5611->offset.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (172))))._operator_concat (GGS_string (" of schedule table ")))._operator_concat (operand_5535->mKey.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (172))) COMMA_SOURCE_FILE_AT_LINE (173)) ;
              }
            }
          }
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_schedule_tables_tasks_and_events_exist\n") ;
  #endif
}

//---------------------------------------------------------------------------*

