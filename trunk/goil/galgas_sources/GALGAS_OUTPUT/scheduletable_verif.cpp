//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'scheduletable_verif.cpp'                       *
//                        Generated by version 1.8.5                         *
//                       june 24th, 2009, at 14h32'5"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != 515
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "scheduletable_verif.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "scheduletable_verif.ggs", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//         Implementation of routine "schedule_tables_well_formed"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_schedule_tables_well_formed (C_Compiler & inLexique,
                                const GGS_scheduletable_map   var_cas_sts,
                                const GGS_root_obj   var_cas_cpu COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_schedule_tables_well_formed at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_scheduletable_map::cEnumerator enumerator_502 (var_cas_sts, true) ;
    const GGS_scheduletable_map::cElement * operand_502 = NULL ;
    while (((operand_502 = enumerator_502.nextObject ()))) {
      macroValidPointer (operand_502) ;
      GGS_string var_cas_perio ;
      var_cas_perio = GGS_string ("") ;
      { const GGS_basic_type _var_1185 = operand_502->mInfo.st.reader_periodic (inLexique COMMA_SOURCE_FILE_AT_LINE (19)) ; // CAST instruction
        if (_var_1185.getPtr () != NULL) {
          macroValidPointer (_var_1185.getPtr ()) ;
          if (typeid (cPtr_bool_class) == typeid (* (_var_1185.getPtr ()))) {
            const GGS_bool_class var_cas_b (_var_1185.getPtr ()) ;
            if (((var_cas_b.reader_value (inLexique COMMA_SOURCE_FILE_AT_LINE (21))).operator_isEqual (GGS_bool (true))).isBuiltAndTrue ()) {
              var_cas_perio = GGS_string ("TRUE") ;
            }else{
              var_cas_perio = GGS_string ("FALSE") ;
              { const GGS_ltgt_sync_obj _var_1031 = operand_502->mInfo.st.reader_ltgt_sync (inLexique COMMA_SOURCE_FILE_AT_LINE (25)) ; // CAST instruction
                if (_var_1031.getPtr () != NULL) {
                  macroValidPointer (_var_1031.getPtr ()) ;
                  if (typeid (cPtr_ltgt_sync_true) == typeid (* (_var_1031.getPtr ()))) {
                    operand_502->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (GGS_string ("An implicit schedule table shall be repeating otherwise, synchronisation can't be done. See ")).operator_concat (operand_502->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (27))) COMMA_SOURCE_FILE_AT_LINE (28)) ;
                  }else{
                  }
                }
              }
            }
          }else{
            operand_502->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (GGS_string ("Internal error, unexpected type for PERIODIC attribute of schedule table ")).operator_concat (operand_502->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (30))) COMMA_SOURCE_FILE_AT_LINE (31)) ;
          }
        }
      }
      GGS_uint64  var_cas_len ;
      var_cas_len = GGS_uint64 (0U) ;
      { const GGS_basic_type _var_1457 = operand_502->mInfo.st.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (35)) ; // CAST instruction
        if (_var_1457.getPtr () != NULL) {
          macroValidPointer (_var_1457.getPtr ()) ;
          if (typeid (cPtr_uint64_class) == typeid (* (_var_1457.getPtr ()))) {
            const GGS_uint64_class var_cas_ui (_var_1457.getPtr ()) ;
            var_cas_len = var_cas_ui.reader_value (inLexique COMMA_SOURCE_FILE_AT_LINE (37)) ;
          }else{
            operand_502->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (GGS_string ("Internal error, incorrect datatype for LENGTH attribute of Schedule Table ")).operator_concat (operand_502->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (39))) COMMA_SOURCE_FILE_AT_LINE (40)) ;
          }
        }
      }
      if (((var_cas_len).operator_isEqual (GGS_uint64 (0U))).isBuiltAndTrue ()) {
        operand_502->mInfo.st.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (44)).reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (44)).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("The LENGTH attribute should not be 0") COMMA_SOURCE_FILE_AT_LINE (45)) ;
      }
      GGS_action_list  var_cas_actions ;
      var_cas_actions = operand_502->mInfo.st.reader_actions (inLexique COMMA_SOURCE_FILE_AT_LINE (47)) ;
      if (((var_cas_actions.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (49))).operator_isEqual (GGS_uint (0U))).isBuiltAndTrue ()) {
        operand_502->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (GGS_string ("OS401-OS407 - ACTION attribute not defined for SCHEDULETABLE ")).operator_concat (operand_502->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (50))) COMMA_SOURCE_FILE_AT_LINE (51)) ;
      }
      GGS_counter_map  var_cas_counters ;
      var_cas_counters = var_cas_cpu.reader_counters (inLexique COMMA_SOURCE_FILE_AT_LINE (54)) ;
      GGS_uint64  var_cas_mc ;
      var_cas_mc = GGS_uint64 (0U) ;
      GGS_uint64  var_cas_mav ;
      var_cas_mav = GGS_uint64 (0U) ;
      if ((var_cas_counters.reader_hasKey (inLexique, operand_502->mInfo.st.reader_counter (inLexique COMMA_SOURCE_FILE_AT_LINE (57)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (57)) COMMA_SOURCE_FILE_AT_LINE (57))).isBuiltAndTrue ()) {
        GGS_counter_obj  var_cas_cnt ;
        const GGS_counter_map  temp_2079 = var_cas_counters ;
        if (temp_2079.isBuilt ()) {
          temp_2079 (HERE)->method_getCounter (inLexique, operand_502->mInfo.st.reader_counter (inLexique COMMA_SOURCE_FILE_AT_LINE (59)), var_cas_cnt COMMA_SOURCE_FILE_AT_LINE (59)) ;
        }
        { const GGS_basic_type _var_2196 = var_cas_cnt.reader_min_cycle (inLexique COMMA_SOURCE_FILE_AT_LINE (60)) ; // CAST instruction
          if (_var_2196.getPtr () != NULL) {
            macroValidPointer (_var_2196.getPtr ()) ;
            if (typeid (cPtr_uint32_class) == typeid (* (_var_2196.getPtr ()))) {
              const GGS_uint32_class var_cas_a (_var_2196.getPtr ()) ;
              var_cas_mc = var_cas_a.reader_value (inLexique COMMA_SOURCE_FILE_AT_LINE (62)).reader_uint64 (inLexique COMMA_SOURCE_FILE_AT_LINE (62)) ;
            }else{
            }
          }
        }
        { const GGS_basic_type _var_2307 = var_cas_cnt.reader_max_allowed_value (inLexique COMMA_SOURCE_FILE_AT_LINE (64)) ; // CAST instruction
          if (_var_2307.getPtr () != NULL) {
            macroValidPointer (_var_2307.getPtr ()) ;
            if (typeid (cPtr_uint32_class) == typeid (* (_var_2307.getPtr ()))) {
              const GGS_uint32_class var_cas_b (_var_2307.getPtr ()) ;
              var_cas_mav = var_cas_b.reader_value (inLexique COMMA_SOURCE_FILE_AT_LINE (66)).reader_uint64 (inLexique COMMA_SOURCE_FILE_AT_LINE (66)) ;
            }else{
            }
          }
        }
      }
      GGS_uint64  var_cas_cur_offset ;
      var_cas_cur_offset = GGS_uint64 (0U) ;
      GGS_uint64  var_cas_diff_offset ;
      var_cas_diff_offset = GGS_uint64 (0U) ;
      GGS_bool var_cas_first_time ;
      var_cas_first_time = GGS_bool (true) ;
      {
        GGS_action_list::cEnumerator enumerator_2430 (var_cas_actions, true) ;
        const GGS_action_list::cElement * operand_2430 = NULL ;
        while (((operand_2430 = enumerator_2430.nextObject ()))) {
          macroValidPointer (operand_2430) ;
          if (((operand_2430->offset).operator_strictSup (var_cas_len)).isBuiltAndTrue ()) {
            operand_2430->act.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (76)).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (GGS_string ("Offset of action is greater than the LENGTH attribute of Schedule Table ")).operator_concat (operand_502->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (76))) COMMA_SOURCE_FILE_AT_LINE (77)) ;
          }
          var_cas_diff_offset = operand_2430->offset.substract_operation (inLexique, var_cas_cur_offset COMMA_SOURCE_FILE_AT_LINE (79)) ;
          GGS_string var_cas_OS ;
          if (((var_cas_cur_offset).operator_isEqual (GGS_uint64 (0U))).isBuiltAndTrue ()) {
            var_cas_OS = GGS_string ("OS443") ;
          }else{
            var_cas_OS = GGS_string ("OS408") ;
          }
          if (((var_cas_diff_offset).operator_isNotEqual (GGS_uint64 (0U))).isBuiltAndTrue ()) {
            if (((var_cas_diff_offset).operator_strictInf (var_cas_mc)).isBuiltAndTrue ()) {
              operand_502->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((((((var_cas_OS).operator_concat (GGS_string (" - Delay between offset("))).operator_concat (var_cas_cur_offset.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (92)))).operator_concat (GGS_string (") and offset("))).operator_concat (operand_2430->offset.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (92)))).operator_concat (GGS_string (") is less than mincyle("))).operator_concat (var_cas_mc.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (92)))).operator_concat (GGS_string (") of the counter of "))).operator_concat (operand_502->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (92))) COMMA_SOURCE_FILE_AT_LINE (93)) ;
            }
            if (((var_cas_diff_offset).operator_strictSup (var_cas_mav)).isBuiltAndTrue ()) {
              operand_502->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((((((var_cas_OS).operator_concat (GGS_string (" - Delay between offset("))).operator_concat (var_cas_cur_offset.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (95)))).operator_concat (GGS_string (") and offset("))).operator_concat (operand_2430->offset.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (95)))).operator_concat (GGS_string (") is greater than maxallowedvalue("))).operator_concat (var_cas_mav.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (95)))).operator_concat (GGS_string (") of the counter of "))).operator_concat (operand_502->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (95))) COMMA_SOURCE_FILE_AT_LINE (96)) ;
            }
          }
          if (((((operand_2430->offset).operator_isEqual (var_cas_len)).operator_and ((var_cas_first_time).operator_isEqual (GGS_bool (true)))).operator_and ((var_cas_perio).operator_isEqual (GGS_string ("TRUE")))).isBuiltAndTrue ()) {
            operand_502->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("OS444 - Final delay (final offset) can be equal to LENGTH only for single-shot schedule table and ")).operator_concat (operand_502->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (103)))).operator_concat (GGS_string (" isn't one")) COMMA_SOURCE_FILE_AT_LINE (104)) ;
          }
          var_cas_cur_offset = operand_2430->offset ;
        }
      }
      { const GGS_ltgt_sync_obj _var_4935 = operand_502->mInfo.st.reader_ltgt_sync (inLexique COMMA_SOURCE_FILE_AT_LINE (110)) ; // CAST instruction
        if (_var_4935.getPtr () != NULL) {
          macroValidPointer (_var_4935.getPtr ()) ;
          if (typeid (cPtr_ltgt_sync_true) == typeid (* (_var_4935.getPtr ()))) {
            const GGS_ltgt_sync_true var_cas_sst (_var_4935.getPtr ()) ;
            if (((var_cas_sst.reader_strategy (inLexique COMMA_SOURCE_FILE_AT_LINE (112)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (112))).operator_isEqual (GGS_string ("IMPLICIT"))).isBuiltAndTrue ()) {
              { const GGS_autostart_obj _var_4728 = operand_502->mInfo.st.reader_autostart (inLexique COMMA_SOURCE_FILE_AT_LINE (113)) ; // CAST instruction
                if (_var_4728.getPtr () != NULL) {
                  macroValidPointer (_var_4728.getPtr ()) ;
                  if (typeid (cPtr_sd_autostart_relative) == typeid (* (_var_4728.getPtr ()))) {
                    operand_502->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("OS430 - ")).operator_concat (operand_502->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (115)))).operator_concat (GGS_string (" should be started in Absolute mode only")) COMMA_SOURCE_FILE_AT_LINE (116)) ;
                  }else if (typeid (cPtr_sd_autostart_synchron) == typeid (* (_var_4728.getPtr ()))) {
                    operand_502->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("OS430 - ")).operator_concat (operand_502->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (117)))).operator_concat (GGS_string (" should be started in Absolute mode only")) COMMA_SOURCE_FILE_AT_LINE (118)) ;
                  }else{
                  }
                }
              }
              if (((var_cas_len).operator_isNotEqual (var_cas_mav.add_operation (inLexique, GGS_uint64 (1U) COMMA_SOURCE_FILE_AT_LINE (120)))).isBuiltAndTrue ()) {
                operand_502->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("OS429 - LENGTH of ")).operator_concat (operand_502->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (121)))).operator_concat (GGS_string (" should be equal to OSMAXALLOWEDVALUE + 1 ("))).operator_concat (var_cas_mav.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (121)))).operator_concat (GGS_string (")")) COMMA_SOURCE_FILE_AT_LINE (122)) ;
              }
            }
          }else{
          }
        }
      }
      { const GGS_autostart_obj _var_5778 = operand_502->mInfo.st.reader_autostart (inLexique COMMA_SOURCE_FILE_AT_LINE (128)) ; // CAST instruction
        if (_var_5778.getPtr () != NULL) {
          macroValidPointer (_var_5778.getPtr ()) ;
          if (typeid (cPtr_sd_autostart_relative) == typeid (* (_var_5778.getPtr ()))) {
            const GGS_sd_autostart_relative var_cas_relative_data (_var_5778.getPtr ()) ;
            if (((((var_cas_relative_data.reader_offset (inLexique COMMA_SOURCE_FILE_AT_LINE (130)).reader_uint64 (inLexique COMMA_SOURCE_FILE_AT_LINE (130))).operator_isEqual (GGS_uint64 (0U))).operator_or ((var_cas_relative_data.reader_offset (inLexique COMMA_SOURCE_FILE_AT_LINE (130)).reader_uint64 (inLexique COMMA_SOURCE_FILE_AT_LINE (130))).operator_strictSup (var_cas_mav))).operator_or ((var_cas_relative_data.reader_offset (inLexique COMMA_SOURCE_FILE_AT_LINE (130)).reader_uint64 (inLexique COMMA_SOURCE_FILE_AT_LINE (130))).operator_strictInf (var_cas_mc))).isBuiltAndTrue ()) {
              operand_502->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (((((operand_502->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (131))).operator_concat (GGS_string (" autostart's offset out of range ["))).operator_concat (var_cas_mc.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (131)))).operator_concat (GGS_string (" "))).operator_concat (var_cas_mav.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (131)))).operator_concat (GGS_string ("] and not 0")) COMMA_SOURCE_FILE_AT_LINE (132)) ;
            }
          }else if (typeid (cPtr_sd_autostart_absolute) == typeid (* (_var_5778.getPtr ()))) {
            const GGS_sd_autostart_absolute var_cas_absolute_data (_var_5778.getPtr ()) ;
            if ((((var_cas_absolute_data.reader_value (inLexique COMMA_SOURCE_FILE_AT_LINE (134)).reader_uint64 (inLexique COMMA_SOURCE_FILE_AT_LINE (134))).operator_strictSup (var_cas_mav)).operator_or ((var_cas_absolute_data.reader_value (inLexique COMMA_SOURCE_FILE_AT_LINE (134)).reader_uint64 (inLexique COMMA_SOURCE_FILE_AT_LINE (134))).operator_strictInf (var_cas_mc))).isBuiltAndTrue ()) {
              operand_502->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (((((operand_502->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (135))).operator_concat (GGS_string (" autostart's offset out of range ["))).operator_concat (var_cas_mc.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (135)))).operator_concat (GGS_string (" "))).operator_concat (var_cas_mav.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (135)))).operator_concat (GGS_string ("]")) COMMA_SOURCE_FILE_AT_LINE (136)) ;
            }
          }else{
          }
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_schedule_tables_well_formed\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//Implementation of routine "schedule_tables_counters_exist_and_compatible"  *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_schedule_tables_counters_exist_and_compatible (C_Compiler & inLexique,
                                const GGS_scheduletable_map   var_cas_sts,
                                const GGS_counter_map   var_cas_cnts COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_schedule_tables_counters_exist_and_compatible at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_scheduletable_map::cEnumerator enumerator_5938 (var_cas_sts, true) ;
    const GGS_scheduletable_map::cElement * operand_5938 = NULL ;
    while (((operand_5938 = enumerator_5938.nextObject ()))) {
      macroValidPointer (operand_5938) ;
      GGS_lstring  var_cas_cnt ;
      var_cas_cnt = operand_5938->mInfo.st.reader_counter (inLexique COMMA_SOURCE_FILE_AT_LINE (146)) ;
      if ((((var_cas_cnts.reader_hasKey (inLexique, var_cas_cnt.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (148)) COMMA_SOURCE_FILE_AT_LINE (148))).operator_not ()).operator_and ((var_cas_cnt.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (148))).operator_isNotEqual (GGS_string ("SystemCounter")))).isBuiltAndTrue ()) {
        var_cas_cnt.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("counter ")).operator_concat (var_cas_cnt.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (149)))).operator_concat (GGS_string (" is not defined !")) COMMA_SOURCE_FILE_AT_LINE (150)) ;
      }else{
        GGS_uint64  var_cas_len ;
        var_cas_len = GGS_uint64 (0U) ;
        GGS_location  var_cas_loc ;
        var_cas_loc = GGS_location (inLexique) ;
        { const GGS_basic_type _var_6444 = operand_5938->mInfo.st.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (153)) ; // CAST instruction
          if (_var_6444.getPtr () != NULL) {
            macroValidPointer (_var_6444.getPtr ()) ;
            if (typeid (cPtr_uint64_class) == typeid (* (_var_6444.getPtr ()))) {
              const GGS_uint64_class var_cas_ui (_var_6444.getPtr ()) ;
              var_cas_len = var_cas_ui.reader_value (inLexique COMMA_SOURCE_FILE_AT_LINE (154)) ;
              var_cas_loc = var_cas_ui.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (154)) ;
            }else{
              GGS_location (inLexique).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (GGS_string ("Internal error, incorrect datatype for LENGTH attribute of schedule table ")).operator_concat (operand_5938->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (155))) COMMA_SOURCE_FILE_AT_LINE (156)) ;
            }
          }
        }
        GGS_counter_obj  var_cas_cpt ;
        const GGS_counter_map  temp_6609 = var_cas_cnts ;
        if (temp_6609.isBuilt ()) {
          temp_6609 (HERE)->method_getCounter (inLexique, var_cas_cnt, var_cas_cpt COMMA_SOURCE_FILE_AT_LINE (161)) ;
        }
        GGS_uint64  var_cas_max ;
        var_cas_max = GGS_uint64 (0U) ;
        { const GGS_basic_type _var_6893 = var_cas_cpt.reader_max_allowed_value (inLexique COMMA_SOURCE_FILE_AT_LINE (164)) ; // CAST instruction
          if (_var_6893.getPtr () != NULL) {
            macroValidPointer (_var_6893.getPtr ()) ;
            if (typeid (cPtr_uint32_class) == typeid (* (_var_6893.getPtr ()))) {
              const GGS_uint32_class var_cas_ui (_var_6893.getPtr ()) ;
              var_cas_max = var_cas_ui.reader_value (inLexique COMMA_SOURCE_FILE_AT_LINE (166)).reader_uint64 (inLexique COMMA_SOURCE_FILE_AT_LINE (166)) ;
            }else{
              GGS_location (inLexique).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (GGS_string ("Internal error, incorrect datatype for MAXALLOWEDVALUE attribute of counter ")).operator_concat (var_cas_cnt.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (168))) COMMA_SOURCE_FILE_AT_LINE (169)) ;
            }
          }
        }
        if (((var_cas_len).operator_strictSup (var_cas_max.add_operation (inLexique, GGS_uint64 (1U) COMMA_SOURCE_FILE_AT_LINE (171)))).isBuiltAndTrue ()) {
          var_cas_loc.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (((GGS_string ("LENGTH of schedule table ")).operator_concat (operand_5938->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (172)))).operator_concat (GGS_string (" is greater than MAXALLOWEDVALUE of counter "))).operator_concat (var_cas_cnt.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (172))) COMMA_SOURCE_FILE_AT_LINE (173)) ;
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_schedule_tables_counters_exist_and_compatible\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Implementation of routine "schedule_tables_tasks_and_events_exist"     *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_schedule_tables_tasks_and_events_exist (C_Compiler & inLexique,
                                const GGS_root_obj   var_cas_cpu COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_schedule_tables_tasks_and_events_exist at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_scheduletable_map::cEnumerator enumerator_7277 (var_cas_cpu.reader_scheduletables (inLexique COMMA_SOURCE_FILE_AT_LINE (185)), true) ;
    const GGS_scheduletable_map::cElement * operand_7277 = NULL ;
    while (((operand_7277 = enumerator_7277.nextObject ()))) {
      macroValidPointer (operand_7277) ;
      {
        GGS_action_list::cEnumerator enumerator_7353 (operand_7277->mInfo.st.reader_actions (inLexique COMMA_SOURCE_FILE_AT_LINE (186)), true) ;
        const GGS_action_list::cElement * operand_7353 = NULL ;
        while (((operand_7353 = enumerator_7353.nextObject ()))) {
          macroValidPointer (operand_7353) ;
          { const GGS_action_obj _var_8489 = operand_7353->act ; // CAST instruction
            if (_var_8489.getPtr () != NULL) {
              macroValidPointer (_var_8489.getPtr ()) ;
              if (typeid (cPtr_activatetask_action) == typeid (* (_var_8489.getPtr ()))) {
                const GGS_activatetask_action var_cas_ata (_var_8489.getPtr ()) ;
                if (((var_cas_cpu.reader_tasks (inLexique COMMA_SOURCE_FILE_AT_LINE (189)).reader_hasKey (inLexique, var_cas_ata.reader_task_name (inLexique COMMA_SOURCE_FILE_AT_LINE (189)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (189)) COMMA_SOURCE_FILE_AT_LINE (189))).operator_not ()).isBuiltAndTrue ()) {
                  operand_7353->act.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (190)).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("TASK attribute of action does not reference an existing task") COMMA_SOURCE_FILE_AT_LINE (191)) ;
                }
              }else if (typeid (cPtr_setevent_action) == typeid (* (_var_8489.getPtr ()))) {
                const GGS_setevent_action var_cas_sea (_var_8489.getPtr ()) ;
                if (((var_cas_cpu.reader_tasks (inLexique COMMA_SOURCE_FILE_AT_LINE (193)).reader_hasKey (inLexique, var_cas_sea.reader_task_name (inLexique COMMA_SOURCE_FILE_AT_LINE (193)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (193)) COMMA_SOURCE_FILE_AT_LINE (193))).operator_not ()).isBuiltAndTrue ()) {
                  operand_7353->act.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (194)).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("TASK attribute of action does not reference an existing task") COMMA_SOURCE_FILE_AT_LINE (195)) ;
                }
                if (((var_cas_cpu.reader_events (inLexique COMMA_SOURCE_FILE_AT_LINE (196)).reader_hasKey (inLexique, var_cas_sea.reader_event_name (inLexique COMMA_SOURCE_FILE_AT_LINE (196)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (196)) COMMA_SOURCE_FILE_AT_LINE (196))).operator_not ()).isBuiltAndTrue ()) {
                  operand_7353->act.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (197)).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("EVENT attribute of action does not reference an existing event") COMMA_SOURCE_FILE_AT_LINE (198)) ;
                }
              }else if (typeid (cPtr_incrementcounter_action) == typeid (* (_var_8489.getPtr ()))) {
                const GGS_incrementcounter_action var_cas_ica (_var_8489.getPtr ()) ;
                if (((var_cas_cpu.reader_counters (inLexique COMMA_SOURCE_FILE_AT_LINE (200)).reader_hasKey (inLexique, var_cas_ica.reader_counter_name (inLexique COMMA_SOURCE_FILE_AT_LINE (200)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (200)) COMMA_SOURCE_FILE_AT_LINE (200))).operator_not ()).isBuiltAndTrue ()) {
                  operand_7353->act.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (201)).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("COUNTER attribute of action does not reference an existing counter") COMMA_SOURCE_FILE_AT_LINE (202)) ;
                }
              }else{
                operand_7277->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (((GGS_string ("Internal error, incorrect datatype for ACTION attribute at offset ")).operator_concat (operand_7353->offset.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (204)))).operator_concat (GGS_string (" of schedule table "))).operator_concat (operand_7277->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (204))) COMMA_SOURCE_FILE_AT_LINE (205)) ;
              }
            }
          }
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_schedule_tables_tasks_and_events_exist\n") ;
  #endif
}

//---------------------------------------------------------------------------*

