#
# Trampoline OS
#
# Trampoline is copyright (c) IRCCyN 2005+
# Trampoline est prot»g» par la loi sur la propri»t» intellectuelle
#
# This software is distributed under the Lesser GNU Public Licence
#
# GOIL counter object parser
#
# $Date$
# $Rev$
# $Author$
# $URL$
#

syntax goil_obj_counter :

import lexique goil_lexique in "goil_lexique.ggs" ;
import option goil_options in "goil_options.ggs" ;
import semantics goil_semantics in "goil_semantics.ggs" ;

nonterminal <counter>
    ?!@counter_map counters ;

nonterminal <counter_parameters> 
    ?!@luint64 max_allowed_value
    ?!@luint64 ticks_per_base
    ?!@luint64 min_cycle ;

#
# external nonterminals
#
nonterminal <description>
    !@lstring description ;

#
# counter rules implementation
#
rule <counter>
    ?!@counter_map counters :

    @lstring counter_name ;
    @counter_obj counter ;
    @basic_type max_allowed_value ;
    @basic_type ticks_per_base ;
    @basic_type min_cycle ;
    @lstring description := [@lstring new !"" !here] ;

    $COUNTER$ ;
    $idf$ ?counter_name ;

    if [counters hasKey ![counter_name string]] then
        
    else
        max_allowed_value := [@void new !here] ;
        ticks_per_base := [@void new !here] ;
        min_cycle := [@void new !here] ;
    end if ;
    ${$ ;
    <counter_parameters> !?max_allowed_value !?ticks_per_base !?min_cycle ;
    $}$ ;
    <description> ?description ;
    $;$ ;

    counter := [@counter_obj new !description !max_allowed_value !ticks_per_base !min_cycle] ;
    [!?counters insertCounter !counter_name !counter] ;
end rule ;

rule <counter_parameters> 
    ?!@luint64 max_allowed_value
    ?!@luint64 ticks_per_base
    ?!@luint64 min_cycle :

    @bool max_allowed_value_known := false ;
    @bool ticks_per_base_known := false ;
    @bool min_cycle_known := false ;

    repeat
    while
        if max_allowed_value_known then
            error here : "MAXALLOWEDVALUE attribute already defined for this counter" ;
        end if ;
        $MAXALLOWEDVALUE$ ;   $=$ ; $uint_number$ ?max_allowed_value ; $;$ ;
        max_allowed_value_known := true ;
    while
        if ticks_per_base_known then
            error here : "TICKSPERBASE attribute already defined for this counter" ;
        end if ;
        $TICKSPERBASE$ ;   $=$ ; $uint_number$ ?ticks_per_base ; $;$ ;
        ticks_per_base_known := true ;
    while
        if min_cycle_known then
            error here : "MINCYCLE attribute already defined for this counter" ;
        end if ;
        $MINCYCLE$ ; $=$ ; $uint_number$ ?min_cycle ; $;$ ;
        min_cycle_known := true ;
    while
        $idf$ ?* ;     $=$ ; select $idf$ ?* ; or $uint_number$ ?* ; end select ; $;$ ;
    end repeat ;
    #check that attributes are sets.
    if not max_allowed_value_known then 
      error here : "MAXALLOWEDVALUE attribute not defined for this counter" ;
    end if;
    if not ticks_per_base_known then 
      error here : "TICKSPERBASE attribute not defined for this counter" ;
    end if;
    if not min_cycle_known then 
      error here : "MINCYCLE attribute not defined for this counter" ;
    end if;

end rule ;

end syntax ;
# vim:ft=ggs:ts=4:sw=4
