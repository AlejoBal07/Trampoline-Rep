#
# Trampoline OS
#
# Trampoline is copyright (c) IRCCyN 2005+
# Trampoline est prot»g» par la loi sur la propri»t» intellectuelle
#
# This software is distributed under the Lesser GNU Public Licence
#
# GOIL counter object parser
#
# $Date$
# $Rev$
# $Author$
# $URL$
#

syntax goil_obj_counter :

import lexique goil_lexique in "goil_lexique.ggs" ;
import option goil_options in "goil_options.ggs" ;
import semantics goil_semantics in "goil_semantics.ggs" ;

nonterminal <counter>
    ?!@counter_map counters ;

nonterminal <counter_parameters> 
    ?!@basic_type max_allowed_value
    ?!@basic_type ticks_per_base
    ?!@basic_type min_cycle ;

#
# external nonterminals
#
nonterminal <description>
    !@lstring desc ;

#
# counter rules implementation
#
rule <counter>
    ?!@counter_map counters :

    @lstring counter_name ;
    @counter_obj counter ;
    @basic_type max_allowed_value ;
    @basic_type ticks_per_base ;
    @basic_type min_cycle ;
    @lstring desc ;

    $COUNTER$ ;
    $idf$ ?counter_name ;

    if [counters hasKey ![counter_name string]] then
        [!?counters del !counter_name ?counter] ;
        max_allowed_value := [counter max_allowed_value] ;
        ticks_per_base := [counter ticks_per_base] ;
        min_cycle := [counter min_cycle] ;
        desc := [counter desc] ;
    else # counter must also be written in this branch to comply with galgas static verification policy
        max_allowed_value := [@void new !here] ;
        ticks_per_base := [@void new !here] ;
        min_cycle := [@void new !here] ;
        desc := [@lstring new !"" !here];
        counter := [@counter_obj new !desc !max_allowed_value !ticks_per_base !min_cycle] ;
    end if ;
    ${$ ;
    <counter_parameters> !?max_allowed_value !?ticks_per_base !?min_cycle ;
    $}$ ;
    <description> ?desc ;
    $;$ ;

    counter := [@counter_obj new !desc !max_allowed_value !ticks_per_base !min_cycle] ;
    [!?counters put !counter_name !counter] ;
end rule ;

rule <counter_parameters> 
    ?!@basic_type max_allowed_value
    ?!@basic_type ticks_per_base
    ?!@basic_type min_cycle :

    repeat
    while
        @luint64 m ;
        $MAXALLOWEDVALUE$ ;   $=$ ; $uint_number$ ?m ; $;$ ;
        extract max_allowed_value :
        when @uint_class(@location l @uint64 i) ->
            error here : "MAXALLOWEDVALUE attribute already defined for this counter" ;
            error l : "was defined here" ;
        when @void(@location l) ->
            max_allowed_value := [@uint_class new !here ![m uint64]] ;
        else
        end extract ;
    while
        @luint64 t ;
        $TICKSPERBASE$ ;   $=$ ; $uint_number$ ?t ; $;$ ;
        extract ticks_per_base :
        when @uint_class(@location l @uint64 i) ->
            error here : "TICKSPERBASE attribute already defined for this counter" ;
            error l : "was defined here" ;
        when @void(@location l) ->
            ticks_per_base := [@uint_class new !here ![t uint64]] ;
        else
        end extract ;
    while
         @luint64 c ;
        $MINCYCLE$ ; $=$ ; $uint_number$ ?c ; $;$ ;
        extract min_cycle :
        when @uint_class(@location l @uint64 i) ->
            error here : "MINCYCLE attribute already defined for this counter" ;
            error l : "was defined here" ;
        when @void(@location l) ->
            min_cycle := [@uint_class new !here ![c uint64]] ;
        else
        end extract ;
    while
        $idf$ ?* ;     $=$ ; select $idf$ ?* ; or $uint_number$ ?* ; end select ; $;$ ;
    end repeat ;
end rule ;

end syntax ;
# vim:ft=ggs:ts=4:sw=4
