semantics goil_routines :

import option goil_options in "goil_options.ggs" ;
import semantics goil_basic_types in "goil_basic_types.ggs" ;

routine target !@string target_platform :
    target_platform := [option goil_options.target_platform] ;
#    message target_platform ;
#    target_platform := "ppc";
end routine ;

routine templates_directory !@string temp_dir :
    temp_dir := "" ;

    if [option goil_options.template_dir] != "" then
        temp_dir := [option goil_options.template_dir] ;
    else
        temp_dir := [@string stringWithEnvironmentVariableOrEmpty !"GOIL_TEMPLATES"] ;
    end if ;

    if temp_dir != "" then
        if [temp_dir characterAtIndex !([temp_dir length] - 1)] != '/' then
            temp_dir .= "/" ;
        end if ;
    end if ;
end routine ;

routine template !@string template ?@string obj :
    @string target_platform ;
    @string targ_tpl := "" ;

# Get the platform
    target ?target_platform ;
    
# Get the template directory
    @string temp_dir ;
    templates_directory ?temp_dir ;

# Look for a template in target plateform path
    targ_tpl := temp_dir.target_platform."/".obj.".tpl" ;
    if [targ_tpl fileExists]
    then template := [@string stringWithContentsOfFile !targ_tpl] ;
    else

# then in the all_targets path
        targ_tpl := temp_dir."all_targets/".obj.".tpl" ;
        if [targ_tpl fileExists]
        then template := [@string stringWithContentsOfFile !targ_tpl] ;
#             message "found template in all_targets\n" ;
        else template := "" ;
             error here: "No template found for ".obj;
        end if ;
    end if;
end routine ;

routine prefix ?@prefix_map p ?@string key !@string val :
    @lstring lkey := [@lstring new !key !here] ;
    [p prefix !lkey ?val ?*] ;
end routine ;

routine replace ?@prefix_map p ?@string key ?@string name ?!@string res :
    @lstring lkey := [@lstring new !key !here] ;
    @string prefix ;
    @string tag_to_rep ;
    [p prefix !lkey ?prefix ?tag_to_rep] ;
    res := [res stringByReplacingStringByString !tag_to_rep !prefix.name] ;
end routine ;

routine replace_no_prefix ?@prefix_map p ?@string key ?@string name ?!@string res :
    @lstring lkey := [@lstring new !key !here] ;
#    @string prefix ;
    @string tag_to_rep ;
    [p prefix !lkey ?* ?tag_to_rep] ;
    res := [res stringByReplacingStringByString !tag_to_rep !name] ;
end routine ;

routine obj_table
    ?@string     typename
    ?@string     varname
    ?@string     prefix
    ?@prefix_map p
    ?@stringset  names
    !@string     header
    !@string     implementation :

    implementation := "tpl_". typename." *tpl_".varname."_table[".[varname uppercaseString]."_COUNT] = {\n" ;
    header := "\n" ;
    @uint n := 0 ;
    @string obj_prefix ;
    @string obj_ids := "" ;
    prefix !p !prefix ?obj_prefix ;
    foreach names (@string name) :
        header := header."#define ".varname."_id_of_".name."  ".[n string]."\n" ;
        header := header."#define ".name."  ".varname."_id_of_".name."\n" ;
        implementation := implementation."    (tpl_".typename." *)&".obj_prefix.name ;
        n++ ;
        if n != [names count]
        then implementation := implementation . ",\n" ;
        else implementation := implementation . "\n" ;
        end if ;
    end foreach ;
    implementation := implementation . "};\n" ;

    if [names count] == 0 then implementation := "" ; end if ;

#    header := header."\n#define ".[varname uppercaseString]."_COUNT ".[[names count] string] ;
end routine ;

routine additional_int_key_required
    ?? @string key
    ?? @ident_map others
    ?? @lstring name
    !  @uint64 result :

    result := 0L;
    if [others hasKey !key]
    then
        @basic_type value ;
        [others get ![@lstring new !key !here] ?value] ;
        extract value :
        when @uint_class (@location l @uint64 uintVal) ->
            result := uintVal;
        else error name : key." should be an integer" ;
        end extract ;
    else
        error name : "no ".key." specified" ;
    end if ;
end routine;

routine additional_string_key_required
    ?? @string key
    ?? @ident_map others
    ?? @lstring name
    !  @string result :

    result := "";
    if [others hasKey !key]
    then
        @basic_type value ;
        [others get ![@lstring new !key !here] ?value] ;
        extract value :
        when @string_class (@location l @string str) ->
            result := str;
        else 
            error name : key." should be a string" ;
        end extract ;
    else
        error name : "no ".key." specified" ;
    end if ;
end routine;

end semantics ;
# vim:ft=ggs:ts=4:sw=4
