semantics goil_routines :

import option goil_options in "goil_options.ggs" ;
import semantics goil_semantic_types in "goil_semantic_types.ggs" ;

routine target !@string target_platform :
    target_platform := [option goil_options.target_platform] ;
#    message target_platform ;
#    target_platform := "ppc";
end routine ;

routine template !@string template ?@string obj :
    @string target_platform ;
    @string targ_tpl := "" ;

# Get the platform
    target ?target_platform ;

# Look for a template in target plateform path
    targ_tpl := "../templates/".target_platform."/".obj.".tpl" ;
    if [targ_tpl fileExists]
    then template := [@string stringWithContentsOfFile !targ_tpl] ;
    else

# then in the all_targets path
        targ_tpl := "../templates/all_targets/".obj.".tpl" ;
        if [targ_tpl fileExists]
        then template := [@string stringWithContentsOfFile !targ_tpl] ;
#             message "found template in all_targets\n" ;
        else template := "" ;
             error here: "No template found for ".obj;
        end if ;
    end if;
end routine ;

routine prefix ?@prefix_map p ?@string key !@string val :
    @lstring lkey := [@lstring new !key !here] ;
    [p prefix !lkey ?val ?*] ;
end routine ;

routine replace ?@prefix_map p ?@string key ?@string name ?!@string res :
    @lstring lkey := [@lstring new !key !here] ;
    @string prefix ;
    @string tag_to_rep ;
    [p prefix !lkey ?prefix ?tag_to_rep] ;
    res := [res stringByReplacingStringByString !tag_to_rep !prefix.name] ;
end routine ;

routine obj_table
    ?@string prefix
    ?@prefix_map p
    ?@stringset names
    !@string header
    !@string implementation :

    implementation := "tpl_".prefix." *tpl_".prefix."_table[".[prefix uppercaseString]."_COUNT] = {\n" ;
    header := "" ;
    @uint n := 0 ;
    @string obj_prefix ;
    @string obj_ids := "" ;
    prefix !p !prefix ?obj_prefix ;
    foreach names (@string name) :
        header := header."#define ".prefix."_id_of_".name."  ".[n string]."\n" ;
        implementation := implementation."    &".obj_prefix.name ;
        n++ ;
        if n != [names count]
        then implementation := implementation . ",\n" ;
        else implementation := implementation . "\n" ;
        end if ;
    end foreach ;
    implementation := implementation . "};\n" ;

    if [names count] == 0 then implementation := "" ; end if ;

    header := header."\n#define ".[prefix uppercaseString]."_COUNT ".[[names count] string] ;
end routine ;

routine additional_int_key_required
    ?? @string key
    ?? @string templateName
    ?? @ident_map others
    ?? @lstring name
    ?! @string result :

    if [others hasKey !key]
    then
        @basic_type value ;
        [others searchIdent ![@lstring new !key !here] ?value] ;
        extract value :
        when @uint_class (@uint64 uintVal) ->
            result := [result stringByReplacingStringByString !templateName ![uintVal string]] ;
        else error name : key." should be an integer" ;
        end extract ;
    else
        error name : "no ".key." specified" ;
    end if ;
end routine;

end semantics ;
