semantics goil_code_msg_gen :

import semantics goil_routines in "goil_routines.ggs" ;
import semantics goil_semantic_types in "goil_semantic_types.ggs" ;
import semantics goil_targets in "goil_targets.ggs" ;

#--------------------------------------------------------------------
# Messages generation
#--------------------------------------------------------------------
routine generate_messages
    ?@message_map messages
    ?@prefix_map  p
    ?!@string     header
    ?!@string     obj_header
    ?!@string     implementation :

    @string h_res := "" ;
    @string i_res := "" ;

    #
    # first, build a map of destination message
    # list keyed by source messages.
    #
    @message_map mm := messages ;
    @ident_list_map dests [emptyMap] ;
    
    foreach mm (@lstring name @message_obj mess) :
        @mess_prop_obj mp := [mess messageproperty] ;
        @lstring src ;
        [mp s_mess ?src] ;

        if ([src string] != "") & (not [dests hasKey ![src string]]) then
           @ident_list dest_list [emptyList] ;
           foreach mm (@lstring same_name @message_obj same_mess) :
                @mess_prop_obj same_mp := [same_mess messageproperty] ;
                @lstring same_src ;
                [same_mp s_mess ?same_src] ;
                if [same_src string] == [src string] then
                    dest_list += !same_name;
                end if ;
            end foreach ;
            [!?dests add !src !dest_list] ;
        end if ;
    end foreach ;

#    foreach dests (@lstring src @ident_list d_mess) :
##        message [src string].": " ;
#        foreach d_mess (@lstring dst) :
#            message "[".[dst string]."] ";
#        end foreach ;
##        message "\n" ;
#    end foreach ;

    @string result := "" ;

    # generate the code of the message objects in the
    # good order.
    foreach dests (@lstring src @ident_list d_mess) :
        @ident_list dm := d_mess ;

#        foreach dm (@lstring mn) :
#            message "[".[mn string]."]" ;
#        end foreach ;

#        message "\n" ;

        loop [dm length] :
        while [dm length] > 0 do
            @lstring mname ;
            @message_obj mess ;
            [!?dm popLast ?mname] ;
            [messages get !mname ?mess] ;
            @mess_prop_obj mp := [mess messageproperty] ;
            [mp generate !p !mname !mess !messages !dests ?h_res ?i_res] ;
            result .= i_res ;
        end loop ;

        @lstring mname ;
        @message_obj mess ;
        [messages get !src ?mess] ;
        @mess_prop_obj mp := [mess messageproperty] ;
        [mp generate !p !src !mess !messages !dests ?h_res ?i_res] ;
        result .= i_res ;
   end foreach ;

#    foreach messages (@lstring name @message_obj mess) :
#       @mess_prop_obj mp := [mess messageproperty] ;
#       [mp generate !p !name !mess !messages !dests ?h_res ?i_res] ;
#       message i_res ;
#       result .= i_res ;
#    end foreach ;

    @stringset smo [emptySet] ;
    @stringset rmo [emptySet] ;
    @stringset flags [emptySet] ;
    #
    # Build 2 stringsets, 1 of the sending and 1 of the receiving message objects
    # Build also a stringset of flag notification used (both normal and error)
    #
    foreach messages (@lstring name @message_obj mess) :
        @mess_prop_obj mp := [mess messageproperty] ;
        extract mp :
        when @ssi_mess_prop (...) -> smo += ![name string] ;
        when @sse_mess_prop (...) -> smo += ![name string] ;
        when @sde_mess_prop (...) -> smo += ![name string] ;
        when @szi_mess_prop (...) -> smo += ![name string] ;
        when @sze_mess_prop (...) -> smo += ![name string] ;
        when @rzi_mess_prop (...) -> # rmo += ![name string] ;
        when @rze_mess_prop (...) -> # rmo += ![name string] ;
        when @rui_mess_prop (...) -> rmo += ![name string] ;
        when @rqi_mess_prop (...) -> rmo += ![name string] ;
        when @rue_mess_prop (...) -> rmo += ![name string] ;
        when @rqe_mess_prop (...) -> rmo += ![name string] ;
        when @rde_mess_prop (...) -> rmo += ![name string] ;
        when @rzs_mess_prop (...) -> rmo += ![name string] ;
        else error here : "Internal error, illegal message object type" ;
        end extract ;

        @action_obj notif := [mess notification] ;
        [notif flag !?flags] ;
        notif := [mess notificationerror] ;
        [notif flag !?flags] ;
    end foreach ;

    

    @string h_tab ;
    @string i_tab ;
    obj_table !"base_sending_mo" !"send_message" !"msg" !p !smo ?h_tab ?i_tab ;
    h_res .= "\n".h_tab ;
    result .= "\n".i_tab ;
    obj_table !"base_receiving_mo" !"receive_message" !"msg" !p !rmo ?h_tab ?i_tab ;
    h_res .= "\n".h_tab ;
    result .= "\n".i_tab ;

    implementation := [implementation stringByReplacingStringByString !"$MESSAGES$" !result] ;
    header := [header stringByReplacingStringByString !"$MESSAGES$" !h_res] ;
    obj_header := [obj_header stringByReplacingStringByString !"$SEND_MESSAGE_COUNT$" ![[smo count] string]] ;
    obj_header := [obj_header stringByReplacingStringByString !"$RECEIVE_MESSAGE_COUNT$" ![[rmo count] string]] ;

    # Add the macros to Read and Reset the flags
    # and the functions to set them (internal use)

    @uint flag_count := [flags count] / 8 ;
    if ([flags count] mod 8) != 0 then
       flag_count ++ ;
    end if ;

    h_res := "" ;
    result := "" ;

    if flag_count > 0 then
        h_res := "extern u8 tpl_notification_flags[".[flag_count string]."];\n" ;

        result := "u8 tpl_notification_flags[".[flag_count string]."]\n    = { " ;
        @uint i := 1 ;
        loop flag_count :
        while i <= flag_count do
            result .= "0" ;
            if i < flag_count then result .= ", " ; end if ;
            i++ ;
        end loop ;    
        result .= " };\n" ;
        
        @uint flag_order := 0 ;
        @string flag_macros ;
        @string flag_function ;
        template ?flag_macros !"flag_macros" ;
        template ?flag_function !"flag_function" ;

        foreach flags (@string flag) :
           @string fm := flag_macros ;
           fm := [fm stringByReplacingStringByString !"$FLAGNAME$" !flag] ;
           @uint flag_elem := flag_order / 8 ;
           @uint flag_bit := flag_order mod 8 ;
           @uint flag_mask := 1 << flag_bit ;
           @uint invert_flag_mask := (~(flag_mask << 24)) >> 24 ;
           @string flag_read ;
           @string flag_reset ;
           if flag_bit == 0 then
              flag_read := "(tpl_notification_flags[".[flag_elem string]."] & 0x1)" ;
           else
              flag_read := "((tpl_notification_flags[".[flag_elem string]."] & ".[flag_mask hexString].") >> ".[flag_bit string].")"  ;
           end if ;
           flag_reset := "tpl_notification_flags[".[flag_elem string]."] &= ".[invert_flag_mask hexString];
           fm := [fm stringByReplacingStringByString !"$FLAG_READ_EXP$" !flag_read] ;
           fm := [fm stringByReplacingStringByString !"$FLAG_RESET_EXP$" !flag_reset] ;

           @string ff := flag_function ;
           ff := [ff stringByReplacingStringByString !"$FLAGNAME$" !flag] ;
           @string flag_set ;

           flag_set := "tpl_notification_flags[".[flag_elem string]."] |= ".[flag_mask hexString] ;
           ff := [ff stringByReplacingStringByString !"$FLAG_SET_EXP$" !flag_set] ;

           flag_order++ ;

           h_res .= fm ;
           result .= ff ;
        end foreach ;
    end if ;

    header := [header stringByReplacingStringByString !"$FLAGSMACROS$" !h_res] ;
    implementation := [implementation stringByReplacingStringByString !"$FLAGSFUNCTIONS$" !result] ;

end routine ;

end semantics ;
# vim:ft=ggs:ts=4:sw=4
