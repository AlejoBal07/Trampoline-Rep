semantics goil_code_msg_gen :

import semantics goil_routines in "goil_routines.ggs" ;
import semantics goil_semantic_types in "goil_semantic_types.ggs" ;
import semantics goil_targets in "goil_targets.ggs" ;

#--------------------------------------------------------------------
# Messages generation
#--------------------------------------------------------------------
routine generate_messages
    ?@message_map messages
    ?@prefix_map  unused p
    ?!@string     unused header
    ?!@string     obj_header
    ?!@string     implementation :

    @string h_res := "" ;
    @string i_res := "" ;

    #
    # first, build a map of destination message
    # list keyed by source messages.
    #
    @message_map mm := messages ;
    @ident_list_map dests [emptyMap] ;
    
    foreach mm (@lstring name @message_obj mess) do
        @mess_prop_obj mp := [mess messageproperty] ;
        @lstring src ;
        [mp s_mess ?src] ;

        if ([src string] != "") & (not [dests hasKey ![src string]]) then
           @ident_list dest_list [emptyList] ;
           foreach mm (@lstring same_name @message_obj same_mess) do
                @mess_prop_obj same_mp := [same_mess messageproperty] ;
                @lstring same_src ;
                [same_mp s_mess ?same_src] ;
                if [same_src string] == [src string] then
                    dest_list += !same_name;
                end if ;
            end foreach ;
            [!?dests add !src !dest_list] ;
        end if ;
    end foreach ;

#    foreach dests (@lstring src @ident_list d_mess) do
##        message [src string].": " ;
#        foreach d_mess (@lstring dst) do
#            message "[".[dst string]."] ";
#        end foreach ;
##        message "\n" ;
#    end foreach ;

    @string result := "" ;

    @message_map extern_mess := messages ;

    # generate the code of the message objects in the
    # good order.
    foreach dests (@lstring src @ident_list d_mess) do
        @ident_list dm := d_mess ;

#        foreach dm (@lstring mn) do
#            message "[".[mn string]."]" ;
#        end foreach ;

#        message "\n" ;

        loop [dm length] :
        while [dm length] > 0 do
            @lstring mname ;
            @message_obj mess ;
            [!?dm popLast ?mname] ;
            [messages get !mname ?mess] ;
            # remove from the extern message map
            [!?extern_mess del !mname ?*] ;
            @mess_prop_obj mp := [mess messageproperty] ;
            [mp generate !mname !mess !messages !dests ?h_res ?i_res] ;
            result .= i_res ;
        end loop ;

        # remove from the extern message map
        [!?extern_mess del !src ?*] ;

        @lstring mname ;
        @message_obj mess ;
        [messages get !src ?mess] ;
        @mess_prop_obj mp := [mess messageproperty] ;
        [mp generate !src !mess !messages !dests ?h_res ?i_res] ;
        result .= i_res ;
    end foreach ;

    # generate the external messages
    foreach extern_mess (@lstring name @message_obj mess) do
        @mess_prop_obj mp := [mess messageproperty] ;
        [mp generate !name !mess !messages !dests ?h_res ?i_res] ;
        result .= i_res ;
    end foreach ;

#    foreach messages (@lstring name @message_obj mess) do
#       @mess_prop_obj mp := [mess messageproperty] ;
#       [mp generate !p !name !mess !messages !dests ?h_res ?i_res] ;
#       message i_res ;
#       result .= i_res ;
#    end foreach ;

    @stringset smo [emptySet] ;
    @stringset rmo [emptySet] ;
    @stringset flags [emptySet] ;
    #
    # Build 2 stringsets, 1 of the sending and 1 of the receiving message objects
    # Build also a stringset of flag notification used (both normal and error)
    #
    foreach messages (@lstring name @message_obj mess) do
        @mess_prop_obj mp := [mess messageproperty] ;
        cast mp :
        when == @ssi_mess_prop do smo += ![name string] ;
        when == @sse_mess_prop do smo += ![name string] ;
        when == @sde_mess_prop do smo += ![name string] ;
        when == @szi_mess_prop do smo += ![name string] ;
        when == @sze_mess_prop do smo += ![name string] ;
        when == @rzi_mess_prop do # rmo += ![name string] ;
        when == @rze_mess_prop do # rmo += ![name string] ;
        when == @rui_mess_prop do rmo += ![name string] ;
        when == @rqi_mess_prop do rmo += ![name string] ;
        when == @rue_mess_prop do rmo += ![name string] ;
        when == @rqe_mess_prop do rmo += ![name string] ;
        when == @rde_mess_prop do rmo += ![name string] ;
        when == @rzs_mess_prop do rmo += ![name string] ;
        else error here : "Internal error, illegal message object type" ;
        end cast ;

        @action_obj notif := [mess notification] ;
        [notif flag !?flags] ;
        notif := [mess notificationerror] ;
        [notif flag !?flags] ;
    end foreach ;

    

    @string h_tab := "" ;
    @string i_tab := "" ;

    foreach smo (@string name) :n
    before
      i_tab := "CONSTP2VAR(tpl_base_sending_mo, AUTOMATIC, OS_APPL_DATA)\n" ;
      i_tab .= "  tpl_send_message_table[SEND_MESSAGE_COUNT] = {\n" ;
    do
      message name."\n";
      i_tab .= "  (tpl_base_sending_mo *)&".name."_message" ;
      h_tab .= "#define ".name."_id ".[n string]."\n" ;
      h_tab .= "CONST(MessageIdentifier, AUTOMATIC) ".name." = ".name."_id;\n" ;
    between
      i_tab .= ",\n" ;
    after
      i_tab .= "\n};\n" ;
    end foreach ;

    h_res .= "\n".h_tab ;
    result .= "\n".i_tab ;
    h_tab := "";
    i_tab := "";

    foreach rmo (@string name) :n
    before
      i_tab := "CONSTP2VAR(tpl_base_receiving_mo, AUTOMATIC, OS_APPL_DATA)\n" ;
      i_tab .= "  tpl_receive_message_table[RECEIVE_MESSAGE_COUNT] = {\n" ;
      h_tab := "" ;
    do
      i_tab .= "  (tpl_base_receiving_mo *)&".name."_message" ;
      h_tab .= "#define ".name."_id ".[n string]."\n" ;
      h_tab .= "CONST(MessageIdentifier, AUTOMATIC) ".name." = ".name."_id;\n" ;
    between
      i_tab .= ",\n" ;
    after
      i_tab .= "\n};\n" ;
    end foreach ;

    h_res .= "\n".h_tab ;
    result .= "\n".i_tab ;

    message result;
    message h_res;

    doReplace !?implementation !"$MESSAGES$" !result ;
    doReplace !?implementation !"$MESSAGEIDS$" !h_res ;
    doReplace !?obj_header !"$SEND_MESSAGE_COUNT$" ![[smo count] string] ;
    doReplace !?obj_header !"$RECEIVE_MESSAGE_COUNT$" ![[rmo count] string] ;

    # Add the macros to Read and Reset the flags
    # and the functions to set them (internal use)

    @uint flag_count := [flags count] / 8 ;
    if ([flags count] mod 8) != 0 then
       flag_count ++ ;
    end if ;

    h_res := "" ;
    result := "" ;

    if flag_count > 0 then
        h_res := "extern u8 tpl_notification_flags[".[flag_count string]."];\n" ;

        result := "u8 tpl_notification_flags[".[flag_count string]."]\n    = { " ;
        @uint i := 1 ;
        loop flag_count :
        while i <= flag_count do
            result .= "0" ;
            if i < flag_count then result .= ", " ; end if ;
            i++ ;
        end loop ;    
        result .= " };\n" ;
        
        @uint flag_order := 0 ;
        @string flag_macros ;
        @string flag_function ;
        retrieveTemplateString ?flag_macros !"flag_macros" ;
        retrieveTemplateString ?flag_function !"flag_function" ;

        foreach flags (@string flag) do
           @string fm := flag_macros ;
           doReplace !?fm !"$FLAGNAME$" !flag ;
           @uint flag_elem := flag_order / 8 ;
           @uint flag_bit := flag_order mod 8 ;
           @uint flag_mask := 1 << flag_bit ;
           @uint invert_flag_mask := (~(flag_mask << 24)) >> 24 ;
           @string flag_read ;
           @string flag_reset ;
           if flag_bit == 0 then
              flag_read := "(tpl_notification_flags[".[flag_elem string]."] & 0x1)" ;
           else
              flag_read := "((tpl_notification_flags[".[flag_elem string]."] & ".[flag_mask hexString].") >> ".[flag_bit string].")"  ;
           end if ;
           flag_reset := "tpl_notification_flags[".[flag_elem string]."] &= ".[invert_flag_mask hexString];
           doReplace !?fm !"$FLAG_READ_EXP$" !flag_read ;
           doReplace !?fm !"$FLAG_RESET_EXP$" !flag_reset ;

           @string ff := flag_function ;
           doReplace !?ff !"$FLAGNAME$" !flag ;
           @string flag_set ;

           flag_set := "tpl_notification_flags[".[flag_elem string]."] |= ".[flag_mask hexString] ;
           doReplace !?ff !"$FLAG_SET_EXP$" !flag_set ;

           flag_order++ ;

           h_res .= fm ;
           result .= ff ;
        end foreach ;
    end if ;

    doReplace !?header !"$FLAGSMACROS$" !h_res ;
    doReplace !?implementation !"$FLAGSFUNCTIONS$" !result ;

end routine ;

end semantics ;
# vim:ft=ggs:ts=4:sw=4
