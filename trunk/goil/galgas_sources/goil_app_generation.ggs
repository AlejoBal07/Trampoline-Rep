#
# @file goil_app_generation.ggs
#
# @section File description
#
# This file contains routines to generate the OS Application data.
#
# @section Copyright
#
# Trampoline OS
#
# Trampoline is copyright (c) IRCCyN 2005+
# Trampoline is protected by the french intellectual property law.
#
# goil is distributed under the GNU Public Licence V2
#
# @section File informations
#
# $Date$
# $Rev$
# $Author$
# $URL$
#

semantics goil_app_generation :

import semantics goil_types_app in "goil_types_app.ggs" ;
import semantics goil_types_task in "goil_types_task.ggs" ;
import semantics goil_types_isr in "goil_types_isr.ggs" ;
import semantics goil_semantic_types in "goil_semantic_types.ggs" ;
import semantics goil_types_resource in "goil_types_resource.ggs" ; 
import semantics goil_types_scheduletable in "goil_types_scheduletable.ggs" ;
import semantics goil_types_counter in "goil_types_counter.ggs" ;
import semantics goil_routines in "goil_routines.ggs" ;


#
# generate_vect generates a binary vector from its
# string representation
#
routine generate_vector
  ?@string vec
  !@string res
  !@uint   byte_count
:
  # compute the number of bytes used
  byte_count := [vec length] / 8 ;
  if [vec length] mod 8 != 0 then byte_count++ ; end if ;

  @stringlist data [emptyList] ;
  @uint i := 0 ;
  @uint start := 0 ;

  # get each byte
  loop byte_count :
  while i < byte_count do
    @string byte := [[vec subString !start !8] reversedString] ;
    @uint bit_pos := 0 ;
    @uint val := 0;
    # get each bit
    loop 8 :
    while bit_pos < [byte length] do
      @char bit := [byte characterAtIndex !bit_pos] ;
      val := val << 1 ;
      if bit == '1' then
        val++ ;
      end if ;
      bit_pos++ ;
    end loop ;
    data += ![val string] ;
    i++ ;
    start := start + 8 ;
  end loop ;
  res := [@string componentsJoinedByString !data !","] ;
end routine ;

routine generate_apps
  ?@app_map           apps
  ?@task_map          tasks
  ?@isr_map           isrs
  ?@alarm_map         alarms
  ?@resource_map      rezs
  ?@scheduletable_map sts
  ?@counter_map       cnts
  ?!@string unused    head
  ?!@string           obj_head
  ?!@string           imp
:

 @string res := "" ;
  @stringlist app_list [emptyList] ;
  @string ids := "" ;

# set up the application count
  doReplace !?obj_head !"$APP_COUNT$" ![[apps count] string] ;

  if [apps count] > 0 then
# Build the descriptor of the app
# First, sort the task as in the task table
  @tasks_by_type stasks [emptySortedList];
# sort tasks according to type (basic or extended)
  foreach tasks do
    if [[task events] length] > 0 then
      stasks += !0 ![key string] ;
    else
      stasks += !1 ![key string] ;
    end if ;
  end foreach ;


  foreach apps (@lstring app_name @app_obj app) :n do
    app_list += !"&".[app_name string]."_app_access" ;
    ids .= "#define ".[app_name string]."_id ".[n string]."\n" ;
    ids .= "CONST(ApplicationType, OS_APPL_CONST) ".[app_name string]." = ".[app_name string]."_id;\n" ;
    # vectors store all the bit vectors
    @string vectors := "" ;
    @string vec := "" ;
    @string init ;
    @uint count ;
    @string tpl ;
    retrieveTemplateString ?tpl !"app" ;

    doReplace !?tpl !"$APP_NAME$" ![app_name string] ;

#------------------------------------------------------------------------------
# tasks first
    foreach stasks do
# bit that flag ownership
      if [[app tasks] hasKey !name] then
        vec .= "11" ;
      else
        vec .= "0" ; 
# bit that flag access
        @task_obj t ;
        [tasks get ![@lstring new !name !here] ?t] ;
        @bool found ;
        is_in_lstringlist ![t acc_apps] !app_name ?* ?found ;
        if found then vec .= "1" ; else vec .= "0" ; end if ;
      end if ;
    end foreach ;

# ISRs in the same vector
    foreach isrs do
      if [[app isrs] hasKey ![key string]] then
        vec .= "11" ;
      else
        vec .= "0" ;
        @bool found ;
        is_in_lstringlist ![isr acc_apps] !app_name ?* ?found ;
        if found then vec .= "1" ; else vec .= "0" ; end if ;
      end if ;
    end foreach ;
   
#IDLE task can access to every OS-Application (for autostarting Schedule table...)
    vec .= "01" ;  
#    message vec."\n" ;

    generate_vector !vec ?init ?count ;
    if count > 0 then
      vectors .= "u8 ".[app_name string]."_procs_access[".[count string]."] = {".init."};\n" ;
      doReplace !?tpl !"$PROC_ACCESS$" ![app_name string]."_procs_access" ;
    else
      doReplace !?tpl !"$PROC_ACCESS$" !"NULL" ;
    end if ;
#------------------------------------------------------------------------------
# Alarms
    vec := "" ;
    foreach alarms do
      if [[app alarms] hasKey ![key string]] then
        vec .= "11" ;
      else
        vec .= "0" ;
        @bool found ;
        is_in_lstringlist ![alarm acc_apps] !app_name ?* ?found ;
        if found then vec .= "1" ; else vec .= "0" ; end if ;
      end if ;
    end foreach ;
#    message vec."\n" ;

    generate_vector !vec ?init ?count ;
    if count > 0 then
      vectors .= "u8 ".[app_name string]."_alarms_access[".[count string]."] = {".init."};\n" ;
      doReplace !?tpl !"$ALARM_ACCESS$" ![app_name string]."_alarms_access" ;
    else
      doReplace !?tpl !"$ALARM_ACCESS$" !"NULL" ;
    end if ;

#------------------------------------------------------------------------------
# Resources
    vec := "" ;
    foreach rezs do
      if [[app resources] hasKey ![key string]] then
        vec .= "11" ;
      else
        vec .= "0" ;
        @bool found ;
        is_in_lstringlist ![resource acc_apps] !app_name ?* ?found ;
        if found then vec .= "1" ; else vec .= "0" ; end if ;
      end if ;
    end foreach ;

    # add the res_scheduler
    vec .= "10" ;

#    message vec."\n" ;

    generate_vector !vec ?init ?count ;
    if count > 0 then
      vectors .= "u8 ".[app_name string]."_rezs_access[".[count string]."] = {".init."};\n" ;
      doReplace !?tpl !"$REZ_ACCESS$" ![app_name string]."_rezs_access" ;
    else
      doReplace !?tpl !"$REZ_ACCESS$" !"NULL" ;
    end if ;

#------------------------------------------------------------------------------
# Schedule tables
    vec := "" ;
    foreach sts do
      if [[app schedtables] hasKey ![key string]] then
        vec .= "11" ;
      else
        vec .= "0" ;
        @bool found ;
        is_in_lstringlist ![st acc_apps] !app_name ?* ?found ;
        if found then vec .= "1" ; else vec .= "0" ; end if ;
      end if ;
    end foreach ;

    generate_vector !vec ?init ?count ;
    if count > 0 then
      vectors .= "u8 ".[app_name string]."_sts_access[".[count string]."] = {".init."};\n" ;
      doReplace !?tpl !"$ST_ACCESS$" ![app_name string]."_sts_access" ;
    else
      doReplace !?tpl !"$ST_ACCESS$" !"NULL" ;
    end if ;

#------------------------------------------------------------------------------
# Counters
    vec := "" ;
    foreach cnts do
      if [[app counters] hasKey ![key string]] then
        vec .= "11" ;
      else
        vec .= "0" ;
        @bool found ;
        is_in_lstringlist ![counter acc_apps] !app_name ?* ?found ;
        if found then vec .= "1" ; else vec .= "0" ; end if ;
      end if ;
    end foreach ;

    generate_vector !vec ?init ?count ;
    if count > 0 then
      vectors .= "u8 ".[app_name string]."_cnts_access[".[count string]."] = {".init."};\n" ;
      doReplace !?tpl !"$CNT_ACCESS$" ![app_name string]."_cnts_access" ;
    else
      doReplace !?tpl !"$CNT_ACCESS$" !"NULL" ;
    end if ;

    doReplace !?tpl !"$ACCESS_VEC$" !vectors ;

# Build the ownership tables
    @string ownership_vec := "" ;
    @lstringlist procs := [[app tasks] keyList] . [[app isrs] keyList] ;
    @string table := "" ;
    foreach procs (@lstring item)
    before  table := "tpl_proc_id ".[app_name string]."_proc_own [".[[procs length] string]."] = {" ;
    do      table .= [item string]."_id" ;
    between table .= "," ;
    after   table .= "};\n" ;
    end foreach ;
    ownership_vec .= table ;
    doReplace !?tpl !"$PROC_COUNT$" ![[procs length] string] ;
    if table != "" then
      doReplace !?tpl !"$PROC_OWNERSHIP$" ![app_name string]."_proc_own" ;
    else 
      doReplace !?tpl !"$PROC_OWNERSHIP$" !"NULL" ;
    end if ;

    table := "" ;
    foreach [app alarms]
    before  table := "tpl_alarm_id ".[app_name string]."_alarm_own [".[[[app alarms] count] string]."] = {" ;
    do      table .= [key string]."_id" ;
    between table .= "," ;
    after   table .= "};\n" ;
    end foreach ;
    ownership_vec .= table ;
    doReplace !?tpl !"$ALARM_COUNT$" ![[[app alarms] count] string] ;
    if table != "" then
      doReplace !?tpl !"$ALARM_OWNERSHIP$" ![app_name string]."_alarm_own" ;
    else 
      doReplace !?tpl !"$ALARM_OWNERSHIP$" !"NULL" ;
    end if ;

    table := "" ;
    foreach [app resources]
    before  table := "tpl_resource_id ".[app_name string]."_rez_own [".[[[app resources] count] string]."] = {" ;
    do      table .= [key string]."_id" ;
    between table .= "," ;
    after   table .= "};\n" ;
    end foreach ;
    ownership_vec .= table ;
    doReplace !?tpl !"$REZ_COUNT$" ![[[app resources] count] string] ;
    if table != "" then
      doReplace !?tpl !"$REZ_OWNERSHIP$" ![app_name string]."_rez_own" ;
    else 
      doReplace !?tpl !"$REZ_OWNERSHIP$" !"NULL" ;
    end if ;

    table := "" ;
    foreach [app schedtables]
    before  table := "tpl_schedtable_id ".[app_name string]."_st_own [".[[[app schedtables] count] string]."] = {" ;
    do      table .= [key string]."_id" ;
    between table .= "," ;
    after   table .= "};\n" ;
    end foreach ;
    ownership_vec .= table ;
    doReplace !?tpl !"$ST_COUNT$" ![[[app schedtables] count] string] ;
    if table != "" then
      doReplace !?tpl !"$ST_OWNERSHIP$" ![app_name string]."_st_own" ;
    else 
      doReplace !?tpl !"$ST_OWNERSHIP$" !"NULL" ;
    end if ;

    table := "" ;
    foreach [app counters]
    before  table := "tpl_counter_id ".[app_name string]."_cnt_own [".[[[app counters] count] string]."] = {" ;
    do      table .= [key string]."_id" ;
    between table .= "," ;
    after   table .= "};\n" ;
    end foreach ;
    ownership_vec .= table ;
    doReplace !?tpl !"$CNT_COUNT$" ![[[app counters] count] string] ;
    if table != "" then
      doReplace !?tpl !"$CNT_OWNERSHIP$" ![app_name string]."_cnt_own" ;
    else 
      doReplace !?tpl !"$CNT_OWNERSHIP$" !"NULL" ;
    end if ;

#
# Restart task, INVALID_TASK if no retart task specified
#
    cast [app restart] :
    when == @string_class rst do
      doReplace !?tpl !"$RESTART$" ![rst value]."_id" ;
    else
      doReplace !?tpl !"$RESTART$" !"INVALID_TASK_ID" ;
    end cast ;

    doReplace !?tpl !"$OWNERSHIP_VEC$" !ownership_vec ;

#    log tpl ;
    res .= tpl ;    
  end foreach ;
  
  res .= "CONSTP2CONST(tpl_app_access, AUTOMATIC, OS_APPL_CONST) tpl_app_table[APP_COUNT] = {\n" ;
  res .= "  ".[@string componentsJoinedByString !app_list !",\n  "] ;
  res .= "\n};\n" ;

  end if ;

  doReplace !?imp !"$OSAPPLICATIONS$" !res ; 
  doReplace !?imp !"$OSAPPIDS$" !ids ;

end routine ;

#
# generate_trusted_functions generates the data structures
# used for Trusted Functions : table and ids
#
routine generate_trusted_functions
  ?@app_map           apps
  ?!@string unused    head
  ?!@string           obj_head
  ?!@string           imp
:
  @stringset tfs [emptySet] ;

  foreach apps do
    cast [app trusted] :
    when == @app_trusted_true t do
      foreach [t trusted_fcts] (@string s) do
        tfs += !s ;
      end foreach ;
    else end cast ;
  end foreach ;

  @string fcts := "" ;
  @string fct_ids := "" ;
  @string fct_table := "" ;
  @uint tf_id := 0 ;

  foreach tfs (@string s)
  before
    fct_table := "CONST(tpl_trusted_fct, OS_APPL_CODE)\n" ;
    fct_table .= "  tpl_trusted_fct_table[TRUSTED_FCT_COUNT] = {\n" ;
  do
    fcts .= "FUNC(void, OS_APPL_CODE) TRUSTED_".s."(\n" ;
    fcts .= "  CONST(TrustedFunctionIndexType, AUTOMATIC) idx,\n" ;
    fcts .= "  CONST(TrustedFunctionParameterRefType, AUTOMATIC) params);\n" ;
    fct_ids .= "#define ".s."_id    ".[tf_id string]."\n" ;
    fct_ids .= "CONST(TrustedFunctionIndexType, AUTOMATIC) ".s." = ".s."_id;\n" ;
    fct_table .= "  TRUSTED_".s ;
    tf_id++ ;
  between
    fct_table .= ",\n" ;
  after
    fct_table .= "\n};\n" ;
  end foreach ;

  doReplace !?imp !"$TRUSTED_IDS$" !fct_ids ;
  doReplace !?imp !"$TRUSTED_FCTS$" !fcts ;
  doReplace !?imp !"$TRUSTED_TABLE$" !fct_table ;
  doReplace !?obj_head !"$TRUSTED_FCT_COUNT$" ![tf_id string] ;
end routine ;

end semantics ;
