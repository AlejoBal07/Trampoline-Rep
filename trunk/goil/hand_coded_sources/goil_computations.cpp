//---------------------------------------------------------------------------*
//                                                                           *
//                               goil Project                                *
//                   Generated by GALGAS Project Creation                    *
//                       june 1st, 2006, at 15h40'43"                        *
//                                                                           *
//---------------------------------------------------------------------------*

#include "goil_semantics.h"
#include "utilities/MF_MemoryControl.h"

//---------------------------------------------------------------------------*

const char *generatedBy = 
"/*\n"
" * Header file for %s\n"
" *\n"
" * Generated by goil\n"
" */\n\n";


void
routine_generateHeader(
    C_Lexique &inLex,
    GGS_lstring inVersion,
    GGS_lstring inDesc
    COMMA_LOCATION_ARGS)
{
    if (inLex.currentFileErrorsCount() == 0) {
        C_String outFile =
            inLex.sourceFileName().stringByDeletingPathExtension() + ".h" ;
        C_String multiInclude =
            inLex.sourceFileName().lastPathComponent().stringByDeletingPathExtension();
//        printf("%s\n",outFile.cString());
        /*  Open the Header File    */
        FILE *hf = fopen(outFile.cString(),"w");
        if (hf) {
            fprintf(hf,"%s",generatedBy);
            fprintf(hf,"#ifndef __%s_H__\n",multiInclude.cString());
            fprintf(hf,"#define __%s_H__\n\n",multiInclude.cString());
            fprintf(hf,"/*  %s  */\n",inDesc.cString());
            fprintf(hf,"#define OIL_VERSION \"%s\"\n",inVersion.cString());
            
            fprintf(hf,"\n#endif\n");
            fclose(hf);
        }
    }
}

//---------------------------------------------------------------------------*

/*
 * Generate the alarms header and implementation files
 */
void
routine_generateAlarms(
    C_Lexique &inLex,
    GGS_alarm_map in_alarm_map
    COMMA_LOCATION_ARGS)
{
    GGS_alarm_map::element_type *alarm = in_alarm_map.firstObject();
    while (alarm != NULL) {
        macroValidPointer(alarm);
        const GGS_lstring &alarm_name       = alarm->mKey;
        const GGS_lstring &counter_name     = alarm->mInfo.alarm(HERE)->counter_name;
        GGS_action_obj    &action_params    = alarm->mInfo.alarm(HERE)->action_params;
//        GGS_autostart_obj &autostart_params = alarm->mInfo.alarm(HERE)->autostart_params;
        printf("/*\n");
        printf(" * Initialisation of alarm %s\n",alarm_name.cString());
        printf(" *\n");
        printf(" * Generated by goil from %s\n",alarm_name.locationString().cString());
        printf(" */\n\n");
        printf("extern tpl_counter counter_descriptor_of_%s;\n\n",counter_name.cString());
        printf("tpl_alarm alarm_descriptor_of_%s = {\n",alarm_name.cString());
        printf("    /* State of the alarm   */  ALARM_SLEEP,\n");
        if (dynamic_cast <cPtr_setevent_action *>(action_params.getPtr()) != NULL) {
            cPtr_setevent_action *setevent_action = dynamic_cast <cPtr_setevent_action *>(action_params.getPtr());
            C_String &task_name = setevent_action->task_name;
            C_String &event_name = setevent_action->event_name;
            printf("    /* kind of the alarm    */  ALARM_EVENT_SETTING,\n");
            printf("                                {\n");
            printf("                                    {\n");
            printf("                                        (tpl_callback_func)&task_descriptor_of_%s\n",task_name.cString());
            printf("                                    },\n");
            printf("                                    %s_value\n",event_name.cString());
            printf("                                },\n");
        }
        else if (dynamic_cast <cPtr_activatetask_action *>(action_params.getPtr()) != NULL) {
            cPtr_activatetask_action *activatetask_action = dynamic_cast <cPtr_activatetask_action *>(action_params.getPtr());
            C_String &task_name = activatetask_action->task_name;
            printf("    /* kind of the alarm    */  ALARM_TASK_ACTIVATION,\n");
            printf("                                {\n");
            printf("                                    {\n");
            printf("                                        (tpl_callback_func)&task_descriptor_of_%s\n",task_name.cString());
            printf("                                    },\n");
            printf("                                    0\n");
            printf("                                },\n");
        }
        else if (dynamic_cast <cPtr_callback_action *>(action_params.getPtr()) != NULL) {
            printf("    /* kind of the alarm    */  ALARM_CALLBACK,\n");
            printf("                                {\n");
            printf("                                    {\n");
            printf("                                    },\n");
            printf("                                    0\n");
            printf("                                },\n");
        }
        printf("    /* pointer to counter   */  &counter_descriptor_of_%s,\n",counter_name.cString());
        printf("};\n\n");
        alarm = alarm->nextObject();
    }
}