//---------------------------------------------------------------------------*
//                                                                           *
//                               goil Project                                *
//                   Generated by GALGAS Project Creation                    *
//                       june 1st, 2006, at 15h40'43"                        *
//                                                                           *
//---------------------------------------------------------------------------*

#include "goil_semantics.h"
#include "utilities/MF_MemoryControl.h"

//---------------------------------------------------------------------------*

const char *generatedBy = 
"/*\n"
" * Header file for %s\n"
" *\n"
" * Generated by goil\n"
" */\n\n";

const C_String alarm_name   = "$ALARM_NAME$";
const C_String alarm_state  = "$ALARM_STATE$";
const C_String alarm_cycle  = "$ALARM_CYCLE$";
const C_String alarm_date   = "$ALARM_DATE$";

const C_String event_name   = "$EVENT_NAME$";

const C_String task_name    = "$TASK_NAME$";
const C_String counter_name = "$COUNTER_NAME$";

void
routine_generateHeader(
    C_Lexique &inLex,
    GGS_lstring inVersion,
    GGS_lstring inDesc
    COMMA_LOCATION_ARGS)
{
    if (inLex.currentFileErrorCount() == 0) {
        C_String outFile =
            inLex.sourceFileName().stringByDeletingPathExtension() + ".h" ;
        C_String multiInclude =
            inLex.sourceFileName().lastPathComponent().stringByDeletingPathExtension();
//        printf("%s\n",outFile.cString());
        /*  Open the Header File    */
        FILE *hf = fopen(outFile.cString(),"w");
        if (hf) {
            fprintf(hf,"%s",generatedBy);
            fprintf(hf,"#ifndef __%s_H__\n",multiInclude.cString());
            fprintf(hf,"#define __%s_H__\n\n",multiInclude.cString());
            fprintf(hf,"/*  %s  */\n",inDesc.cString());
            fprintf(hf,"#define OIL_VERSION \"%s\"\n",inVersion.cString());
            
            fprintf(hf,"\n#endif\n");
            fclose(hf);
        }
    }
}

//---------------------------------------------------------------------------*

/*
 * Generate the alarms header and implementation files
 */
void
routine_generateAlarms(
    C_Lexique &inLex,
    GGS_alarm_map in_alarm_map
    COMMA_LOCATION_ARGS)
{
    GGS_alarm_map::element_type *alarm = in_alarm_map.firstObject();
    while (alarm != NULL) {
        macroValidPointer(alarm);
        const GGS_lstring &g_alarm_name       = alarm->mKey;
        const GGS_lstring &g_counter_name     = alarm->mInfo.alarm(HERE)->counter_name;
        GGS_action_obj    &g_action_params    = alarm->mInfo.alarm(HERE)->action_params;
        //GGS_autostart_obj &autostart_params   = alarm->mInfo.alarm(HERE)->autostart_params;
        
        C_String result = "";
        
        if (dynamic_cast <cPtr_setevent_action *>(g_action_params.getPtr()) != NULL) {
            cPtr_setevent_action *setevent_action =
                dynamic_cast <cPtr_setevent_action *>(g_action_params.getPtr());
            C_String &g_task_name = setevent_action->task_name;
            C_String &g_event_name = setevent_action->event_name;
            C_String tplfile = "../templates/alarm_event_set.tpl";
            C_String tpl = C_String::stringWithContentOfFile(tplfile);
            result = tpl.stringByReplacingStringByString(alarm_name,g_alarm_name);
            result = result.stringByReplacingStringByString(task_name,g_task_name);
            result = result.stringByReplacingStringByString(event_name,g_event_name);
            result = result.stringByReplacingStringByString(counter_name,g_counter_name);
        }
        else if (dynamic_cast <cPtr_activatetask_action *>(g_action_params.getPtr()) != NULL) {
//            cPtr_activatetask_action *activatetask_action = dynamic_cast <cPtr_activatetask_action *>(g_action_params.getPtr());
//            C_String &g_task_name = activatetask_action->task_name;
        }
        else if (dynamic_cast <cPtr_callback_action *>(g_action_params.getPtr()) != NULL) {
        }
        
        if (dynamic_cast <cPtr_autostart_void *>(g_action_params.getPtr()) != NULL) {
            result = result.stringByReplacingStringByString(alarm_state,"ALARM_SLEEP");
        }
        else {
//            cPtr_autostart_true_params *auto_start =
                dynamic_cast <cPtr_autostart_true_params *>(g_action_params.getPtr());
            //C_String &g_alarm_time = auto_start->alarm_time;
            //C_String &g_cycle_time = auto_start->cycle_time;
            result = result.stringByReplacingStringByString(alarm_state,"ALARM_READY");
            //result = result.stringByReplacingStringByString(alarm_cycle,g_alarm_time);
            //result = result.stringByReplacingStringByString(alarm_date,g_cycle_time);
        }
        
        printf("%s",result.cString());

        alarm = alarm->nextObject();
    }
}