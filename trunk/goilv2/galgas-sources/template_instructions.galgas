#---------------------------------------------------------------------------*
#                                                                           *
#  GOIL Template parser                                                     *
#                                                                           *
#  Copyright (C) 2014+ IRCCyN.                                              *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @gtlVarItem { @lstring itemName }
class @gtlVarItemField : @gtlVarItem { @lstring field }
class @gtlVarItemKey :   @gtlVarItem { @lstring key   }
class @gtlVarItemIdx :   @gtlVarItem { @lsint   idx   }

list @gtlVarPath {
  @gtlVarItem item
}

map @gtlVarMap {
  @gtlData mValue 
  insert put error message "a variable or field named '%K' is already declared in %L"
  search get error message "there is no variable or field named '%K'"
  remove del error message "there is no variable or field named '%K' to delete"
}

proc setVarInPath 
  ?@gtlVarPath path
  ?!@gtlVarMap fieldMap
  ?let @gtlData data
{
  # get the first item of the variable path
  [!?path popFirst ?@gtlVarItem item]
  @lstring varName = [item itemName]
  if [fieldMap hasKey ![varName string]] then
    [fieldMap get !varName ?@gtlData fieldValue]
    if fieldValue is == @gtlMap then
      # then referenced field is a map
      if item is == @gtlVarItemKey then
        # a key has been defined for the map,
        @gtlVarMap items = [fieldValue as @gtlMap value]
        if [items hasKey ![[item as @gtlVarItemKey key] string]] then
          @lstring key = [item as @gtlVarItemKey key]
          if [path length] == 0 then
            [!?items setMValueForKey !data ![key string]]
          else
            [items get !key ?@gtlData keyedItem]
            @gtlMap keyedMapItem = keyedItem as @gtlMap
            @gtlVarMap nextFieldMap = [keyedMapItem value]
            setVarInPath(!path !?nextFieldMap !data)
            [!?keyedMapItem setValue !nextFieldMap]
            [!?items setMTypeForKey !itemType ![key string]]
            [!?items setMValueForKey !itemValue ![key string]]
          end
        else
          if [path length] == 0 then
            [!?items insertKey !key !expressionType !enumeratedValue]
          else
            var nextFieldMap =@TfieldMap.emptyMap{}
            setVariableInPath ( !path !?nextFieldMap !expressionType !enumeratedValue)
            [!?items insertKey !key !@Ttype. structType !valueWithStruct(!nextFieldMap !emptyLString())]
          end
        end
        fieldValue.mStructValue = items
        [!?ioFieldMap setMTypeForKey !fieldType ![varName string]]
        [!?ioFieldMap setMValueForKey !fieldValue ![varName string]]
      else # no key has been defined, the type is changed to
        if [path length] == 0 then
          # the actual type
          [!?ioFieldMap setMTypeForKey !expressionType ![varName string]]
          [!?ioFieldMap setMValueForKey !enumeratedValue ![varName string]]
        else
          # a struct type
          var nextFieldMap =@TfieldMap.emptyMap{}
          setVariableInPath ( !path !?nextFieldMap !expressionType !enumeratedValue)
          [!?ioFieldMap setMTypeForKey !@Ttype. structType ![varName string]]
          [!?ioFieldMap setMValueForKey !valueWithStruct(!nextFieldMap !emptyLString()) ![varName string]]
        end
      end
    elsif fieldType == @Ttype. listType then
      # then referenced field is a list
      if [idx sint] != -1s then
        if [path length] == 0 then
          if expressionType == @Ttype. structType then
            # ok, trying to put a struct in a list item
            @TfieldMapList theList = [fieldValue mMapListValue]
            [!?theList setMMapAtIndex ![enumeratedValue mStructValue] ![idx uint]]
            fieldValue.mMapListValue = theList
          else
            # it is an error to put something else than a struct in a list item
            error varName: "struct expression expected"
          end
        else
          # an item of the list is referenced, get it
          @TfieldMapList theList = [fieldValue mMapListValue]
          @TfieldMap nextFieldMap = [theList mMapAtIndex ![idx uint]]
          setVariableInPath ( !path !?nextFieldMap !expressionType !enumeratedValue)
          [!?theList setMMapAtIndex !nextFieldMap ![idx uint]]
          fieldValue.mMapListValue = theList
        end
        [!?ioFieldMap setMTypeForKey !fieldType ![varName string]]
        [!?ioFieldMap setMValueForKey !fieldValue ![varName string]]
      else
        # this is the whole list
        if [path length] == 0 then
          # the actual type
          [!?ioFieldMap setMTypeForKey !expressionType ![varName string]]
          [!?ioFieldMap setMValueForKey !enumeratedValue ![varName string]]
        else
          # a struct type
          var nextFieldMap =@TfieldMap.emptyMap{}
          setVariableInPath ( !path !?nextFieldMap !expressionType !enumeratedValue)
          [!?ioFieldMap setMTypeForKey !@Ttype. structType ![varName string]]
          [!?ioFieldMap setMValueForKey !valueWithStruct(!nextFieldMap !emptyLString()) ![varName string]]
        end
      end
    elsif fieldType == @Ttype. structType then
      if [path length] == 0 then
        # the type is changed to the actual type
        [!?ioFieldMap setMTypeForKey !expressionType ![varName string]]
        [!?ioFieldMap setMValueForKey !enumeratedValue ![varName string]]
      else
        # the existing struct is got
        @TfieldMap nextFieldMap = [fieldValue mStructValue]
        setVariableInPath ( !path !?nextFieldMap !expressionType !enumeratedValue)
        # and updated
        fieldValue.mStructValue = nextFieldMap
        [!?ioFieldMap setMValueForKey !fieldValue ![varName string]]
      end
    else
      if [key string] == "" then
        if [idx sint] == -1s then
          if [path length] == 0 then
            # the type is changed to the actual type
            [!?ioFieldMap setMTypeForKey !expressionType ![varName string]]
            [!?ioFieldMap setMValueForKey !enumeratedValue ![varName string]]
          else
            var nextFieldMap =@TfieldMap.emptyMap{}
            setVariableInPath ( !path !?nextFieldMap !expressionType !enumeratedValue)
            [!?ioFieldMap setMTypeForKey !@Ttype. structType ![varName string]]
            [!?ioFieldMap setMValueForKey !valueWithStruct(!nextFieldMap !emptyLString()) ![varName string]]
          end
        else
          # it is an error to set an item of a list it the list does not exist
          error varName: "A list must exist before setting one of its item"
        end
      else
        # create a map
        var newMap =@TfieldMap.emptyMap{}
        if [path length] == 0 then
          [!?newMap insertKey !key !expressionType !enumeratedValue]
        else
          var nextFieldMap =@TfieldMap.emptyMap{}
          setVariableInPath ( !path !?nextFieldMap !expressionType !enumeratedValue)
          [!?newMap insertKey !key !@Ttype. structType !valueWithStruct(!nextFieldMap !emptyLString())]
        end
        [!?ioFieldMap setMTypeForKey !@Ttype. mapType ![varName string]]
        [!?ioFieldMap setMValueForKey !valueWithMap(!newMap !emptyLString()) ![varName string]]
      end
    end
  else
    # The variable does not exist
    if [path length] == 0 then
      if [key string] == "" then
        if [idx sint] == -1s then
          [!?ioFieldMap insertKey !varName !expressionType !enumeratedValue]
        else
          # it is an error to set an item of a list it the list does not exist
          error varName: "A list must exist before setting one of its item"
        end
      else
        var newMap =@TfieldMap.emptyMap{}
        [!?newMap insertKey !key !expressionType !enumeratedValue]
        [!?ioFieldMap insertKey !varName !@Ttype. mapType !valueWithMap(!newMap !emptyLString())]
      end
    else
      if [key string] == "" then
        if [idx sint] == -1s then
          var nextFieldMap =@TfieldMap.emptyMap{}
          setVariableInPath ( !path !?nextFieldMap !expressionType !enumeratedValue)
          [!?ioFieldMap insertKey !varName !@Ttype. structType !valueWithStruct(!nextFieldMap !emptyLString())]
        else
          # it is an error to set an item of a list it the list does not exist
          error varName: "A list must exist before setting one of its item"
        end
      else
        var newMap =@TfieldMap.emptyMap{}
        var nextFieldMap =@TfieldMap.emptyMap{}
        setVariableInPath ( !path !?nextFieldMap !expressionType !enumeratedValue)
        [!?newMap insertKey !key !@Ttype. structType !valueWithStruct(!nextFieldMap !emptyLString())]
        [!?ioFieldMap insertKey !varName !@Ttype. mapType !valueWithMap(!newMap !emptyLString())]
      end
    end
  end
}

abstract class @gtlData { @location where %setter }

abstract getter @gtlData plusOp  -> @gtlData result
abstract getter @gtlData minusOp -> @gtlData result
abstract getter @gtlData notOp   -> @gtlData result
abstract getter @gtlData addOp ?let @gtlData right -> @gtlData result
abstract getter @gtlData subOp ?let @gtlData right -> @gtlData result
abstract getter @gtlData mulOp ?let @gtlData right -> @gtlData result
abstract getter @gtlData divOp ?let @gtlData right -> @gtlData result
abstract getter @gtlData andOp ?let @gtlData right -> @gtlData result
abstract getter @gtlData orOp  ?let @gtlData right -> @gtlData result
abstract getter @gtlData xorOp ?let @gtlData right -> @gtlData result
abstract getter @gtlData slOp  ?let @gtlData right -> @gtlData result
abstract getter @gtlData srOp  ?let @gtlData right -> @gtlData result
abstract getter @gtlData neqOp ?let @gtlData right -> @gtlData result
abstract getter @gtlData eqOp  ?let @gtlData right -> @gtlData result
abstract getter @gtlData ltOp  ?let @gtlData right -> @gtlData result
abstract getter @gtlData leOp  ?let @gtlData right -> @gtlData result
abstract getter @gtlData gtOp  ?let @gtlData right -> @gtlData result
abstract getter @gtlData geOp  ?let @gtlData right -> @gtlData result

#---------------------------------------------------------------------------*
# Int type and operations on int
#---------------------------------------------------------------------------*
class @gtlInt    : @gtlData { @sint64  value }
override getter @gtlInt plusOp  -> @gtlData result { result = self }
override getter @gtlInt minusOp -> @gtlData result { result = @gtlInt.new { !where !-value } }
override getter @gtlInt notOp   -> @gtlData result { result = @gtlInt.new { !where !~value } }
override getter @gtlInt addOp ?let @gtlData right -> @gtlData result {
  result = @gtlInt.new { !where !value + [right as @gtlInt value] }
    error [right where] : "int expected" : result
}
override getter @gtlInt subOp ?let @gtlData right -> @gtlData result {
  result = @gtlInt.new { !where !value - [right as @gtlInt value] }
    error [right where] : "int expected" : result
}
override getter @gtlInt mulOp ?let @gtlData right -> @gtlData result {
  result = @gtlInt.new { !where !value * [right as @gtlInt value] }
    error [right where] : "int expected" : result
}
override getter @gtlInt divOp ?let @gtlData right -> @gtlData result {
  result = @gtlInt.new { !where !value / [right as @gtlInt value] }
    error [right where] : "int expected" : result
}
override getter @gtlInt andOp ?let @gtlData right -> @gtlData result {
  result = @gtlInt.new { !where !value & [right as @gtlInt value] }
    error [right where] : "int expected" : result
}
override getter @gtlInt orOp ?let @gtlData right -> @gtlData result {
  result = @gtlInt.new { !where !value | [right as @gtlInt value] }
    error [right where] : "int expected" : result
}
override getter @gtlInt xorOp ?let @gtlData right -> @gtlData result {
  result = @gtlInt.new { !where !value ^ [right as @gtlInt value] }
    error [right where] : "int expected" : result
}
override getter @gtlInt slOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlInt then
    @sint64 r = [right as @gtlInt value];
    if r >= 0LS then 
      result = @gtlInt.new { !where !value << [[right as @gtlInt value] uint] }
    else
      error [right where] : "positive int expected" : result
    end
  else
    error [right where] : "int expected" : result
  end
}
override getter @gtlInt srOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlInt then
    @sint64 r = [right as @gtlInt value];
    if r >= 0LS then 
      result = @gtlInt.new { !where !value >> [r uint] }
    else
      error [right where] : "positive int expected" : result
    end
  else
    error [right where] : "int expected" : result
  end
}
override getter @gtlInt neqOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value != [right as @gtlInt value] }
    error [right where] : "int expected" : result
}
override getter @gtlInt eqOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value == [right as @gtlInt value] }
    error [right where] : "int expected" : result
}
override getter @gtlInt gtOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value > [right as @gtlInt value] }
    error [right where] : "int expected" : result
}
override getter @gtlInt geOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value >= [right as @gtlInt value] }
    error [right where] : "int expected" : result
}
override getter @gtlInt ltOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value < [right as @gtlInt value] }
    error [right where] : "int expected" : result
}
override getter @gtlInt leOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value <= [right as @gtlInt value] }
    error [right where] : "int expected" : result
}

#---------------------------------------------------------------------------*
# Float type and operations on float
#---------------------------------------------------------------------------*
class @gtlFloat  : @gtlData { @double  value }
override getter @gtlFloat plusOp  -> @gtlData result { result = self }
override getter @gtlFloat minusOp -> @gtlData result { result = @gtlFloat.new { !where !-value } }
override getter @gtlFloat notOp   -> @gtlData result {
  error where : "float forbidden" : result
}
override getter @gtlFloat addOp ?let @gtlData right -> @gtlData result {
  result = @gtlFloat.new { !where !value + [right as @gtlFloat value] }
    error [right where] : "float expected" : result
}
override getter @gtlFloat subOp ?let @gtlData right -> @gtlData result {
  result = @gtlFloat.new { !where !value - [right as @gtlFloat value] }
    error [right where] : "float expected" : result
}
override getter @gtlFloat mulOp ?let @gtlData right -> @gtlData result {
  result = @gtlFloat.new { !where !value * [right as @gtlFloat value] }
    error [right where] : "float expected" : result
}
override getter @gtlFloat divOp ?let @gtlData right -> @gtlData result {
  result = @gtlFloat.new { !where !value / [right as @gtlFloat value] }
    error [right where] : "float expected" : result
}
override getter @gtlFloat andOp ?let @gtlData unused right -> @gtlData result {
  error where : "float forbidden" : result
}
override getter @gtlFloat orOp ?let @gtlData unused right -> @gtlData result {
  error where : "float forbidden" : result
}
override getter @gtlFloat xorOp ?let @gtlData unused right -> @gtlData result {
  error where : "float forbidden" : result
}
override getter @gtlFloat slOp ?let @gtlData unused right -> @gtlData result {
  error where : "float forbidden" : result
}
override getter @gtlFloat srOp ?let @gtlData unused right -> @gtlData result {
  error where : "float forbidden" : result
}
override getter @gtlFloat neqOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value != [right as @gtlFloat value] }
    error [right where] : "float expected" : result
}
override getter @gtlFloat eqOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value == [right as @gtlFloat value] }
    error [right where] : "float expected" : result
}
override getter @gtlFloat gtOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value > [right as @gtlFloat value] }
    error [right where] : "float expected" : result
}
override getter @gtlFloat geOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value >= [right as @gtlFloat value] }
    error [right where] : "float expected" : result
}
override getter @gtlFloat ltOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value < [right as @gtlFloat value] }
    error [right where] : "float expected" : result
}
override getter @gtlFloat leOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value <= [right as @gtlFloat value] }
    error [right where] : "float expected" : result
}

#---------------------------------------------------------------------------*
# String type and operations on string
#---------------------------------------------------------------------------*
class @gtlString : @gtlData { @string  value }
override getter @gtlString plusOp  -> @gtlData result {
  error where : "string forbidden" : result
}
override getter @gtlString minusOp -> @gtlData result {
  error where : "string forbidden" : result
}
override getter @gtlString notOp   -> @gtlData result {
  error where : "string forbidden" : result
}
override getter @gtlString addOp ?let @gtlData right -> @gtlData result {
  result = @gtlString.new { !where !value + [right as @gtlString value] }
    error [right where] : "string expected" : result
}
override getter @gtlString subOp ?let @gtlData unused right -> @gtlData result {
  error where : "string forbidden" : result
}
override getter @gtlString mulOp ?let @gtlData unused right -> @gtlData result {
  error where : "string forbidden" : result
}
override getter @gtlString divOp ?let @gtlData unused right -> @gtlData result {
  error where : "string forbidden" : result
}
override getter @gtlString andOp ?let @gtlData unused right -> @gtlData result {
  error where : "string forbidden" : result
}
override getter @gtlString orOp ?let @gtlData unused right -> @gtlData result {
  error where : "string forbidden" : result
}
override getter @gtlString xorOp ?let @gtlData unused right -> @gtlData result {
  error where : "string forbidden" : result
}
override getter @gtlString slOp ?let @gtlData unused right -> @gtlData result {
  error where : "string forbidden" : result
}
override getter @gtlString srOp ?let @gtlData unused right -> @gtlData result {
  error where : "string forbidden" : result
}
override getter @gtlString neqOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value != [right as @gtlString value] }
    error [right where] : "string expected" : result
}
override getter @gtlString eqOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value == [right as @gtlString value] }
    error [right where] : "string expected" : result
}
override getter @gtlString gtOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value > [right as @gtlString value] }
    error [right where] : "string expected" : result
}
override getter @gtlString geOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value >= [right as @gtlString value] }
    error [right where] : "string expected" : result
}
override getter @gtlString ltOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value < [right as @gtlString value] }
    error [right where] : "string expected" : result
}
override getter @gtlString leOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value <= [right as @gtlString value] }
    error [right where] : "string expected" : result
}

#---------------------------------------------------------------------------*
# Bool type and operations on bool
#---------------------------------------------------------------------------*
class @gtlBool   : @gtlData { @bool    value }
override getter @gtlBool plusOp  -> @gtlData result {
  error where : "bool forbidden" : result
}
override getter @gtlBool minusOp -> @gtlData result {
  error where : "bool forbidden" : result
}
override getter @gtlBool notOp   -> @gtlData result {
  error where : "bool forbidden" : result
}
override getter @gtlBool addOp ?let @gtlData unused right -> @gtlData result {
  error where : "bool forbidden" : result
}
override getter @gtlBool subOp ?let @gtlData unused right -> @gtlData result {
  error where : "bool forbidden" : result
}
override getter @gtlBool mulOp ?let @gtlData unused right -> @gtlData result {
  error where : "bool forbidden" : result
}
override getter @gtlBool divOp ?let @gtlData unused right -> @gtlData result {
  error where : "bool forbidden" : result
}
override getter @gtlBool andOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value & [right as @gtlBool value] }
    error [right where] : "bool expected" : result
}
override getter @gtlBool orOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value | [right as @gtlBool value] }
    error [right where] : "bool expected" : result
}
override getter @gtlBool xorOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value ^ [right as @gtlBool value] }
    error [right where] : "bool expected" : result
}
override getter @gtlBool slOp ?let @gtlData unused right -> @gtlData result {
  error where : "bool forbidden" : result
}
override getter @gtlBool srOp ?let @gtlData unused right -> @gtlData result {
  error where : "bool forbidden" : result
}
override getter @gtlBool neqOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value != [right as @gtlBool value] }
    error [right where] : "string expected" : result
}
override getter @gtlBool eqOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value == [right as @gtlBool value] }
    error [right where] : "string expected" : result
}
override getter @gtlBool gtOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value > [right as @gtlBool value] }
    error [right where] : "string expected" : result
}
override getter @gtlBool geOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value >= [right as @gtlBool value] }
    error [right where] : "string expected" : result
}
override getter @gtlBool ltOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value < [right as @gtlBool value] }
    error [right where] : "string expected" : result
}
override getter @gtlBool leOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value <= [right as @gtlBool value] }
    error [right where] : "string expected" : result
}

#---------------------------------------------------------------------------*
# foundation types for collections
#---------------------------------------------------------------------------*
list @list { @gtlVarMap value }

#---------------------------------------------------------------------------*
# Struct type and operations on struct
#---------------------------------------------------------------------------*
class @gtlStruct : @gtlData { @gtlVarMap  value }
override getter @gtlStruct plusOp  -> @gtlData result {
  error where : "struct forbidden" : result
}
override getter @gtlStruct minusOp -> @gtlData result {
  error where : "struct forbidden" : result
}
override getter @gtlStruct notOp   -> @gtlData result {
  error where : "struct forbidden" : result
}
override getter @gtlStruct addOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}
override getter @gtlStruct subOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}
override getter @gtlStruct mulOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}
override getter @gtlStruct divOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}
override getter @gtlStruct andOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}
override getter @gtlStruct orOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}
override getter @gtlStruct xorOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}
override getter @gtlStruct slOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}
override getter @gtlStruct srOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}
override getter @gtlStruct neqOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !(value != [right as @gtlStruct value]) }
    error [right where] : "struct expected" : result
}
override getter @gtlStruct eqOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !(value == [right as @gtlStruct value]) }
    error [right where] : "struct expected" : result
}
override getter @gtlStruct gtOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}
override getter @gtlStruct geOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}
override getter @gtlStruct ltOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}
override getter @gtlStruct leOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}

#---------------------------------------------------------------------------*
# List type and operations on lists
#---------------------------------------------------------------------------*
class @gtlList   : @gtlData { @list value }
override getter @gtlList plusOp  -> @gtlData result {
  error where : "list forbidden" : result
}
override getter @gtlList minusOp -> @gtlData result {
  error where : "list forbidden" : result
}
override getter @gtlList notOp   -> @gtlData result {
  error where : "list forbidden" : result
}
override getter @gtlList addOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlList then
    result = @gtlList.new { !where !value + [right as @gtlList value] }
  elsif right is == @gtlStruct then
    @list res = value;
    res += ![right as @gtlStruct value]
    result = @gtlList.new { !where !res  }
  else
    error [right where] : "list or struct expected" : result
  end
}
override getter @gtlList subOp ?let @gtlData unused right -> @gtlData result {
  error where : "list forbidden" : result
}
override getter @gtlList mulOp ?let @gtlData unused right -> @gtlData result {
  error where : "list forbidden" : result
}
override getter @gtlList divOp ?let @gtlData unused right -> @gtlData result {
  error where : "list forbidden" : result
}
override getter @gtlList andOp ?let @gtlData unused right -> @gtlData result {
  error where : "list forbidden" : result
}
override getter @gtlList orOp ?let @gtlData unused right -> @gtlData result {
  error where : "list forbidden" : result
}
override getter @gtlList xorOp ?let @gtlData unused right -> @gtlData result {
  error where : "list forbidden" : result
}
override getter @gtlList slOp ?let @gtlData unused right -> @gtlData result {
  error where : "list forbidden" : result
}
override getter @gtlList srOp ?let @gtlData unused right -> @gtlData result {
  error where : "list forbidden" : result
}
override getter @gtlList neqOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !(value != [right as @gtlList value]) }
    error [right where] : "list expected" : result
}
override getter @gtlList eqOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !(value == [right as @gtlList value]) }
    error [right where] : "list expected" : result
}
override getter @gtlList gtOp ?let @gtlData unused right -> @gtlData result {
  error where : "a list does not support the > operator" : result
}
override getter @gtlList geOp ?let @gtlData unused right -> @gtlData result {
  error where : "a list does not support the >= operator" : result
}
override getter @gtlList ltOp ?let @gtlData unused right -> @gtlData result {
  error where : "a list does not support the < operator" : result
}
override getter @gtlList leOp ?let @gtlData unused right -> @gtlData result {
  error where : "a list does not support the <= operator" : result
}

#---------------------------------------------------------------------------*
# Map type and operations on maps
#---------------------------------------------------------------------------*
class @gtlMap    : @gtlData { @gtlVarMap  value %setter }
override getter @gtlMap plusOp  -> @gtlData result {
  error where : "map forbidden" : result
}
override getter @gtlMap minusOp -> @gtlData result {
  error where : "map forbidden" : result
}
override getter @gtlMap notOp   -> @gtlData result {
  error where : "map forbidden" : result
}
override getter @gtlMap addOp ?let @gtlData unused right -> @gtlData result {
  error where : "map forbidden" : result
}
override getter @gtlMap subOp ?let @gtlData unused right -> @gtlData result {
  error where : "map forbidden" : result
}
override getter @gtlMap mulOp ?let @gtlData unused right -> @gtlData result {
  error where : "map forbidden" : result
}
override getter @gtlMap divOp ?let @gtlData unused right -> @gtlData result {
  error where : "map forbidden" : result
}
override getter @gtlMap andOp ?let @gtlData unused right -> @gtlData result {
  error where : "map forbidden" : result
}
override getter @gtlMap orOp ?let @gtlData unused right -> @gtlData result {
  error where : "map forbidden" : result
}
override getter @gtlMap xorOp ?let @gtlData unused right -> @gtlData result {
  error where : "map forbidden" : result
}
override getter @gtlMap slOp ?let @gtlData unused right -> @gtlData result {
  error where : "map forbidden" : result
}
override getter @gtlMap srOp ?let @gtlData unused right -> @gtlData result {
  error where : "map forbidden" : result
}
override getter @gtlMap neqOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !(value != [right as @gtlMap value]) }
    error [right where] : "map expected" : result
}
override getter @gtlMap eqOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !(value == [right as @gtlMap value]) }
    error [right where] : "map expected" : result
}
override getter @gtlMap gtOp ?let @gtlData unused right -> @gtlData result {
  error where : "a map does not support the > operator" : result
}
override getter @gtlMap geOp ?let @gtlData unused right -> @gtlData result {
  error where : "a map does not support the >= operator" : result
}
override getter @gtlMap ltOp ?let @gtlData unused right -> @gtlData result {
  error where : "a map does not support the < operator" : result
}
override getter @gtlMap leOp ?let @gtlData unused right -> @gtlData result {
  error where : "a map does not support the <= operator" : result
}

#---------------------------------------------------------------------------*
# abstract classes for an expression
#---------------------------------------------------------------------------*
abstract class @gtlExpression { @location where }
abstract class @gtlUnaryExpression : @gtlExpression {
  @gtlExpression son
}
abstract class @gtlBinaryExpression : @gtlExpression {
  @gtlExpression lSon
  @gtlExpression rSon
}

abstract getter @gtlExpression eval -> @gtlData result

#===========================================================================*
# class for a literal terminal
#---------------------------------------------------------------------------*
class @gtlTerminal : @gtlExpression { @gtlData value }
override getter @gtlTerminal eval -> @gtlData result { result = value }

#===========================================================================*
# classes for unary expressions
#---------------------------------------------------------------------------*
# @gtlParenthesizedExpression : ( son )
#---------------------------------------------------------------------------*
class @gtlParenthesizedExpression : @gtlUnaryExpression {}
override getter @gtlParenthesizedExpression eval -> @gtlData result {
  result = [son eval]
  [!?result setWhere !where]
}

#---------------------------------------------------------------------------*
# @gtlMinusExpression : unary -. Does a - son
#---------------------------------------------------------------------------*
class @gtlMinusExpression : @gtlUnaryExpression {}
override getter @gtlMinusExpression eval -> @gtlData result {
  result = [[son eval] minusOp]
}

#---------------------------------------------------------------------------*
# @gtlPlusExpression : unary +. Does a + son 
#---------------------------------------------------------------------------*
class @gtlPlusExpression : @gtlUnaryExpression {}
override getter @gtlPlusExpression eval -> @gtlData result {
  result = [[son eval] plusOp]
}

#---------------------------------------------------------------------------*
# @gtlTildeExpression : unary bitwise not or boolean not. Does a ~ son 
#---------------------------------------------------------------------------*
class @gtlNotExpression : @gtlUnaryExpression {}
override getter @gtlNotExpression eval -> @gtlData result {
  result = [[son eval] notOp]
}

#===========================================================================*
# classes for binary expressions
#---------------------------------------------------------------------------*
# @gtlAddExpression : binary add. Does a lSon + rSon
#---------------------------------------------------------------------------*
class @gtlAddExpression : @gtlBinaryExpression {}
override getter @gtlAddExpression eval -> @gtlData result {
  result = [[lSon eval] addOp ![rSon eval]]
}

#---------------------------------------------------------------------------*
# @gtlSubstractExpression : binary substract. Does a lSon - rSon
#---------------------------------------------------------------------------*
class @gtlSubstractExpression : @gtlBinaryExpression {}
override getter @gtlSubstractExpression eval -> @gtlData result {
  result = [[lSon eval] subOp ![rSon eval]]
}

#---------------------------------------------------------------------------*
# @gtlMultiplyExpression : binary multiply. Does a lSon * rSon
#---------------------------------------------------------------------------*
class @gtlMultiplyExpression : @gtlBinaryExpression {}
override getter @gtlMultiplyExpression eval -> @gtlData result {
  result = [[lSon eval] mulOp ![rSon eval]]
}

#---------------------------------------------------------------------------*
# @gtlDivideExpression : binary divide. Does a lSon / rSon
#---------------------------------------------------------------------------*
class @gtlDivideExpression : @gtlBinaryExpression {}
override getter @gtlDivideExpression eval -> @gtlData result {
  result = [[lSon eval] divOp ![rSon eval]]
}

#---------------------------------------------------------------------------*
# @gtlAndExpression : binary and. Does a lSon & rSon
#---------------------------------------------------------------------------*
class @gtlAndExpression : @gtlBinaryExpression {}
override getter @gtlAndExpression eval -> @gtlData result {
  result = [[lSon eval] andOp ![rSon eval]]
}

#---------------------------------------------------------------------------*
# @gtlOrExpression : binary or. Does a lSon | rSon
#---------------------------------------------------------------------------*
class @gtlOrExpression : @gtlBinaryExpression {}
override getter @gtlOrExpression eval -> @gtlData result {
  result = [[lSon eval] orOp ![rSon eval]]
}

#---------------------------------------------------------------------------*
# @gtlXorExpression : binary or. Does a lSon ^ rSon
#---------------------------------------------------------------------------*
class @gtlXorExpression : @gtlBinaryExpression {}
override getter @gtlXorExpression eval -> @gtlData result {
  result = [[lSon eval] xorOp ![rSon eval]]
}

#---------------------------------------------------------------------------*
# @gtlShiftLeftExpression : Does a lSon << rSon
#---------------------------------------------------------------------------*
class @gtlShiftLeftExpression : @gtlBinaryExpression {}
override getter @gtlShiftLeftExpression eval -> @gtlData result {
  result = [[lSon eval] slOp ![rSon eval]]
}

#---------------------------------------------------------------------------*
# @gtlShiftRightExpression : Does a lSon >> rSon
#---------------------------------------------------------------------------*
class @gtlShiftRightExpression : @gtlBinaryExpression {}
override getter @gtlShiftRightExpression eval -> @gtlData result {
  result = [[lSon eval] srOp ![rSon eval]]
}

#---------------------------------------------------------------------------*
# @gtlNotEqualExpression : Does a lSon != rSon
#---------------------------------------------------------------------------*
class @gtlNotEqualExpression : @gtlBinaryExpression {}
override getter @gtlNotEqualExpression eval -> @gtlData result {
  result = [[lSon eval] neqOp ![rSon eval]]
}

#---------------------------------------------------------------------------*
# @gtlEqualExpression : Does a lSon == rSon
#---------------------------------------------------------------------------*
class @gtlEqualExpression : @gtlBinaryExpression {}
override getter @gtlEqualExpression eval -> @gtlData result {
  result = [[lSon eval] eqOp ![rSon eval]]
}

#---------------------------------------------------------------------------*
# @gtlLowerThanExpression : Does a lSon < rSon
#---------------------------------------------------------------------------*
class @gtlLowerThanExpression : @gtlBinaryExpression {}
override getter @gtlLowerThanExpression eval -> @gtlData result {
  result = [[lSon eval] ltOp ![rSon eval]]
}

#---------------------------------------------------------------------------*
# @gtlLowerOrEqualExpression : Does a lSon < rSon
#---------------------------------------------------------------------------*
class @gtlLowerOrEqualExpression : @gtlBinaryExpression {}
override getter @gtlLowerOrEqualExpression eval -> @gtlData result {
  result = [[lSon eval] leOp ![rSon eval]]
}

#---------------------------------------------------------------------------*
# @gtlGreaterThanExpression : Does a lSon < rSon
#---------------------------------------------------------------------------*
class @gtlGreaterThanExpression : @gtlBinaryExpression {}
override getter @gtlGreaterThanExpression eval -> @gtlData result {
  result = [[lSon eval] gtOp ![rSon eval]]
}

#---------------------------------------------------------------------------*
# @gtlGreaterOrEqualExpression : Does a lSon < rSon
#---------------------------------------------------------------------------*
class @gtlGreaterOrEqualExpression : @gtlBinaryExpression {}
override getter @gtlGreaterOrEqualExpression eval -> @gtlData result {
  result = [[lSon eval] geOp ![rSon eval]]
}

#===========================================================================*
# abstract class for a template instruction
#---------------------------------------------------------------------------*
abstract class @gtlInstruction {}

abstract method @gtlInstruction execute ?!@gtlVarMap gtlVariableMap

#---------------------------------------------------------------------------*
# let instructions
#---------------------------------------------------------------------------*
abstract class @gtlAssign : @gtlInstruction {
  @gtlVarPath    lValue
  @gtlExpression rValue
}

class @gtlLet           : @gtlAssign {}
#class @gtlLetAdd        : @gtlAssign {}
#class @gtlLetSubstract  : @gtlAssign {}
#class @gtlLetMultiply   : @gtlAssign {}
#class @gtlLetDivide     : @gtlAssign {}
#class @gtlLetModulo     : @gtlAssign {}
#class @gtlLetShiftLeft  : @gtlAssign {}
#class @gtlLetShiftRight : @gtlAssign {}
#class @gtlLetAnd        : @gtlAssign {}
#class @gtlLetOr         : @gtlAssign {}
#class @gtlLetXor        : @gtlAssign {}

override method @gtlLet execute ?!@gtlVarMap gtlVariableMap {
#  [!?gtlVariableMap setVar !lValue ![rValue eval]]
}
  
