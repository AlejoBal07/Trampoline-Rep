#include "tpl_os_kernel.h"          /* tpl_schedule */
#include "tpl_os_timeobj_kernel.h"  /* tpl_counter_tick */
#include "tpl_machine_interface.h"  /* tpl_switch_context_from_it */
#include "AT91SAM7.h" /* AT91C_AIC_ISCR */

#define OS_START_SEC_VAR_8BIT
#include "tpl_memmap.h"
VAR(uint8, OS_VAR) check_buttons_period = 0;
#define OS_STOP_SEC_VAR_8BIT
#include "tpl_memmap.h"

#define OS_START_SEC_CODE
#include "tpl_memmap.h"
%

foreach interrupt in INTERRUPT do
  let counterFct := emptylist
  foreach counter in COUNTERS do
    if counter::SOURCE == interrupt::NAME then
      let counterFct += counter::NAME
    end if
  end foreach
  foreach fct in counterFct
    before
%
FUNC(void, OS_CODE) tpl_tick_% ! interrupt::NAME %()
{
  tpl_status  need_rescheduling = NO_SPECIAL_CODE;

%
    do
      %  need_rescheduling |= tpl_counter_tick(&% !fct::VALUE %_counter_desc);
%
    after %
  
  check_buttons_period++;
  if (check_buttons_period == 10)
  {
    /* Call check_buttons_status() (via interrupts)
     * which will check if buttons are pressed or not.
     */
     *AT91C_AIC_ISCR = (1 << AT91C_PERIPHERAL_ID_IRQ0);
     check_buttons_period = 0;
  }

  if (need_rescheduling == NEED_RESCHEDULING)
  {
    tpl_schedule_from_running();
#if WITH_SYSTEM_CALL == NO
    if (tpl_kern.need_switch != NO_NEED_SWITCH) {
      tpl_switch_context_from_it(
        &(tpl_kern.s_old->context),
        &(tpl_kern.s_running->context)
      );
    }
#endif
  }
}
%
  end foreach
end foreach
%
#define OS_STOP_SEC_CODE
#include "tpl_memmap.h"

