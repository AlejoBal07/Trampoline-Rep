/**
 * @file tpl_second_stage_irq.% !EXTENSIONSECONDSTAGE %
 *
 * @section descr File description
 *
 * 
 *
 * @warning this file is generated by gen_invoque.sh based on the 
 * tpl_os_service_ids.h header file.
 *
 * @section copyright Copyright
 *
 * Trampoline OS
 *
 * Trampoline is copyright (c) IRCCyN 2005+
 * Copyright ESEO for function and data structures documentation and ARM port
 * Trampoline is protected by the French intellectual property law.
 *
 * This software is distributed under the Lesser GNU Public Licence
 *
 * @section infos File informations
 *
 * $$Date$$
 * $$Rev$$
 * $$Author$$
 * $$URL$$
 */
#include "tpl_os_application_def.h"
#include "tpl_service_ids.h"
#include "tpl_asm_definitions.h"

	.syntax unified
	.thumb

	.equ  NO_NEED_SWITCH_NOR_SCHEDULE , 0
	.equ  NO_NEED_SWITCH , 0
	.equ  NEED_SWITCH , 1
	.equ  NEED_SAVE , 2

#define OS_START_SEC_CODE
#include "tpl_as_memmap.h"

	.extern nested_kernel_entrance_counter
	.extern tpl_kern
	.extern tpl_dispatch_table

/*
 * Second stage category 2 interrupt handler (which means only IRQ on
 * this architecture, FIQ are category 1 interrupts)
 */

%
let IT_SOURCES := mapof INTERRUPT by NAME
foreach counter in HARDWARECOUNTERS do 
  if not exists IT_SOURCES[counter::SOURCE] then
    error counter::SOURCE : "Interrupt source ".counter::SOURCE." does not exist"
  end if
end foreach
foreach isr in ISRS2 do
  if not exists IT_SOURCES[isr::SOURCE] then
    error isr::SOURCE : "Interrupt source ".isr::SOURCE." does not exist"
  end if
end foreach

loop ENTRY from 0 to INTERRUPT_COUNT::IT_TABLE_SIZE - 1
  before
%

%
  do
    let entryFound := false
    foreach interrupt in INTERRUPT do
      if ENTRY == interrupt::VECT then
        # check first for counters
        foreach counter in HARDWARECOUNTERS do
          if counter::SOURCE == interrupt::NAME & not entryFound & interrupt::VECTOR_TYPE == "HANDLER" & interrupt::VECTOR_TYPE_S::NAME != "NONE" then
%
	/******************************************************************************
	* IRQ Handler for interrupt % !interrupt::NAME % vector % !interrupt::VECT %
	*******************************************************************************/
	.global tpl_primary_irq_handler_% !interrupt::VECT %
	.type   tpl_primary_irq_handler_% !interrupt::VECT %, \%function
tpl_primary_irq_handler_% !interrupt::VECT %:
	/* Save EXC_RETURN value */
	push {lr}

	/* manage reentrance of kernel */
	ldr r1, =nested_kernel_entrance_counter
	ldr r2, [r1]
	add r2, r2, #1
	str r2, [r1]

#if WITH_MEMORY_PROTECTION == YES
	bl tpl_mp_kernel_enter
#endif /* WITH_MEMORY_PROTECTION == YES */

	/* reset tpl_kern variables */ /* <! DGAR POURQUOI ? !> */
	ldr r1, =tpl_kern
	mov r2, #NO_NEED_SWITCH_NOR_SCHEDULE
	strb r2, [r1, #TPL_KERN_OFFSET_NEED_SWITCH]
	strb r2, [r1, #TPL_KERN_OFFSET_NEED_SCHEDULE]

	/* save volatile registers
	* get the context block address
	* r1 is the address of tpl_kern */
	ldr r2, [r1, #TPL_KERN_OFFSET_S_ELECTED]
	ldr r2, [r2]
	mrs r1, psp                  /* Get current process stack pointer value */
	stmia r2, {r4-r11}           /* Save r4-r11 into context bloc reg */
	str r1, [r2, #32]            /* Save psp into context bloc sp */

	/************************
	* IRQ processing stage *
	************************/

	push {lr}
	bl tpl_interrupt_source_% !interrupt::VECT %
	pop {lr}

#if WITH_MEMORY_PROTECTION == YES
    bl tpl_mp_kernel_exit
#endif

	/***************************************************
	* on the way to exit IRQ routine (with or without *
	* context switch)                                 *
	***************************************************/
	/* Do we need to switch context ? */

	ldr r2, =tpl_kern
	ldrb r2, [r2, #TPL_KERN_OFFSET_NEED_SWITCH]
	cmp r2, #NO_NEED_SWITCH
	beq irq_no_context_switch_% !interrupt::VECT %
	
	/***************************
	* CONTEXT SWITCHING STAGE *
	***************************/

context_switch_irq_% !interrupt::VECT %:
	/* load the tpl_kern base address */
	ldr r0, =tpl_kern

	/* do we need to save the context ? if not, jump to load */
	ldrb r2, [r0, #TPL_KERN_OFFSET_NEED_SWITCH]
	tst r2, #NEED_SAVE
	beq skip_save_context_irq_% !interrupt::VECT %

	/*
	* SAVES OLD CONTEXT
	*/
save_context_irq_% !interrupt::VECT %:
	/* Context is saved, so the value of r3 will be 1 */
	mov r3, #1
	/* already done at the beginning of the subroutine */

	b load_context_irq_% !interrupt::VECT %

	/* only executed if context saving step has not been done */
skip_save_context_irq_% !interrupt::VECT %: /* <! DGAR POURQUOI > */
	/* Context is not saved, so the value of r3 will be 0 */
    mov r3, #0

	/*
	* LOADS NEW CONTEXT
	*/
load_context_irq_% !interrupt::VECT %:
	/* First call tpl_run_elected with the value of tpl_kern.need_switch
	 * and get the value of the elected task.
	 * tpl_kern.need_switch (stored into r3) is copied into r0
	 */
	mov r0, r3
	push {lr}
	bl tpl_run_elected
	pop {lr}
	mov r3, r0 	/* Keep the returned value into r3 */

	/* We update kernel reentrance counter while registers are freely
	* usable and as we know we won't enter in kernel again (IRQ locked and
	* no SWI can occur)
	*/
	ldr r3, =nested_kernel_entrance_counter
	ldr r2, [r3]
	sub r2, r2, #1
	str r2, [r3]

	/* Get the context block address */
	ldr r0, =tpl_kern
	ldr lr, [r0, #TPL_KERN_OFFSET_S_RUNNING] /* get the address of the context bloc */
	ldr lr, [lr]                   /* jump to context bloc (from static descriptor) */

	ldmia lr, {r4-r11}      /* loads from lr base register into r4 to r11 */
	ldr r0, [lr, #32]
	msr psp, r0

	b tpl_primary_irq_handler_% !interrupt::VECT %_exit

	/********************************************
	* KERNEL EXIT WITHOUT CONTEXT SWITCH STAGE *
	********************************************/
irq_no_context_switch_% !interrupt::VECT %:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r2, [r3]
	sub r2, r2, #1
	str r2, [r3]

	/* return to interrupted task */
tpl_primary_irq_handler_% !interrupt::VECT %_exit:
	pop {lr} /* Moves back EXC_RETURN into lr */
	bx lr
%
            let entryFound := true
          end if
        end foreach
        if not entryFound then
          foreach isr in ISRS2 do
            if isr::SOURCE == interrupt::NAME & not entryFound & interrupt::VECTOR_TYPE == "HANDLER" & interrupt::VECTOR_TYPE_S::NAME != "NONE" then
%
	/******************************************************************************
	* IRQ Handler for interrupt % !interrupt::NAME % vector % !interrupt::VECT %
	*******************************************************************************/
	.global tpl_primary_irq_handler_% !interrupt::VECT %
	.type   tpl_primary_irq_handler_% !interrupt::VECT %, \%function
tpl_primary_irq_handler_% !interrupt::VECT %:
	/* Save EXC_RETURN value */
	push {lr}

	/* manage reentrance of kernel */
	ldr r1, =nested_kernel_entrance_counter
	ldr r2, [r1]
	add r2, r2, #1
	str r2, [r1]

#if WITH_MEMORY_PROTECTION == YES
	bl tpl_mp_kernel_enter
#endif /* WITH_MEMORY_PROTECTION == YES */

	/* reset tpl_kern variables */ /* <! DGAR POURQUOI ? !> */
	ldr r1, =tpl_kern
	mov r2, #NO_NEED_SWITCH_NOR_SCHEDULE
	strb r2, [r1, #TPL_KERN_OFFSET_NEED_SWITCH]
	strb r2, [r1, #TPL_KERN_OFFSET_NEED_SCHEDULE]

	/* save volatile registers
	* get the context block address
	* r1 is the address of tpl_kern */
	ldr r2, [r1, #TPL_KERN_OFFSET_S_ELECTED]
	ldr r2, [r2]
	mrs r1, psp                  /* Get current process stack pointer value */
	stmia r2, {r4-r11}           /* Save r4-r11 into context bloc reg */
	str r1, [r2, #32]            /* Save psp into context bloc sp */

	/************************
	* IRQ processing stage *
	************************/

	push {lr}
	bl tpl_interrupt_source_% !interrupt::VECT %
	pop {lr}

#if WITH_MEMORY_PROTECTION == YES
    bl tpl_mp_kernel_exit
#endif

	/***************************************************
	* on the way to exit IRQ routine (with or without *
	* context switch)                                 *
	***************************************************/
	/* Do we need to switch context ? */

	ldr r2, =tpl_kern
	ldrb r2, [r2, #TPL_KERN_OFFSET_NEED_SWITCH]
	cmp r2, #NO_NEED_SWITCH
	beq irq_no_context_switch_% !interrupt::VECT %
	
	/***************************
	* CONTEXT SWITCHING STAGE *
	***************************/

context_switch_irq_% !interrupt::VECT %:
	/* load the tpl_kern base address */
	ldr r0, =tpl_kern

	/* do we need to save the context ? if not, jump to load */
	ldrb r2, [r0, #TPL_KERN_OFFSET_NEED_SWITCH]
	tst r2, #NEED_SAVE
	beq skip_save_context_irq_% !interrupt::VECT %

	/*
	* SAVES OLD CONTEXT
	*/
save_context_irq_% !interrupt::VECT %:
	/* Context is saved, so the value of r3 will be 1 */
	mov r3, #1
	/* already done at the beginning of the subroutine */

	b load_context_irq_% !interrupt::VECT %

	/* only executed if context saving step has not been done */
skip_save_context_irq_% !interrupt::VECT %: /* <! DGAR POURQUOI > */
	/* Context is not saved, so the value of r3 will be 0 */
    mov r3, #0

	/*
	* LOADS NEW CONTEXT
	*/
load_context_irq_% !interrupt::VECT %:
	/* First call tpl_run_elected with the value of tpl_kern.need_switch
	 * and get the value of the elected task.
	 * tpl_kern.need_switch (stored into r3) is copied into r0
	 */
	mov r0, r3
	push {lr}
	bl tpl_run_elected
	pop {lr}
	mov r3, r0 	/* Keep the returned value into r3 */

	/* We update kernel reentrance counter while registers are freely
	* usable and as we know we won't enter in kernel again (IRQ locked and
	* no SWI can occur)
	*/
	ldr r3, =nested_kernel_entrance_counter
	ldr r2, [r3]
	sub r2, r2, #1
	str r2, [r3]

	/* Get the context block address */
	ldr r0, =tpl_kern
	ldr lr, [r0, #TPL_KERN_OFFSET_S_RUNNING] /* get the address of the context bloc */
	ldr lr, [lr]                   /* jump to context bloc (from static descriptor) */

	ldmia lr, {r4-r11}      /* loads from lr base register into r4 to r11 */
	ldr r0, [lr, #32]
	msr psp, r0

	b tpl_primary_irq_handler_% !interrupt::VECT %_exit

	/********************************************
	* KERNEL EXIT WITHOUT CONTEXT SWITCH STAGE *
	********************************************/
irq_no_context_switch_% !interrupt::VECT %:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r2, [r3]
	sub r2, r2, #1
	str r2, [r3]

	/* return to interrupted task */
tpl_primary_irq_handler_% !interrupt::VECT %_exit:
	pop {lr} /* Moves back EXC_RETURN into lr */
	bx lr
%
              let entryFound := true
            end if
          end foreach
        end if
      end if
    end foreach
#    if not entryFound then
#      %  { (tpl_it_handler)tpl_null_it, (void *)NULL }%
#    end if
#  between %%
  after
%
%
end loop

%

#define OS_STOP_SEC_CODE
#include "tpl_as_memmap.h"

#define OS_START_LTORG
#include "tpl_as_memmap.h"
#define OS_STOP_LTORG
#include "tpl_as_memmap.h"

/* End of file tpl_second_stage_irq.% !EXTENSIONSECONDSTAGE % */
