#---------------------------------------------------------------------------*
#                                                                           *
#  GOIL template expression parser definition                               *
#                                                                           *
#  Copyright (C) 2009, ..., 2009 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax template_expression_parser ("template_scanner.gLexique"):

import "template_invocation.gSemantics";
import "template_semantics.gSemantics";
import "systemConfig.gSemantics";

#------------------------------------------------------------------------------*
#                                                                              *
#          Rules prototypes                                                    *
#                                                                              *
#------------------------------------------------------------------------------*

nonterminal <expression>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
;

nonterminal <relation_term>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
;

nonterminal <relation_factor>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
;

nonterminal <simple_expression>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
;

nonterminal <term>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
;

nonterminal <factor>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
;

nonterminal <variable>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@TvarPath path
;

#---------------------------------------------------------------------------*
#                                                                           *
#   M A T C H    &    O P E R A T O R                                       *
#                                                                           *
#---------------------------------------------------------------------------*

routine matchAndOperatorForTemplate
  ??@Ttype inLeftExpressionType
  ??@Ttype inRightExpressionType
  !@Ttype outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when boolType :: boolType :
    outResultType := inLeftExpressionType;
  when intType :: intType :
    outResultType := inLeftExpressionType;
  else
    error here : "operand type error : (" . [inLeftExpressionType messageGoilTemplateType] .
           " & " . [inRightExpressionType messageGoilTemplateType] . ") is not valid" 
           : outResultType;
  end match;
end routine;

#---------------------------------------------------------------------------*
#                                                                           *
#   M A T C H    |    O P E R A T O R                                       *
#                                                                           *
#---------------------------------------------------------------------------*

routine matchOrOperatorForTemplate
  ??@Ttype inLeftExpressionType
  ??@Ttype inRightExpressionType
  !@Ttype outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when boolType :: boolType :
    outResultType := inLeftExpressionType;
  when intType :: intType :
    outResultType := inLeftExpressionType;
  else
    error here : "operand type error : (" . [inLeftExpressionType messageGoilTemplateType] .
           " | " . [inRightExpressionType messageGoilTemplateType] . ") is not valid" 
           : outResultType;
  end match;
end routine;

#---------------------------------------------------------------------------*
#                                                                           *
#   M A T C H    ^    O P E R A T O R                                       *
#                                                                           *
#---------------------------------------------------------------------------*

routine matchXorOperatorForTemplate
  ??@Ttype inLeftExpressionType
  ??@Ttype inRightExpressionType
  !@Ttype outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when boolType :: boolType :
    outResultType := inLeftExpressionType;
  when intType :: intType :
    outResultType := inLeftExpressionType;
  else
    error here : "operand type error : (" . [inLeftExpressionType messageGoilTemplateType] .
           " | " . [inRightExpressionType messageGoilTemplateType] . ") is not valid" 
           : outResultType;
  end match;
end routine;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    N O T    O P E R A T O R                                   *
#                                                                           *
#---------------------------------------------------------------------------*

routine checkNotOperatorForTemplate
  ??@Ttype inOperandType
  !@Ttype outResultType
:
  if inOperandType != [@Ttype boolType] then
    error here : "the 'not' operator is not defined for an "
    . [inOperandType messageGoilTemplateType] . " type";
  end if;
  outResultType := inOperandType;
end routine;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    ~    O P E R A T O R                                       *
#                                                                           *
#---------------------------------------------------------------------------*

routine checkBitComplementOperatorForTemplate
  ??@Ttype inOperandType
  !@Ttype outResultType
:
  outResultType := inOperandType;
  if inOperandType != [@Ttype intType] then
    error here : "the ~ operator is not defined for an "
    . [inOperandType messageGoilTemplateType] . " type";
  end if;
end routine;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    ==    !=    C O M P A R I S O N S                          *
#                                                                           *
#---------------------------------------------------------------------------*

routine comparison_types_checkForTemplate
  ??@Ttype inLeftExpressionType
  ??@Ttype inRightExpressionType
:
  match inLeftExpressionType :: inRightExpressionType :
  when boolType     :: boolType :
  when intType      :: intType :
  when stringType   :: stringType :
  when enumType     :: enumType :
  else
    error here : "comparison between " . [inLeftExpressionType messageGoilTemplateType] .
           " and " . [inRightExpressionType messageGoilTemplateType] . " is not valid" ;
  end match;
end routine;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    ==    !=    <    <=    >    >=   C O M P A R I S O N S     *
#                                                                           *
#---------------------------------------------------------------------------*

routine magnitude_comparison_types_checkForTemplate
  ??@Ttype inLeftExpressionType
  ??@Ttype inRightExpressionType
:
  match inLeftExpressionType :: inRightExpressionType :
  when boolType      :: boolType :
  when intType       :: intType :
  when stringType    :: stringType :
  else
    error here : "comparison between " . [inLeftExpressionType messageGoilTemplateType] .
           " and " . [inRightExpressionType messageGoilTemplateType] . " is not valid" ;
  end match;
end routine;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    S H I F T    O P E R A T O R                               *
#                                                                           *
#---------------------------------------------------------------------------*

routine left_shift_types_checkForTemplate
  ??@Ttype inLeftExpressionType
  ??@Ttype inRightExpressionType
  !@Ttype outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when intType    :: intType :
    outResultType := inLeftExpressionType;
  else
    error here : "shift between " . [inLeftExpressionType messageGoilTemplateType]
      ." and " . [inRightExpressionType messageGoilTemplateType] . " is not valid"
      : outResultType
   ;
  end match;
end routine;

#---------------------------------------------------------------------------*

routine right_shift_types_checkForTemplate
  ??@Ttype inLeftExpressionType
  ??@Ttype inRightExpressionType
  !@Ttype outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when intType    :: intType :
    outResultType := inLeftExpressionType;
  else
    error here : "shift between " . [inLeftExpressionType messageGoilTemplateType]
      ." and " . [inRightExpressionType messageGoilTemplateType] . " is not valid"
      : outResultType
   ;
  end match;
end routine;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    A D D I T I O N    O P E R A T O R                         *
#                                                                           *
#---------------------------------------------------------------------------*

routine addition_types_checkForTemplate
  ??@Ttype inLeftExpressionType
  ??@Ttype inRightExpressionType
  !@Ttype outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when intType      :: intType :
    outResultType := inLeftExpressionType;
  else
    error here : "addition between " . [inLeftExpressionType messageGoilTemplateType]
      ." and " . [inRightExpressionType messageGoilTemplateType] . " is not valid"
      : outResultType
   ;
  end match;
end routine;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    C O N C A T E N A T I O N    O P E R A T O R               *
#                                                                           *
#---------------------------------------------------------------------------*

routine concatenation_types_checkForTemplate
  ??@Ttype inLeftExpressionType
  ??@Ttype inRightExpressionType
  !@Ttype outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when stringType        :: stringType :
    outResultType := inLeftExpressionType;
  when listType :: listType :
    outResultType := inLeftExpressionType;
  else
    error here : "addition between " . [inLeftExpressionType messageGoilTemplateType]
      ." and " . [inRightExpressionType messageGoilTemplateType] . " is not valid"
      : outResultType
   ;
  end match;
end routine;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    S U B S T R A C T I O N    O P E R A T O R                 *
#                                                                           *
#---------------------------------------------------------------------------*

routine substraction_types_checkForTemplate
  ??@Ttype inLeftExpressionType
  ??@Ttype inRightExpressionType
  !@Ttype outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when intType      :: intType :
    outResultType := inLeftExpressionType;
  else
    error here : "substraction between " . [inLeftExpressionType messageGoilTemplateType]
      ." and " . [inRightExpressionType messageGoilTemplateType] . " is not valid"
      : outResultType
   ;
  end match;
end routine;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    M U L T I P L Y    O P E R A T O R                         *
#                                                                           *
#---------------------------------------------------------------------------*

routine multiply_types_checkForTemplate
  ??@Ttype inLeftExpressionType
  ??@Ttype inRightExpressionType
  !@Ttype outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when intType      :: intType :
    outResultType := inLeftExpressionType;
  else
    error here : "multiplication between " . [inLeftExpressionType messageGoilTemplateType]
      ." and " . [inRightExpressionType messageGoilTemplateType] . " is not valid"
      : outResultType
   ;
  end match;
end routine;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    D I V I D E    O P E R A T O R                             *
#                                                                           *
#---------------------------------------------------------------------------*

routine divide_types_checkForTemplate
  ??@Ttype inLeftExpressionType
  ??@Ttype inRightExpressionType
  !@Ttype outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when intType      :: intType :
    outResultType := inLeftExpressionType;
  else
    error here : "division between " . [inLeftExpressionType messageGoilTemplateType]
      ." and " . [inRightExpressionType messageGoilTemplateType] . " is not valid"
      : outResultType
   ;
  end match;
end routine;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    M O D U L O    O P E R A T O R                             *
#                                                                           *
#---------------------------------------------------------------------------*

routine modulo_types_checkForTemplate
  ??@Ttype inLeftExpressionType
  ??@Ttype inRightExpressionType
  !@Ttype outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when intType      :: intType :
    outResultType := inLeftExpressionType;
  else
    error here : "modulo between " . [inLeftExpressionType messageGoilTemplateType]
      ." and " . [inRightExpressionType messageGoilTemplateType] . " is not valid"
      : outResultType
   ;
  end match;
end routine;

#------------------------------------------------------------------------------*
#                                                                              *
#  A R G U M E N T    L I S T    S I G N A T U R E                             *
#                                                                              *
#------------------------------------------------------------------------------*

function argumentListSignature
  ??@TexpressionList inParameterTypeList
  -> @string outResult
:
  outResult := " this method call has ";
  outResult .= [[inParameterTypeList length] string] . " argument";
  outResult .= if [inParameterTypeList length] > 0 then "s" else "" end;
  foreach inParameterTypeList
  before outResult .= ": ";
  do outResult .= [mType messageGoilTemplateType];
  between outResult .= ", ";
  end foreach;
end function;

#------------------------------------------------------------------------------*
#                                                                              *
#  C H E C K    I N V O C A T I O N    H A S   N O    A R G U M E N T          *
#                                                                              *
#------------------------------------------------------------------------------*

routine checkInvocationHasNoArgument
  ??@Ttype inType
  ??@lstring inMethodName
  ??@TexpressionList inParameterTypeList
:
  if [inParameterTypeList length] > 0 then
    error inMethodName:"calling '" . inMethodName . "' on a "
    . [inType messageGoilTemplateType] . " type requires no argument; "
    . argumentListSignature [!inParameterTypeList];
  end if;
end routine;

routine checkInvocationHasArguments
  ??@Ttype inType
  ??@lstring inMethodName
  ??@TexpressionList inParameterTypeList
  ??@Ttype inExpectedType
  ??@uint argsNumber
:
  @Ttype parameterType;
  [inParameterTypeList first ?* ?parameterType];
  if [inParameterTypeList length] != argsNumber | parameterType != inExpectedType then
    error inMethodName:"calling '" . inMethodName . "' on a "
    . [inType messageGoilTemplateType] . " type requires ".argsNumber." unsigned argument(s); "
    . argumentListSignature [!inParameterTypeList];
  end if;  
end routine;

#------------------------------------------------------------------------------*
#                                                                              *
#  M E T H O D    I N V O C A T I O N                                          *
#                                                                              *
#------------------------------------------------------------------------------*

routine templateMethodInvocation
  ??@Ttype inType
  ??@Tvalue inValue
  ??@lstring inMethodName
  ??@TexpressionList inParameterTypeList
  !@Ttype outResultType
  !@Tvalue outResultValue
:
  switch inType
  when boolType :
    if [inMethodName string] == "trueOrFalse" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList;
      outResultType := [@Ttype stringType];
      outResultValue := valueWithString [
        ! if [inValue mInt64Value] > 0LS then "true" else "false" end
      ];
    elsif [inMethodName string] == "yesOrNo" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList;
      outResultType := [@Ttype stringType];
      outResultValue := valueWithString [
        ! if [inValue mInt64Value] > 0LS then "yes" else "no" end
      ];
    elsif [inMethodName string] == "unsigned" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList;
      outResultType := [@Ttype intType];
      outResultValue := inValue;
    else
      error inMethodName: "the ".inMethodName." template method is not defined" : outResultValue, outResultType;
    end if;
  when intType :
    if [inMethodName string] == "string" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList;
      outResultType := [@Ttype stringType];
      outResultValue := valueWithString [![[inValue mInt64Value] string]];
    elsif [inMethodName string] == "hexString" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList;
      outResultType := [@Ttype stringType];
      outResultValue := valueWithString [![[[inValue mInt64Value] uint64] hexString]];
    elsif [inMethodName string] == "numberOfBytes" | [inMethodName string] == "signedNumberOfBytes" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList;
      outResultType := [@Ttype intType];
      @sint64 value := [inValue mInt64Value];
      # compute the number of bytes needed
      @uint numberOfBytes := 1;
      if [inMethodName string] == "signedNumberOfBytes" then
        value := value * 2;
      end if;
      @uint count := 0;
      loop 4:
      while count < 4 do
        @sint64 maxValue := (1LS << (numberOfBytes * 8)) - 1LS;
        if maxValue < value then
          numberOfBytes := numberOfBytes * 2;
        end if;
        count++;
      end loop;
      outResultValue := valueWithUnsigned [![numberOfBytes uint64]];
    else
      error inMethodName: "the ".inMethodName." template method is not defined for ".[inType messageGoilTemplateType] : outResultValue, outResultType;
    end if;
  when stringType :
    if [inMethodName string] == "HTMLRepresentation" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList;
      outResultType := [@Ttype stringType];
      outResultValue := valueWithString [![[inValue mStringValue] HTMLRepresentation]];
    elsif [inMethodName string] == "identifierRepresentation" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList;
      outResultType := [@Ttype stringType];
      outResultValue := valueWithString [![[inValue mStringValue] identifierRepresentation]];
    elsif [inMethodName string] == "fileExists" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList;
      outResultType := [@Ttype boolType];
      outResultValue := valueWithBool [![[inValue mStringValue] fileExists]];
    elsif [inMethodName string] == "lowercaseString" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList;
      outResultType := [@Ttype stringType];
      outResultValue := valueWithString [![[inValue mStringValue] lowercaseString]];
    elsif [inMethodName string] == "length" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList;
      outResultType := [@Ttype intType];
      outResultValue := valueWithUnsigned [![[[inValue mStringValue] length] uint64]];
    elsif [inMethodName string] == "stringByCapitalizingFirstCharacter" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList;
      outResultType := [@Ttype stringType];
      outResultValue := valueWithString [![[inValue mStringValue] stringByCapitalizingFirstCharacter]];
    elsif [inMethodName string] == "uppercaseString" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList;
      outResultType := [@Ttype stringType];
      outResultValue := valueWithString [![[inValue mStringValue] uppercaseString]];
    elsif [inMethodName string] == "unsigned" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList;
      outResultType := [@Ttype intType];
      outResultValue := valueWithUnsigned [![[[inValue mStringValue] decimalUnsignedNumber] uint64]];
    elsif [inMethodName string] == "leftSubString" then
      checkInvocationHasArguments !inType !inMethodName !inParameterTypeList ![@Ttype intType] !1;
      @Tvalue parameter;
      [inParameterTypeList first ?parameter ?*];
      outResultType := [@Ttype stringType];
      outResultValue := valueWithString [![[inValue mStringValue] leftSubString ![[parameter mInt64Value] uint]]];
    elsif [inMethodName string] == "rightSubString" then
      checkInvocationHasArguments !inType !inMethodName !inParameterTypeList ![@Ttype intType] !1;
      @Tvalue parameter;
      [inParameterTypeList first ?parameter ?*];
      outResultType := [@Ttype stringType];
      outResultValue := valueWithString [![[inValue mStringValue] rightSubString ![[parameter mInt64Value] uint]]];
    elsif [inMethodName string] == "subString" then
      checkInvocationHasArguments !inType !inMethodName !inParameterTypeList ![@Ttype intType] !2;
      @Tvalue start := [inParameterTypeList mValueAtIndex !0];
      @Tvalue length := [inParameterTypeList mValueAtIndex !1];
#      log start;
#      log length;
      outResultType := [@Ttype stringType];
      outResultValue := valueWithString [![[inValue mStringValue] subString ![[start mInt64Value] uint] ![[length mInt64Value] uint]]];
    elsif [inMethodName string] == "reversedString" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList;
      outResultType := [@Ttype stringType];
      outResultValue := valueWithString [![[inValue mStringValue] reversedString]];
    elsif [inMethodName string] == "componentsSeparatedByString" then
      checkInvocationHasArguments !inType !inMethodName !inParameterTypeList ![@Ttype stringType] !1;
      @Tvalue separator;
      [inParameterTypeList first ?separator ?*];
      @stringlist stringlist := [[inValue mStringValue] componentsSeparatedByString ![separator mStringValue]];
      @TfieldMapList result [emptyList];
      foreach stringlist do
        @TfieldMap item [emptyMap];
        addStringValue !?item !lstringWith[!"VALUE"] !mValue;
        result += !item;
      end foreach;
      outResultType := [@Ttype listType];
      outResultValue := valueWithList[!result];
    else
      error inMethodName: "the ".inMethodName." template method is not defined for ".[inType messageGoilTemplateType] : outResultValue, outResultType;
    end if;
  when floatType:
      error inMethodName: "the ".inMethodName." template method is not defined for ".[inType messageGoilTemplateType] : outResultValue, outResultType;
  when listType :
    if [inMethodName string] == "length" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList;
      outResultType := [@Ttype intType];
      outResultValue := valueWithUnsigned [![[[inValue mMapListValue] length] uint64]];
    elsif [inMethodName string] == "first" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList;
      outResultType := [@Ttype structType];
      @TfieldMap firstElement;
      [[inValue mMapListValue] first ?firstElement];
      outResultValue := valueWithStruct [!firstElement];
    elsif [inMethodName string] == "last" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList;
      outResultType := [@Ttype structType];
      @TfieldMap lastElement;
      [[inValue mMapListValue] last ?lastElement];
      outResultValue := valueWithStruct [!lastElement];
    else
      error inMethodName: "the ".inMethodName." template method is not defined for ".[inType messageGoilTemplateType] : outResultValue, outResultType;
    end if;
  when enumType, structType, mapType:
      error inMethodName: "the ".inMethodName." template method is not defined for ".[inType messageGoilTemplateType] : outResultValue, outResultType;
  when unconstructedType, functionType:
    error here: "internal error, unconstructed type found": outResultValue, outResultType;
  end switch;
end routine;

#------------------------------------------------------------------------------*
#                                                                              *
#   E X P R E S S I O N                                                        *
#                                                                              *
#------------------------------------------------------------------------------*

rule <expression>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  <relation_term>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?outValue
    ?outResultType
 ;
  repeat
  while
    $|$;
    @Tvalue leftOperand := outValue;
    @Tvalue rightOperand;
    @Ttype firstOperandType := outResultType;
    @Ttype secondOperandType;
    <relation_term>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightOperand
      ?secondOperandType
   ;
    outValue->mInt64Value := [leftOperand mInt64Value] | [rightOperand mInt64Value];
    matchOrOperatorForTemplate
      !firstOperandType
      !secondOperandType
      ?outResultType
    ;
  while
    $^$;
    @Tvalue leftOperand := outValue;
    @Tvalue rightOperand;
    @Ttype firstOperandType := outResultType;
    @Ttype secondOperandType;
    <relation_term>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightOperand
      ?secondOperandType
   ;
    outValue->mInt64Value := [leftOperand mInt64Value] ^ [rightOperand mInt64Value];
    matchXorOperatorForTemplate
      !firstOperandType
      !secondOperandType
      ?outResultType
    ;
  end repeat;
end rule;

#------------------------------------------------------------------------------*
#                                                                              *
#   R E L A T I O N    T E R M                                                 *
#                                                                              *
#------------------------------------------------------------------------------*

rule <relation_term>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  <relation_factor>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?outValue
    ?outResultType
 ;
  repeat
  while
    $&$;
    @Tvalue leftOperand := outValue;
    @Tvalue rightOperand;
    @Ttype firstOperandType := outResultType;
    @Ttype secondOperandType;
    <relation_factor>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightOperand
      ?secondOperandType
   ;
    outValue->mInt64Value := [leftOperand mInt64Value] & [rightOperand mInt64Value];
    matchAndOperatorForTemplate
      !firstOperandType
      !secondOperandType
      ?outResultType
   ;
  end repeat;
end rule;

#------------------------------------------------------------------------------*
#                                                                              *
#   R E L A T I O N    F A C T O R                                             *
#                                                                              *
#------------------------------------------------------------------------------*

rule <relation_factor>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  <simple_expression>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?outValue
    ?outResultType
 ;
  select
  or
    $==$;
    @Tvalue leftExpression := outValue;
    @Ttype leftType := outResultType;
    @Tvalue rightExpression;
    @Ttype rightType;
    <simple_expression>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType;
    comparison_types_checkForTemplate !leftType !rightType;
    @bool result;
    switch leftType
    when boolType :
      result := [leftExpression mInt64Value] == [rightExpression mInt64Value];
    when intType :
      result := [leftExpression mInt64Value] == [rightExpression mInt64Value];
    when floatType :
      result := [leftExpression mFloatValue] == [rightExpression mFloatValue];
    when stringType :
      result := [leftExpression mStringValue] == [rightExpression mStringValue];
    when enumType :
      result := [leftExpression mStringValue] == [rightExpression mStringValue];
    when listType, structType, mapType:
      error here: "lists, structs and maps may not be compared" : result;
    when unconstructedType, functionType:
      error here: "internal error, unconstructed type found" : result;
    end switch;
    outResultType := [@Ttype boolType];
    outValue-> mInt64Value := if result then 1LS else 0LS end;
  or
    $!=$;
    @Tvalue leftExpression := outValue;
    @Ttype leftType := outResultType;
    @Tvalue rightExpression;
    @Ttype rightType;
    <simple_expression>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
   ;
    comparison_types_checkForTemplate !leftType !rightType;
    @bool result;
    switch leftType
    when boolType :
      result := [leftExpression mInt64Value] != [rightExpression mInt64Value];
    when intType :
      result := [leftExpression mInt64Value] != [rightExpression mInt64Value];
    when floatType :
      result := [leftExpression mFloatValue] != [rightExpression mFloatValue];
    when stringType :
      result := [leftExpression mStringValue] != [rightExpression mStringValue];
    when enumType :
      result := [leftExpression mStringValue] != [rightExpression mStringValue];
    when listType, structType, mapType:
      error here: "lists, structs and maps may not be compared": result;
    when unconstructedType, functionType:
      error here: "internal error, unconstructed type found" : result;
    end switch;
    outResultType := [@Ttype boolType];
    outValue-> mInt64Value := if result then 1LS else 0LS end;
  or
    $<=$;
    @Tvalue leftExpression := outValue;
    @Ttype leftType := outResultType;
    @Tvalue rightExpression;
    @Ttype rightType;
    <simple_expression>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
   ;
    magnitude_comparison_types_checkForTemplate !leftType !rightType;
    @bool result;
    switch leftType
    when boolType :
      result := [leftExpression mInt64Value] <= [rightExpression mInt64Value];
    when intType :
      result := [leftExpression mInt64Value] <= [rightExpression mInt64Value];
    when floatType :
      result := [leftExpression mFloatValue] <= [rightExpression mFloatValue];
    when stringType, enumType, listType, structType, mapType :
      result := false;
    when unconstructedType, functionType:
      error here: "internal error, unconstructed type found" : result;
    end switch;
    outResultType := [@Ttype boolType];
    outValue-> mInt64Value := if result then 1LS else 0LS end;
  or
    $>=$;
    @Tvalue leftExpression := outValue;
    @Ttype leftType := outResultType;
    @Tvalue rightExpression;
    @Ttype rightType;
    <simple_expression>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
   ;
    magnitude_comparison_types_checkForTemplate !leftType !rightType;
    @bool result;
    switch leftType
    when boolType :
      result := [leftExpression mInt64Value] >= [rightExpression mInt64Value];
    when intType :
      result := [leftExpression mInt64Value] >= [rightExpression mInt64Value];
    when floatType :
      result := [leftExpression mFloatValue] >= [rightExpression mFloatValue];
    when stringType, enumType, listType, structType, mapType :
      result := false;
    when unconstructedType, functionType:
      error here: "internal error, unconstructed type found" : result;
    end switch;
    outResultType := [@Ttype boolType];
    outValue-> mInt64Value := if result then 1LS else 0LS end;
  or
    $>$;
    @Tvalue leftExpression := outValue;
    @Ttype leftType := outResultType;
    @Tvalue rightExpression;
    @Ttype rightType;
    <simple_expression>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
   ;
    magnitude_comparison_types_checkForTemplate !leftType !rightType;
    @bool result;
    switch leftType
    when boolType :
      result := [leftExpression mInt64Value] > [rightExpression mInt64Value];
    when intType :
      result := [leftExpression mInt64Value] > [rightExpression mInt64Value];
    when floatType :
      result := [leftExpression mFloatValue] > [rightExpression mFloatValue];
    when stringType, enumType, listType, structType, mapType :
      result := false;
    when unconstructedType, functionType:
      error here: "internal error, unconstructed type found" : result;
    end switch;
    outResultType := [@Ttype boolType];
    outValue-> mInt64Value := if result then 1LS else 0LS end;
  or
    $<$;
    @Tvalue leftExpression := outValue;
    @Ttype leftType := outResultType;
    @Tvalue rightExpression;
    @Ttype rightType;
    <simple_expression>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
   ;
    magnitude_comparison_types_checkForTemplate !leftType !rightType;
    @bool result;
    switch leftType
    when boolType :
      result := [leftExpression mInt64Value] < [rightExpression mInt64Value];
    when intType :
      result := [leftExpression mInt64Value] < [rightExpression mInt64Value];
    when floatType :
      result := [leftExpression mFloatValue] < [rightExpression mFloatValue];
    when stringType, enumType, listType, structType, mapType :
      result := false;
    when unconstructedType, functionType:
      error here: "internal error, unconstructed type found" : result;
    end switch;
    outResultType := [@Ttype boolType];
    outValue-> mInt64Value := if result then 1LS else 0LS end;
  end select;
end rule;

#------------------------------------------------------------------------------*
#                                                                              *
#   S I M P L E    E X P R E S S I O N                                         *
#                                                                              *
#------------------------------------------------------------------------------*

rule <simple_expression>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  <term>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?outValue
    ?outResultType
 ;
  repeat
  while 
    $<<$;
    @Tvalue leftExpression := outValue;
    @Ttype leftType := outResultType;
    @Tvalue rightExpression;
    @Ttype rightType;
    <term>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
   ;
    left_shift_types_checkForTemplate !leftType !rightType ?outResultType;
    outValue-> mInt64Value := [leftExpression mInt64Value] << [[rightExpression mInt64Value] uint];
  while 
    $>>$;
    @Tvalue leftExpression := outValue;
    @Ttype leftType := outResultType;
    @Tvalue rightExpression;
    @Ttype rightType;
    <term>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
   ;
    right_shift_types_checkForTemplate !leftType !rightType ?outResultType;
    outValue-> mInt64Value := [leftExpression mInt64Value] >> [[rightExpression mInt64Value] uint];
  while 
    $+$;
    @Tvalue leftExpression := outValue;
    @Ttype leftType := outResultType;
    @Tvalue rightExpression;
    @Ttype rightType;
    <term>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
    ;
    addition_types_checkForTemplate !leftType !rightType ?outResultType;
    outValue-> mInt64Value := [leftExpression mInt64Value] + [rightExpression mInt64Value];
  while 
    $.$;
    @Tvalue leftExpression := outValue;
    @Ttype leftType := outResultType;
    @Tvalue rightExpression;
    @Ttype rightType;
    <term>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
    ;
    concatenation_types_checkForTemplate !leftType !rightType ?outResultType;
    if outResultType == [@Ttype stringType] then
      outValue->mStringValue := [leftExpression mStringValue] . [rightExpression mStringValue];
    elsif outResultType == [@Ttype listType] then
      outValue->mMapListValue := [leftExpression mMapListValue] . [rightExpression mMapListValue];
    end if;
  while 
    $-$;
    @Tvalue leftExpression := outValue;
    @Ttype leftType := outResultType;
    @Tvalue rightExpression;
    @Ttype rightType;
    <term>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
   ;
    addition_types_checkForTemplate !leftType !rightType ?outResultType;
    outValue-> mInt64Value := [leftExpression mInt64Value] - [rightExpression mInt64Value];
  end repeat;
end rule;

#------------------------------------------------------------------------------*
#                                                                              *
#   T E R M                                                                    *
#                                                                              *
#------------------------------------------------------------------------------*

rule <term>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  <factor>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?outValue
    ?outResultType
 ;
  repeat
  while 
    $*$;
    @Tvalue leftExpression := outValue;
    @Ttype leftType := outResultType;
    @Tvalue rightExpression;
    @Ttype rightType;
    <factor>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
   ;
    multiply_types_checkForTemplate !leftType !rightType ?outResultType;
    outValue-> mInt64Value := [leftExpression mInt64Value] * [rightExpression mInt64Value];
  while 
    $/$;
    @Tvalue leftExpression := outValue;
    @Ttype leftType := outResultType;
    @Tvalue rightExpression;
    @Ttype rightType;
    <factor>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
   ;
    divide_types_checkForTemplate !leftType !rightType ?outResultType;
    outValue-> mInt64Value := [leftExpression mInt64Value] / [rightExpression mInt64Value];
  while 
    $mod$;
    @Tvalue leftExpression := outValue;
    @Ttype leftType := outResultType;
    @Tvalue rightExpression;
    @Ttype rightType;
    <factor>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
   ;
    modulo_types_checkForTemplate !leftType !rightType ?outResultType;
    outValue-> mInt64Value := [leftExpression mInt64Value] mod [rightExpression mInt64Value];
#    log leftExpression;
#    log rightExpression;
#    log outValue;
  end repeat;
end rule;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    ( EXPRESSION )                                         *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  $($;
  <expression>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?outValue
    ?outResultType
 ;
  $)$;
end rule;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    not FACTOR                                             *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  $not$;
  @Tvalue expression;
  @Ttype operandType;
  <factor>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?expression
    ?operandType
 ;
  outValue := valueWithUnsigned[!1L - [expression mInt64Value]];
  checkNotOperatorForTemplate !operandType ?outResultType;
end rule;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    ~ FACTOR                                               *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  $~$;
  @Tvalue value;
  @Ttype operandType;
  <factor>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?value
    ?operandType
 ;
  outValue := valueWithSigned[!~ [value mInt64Value]];
  checkBitComplementOperatorForTemplate !operandType ?outResultType;
end rule;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    true                                                   *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@string unused inPrefix
  ??@string unused inPath
  ??@string unused inTemplateDirectory
  ??@TfieldMap unused inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  $yes$;
  outValue := valueWithUnsigned[!1L];
  outResultType := [@Ttype boolType];
end rule;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    false                                                  *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@string unused inPrefix
  ??@string unused inPath
  ??@string unused inTemplateDirectory
  ??@TfieldMap unused inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  $no$;
  outValue := valueWithUnsigned[!0L];
  outResultType := [@Ttype boolType];
end rule;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    a 64-bit unsigned literal integer value                *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@string unused inPrefix
  ??@string unused inPath
  ??@string unused inTemplateDirectory
  ??@TfieldMap unused inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  @lsint64 literalInt;
  $signed_literal_integer64$ ?literalInt;
  outValue := valueWithSigned[![literalInt sint64]];
  outResultType := [@Ttype intType];
end rule;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    a literal string value                                 *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@string unused inPrefix
  ??@string unused inPath
  ??@string unused inTemplateDirectory
  ??@TfieldMap unused inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  $string$ ?@lstring literalString;
  outValue := valueWithString[![literalString string]];
  outResultType := [@Ttype stringType];
end rule;

#------------------------------------------------------------------------------*
#                                                                              *
#                         F A C T O R                                          *
#   template method call :   [expression method !... ]                         *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  $[$;

  @Tvalue expressionValue;
  @Ttype expressionType;
  <expression>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?expressionValue
    ?expressionType
 ;

  $identifier$ ? @lstring templateMethodName;

  @TexpressionList expressionList [emptyList];
  select
  or
    $:$;
    repeat
      @Tvalue expression;
      @Ttype resultType;
      <expression>
        !inPrefix
        !inPath
        !inTemplateDirectory
        !inVariableMap
        ?expression
        ?resultType
     ;
      expressionList += !expression !resultType;
    while
      $,$;
    end repeat;
  end select;

  $]$;

  templateMethodInvocation
    !expressionType
    !expressionValue
    !templateMethodName
    !expressionList
    ?outResultType
    ?outValue
 ;
end rule;

#------------------------------------------------------------------------------*
#                                                                              *
#                         F A C T O R                                          *
#   function call        :   function_name (..., ...)                          *
#   variable             :   variable_name                                     *
#                                                                              *
#------------------------------------------------------------------------------*

routine typeError
  ??@lstring inFunctionName
  ??@type inActualType
  ??@string inExpectedTypeName
  ??@uint inParameterIndex
:
  @string m := "the function requires the parameter " . [inParameterIndex string]
  . " to be " . inExpectedTypeName . "; its type is "
 ;
  if inActualType == `@bool then
    m .= "boolean";
  elsif inActualType == `@uint64 then
    m .= "unsigned";
  elsif inActualType == `@string then
    m .= "string";
  else
    m .= "a not allowed type";
  end if;
  error inFunctionName : m;
end routine;

#------------------------------------------------------------------------------*

rule <factor>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  @TvarPath path;
  <variable> !inPrefix !inPath !inTemplateDirectory !inVariableMap ?path;
  select
    searchField !path !inVariableMap ?outResultType ?outValue ?*;
  or
    @lstring functionOrVariableName;
    [path first ?functionOrVariableName ?* ?*];
#    message "FUNCTION ".[functionOrVariableName string]." ";
  #--- Parse actual arguments
    @TexpressionList actualArgumentList [emptyList];
    $($;
    repeat
      @Tvalue expression;
      @Ttype resultType;
      <expression>
        !inPrefix
        !inPath
        !inTemplateDirectory
        !inVariableMap
        ?expression
        ?resultType
     ;
      actualArgumentList += !expression !resultType;
    while
      $,$;
    end repeat;
    $)$;
  #--- Search for function name
  #--- function can be a built in function or a defined function
    if not [@function isFunctionDefined ![functionOrVariableName string]] then
      #--- the function is not built in, search the function
#      message "NOT BUILT IN\n";
      @Tvalue fct;
      @Ttype type;
      [inVariableMap searchKey !functionOrVariableName ?type ?fct];
      if [actualArgumentList length] != [[[fct mFunctionValue] args] length] then
        error here : "incorrect number of arguments" : outValue, outResultType;
      else
        # set up a variable map for local variables of the function
        @TfieldMap locals [emptyMap];
        # search arguments values and add them to the locals
        foreach actualArgumentList prefixedby actual_ , [[fct mFunctionValue] args] prefixedby expected_ do
          [!?locals insertKey !expected_mValue !actual_mType !actual_mValue];
        end foreach;
        @string result := "";
#        message "calling ".[[fct mFunctionValue] name]."\n";
        grammar template_grammar on [[fct mFunctionValue] content] !inPrefix !inPath !inTemplateDirectory !locals !?result ?outValue ?outResultType;
      end if;
#      error functionOrVariableName : "there is no '" . functionOrVariableName . "' function defined in GOIL template language" : f;
    else
#      message "BUILT IN\n";
      @function f;
      f := [@function functionWithName ![functionOrVariableName string]];
      #--- Check arguments
      @objectlist actualArgumentObjectList [emptyList];
      const @typelist formalParameterList := [f formalParameterTypeList];
      if [formalParameterList length] != [actualArgumentList length] then
        error functionOrVariableName: "this function is invoked with "
        . [[actualArgumentList length] string]
        . " parameter" . if [actualArgumentList length] > 1 then "s" else "" end
        . ", but requires " 
        . [[formalParameterList length] string]
        . " parameter" . if [formalParameterList length] > 1 then "s" else "" end
        : outValue, outResultType;
      else
        @uint idx := 1;
        foreach formalParameterList prefixedby formal_, actualArgumentList prefixedby actual_ do
          switch actual_mType
          when boolType :
            if formal_mValue != `@bool then
              typeError !functionOrVariableName !formal_mValue !"boolean" !idx;
            end if;
            actualArgumentObjectList += ![if [actual_mValue mInt64Value] == 0LS then false else true end object];
          when intType :
            if formal_mValue != `@sint64 then
              typeError !functionOrVariableName !formal_mValue !"unsigned" !idx;
            end if;
            actualArgumentObjectList += ![[actual_mValue mInt64Value] object];
          when floatType :
            if formal_mValue != `@double then
              typeError !functionOrVariableName !formal_mValue !"float" !idx;
            end if;
            actualArgumentObjectList += ![[actual_mValue mFloatValue] object];
          when stringType :
            if formal_mValue != `@string then
              typeError !functionOrVariableName !formal_mValue !"string" !idx;
            end if;
          when enumType :
            if formal_mValue != `@string then
              typeError !functionOrVariableName !formal_mValue !"enum" !idx;
            end if;
            actualArgumentObjectList += ![[actual_mValue mStringValue] object];
          when listType, structType, mapType :
            typeError !functionOrVariableName !formal_mValue !"string" !idx;
          when unconstructedType, functionType:
            error here: "internal error, unconstructed type found";
          end switch;
          idx ++;     
        end foreach;
        outResultType := [@Ttype intType];
        outValue := valueWithSigned[!0LS];
        if [@uint errorCount] == 0 then
          const @object result := [f invoke !actualArgumentObjectList ![functionOrVariableName location]];
          if [result objectDynamicType] == `@sint64 then
            outResultType := [@Ttype intType];
            outValue->mInt64Value := (cast result if == @sint64 else error functionOrVariableName);
          elsif [result objectDynamicType] == `@bool then
            outResultType := [@Ttype boolType];
            outValue->mInt64Value := [(cast result if == @bool else error functionOrVariableName) sint64];
          elsif [result objectDynamicType] == `@string then
            outResultType := [@Ttype stringType];
            outValue->mStringValue := (cast result if == @string else error functionOrVariableName);
          else
            error functionOrVariableName : "this function does not return an unsigned, boolean or string value";
          end if;
        end if;
      end if;
    end if;
#    message "END OF FUNCTION\n";
  end select;
end rule;

#------------------------------------------------------------------------------*

rule <factor>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  @TvarPath path;
  $exists$; <variable> !inPrefix !inPath !inTemplateDirectory !inVariableMap ?path;

  @Ttype variableType;
  @Tvalue variableValue;
  @bool varExists;

  searchFieldIfExists !path !inVariableMap ?variableType ?variableValue ?varExists;

  select
    $default$;
    @Tvalue expression;
    @Ttype resultType;
    $($;
    <expression>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?expression
      ?resultType
    ;
    $)$;
    if varExists then
      outResultType := variableType;
      outValue := variableValue;
    else
      outResultType := resultType;
      outValue := expression;
    end if;
  or
    outResultType := [@Ttype boolType];
    if varExists then
      outValue := valueWithUnsigned[!1L];
    else
      outValue := valueWithUnsigned[!0L];
    end if;
  end select;
end rule;

#------------------------------------------------------------------------------*

rule <factor>
  ??@string inPrefix
  ??@string  inPath
  ??@string  inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  @TvarPath variableName;
  $typeof$; <variable> !inPrefix !inPath !inTemplateDirectory !inVariableMap ?variableName;
  @Ttype variableType;
  @Tvalue variableValue;
  searchField !variableName !inVariableMap ?variableType ?variableValue ?*;
  outResultType := [@Ttype enumType];
  outValue := valueWithString[![variableType messageGoilTemplateType]];
end rule;

#------------------------------------------------------------------------------*

rule <factor>
  ??@string unused inPrefix
  ??@string unused inPath
  ??@string unused inTemplateDirectory
  ??@TfieldMap unused inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  select
    $true$;
    outValue := valueWithUnsigned[!1L];
  or
    $false$;
    outValue := valueWithUnsigned[!0L];
  end select;
  outResultType := [@Ttype boolType];
end rule;

#------------------------------------------------------------------------------*

rule <factor>
  ??@string unused inPrefix
  ??@string unused inPath
  ??@string unused inTemplateDirectory
  ??@TfieldMap unused inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  $@$; $identifier$ ?@lstring enumValue;
  outValue := valueWithString[![enumValue string]];
  outResultType := [@Ttype enumType];
end rule;

#------------------------------------------------------------------------------*

rule <factor>
  ??@string unused inPrefix
  ??@string unused inPath
  ??@string unused inTemplateDirectory
  ??@TfieldMap unused inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  $emptylist$;
  outValue := [@Tvalue new !0LS !0.0 !"" ![@TfieldMapList emptyList] ![@TfieldMap emptyMap] !dummyFunction[]];
  outResultType := [@Ttype listType];
end rule;

#------------------------------------------------------------------------------*

rule <factor>
  ??@string unused inPrefix
  ??@string unused inPath
  ??@string unused inTemplateDirectory
  ??@TfieldMap unused inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  $emptymap$;
  outValue := [@Tvalue new !0LS !0.0 !"" ![@TfieldMapList emptyList] ![@TfieldMap emptyMap] !dummyFunction[]];
  outResultType := [@Ttype mapType];
end rule;

#------------------------------------------------------------------------------*

rule <factor>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  $mapof$;
  @Tvalue expValue;
  @Ttype expType;
  <expression> !inPrefix !inPath !inTemplateDirectory !inVariableMap ?expValue ?expType;
  @location where := here;
  $by$;
  $identifier$ ?@lstring key;
  
  if expType != [@Ttype listType] then
    error where: "list expected": outValue, outResultType;
  else
    # get the elements of the list to build a map, each key being
    # one of the field of the elements of the list
    @TfieldMap resultMap [emptyMap];
    foreach [expValue mMapListValue] do
      if [mMap hasKey ![key string]] then
        # the specified key is found, get it and check it is a string
        @Ttype keyType;
        @Tvalue keyValue;
        [mMap searchKey !key ?keyType ?keyValue];
        if keyType == [@Ttype stringType] then
          @lstring keyVal := [@lstring new ![keyValue mStringValue] ![mMap locationForKey ![key string]]];
          [!?resultMap insertKey !keyVal ![@Ttype structType] !valueWithMap[!mMap]];
        else
          error [mMap locationForKey ![key string]]: "the list element specified key is not a string";
        end if;
      else
        error here: "the list element has not the specified key";
      end if;
    end foreach;
    outResultType := [@Ttype mapType];
    outValue := valueWithMap[!resultMap];
  end if;
end rule;

#------------------------------------------------------------------------------*

rule <factor>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  $listof$;
  @TvarPath path;
  <variable> !inPrefix !inPath !inTemplateDirectory !inVariableMap ?path;
#  $by$;
#  $identifier$ ?@lstring key;
  
  @Ttype variableType;
  @Tvalue variableValue;
  @location where;
  searchField !path !inVariableMap ?variableType ?variableValue ?where;
  if variableType != [@Ttype mapType] then
    error where: "map expected": outValue, outResultType;
  else
    @TfieldMapList resultList [emptyList];
    foreach [variableValue mStructValue] do
      
      resultList += ![mValue mStructValue];
    end foreach;
    outResultType := [@Ttype listType];
    outValue := valueWithList[!resultList];
  end if;
end rule;

##------------------------------------------------------------------------------*
#
#rule <factor>
#  ??@string inPrefix
#  ??@string inPath
#  ??@string inTemplateDirectory
#  ??@TfieldMap inVariableMap
#  !@Tvalue outValue
#  !@Ttype outResultType
#:
#  @string resultString := "";
#  $templateresult$;
#  select
#    $if$; $exists$;
#    @bool found;
#    $identifier$ ? @lstring templateName;
#    goilTemplateInvocation
#      !templateName
#      !inPrefix
#      !inPath
#      !inTemplateDirectory
#      !false
#      !inVariableMap
#      !?resultString
#      ?*
#    ;
#  or
#    $identifier$ ? @lstring templateName;
#    goilTemplateInvocation
#      !templateName
#      !inPrefix
#      !inPath
#      !inTemplateDirectory
#      !true
#      !inVariableMap
#      !?resultString
#      ?*
#    ;
#  end select;
#  outValue := [@Tvalue new !0L !resultString ![@TfieldMapList emptyList]];
#  outResultType := [@Ttype stringType];
#end rule;

end syntax;
