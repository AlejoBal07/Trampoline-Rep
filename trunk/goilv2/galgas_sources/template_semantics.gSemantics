#---------------------------------------------------------------------------*
#                                                                           *
#  Types for GOIL templates                                                 *
#                                                                           *
#  Copyright (C) 2009, ..., 2009 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics template_semantics :

#------------------------------------------------------------------------------*

enum @Ttype {
  boolType,
  intType,
  floatType,
  stringType,
  listType,
  mapType,
  structType,
  enumType,
  functionType,
  unconstructedType
}{}

reader @Ttype messageGoilTemplateType -> @string result:
  switch selfcopy
  when boolType : result := "bool";
  when intType : result := "int";
  when floatType : result := "float";
  when stringType : result := "string";
  when listType : result := "list";
  when mapType : result := "map";
  when structType : result := "struct";
  when enumType : result := "enum";
  when functionType : result := "function";
  when unconstructedType : result := "unconstructed";
  end switch;
end reader; 


#------------------------------------------------------------------------------*

list @TtypeList {
  @Ttype mType;
}

#------------------------------------------------------------------------------*

map @TfieldMap {
  @Ttype  mType;
  @Tvalue mValue; 
  insert insertKey error message "a template field named '%K' is already declared in %L";
  search searchKey error message "there is no template field named '%K'";
  remove removeKey error message "there is no template field named '%K' to delete";
}

#------------------------------------------------------------------------------*

struct @Tfunction {
  @lstring name;
  @lstringlist args;
  @string content;
}

function dummyFunction -> @Tfunction fct:
  fct := [@Tfunction new ![@lstring new !"" !here] ![@lstringlist emptyList] !""];
end function;

#------------------------------------------------------------------------------*

list @TfieldMapList {
  @TfieldMap mMap feature setter;
}

#------------------------------------------------------------------------------*

struct @Tvalue {
  @sint64 mInt64Value;
  @double mFloatValue;
  @string mStringValue;
  @TfieldMapList mMapListValue;
  @TfieldMap mStructValue;
  @Tfunction mFunctionValue;
  @lstring mDescription;
}

#------------------------------------------------------------------------------*

list @TexpressionList {
  @Tvalue mValue;
  @Ttype mType;
}

#------------------------------------------------------------------------------*

list @TenumationList {
  @Tvalue mEnumeratedValue;
  @string mPrefix;
}

#------------------------------------------------------------------------------*

function valueWithBool
  ??@bool inValue
  ??@lstring description
  ->@Tvalue outValue
:
  outValue := [@Tvalue new
    ![inValue sint64]
    !0.0
    !""
    ![@TfieldMapList emptyList]
    ![@TfieldMap emptyMap]
    !dummyFunction[]
    !description
  ];
end function;

#------------------------------------------------------------------------------*

function valueWithUnsigned
  ??@uint64 inValue
  ??@lstring description
  ->@Tvalue outValue
:
  outValue := [@Tvalue new
    ![inValue sint64]
    !0.0
    !""
    ![@TfieldMapList emptyList]
    ![@TfieldMap emptyMap]
    !dummyFunction[]
    !description
  ];
end function;

#------------------------------------------------------------------------------*

function valueWithSigned
  ??@sint64 inValue
  ??@lstring description
  ->@Tvalue outValue
:
  outValue := [@Tvalue new
    !inValue
    !0.0
    !""
    ![@TfieldMapList emptyList]
    ![@TfieldMap emptyMap]
    !dummyFunction[]
    !description
  ];
end function;

#------------------------------------------------------------------------------*

function valueWithFloat
  ??@double inValue
  ??@lstring description
  ->@Tvalue outValue
:
  outValue := [@Tvalue new
    !0LS
    !inValue
    !""
    ![@TfieldMapList emptyList]
    ![@TfieldMap emptyMap]
    !dummyFunction[]
    !description
  ];
end function;

#------------------------------------------------------------------------------*

function valueWithString
  ??@string inValue
  ??@lstring description
  ->@Tvalue outValue
:
  outValue := [@Tvalue new
    !0LS
    !0.0
    !inValue
    ![@TfieldMapList emptyList]
    ![@TfieldMap emptyMap]
    !dummyFunction[]
    !description
  ];
end function;

#------------------------------------------------------------------------------*

function valueWithStruct
  ??@TfieldMap inValue
  ??@lstring description
  ->@Tvalue outValue
:
  outValue := [@Tvalue new
    !0LS
    !0.0
    !""
    ![@TfieldMapList emptyList]
    !inValue
    !dummyFunction[]
    !description
  ];
end function;

#------------------------------------------------------------------------------*

function valueWithMap
  ??@TfieldMap inValue
  ??@lstring description
  ->@Tvalue outValue
:
  outValue := [@Tvalue new
    !0LS
    !0.0
    !""
    ![@TfieldMapList emptyList]
    !inValue
    !dummyFunction[]
    !description
  ];
end function;

#------------------------------------------------------------------------------*

function valueWithList
  ??@TfieldMapList inValue
  ??@lstring description
  ->@Tvalue outValue
:
  outValue := [@Tvalue new
    !0LS
    !0.0
    !""
    !inValue
    ![@TfieldMap emptyMap]
    !dummyFunction[]
    !description
  ];
end function;

#------------------------------------------------------------------------------*

function valueWithVoid
  ->@Tvalue outValue
:
  outValue := [@Tvalue new
    !0LS
    !0.0
    !""
    ![@TfieldMapList emptyList]
    ![@TfieldMap emptyMap]
    !dummyFunction[]
    ![@lstring new !"" !here]
  ];
end function;

#------------------------------------------------------------------------------*

routine addBoolValue
  ?!@TfieldMap ioTemplateVariableMap
  ??@lstring inVariableName
  ??@bool inValue
  ??@lstring description
:
  [!?ioTemplateVariableMap insertKey
    !inVariableName
    ![@Ttype boolType]
    !valueWithBool[!inValue !description]
  ];
end routine;

#------------------------------------------------------------------------------*

routine addUnsignedValue
  ?!@TfieldMap ioTemplateVariableMap
  ??@lstring inVariableName
  ??@uint64 inValue
  ??@lstring description
:
  [!?ioTemplateVariableMap insertKey
    !inVariableName
    ![@Ttype intType]
    !valueWithUnsigned[!inValue !description]
    #[@goilTemplateValue new !inValue !"" ![@goilTemplateFieldMapList emptyList]]
  ];
end routine;

#------------------------------------------------------------------------------*

routine addSignedValue
  ?!@TfieldMap ioTemplateVariableMap
  ??@lstring inVariableName
  ??@sint64 inValue
  ??@lstring description
:
  [!?ioTemplateVariableMap insertKey
    !inVariableName
    ![@Ttype intType]
    !valueWithSigned[!inValue !description]
    #[@goilTemplateValue new !inValue !"" ![@goilTemplateFieldMapList emptyList]]
  ];
end routine;

#------------------------------------------------------------------------------*

routine addFloatValue
  ?!@TfieldMap ioTemplateVariableMap
  ??@lstring inVariableName
  ??@double inValue
  ??@lstring description
:
  [!?ioTemplateVariableMap insertKey
    !inVariableName
    ![@Ttype floatType]
    !valueWithFloat[!inValue !description]
    #[@goilTemplateValue new !inValue !"" ![@goilTemplateFieldMapList emptyList]]
  ];
end routine;

#------------------------------------------------------------------------------*

routine addLUnsignedValue
  ?!@TfieldMap ioTemplateVariableMap
  ??@string inVariableName
  ??@luint64 inValue
  ??@lstring description
:
  addUnsignedValue !?ioTemplateVariableMap ![@lstring new !inVariableName ![inValue location]] ![inValue uint64] !description;
end routine;

#------------------------------------------------------------------------------*

routine addStringValue
  ?!@TfieldMap ioTemplateVariableMap
  ??@lstring inVariableName
  ??@string inValue
  ??@lstring description
:
  [!?ioTemplateVariableMap insertKey
    !inVariableName
    ![@Ttype stringType]
    !valueWithString[!inValue !description]
    #[@goilTemplateValue new !0L !inValue ![@goilTemplateFieldMapList emptyList]]
  ];
end routine;

#------------------------------------------------------------------------------*

routine addLStringValue
  ?!@TfieldMap ioTemplateVariableMap
  ??@string inVariableName
  ??@lstring inValue
  ??@lstring description
:
  addStringValue !?ioTemplateVariableMap ![@lstring new !inVariableName ![inValue location]] ![inValue string] !description;
end routine;

#------------------------------------------------------------------------------*

routine addListValue
  ?!@TfieldMap ioTemplateVariableMap
  ??@lstring inVariableName
  ??@TfieldMapList inValue
  ??@lstring description
:
  [!?ioTemplateVariableMap insertKey
    !inVariableName
    ![@Ttype listType]
    ![@Tvalue new !0LS !0.0 !"" !inValue ![@TfieldMap emptyMap] !dummyFunction[] !description]
    
  ];
end routine;

#------------------------------------------------------------------------------*

routine addStructValue
  ?!@TfieldMap ioTemplateVariableMap
  ??@lstring inVariableName
  ??@TfieldMap inValue
  ??@lstring description
:
  [!?ioTemplateVariableMap insertKey
    !inVariableName
    ![@Ttype structType]
    ![@Tvalue new !0LS !0.0 !"" ![@TfieldMapList emptyList] !inValue !dummyFunction[] !description]
  ];
end routine;

#------------------------------------------------------------------------------*

routine addEnumValue
  ?!@TfieldMap ioTemplateVariableMap
  ??@lstring inVariableName
  ??@string inValue
  ??@lstring description
:
  [!?ioTemplateVariableMap insertKey
    !inVariableName
    ![@Ttype enumType]
    !valueWithString[!inValue !description]
    #[@goilTemplateValue new !0L !inValue ![@goilTemplateFieldMapList emptyList]]
  ];
end routine;

#------------------------------------------------------------------------------*

list @TvarPath {
  @lstring item;
  @lstring key;
  @lsint idx;
}

#------------------------------------------------------------------------------*

routine printPath
  ??@TvarPath path
:
  foreach path do
    message [item string];
    if [key string] != "" then
      message "[\"".key."\"]";
    end if;
    if [idx sint] != -1s then
      message "[".[idx string]."]";
    end if;
  between message "::";
  end foreach;
end routine;

#------------------------------------------------------------------------------*

routine searchField
  ?@TvarPath variable
  ??@TfieldMap inTemplateFieldMap
  !@Ttype variableType
  !@Tvalue variableValue
  !@location variableLocation
:
  @lstring field;
  @lstring key;
  @lsint idx;
  variableLocation := here;
  [!?variable popFirst ?field ?key ?idx];
  [inTemplateFieldMap searchKey !field ?variableType ?variableValue];
  if [inTemplateFieldMap hasKey ![field string]] then
    variableLocation := [inTemplateFieldMap locationForKey ![field string]];
  end if;
  if [key string] != "" & variableType == [@Ttype mapType] then
    @TfieldMap mapMap := [variableValue mStructValue];
    [mapMap searchKey !key ?variableType ?variableValue];
    if [mapMap hasKey ![key string]] then
      variableLocation := [mapMap locationForKey ![key string]];
    end if;
  elsif [idx sint] != -1s & variableType == [@Ttype listType] then
    @TfieldMapList mapList := [variableValue mMapListValue];
    variableValue->mStructValue := [mapList mMapAtIndex ![idx uint]];
    variableType := [@Ttype structType];
  end if;
  if [variable length] > 0 then
    if variableType == [@Ttype structType] then
      searchField !variable ![variableValue mStructValue] ?variableType ?variableValue ?variableLocation;
    else
      variableLocation := here;
      error field: "struct variable expected": variableValue;
    end if;
  end if;
end routine;

#------------------------------------------------------------------------------*

routine searchFieldIfExists
  ?@TvarPath variable
  ??@TfieldMap inTemplateFieldMap
  !@Ttype variableType
  !@Tvalue variableValue
  !@bool found
:
  @lstring field;
  @lstring key;
  @lsint idx;
  [!?variable popFirst ?field ?key ?idx];
  
  if [inTemplateFieldMap hasKey ![field string]] then
    [inTemplateFieldMap searchKey !field ?variableType ?variableValue];
    if [key string] != "" then
      if variableType == [@Ttype mapType] then
        if [[variableValue mStructValue] hasKey ![key string]] then
          [[variableValue mStructValue] searchKey !key ?variableType ?variableValue];
          found := true;
        else
          found := false;
        end if;
      else
        error key : "a key is only used in a map": found;
      end if;
    elsif [idx sint] != -1s then
      if variableType == [@Ttype listType] then
        if [idx uint] < [[variableValue mMapListValue] length] then
          @TfieldMapList mapList := [variableValue mMapListValue];
          variableValue->mStructValue := [mapList mMapAtIndex ![idx uint]];
          variableType := [@Ttype structType];
          found := true;
        else
          found := false;
        end if;
      else
        error idx : "an index is only used in a list": found;
      end if;
    else
      found := true;
    end if;
  else
    variableType := [@Ttype unconstructedType];
    variableValue := valueWithVoid[];
    found := false;
  end if;
  if [variable length] > 0 & found then
    if variableType == [@Ttype structType] then
      searchFieldIfExists !variable ![variableValue mStructValue] ?variableType ?variableValue ?found;
    else
      found := false;
    end if;
  end if;
end routine;

end semantics;
