semantics goil_types_root :

import "goil_basic_types.gSemantics" ;
import "goil_routines.gSemantics" ;

#import semantics goil_semantic_types in "goil_semantic_types.ggs" ;

map @objectKindMap {
  @objectAttributes attributes;
  insert put error message "%K is duplicated in %L";
  search get error message "%K does not exists";
  remove del error message "%K does not exists";
}

class @objectKind {
  @objectKindMap objects feature setter;
}

map @objectsMap {
  @objectKind objectsOfKind;
  insert put error message "%K is duplicated in %L";
  search get error message "%K does not exists";
  remove del error message "%K does not exists";
}

class @applicationDefinition {
  @lstring name feature setter;
  @lstring cpuDescription feature setter;
  @lstring version feature setter;
  @lstring versionDescription feature setter;
  @objectsMap objects feature setter;
}

function emptyApplicationDefinition -> @applicationDefinition result:
  result := [@applicationDefinition new
    !emptyLString[]
    !emptyLString[]
    !emptyLString[]
    !emptyLString[]
    ![@objectsMap emptyMap]
  ];
end function;

function osObject
  ??@objectsMap objects
  ->@objectAttributes os
:
  @objectKind objectsForKind;
  [objects get !lstringWith[!"OS"] ?objectsForKind];
  @lstringlist names := [[objectsForKind objects] allKeyList];
  @lstring name;
  [names first ?name];
  [[objectsForKind objects] get !name ?os];
end function;

function objectForKindAndName
  ??@objectsMap objects
  ??@string kind
  ??@string name
  ->@objectAttributes object
:
  if [objects hasKey !kind] then
    @objectKind kindObj;
    [objects get !lstringWith[!kind] ?kindObj];
    if [[kindObj objects] hasKey !name] then
      [[kindObj objects] get !lstringWith[!name] ?object];
    else
      object := [@objectAttributes new ![@identifierMap emptyMap]];
    end if;
  else
    object := [@objectAttributes new ![@identifierMap emptyMap]];
  end if;
end function;

routine setObjectForKindAndName
  ?!@objectsMap objects
  ??@string kind
  ??@string name
  ??@objectAttributes object
:
  @lstring lkind := lstringWith[!kind];
  @lstring lname := lstringWith[!name];
  @objectKind kindObj := [@objectKind new ![@objectKindMap emptyMap]];
  if [objects hasKey !kind] then
    [!?objects del !lkind ?kindObj];
  end if;
  @objectKindMap kindMap := [kindObj objects];
  if [kindMap hasKey !name] then
    [!?kindMap del !lname ?*];
  end if;
  [!?kindMap put !lname !object];
  [!?kindObj setObjects !kindMap];
  [!?objects put !lkind !kindObj];
end routine;

function objectsForKind
  ??@objectsMap objects
  ??@string kind
  ->@objectKind result
:
  if [objects hasKey !kind] then
    [objects get !lstringWith[!kind] ?result];
  else
    result := [@objectKind new ![@objectKindMap emptyMap]];
  end if;
end function;
  
function listInOS
  ??@objectsMap objects
  ??@string attributeName
  ->@identifierList items
:
  @object_t itemsContainer;
  @objectAttributes os := osObject[!objects];
  [[os objectParams] get !lstringWith[!attributeName] ?itemsContainer];
  items := multipleAttributeOrError[!itemsContainer !attributeName];
end function;

#function boolInOS
#  ??@objectsMap objects
#  ??@string attributeName
#  ->@boolAttribute bool
#:
#  @object_t boolContainer;
#  @objectAttributes os := osObject[!objects];
#  [[os objectParams] get !lstringWith[!attributeName] ?boolContainer];
#  cast boolContainer:
#  when == @boolAttribute boolAttr do
#    bool := boolAttr;
#  else
#    bool := [@boolAttribute new ![boolContainer location] !false !emptyObject[]];
#    error [boolContainer location]: "Internal error, ".attributeName." has a wrong datatype";
#  end cast;
#end function;

#
#routine setSTRINGAttributeIfVoid
#  ?!@identifierMap object
#  ??@string name
#  ??@location location
#  ??@string value
#:
#  if not [object hasKey !name] then
#    [!?object put !lstringWith[!name] ![@stringAttribute new !location !value]];
#  end if;
#end routine;
  
#routine setUINT32AttributeIfVoid
#  ?!@identifierMap object
#  ??@string name
#  ??@location location
#  ??@uint value
#:
#  if not [object hasKey !name] then
#    [!?object put !lstringWith[!name] ![@uint32_class new !location !value]];
#  end if;
#end routine;

#routine setENUMAttributeIfVoid
#  ?!@identifierMap object
#  ??@string name
#  ??@location location
#  ??@string value
#  ??@objectAttributes subAttributes
#:
#  if not [object hasKey !name] then
#    [!?object put !lstringWith[!name] ![@enumAttribute new !location !value !subAttributes]];
#  end if;
#end routine;

#routine setMULTIPLEAttributeIfVoid
#  ?!@identifierMap object
#  ??@string name
#  ??@location location
#  ??@identifierList value
#:
#  if not [object hasKey !name] then
#    [!?object put !lstringWith[!name] ![@multipleAttribute new !location !value]];
#  end if;
#end routine;

end semantics ;