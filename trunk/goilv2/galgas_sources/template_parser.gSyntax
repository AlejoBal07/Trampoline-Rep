#---------------------------------------------------------------------------*
#                                                                           *
#  GOIL Template parser                                                     *
#                                                                           *
#  Copyright (C) 2009, ..., 2009 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax template_parser ("template_scanner.gLexique") :

import "template_invocation.gSemantics";

nonterminal <goil_template_start_symbol>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ?@goilTemplateVariableMap inTemplateVariableMap
  ?!@string ioResultingString
;

nonterminal <template_instruction>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ?!@goilTemplateVariableMap ioTemplateVariableMap
  ?!@string ioResultingString
label parse
;

nonterminal <sorting_order>
  !@lsint order
label parse
;

nonterminal <struct_path>
  ?!@lstringlist path
label parse
;

nonterminal <variable>
  ?@goilTemplateVariableMap inTemplateVariableMap
  !@lstringlist path
label parse
;

nonterminal <variable_or_here>
  ??@goilTemplateVariableMap inTemplateVariableMap
  !@location outWhere
label parse
;

nonterminal <expression>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@goilTemplateVariableMap inTemplateVariableMap
  !@goilTemplateValue outExpression
  !@goilTemplateType outResultType
label parse
;

nonterminal  <template_instruction_list>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ?!@goilTemplateVariableMap inTemplateVariableMap
  ?!@string ioResultingString
label parse
;

#---------------------------------------------------------------------------*

rule <template_instruction>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ?!@goilTemplateVariableMap ioTemplateVariableMap
  ?!@string ioResultingString
:
  $!$;
  @goilTemplateValue expression;
  @goilTemplateType resultType;
  <expression>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !ioTemplateVariableMap
    ?expression
    ?resultType
  ;
  switch resultType 
  when stringType, enumType:
    ioResultingString .= [expression mStringValue];
  when unsignedType:
    ioResultingString .= [[expression mUnsigned64Value] string];
  when boolType:
    if [expression mUnsigned64Value] == 0L then
      ioResultingString .= "false";
    else
      ioResultingString .= "true";
    end if;
  when listType :
    error here : "a list expression cannot be emitted";
  when structType :
    error here : "a struct expression cannot be emitted";
  when unconstructedType:
    error here: "internal error, unconstructed type found";
  end switch;    
end rule;

#---------------------------------------------------------------------------*

rule <template_instruction>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ?!@goilTemplateVariableMap ioTemplateVariableMap
  ?!@string unused ioResultingString
:
  @bool fileNameOk := true;
  $write$; $to$;
  @goilTemplateValue expression;
  @goilTemplateType expressionType;
  @goilTemplateVariableMap templateVariableMap := ioTemplateVariableMap;
  <expression>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !ioTemplateVariableMap
    ?expression
    ?expressionType
  ;
#  message "EXPRESSION '" . [expression mStringValue] . "'\n" ;
  if [templateVariableMap hasKey !"FILENAME"] then
    [!?templateVariableMap removeKey !lstringWith[!"FILENAME"] ?* ?*];
  end if;
  if [templateVariableMap hasKey !"FILEPATH"] then
    [!?templateVariableMap removeKey !lstringWith[!"FILEPATH"] ?* ?*];
  end if;
  @goilTemplateValue fileName := valueWithString[![[expression mStringValue] lastPathComponent]];
  @goilTemplateValue nativeFilePath := valueWithString[![[expression mStringValue] nativePathWithUnixPath]];
  [!?templateVariableMap insertKey !lstringWith[!"FILENAME"] !expressionType !fileName];
  [!?templateVariableMap insertKey !lstringWith[!"FILEPATH"] !expressionType !nativeFilePath];
  @location fileNameLocation := here;
  if expressionType != [@goilTemplateType stringType] then
    error here: "a file name should be of type string";
    fileNameOk := false;    
  end if;
  $:$;
  @string writeBlockResult := "";
  <template_instruction_list>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !?templateVariableMap
    !?writeBlockResult
  ;
  if fileNameOk & [@uint errorCount] == 0 then
    [writeBlockResult makeDirectoryAndWriteToFile ![expression mStringValue]];
  end if;
  $end$; $write$; 
end rule;

#---------------------------------------------------------------------------*

rule <template_instruction>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ?!@goilTemplateVariableMap ioTemplateVariableMap
  ?!@string ioResultingString
:
  @string nextPrefix := inPrefix;
  $template$;
  select
    $if$; $exists$;
    $identifier$ ? @lstring templateName;
    @bool found;
    select
      $in$; $identifier$ ?@lstring prefix;
      nextPrefix := fullPrefix[!ioTemplateVariableMap !prefix];
    or
    end select;
    goilTemplateInvocation
      !templateName
      !nextPrefix
      !inPath
      !inTemplateDirectory
      !false
      !ioTemplateVariableMap
      !?ioResultingString
      ?found
    ;
    select
      $or$;
      #log found;
      parse when not found:
        @goilTemplateVariableMap templateVariableMap [mapWithMapToOverride !ioTemplateVariableMap];
        <template_instruction_list>
          !nextPrefix
          !inPath
          !inTemplateDirectory
          !?templateVariableMap
          !?ioResultingString
        ;
        ioTemplateVariableMap := [templateVariableMap overriddenMap];
      else
        <template_instruction_list> parse;
      end parse;
      $end$; $template$;
    or
    end select;
  or
    $identifier$ ? @lstring templateName;
    select
      $in$; $identifier$ ?@lstring prefix;
      nextPrefix := fullPrefix[!ioTemplateVariableMap !prefix];
    or
    end select;
    goilTemplateInvocation
      !templateName
      !nextPrefix
      !inPath
      !inTemplateDirectory
      !true
      !ioTemplateVariableMap
      !?ioResultingString
      ?*
    ;
  end select;
end rule;

#---------------------------------------------------------------------------*

rule <template_instruction>
  ??@string unused inPrefix
  ??@string unused inPath
  ??@string unused inTemplateDirectory
  ?!@goilTemplateVariableMap ioTemplateVariableMap
  ?!@string ioResultingString
:
  $?$;
  $identifier$ ? @lstring columnConstantName;
  @string value := "";
  @bool searchEndOfLine := true;
  @uint idx := [ioResultingString length];
  loop [ioResultingString length] :
  while (idx > 0) & searchEndOfLine
  do
    searchEndOfLine := [ioResultingString characterAtIndex !idx - 1] != '\n';
    idx --;
    if searchEndOfLine then
      value .= " ";
    end if;
  end loop;
  [!?ioTemplateVariableMap insertKey
    !columnConstantName
    ![@goilTemplateType stringType]
    !valueWithString[!value]
  ];
end rule;

#---------------------------------------------------------------------------*

#rule <template_instruction>
#  ?!@typeVariablesMap ioTemplateVariableMap
#  ??@EXsemanticContext inSemanticContext
#  ??@goilTemplateVariableMap inComponentSemanticsEntitiesMap
#  ??@M_optionComponents inOptionsComponentsMapForUse
#  ?!@templateInstructionList ioResultingInstructionList
#:
#  $block$;
#  @goilTemplateValue expression;
#  @goilTemplateType resultType;
#  <expression>
#    !inComponentSemanticsEntitiesMap
#    !inSemanticContext
#    !inOptionsComponentsMapForUse
#    !?ioTemplateVariableMap
#    ?expression
#    ?resultType
#  ;
#  @typeGalgas_uint x := (cast resultType if >= @typeGalgas_uint else error here);
#  $:$;
##--- Instruction list
#  @templateInstructionList blockInstructionList [emptyList];
#  enterTemplateString !? blockInstructionList;
#  repeat
#  while
#    <template_instruction>
#      !?ioTemplateVariableMap
#      !inSemanticContext
#      !inComponentSemanticsEntitiesMap
#      !inOptionsComponentsMapForUse
#      !?blockInstructionList
#    ;
#    enterTemplateString !?blockInstructionList;
#  end repeat;
##---
#  $end$;
#  $block$;
#  ioResultingInstructionList += ![@templateBlockInstruction new
#   !expression
#   !here
#   !blockInstructionList
#  ];
#end rule;

#---------------------------------------------------------------------------*

rule <template_instruction>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ?!@goilTemplateVariableMap ioTemplateVariableMap
  ?!@string ioResultingString
:
  $if$;
  @bool currentCondition := false;
  repeat
    parse
    when not currentCondition :
      @goilTemplateValue expression;
      @goilTemplateType expressionType;
      <expression>
        !inPrefix
        !inPath
        !inTemplateDirectory
        !ioTemplateVariableMap
        ?expression
        ?expressionType
      ;
      if expressionType != [@goilTemplateType boolType] then
        error here:"the operand of the 'not' operator should be boolean";
      end if;
      currentCondition := [expression mUnsigned64Value] == 1L;
      $then$;
      parse
      when currentCondition :
        @goilTemplateVariableMap templateVariableMap [mapWithMapToOverride !ioTemplateVariableMap];
        <template_instruction_list>
          !inPrefix
          !inPath
          !inTemplateDirectory
          !?templateVariableMap
          !?ioResultingString
        ;
        ioTemplateVariableMap := [templateVariableMap overriddenMap];
      else
        <template_instruction_list> parse;
      end parse;
    else
      <expression> parse;
      $then$;
      <template_instruction_list> parse;
    end parse;
  while
    $elsif$;
  end repeat;
#--- else
  select
  or
    $else$;
    parse
    when not currentCondition :
      @goilTemplateVariableMap templateVariableMap [mapWithMapToOverride !ioTemplateVariableMap];
      <template_instruction_list>
        !inPrefix
        !inPath
        !inTemplateDirectory
        !?templateVariableMap
        !?ioResultingString
      ;
      ioTemplateVariableMap := [templateVariableMap overriddenMap];
    else
      <template_instruction_list> parse;
    end parse;
  end select;
#---
  $end$;
  $if$;
end rule;

#---------------------------------------------------------------------------*

rule  <template_instruction_list>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ?!@goilTemplateVariableMap ioTemplateVariableMap
  ?!@string ioResultingString
:
  ioResultingString .= [@string retrieveAndResetTemplateString];
  repeat
  while
    <template_instruction>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !?ioTemplateVariableMap
      !?ioResultingString
    ;
    ioResultingString .= [@string retrieveAndResetTemplateString];
  end repeat;
end rule;

#---------------------------------------------------------------------------*

rule  <goil_template_start_symbol>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ?@goilTemplateVariableMap inTemplateVariableMap
  ?!@string ioResultingString
:
  <template_instruction_list>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !?inTemplateVariableMap
    !?ioResultingString
  ;
end rule;

#---------------------------------------------------------------------------*

rule <template_instruction>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ?!@goilTemplateVariableMap ioTemplateVariableMap
  ?!@string ioResultingString
:
  $foreach$; $identifier$ ? @lstring variableName; $in$;
  @uint listLentgh;
#  @goilTemplateEnumationList enumerationList [emptyList];
  @goilTemplateValue enumeratedValue;
  @goilTemplateType expressionType;
  <expression>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !ioTemplateVariableMap
    ?enumeratedValue
    ?expressionType
  ;
    
#    log enumeratedValue;
  if expressionType != [@goilTemplateType listType] then
    error here:"only a list can be enumerated";
    listLentgh := 0;
  else
    listLentgh := [[enumeratedValue mMapListValue] length]; 
  end if;
  @string foreachPrefix;
  select
    foreachPrefix := "";
  or
    $prefixedby$;
    $identifier$ ? @lstring prefixString;
    foreachPrefix := [prefixString string];
  end select;
#  enumerationList += !enumeratedValue !foreachPrefix;

#--- before block
  select
  or
    $before$;
    parse
    when listLentgh > 0 :
      <template_instruction_list>
        !inPrefix
        !inPath
        !inTemplateDirectory
        !?ioTemplateVariableMap
        !?ioResultingString
      ;
    else
      <template_instruction_list> parse;
    end parse;
  end select;
#--- Do block
  $do$;
  @uint idx := 0;
  parse loop listLentgh
  while idx < listLentgh do
    @goilTemplateVariableMap templateVariableMap [mapWithMapToOverride !ioTemplateVariableMap];
#    foreach enumerationList do
    const @goilTemplateFieldMap fieldMap := [[enumeratedValue mMapListValue] mMapAtIndex !idx];
#    foreach fieldMap do
    @lstring varName := [@lstring new !foreachPrefix . [variableName string] ![variableName location]];
#        if [templateVariableMap hasKey ![varName string]] then
#          [!?templateVariableMap removeKey !varName ?* ?*];
#        end if;
    [!?templateVariableMap insertKey
      !varName
      ![@goilTemplateType structType]
      ![@goilTemplateValue new !0L !"" ![@goilTemplateFieldMapList emptyList] !fieldMap]
    ];
#      end foreach;
#    end foreach;

#    if [templateVariableMap hasKey !"INDEX"] then
#      [!?templateVariableMap removeKey ![@lstring new !"INDEX" !here] ?* ?*];
#    end if;
    addUnsignedValue !?templateVariableMap ![@lstring new !foreachPrefix."INDEX" !here] ![idx uint64];

    <template_instruction_list>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !?templateVariableMap
      !?ioResultingString
    ;
    idx ++;
    select
    or
      $between$;
      parse 
      when idx < listLentgh :
        <template_instruction_list>
          !inPrefix
          !inPath
          !inTemplateDirectory
          !?templateVariableMap
          !?ioResultingString
        ;
      else
        <template_instruction_list> parse;
      end parse;
    end select;
    ioTemplateVariableMap := [templateVariableMap overriddenMap];
  end parse;
  @string s := [@string retrieveAndResetTemplateString]; # Value not used
#--- after block
  select
  or
    $after$;
    parse
    when listLentgh > 0 :
      <template_instruction_list>
        !inPrefix
        !inPath
        !inTemplateDirectory
        !?ioTemplateVariableMap
        !?ioResultingString
      ;
    else
      <template_instruction_list> parse;
    end parse;
  end select;
#---
  $end$;
  $foreach$;
end rule;

#---------------------------------------------------------------------------*

rule <template_instruction>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ?!@goilTemplateVariableMap ioTemplateVariableMap
  ?!@string ioResultingString
:
  $for$; $identifier$ ? @lstring variableName;
#  if [ioTemplateVariableMap hasKey ![variableName string]] then
#    [!?ioTemplateVariableMap removeKey !variableName ?* ?*];
#  end if;
  $in$;
  @goilTemplateExpressionList enumerationList [emptyList];
  repeat
    @goilTemplateValue enumeratedValue;
    @goilTemplateType expressionType;
    <expression>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !ioTemplateVariableMap
      ?enumeratedValue
      ?expressionType
    ;
    if expressionType != [@goilTemplateType boolType] &
       expressionType != [@goilTemplateType unsignedType] &
       expressionType != [@goilTemplateType stringType] then
       error here:"only a bool, integer or string can be enumerated";
    end if;
    enumerationList += !enumeratedValue !expressionType;
  while
    $,$;
  end repeat;
#--- Do block
  $do$;
  @uint idx := 0;
  parse loop [enumerationList length]
  while [enumerationList length] > 0 do
    @goilTemplateVariableMap templateVariableMap [mapWithMapToOverride !ioTemplateVariableMap];
    @goilTemplateValue value;
    @goilTemplateType type;
    [!?enumerationList popFirst ?value ?type];
    [!?templateVariableMap insertKey
      !variableName
      !type
      !value];
      
#    if [templateVariableMap hasKey !"INDEX"] then
#      [!?templateVariableMap removeKey ![@lstring new !"INDEX" !here] ?* ?*];
#    end if;
    addUnsignedValue !?templateVariableMap ![@lstring new !"INDEX" !here] ![idx uint64];
      
    <template_instruction_list>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !?templateVariableMap
      !?ioResultingString
    ;
    idx ++;
    select
    or
      $between$;
      parse 
      when [enumerationList length] > 0 :
        <template_instruction_list>
          !inPrefix
          !inPath
          !inTemplateDirectory
          !?templateVariableMap
          !?ioResultingString
        ;
      else
        <template_instruction_list> parse;
      end parse;
    end select;
    ioTemplateVariableMap := [templateVariableMap overriddenMap];
  end parse;
  @string s := [@string retrieveAndResetTemplateString]; # Value not used
#---
  $end$;
  $for$;
end rule;

#---------------------------------------------------------------------------*

rule <template_instruction>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ?!@goilTemplateVariableMap ioTemplateVariableMap
  ?!@string ioResultingString
:
  $loop$; $identifier$ ? @lstring variableName;
  $from$;
  @goilTemplateValue startValue;
  @goilTemplateType startType;
  <expression>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !ioTemplateVariableMap
    ?startValue
    ?startType
  ;
  if startType != [@goilTemplateType unsignedType] then
    error here:"loop start value should be an integer";
  end if;
  $to$;
  @goilTemplateValue endValue;
  @goilTemplateType endType;
  <expression>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !ioTemplateVariableMap
    ?endValue
    ?endType
  ;
  if endType != [@goilTemplateType unsignedType] then
    error here:"loop end value should be an integer";
  end if;
#--- Before block
  select
  or
    $before$;
    parse
    when [endValue mUnsigned64Value] >= [startValue mUnsigned64Value] :
      <template_instruction_list>
        !inPrefix
        !inPath
        !inTemplateDirectory
        !?ioTemplateVariableMap
        !?ioResultingString
      ;
    else
      <template_instruction_list> parse;
    end parse;
  end select;
#--- Do block
  $do$;
  @uint start := [[startValue mUnsigned64Value] uint];
  @uint stop := [[endValue mUnsigned64Value] uint];
  @uint idx := start;
  parse loop stop - start + 1
  while idx <= stop do
    @goilTemplateVariableMap templateVariableMap [mapWithMapToOverride !ioTemplateVariableMap];
#    if [templateVariableMap hasKey ![variableName string]] then
#      [!?templateVariableMap removeKey !variableName ?* ?*];
#    end if;
    addUnsignedValue !?templateVariableMap !variableName ![idx uint64];

    <template_instruction_list>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !?templateVariableMap
      !?ioResultingString
    ;
    idx ++;
    select
    or
      $between$;
      parse 
      when idx <= stop :
        <template_instruction_list>
          !inPrefix
          !inPath
          !inTemplateDirectory
          !?templateVariableMap
          !?ioResultingString
        ;
      else
        <template_instruction_list> parse;
      end parse;
    end select;
    ioTemplateVariableMap := [templateVariableMap overriddenMap];
  end parse;
  @string s := [@string retrieveAndResetTemplateString]; # Value not used
#--- after block
  select
  or
    $after$;
    parse
    when stop >= start :
      <template_instruction_list>
        !inPrefix
        !inPath
        !inTemplateDirectory
        !?ioTemplateVariableMap
        !?ioResultingString
      ;
    else
      <template_instruction_list> parse;
    end parse;
  end select;
#---
  $end$;
  $loop$;
end rule;

#---------------------------------------------------------------------------*

routine setVariableAlongPath
  ?@lstringlist path
  ?!@goilTemplateType variableType
  ?!@goilTemplateValue variableValue
  ??@goilTemplateType expressionType
  ??@goilTemplateValue enumeratedValue
:
  if [path length] > 0 then
    @lstring pathItem;
    [!?path popFirst ?pathItem];
    @goilTemplateType subType [unconstructedType];
    @goilTemplateValue subValue := valueWithVoid[];
    setVariableAlongPath !path !?subType !?subValue !expressionType !enumeratedValue;
    variableType := [@goilTemplateType structType];
    @goilTemplateFieldMap items := [variableValue mStructValue];
    if [items hasKey ![pathItem string]] then
      [!?items removeKey !pathItem ?* ?* ?* ?* ?*];
    end if;
    [!?items insertKey
      !pathItem
      !subType
      ![subValue mUnsigned64Value]
      ![subValue mStringValue]
      ![subValue mMapListValue]
      ![subValue mStructValue]
    ];
    variableValue := valueWithStruct[!items];
  else
    variableType := expressionType;
    variableValue := enumeratedValue;
  end if;  
end routine;

routine setVariableInPath
  ?@lstringlist path
  ?!@goilTemplateVariableMap ioTemplateVariableMap
  ??@goilTemplateType expressionType
  ??@goilTemplateValue enumeratedValue
:
  @lstring rootVariable;
  @goilTemplateValue variableValue := valueWithVoid[];
  @goilTemplateType variableType [unconstructedType];
  [!?path popFirst ?rootVariable];
  if [ioTemplateVariableMap hasKey ![rootVariable string]] then
    [ioTemplateVariableMap searchKey !rootVariable ?variableType ?variableValue];
  end if;
  setVariableAlongPath !path !?variableType !?variableValue !expressionType !enumeratedValue;
  if variableType != [@goilTemplateType unconstructedType] then
    if [ioTemplateVariableMap hasKey ![rootVariable string]] then
      [!?ioTemplateVariableMap setMTypeForKey !variableType ![rootVariable string]];
      [!?ioTemplateVariableMap setMValueForKey !variableValue ![rootVariable string]];
    else
      [!?ioTemplateVariableMap insertKey !rootVariable !variableType !variableValue];
    end if;
  end if;
end routine;

rule <struct_path>
  ?!@lstringlist path
:
  select
    $::$; $identifier$ ?@lstring pathElement;
    path += !pathElement;
    <struct_path> !?path;
  or end select;
end rule;

rule <template_instruction>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ?!@goilTemplateVariableMap ioTemplateVariableMap
  ?!@string unused ioResultingString
:
  @lstringlist path [emptyList];
  $let$; $identifier$ ?@lstring variableName;
  
  path += !variableName;
  <struct_path> !?path;
  @goilTemplateValue enumeratedValue;
  @goilTemplateType expressionType;
  select
    $:=$;
    <expression>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !ioTemplateVariableMap
      ?enumeratedValue
      ?expressionType
    ;
#    if [ioTemplateVariableMap hasKey ![variableName string]] then
#      [!?ioTemplateVariableMap setMTypeForKey !expressionType ![variableName string]];
#      [!?ioTemplateVariableMap setMValueForKey !enumeratedValue ![variableName string]];
#    else
#      [!?ioTemplateVariableMap insertKey !variableName !expressionType !enumeratedValue];
#    end if;
    setVariableInPath !path !?ioTemplateVariableMap !expressionType !enumeratedValue;
  or
    $+=$;
    <expression>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !ioTemplateVariableMap
      ?enumeratedValue
      ?expressionType
    ;
    if expressionType != [@goilTemplateType stringType] then
      if expressionType != [@goilTemplateType structType] then
        error here: "string or struct type expected";
      else
        # struct type
        @goilTemplateValue variableValue;
        @goilTemplateType variableType;
        [ioTemplateVariableMap searchKey !variableName ?variableType ?variableValue];
        if variableType != [@goilTemplateType listType] then
          error variableName: "list type expected";
        else
          variableValue->mMapListValue += ![enumeratedValue mStructValue];
          [!?ioTemplateVariableMap setMTypeForKey !variableType ![variableName string]];
          [!?ioTemplateVariableMap setMValueForKey !variableValue ![variableName string]];
        end if;
      end if;
    else
      @goilTemplateValue variableValue;
      @goilTemplateType variableType;
      [ioTemplateVariableMap searchKey !variableName ?variableType ?variableValue];
      if variableType != [@goilTemplateType listType] then
        error variableName: "list type expected";
      else
        @goilTemplateFieldMap fieldMap [emptyMap];
        [!?fieldMap insertKey ![@lstring new !"NAME" !here] !expressionType !0L ![enumeratedValue mStringValue] ![@goilTemplateFieldMapList emptyList] ![@goilTemplateFieldMap emptyMap]];
        variableValue->mMapListValue += !fieldMap;
        [!?ioTemplateVariableMap setMTypeForKey !variableType ![variableName string]];
        [!?ioTemplateVariableMap setMValueForKey !variableValue ![variableName string]];
      end if;
    end if;
  end select;
end rule;

#---------------------------------------------------------------------------*

rule <variable_or_here>
  ??@goilTemplateVariableMap inTemplateVariableMap
  !@location outWhere
:
  select
    $here$;
    outWhere := here;
  or
    $identifier$ ?@lstring variableName;
    outWhere := [inTemplateVariableMap locationForKey ![variableName string]];
    @goilTemplateValue variableValue;
    @goilTemplateType variableType;
    [inTemplateVariableMap searchKey !variableName ?variableType ?variableValue];
    @goilTemplateFieldMap structValue := [variableValue mStructValue];
    repeat
    while
      if variableType != [@goilTemplateType structType] then
        error here: [variableName string]." is not a struct";
      end if;
      $::$; $identifier$ ?variableName;
      outWhere := [structValue locationForKey ![variableName string]];
      [structValue searchKey !variableName ?variableType ?* ?* ?* ?structValue];
    end repeat;
  end select;
end rule;

#---------------------------------------------------------------------------*

rule <template_instruction>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ?!@goilTemplateVariableMap ioTemplateVariableMap
  ?!@string unused ioResultingString
:
  $error$;
  @location where;
  <variable_or_here> !ioTemplateVariableMap ?where;
  @goilTemplateValue enumeratedValue;
  @goilTemplateType expressionType;
  <expression>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !ioTemplateVariableMap
    ?enumeratedValue
    ?expressionType
  ;
  if expressionType != [@goilTemplateType stringType] then
    error here: "error message should by a string expression";
  else
    error where: [enumeratedValue mStringValue];
  end if;
end rule;

#---------------------------------------------------------------------------*

rule <template_instruction>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ?!@goilTemplateVariableMap ioTemplateVariableMap
  ?!@string unused ioResultingString
:
  $warning$;
  @location where;
  <variable_or_here> !ioTemplateVariableMap ?where;
  @goilTemplateValue enumeratedValue;
  @goilTemplateType expressionType;
  <expression>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !ioTemplateVariableMap
    ?enumeratedValue
    ?expressionType
  ;
  if expressionType != [@goilTemplateType stringType] then
    error here: "error message should by a string expression";
  else
    warning where: [enumeratedValue mStringValue];
  end if;
end rule;

#---------------------------------------------------------------------------*
routine printVariable
  ?@uint indent
  ??@goilTemplateType variableType
  ??@uint64 unsignedValue
  ??@string stringValue
  ??@goilTemplateFieldMapList listValue
  ??@goilTemplateFieldMap structValue
:
  indent := indent + 4;
  @string offset := [@string stringWithSequenceOfCharacters !' ' !indent];
  switch variableType
  when boolType:
    if unsignedValue == 1L then
      message offset."true\n";
    else
      message offset."false\n";
    end if;
  when unsignedType:
    message offset.unsignedValue."\n";
  when stringType:
    message offset."\"".stringValue."\"\n";
  when enumType:
    message offset.stringValue."\n";
  when listType:
    foreach listValue index idx do
      message offset."item at ".idx.":\n";
      printVariable !indent ![@goilTemplateType structType] !0L !"" ![@goilTemplateFieldMapList emptyList] !mMap;
    end foreach;
  when structType:
    foreach structValue do
      message offset.lkey.":\n";
      printVariable !indent !mType !mUnsigned64Value !mStringValue !mListValue !mStructValue;
    end foreach;
  when unconstructedType:
    error here: "internal error, unconstrcuted type";
  end switch;
end routine;

rule <template_instruction>
  ??@string unused inPrefix
  ??@string unused inPath
  ??@string unused inTemplateDirectory
  ?!@goilTemplateVariableMap ioTemplateVariableMap
  ?!@string unused ioResultingString
:
  $display$; $identifier$ ?@lstring variableName;
  @goilTemplateType variableType;
  @goilTemplateValue variableValue;
  [ioTemplateVariableMap searchKey !variableName ?variableType ?variableValue];
  message [variableName string]." (".[[variableName location] locationString].") : ".[variableType messageGoilTemplateType]."\n";
  printVariable
    !0
    !variableType
    ![variableValue mUnsigned64Value]
    ![variableValue mStringValue]
    ![variableValue mMapListValue]
    ![variableValue mStructValue];
end rule;

#---------------------------------------------------------------------------*

list @sortingKeyList {
  @lstring key;
  @lsint order;
}

function structCompare
  ??@goilTemplateFieldMap s1
  ??@goilTemplateFieldMap s2
  ?@sortingKeyList fieldList
  ->@sint result
:
  if [fieldList length] > 0 then
    @lstring field;
    @lsint order;
    [!?fieldList popFirst ?field ?order];
    @goilTemplateType s1Type;
    @uint64 s1Value;
    [s1 searchKey !field ?s1Type ?s1Value ?* ?* ?*];
    @goilTemplateType s2Type;
    @uint64 s2Value;
    [s2 searchKey !field ?s2Type ?s2Value ?* ?* ?*];
    if s1Type == s2Type & s1Type == [@goilTemplateType unsignedType] then
#      message "Compare ".s1Value." and ".s2Value." ";
      if s1Value < s2Value then
#        message "<\n";
        result := -1s * [order sint];
      else
        if s1Value > s2Value then
#          message ">\n";
          result := 1s  * [order sint];
        else
#          message "=\n";
          result := structCompare[!s1 !s2 !fieldList];
        end if;
      end if;
    else
      error field: "unsigned sort key required": result;
    end if;
  else
    result := 0s;
  end if;
end function;

routine swap
  ?!@goilTemplateFieldMapList t
  ??@uint index1
  ??@uint index2
:
#  message "SWAP ".index1." and ".index2."\n";
  @goilTemplateFieldMap temp := [t mMapAtIndex !index1];
  [!?t setMMapAtIndex ![t mMapAtIndex !index2] !index1];
  [!?t setMMapAtIndex !temp !index2];
end routine;

routine partition
  ?!@goilTemplateFieldMapList t
  ?@uint min
  ?@uint max
  ??@sortingKeyList fieldList
  ?!@uint pivotIndex
: 
  @goilTemplateFieldMap pivot := [t mMapAtIndex !pivotIndex];
  swap !?t !pivotIndex !max;
  @uint storeIndex := min;
  @uint i := min;
  loop max - min:
  while i < max do
    if structCompare[![t mMapAtIndex !i] !pivot !fieldList] == -1s then
      swap !?t !i !storeIndex;
      storeIndex++;
    end if;
    i++;
  end loop;
  swap !?t !storeIndex !max;
  pivotIndex := storeIndex;
end routine;

routine quickSort
  ?!@goilTemplateFieldMapList t
  ??@uint min
  ??@uint max
  ??@sortingKeyList fieldList
:
#  message "SORT from ".min." to ".max."\n";
  if min < max then
    @uint pivotIndex := (max + min) / 2;
#    message "PIVOT = ".pivotIndex."\n";
    partition !?t !min !max !fieldList !?pivotIndex;
    quickSort !?t !min !pivotIndex !fieldList;
    quickSort !?t !pivotIndex+1 !max !fieldList;
  end if;
end routine;

rule <sorting_order>
  !@lsint order
:
  select
    $>$; 
    order := [@lsint new !-1s !here];
  or
    $<$;
    order := [@lsint new !1s !here];
  end select;
end rule;

rule <template_instruction>
  ??@string unused inPrefix
  ??@string unused inPath
  ??@string unused inTemplateDirectory
  ?!@goilTemplateVariableMap ioTemplateVariableMap
  ?!@string unused ioResultingString
:
  $sort$; $identifier$ ?@lstring variableName;
  @goilTemplateType variableType;
  @goilTemplateValue variableValue;
  [ioTemplateVariableMap searchKey !variableName ?variableType ?variableValue];
  $by$;
  @sortingKeyList keys [emptyList];
  @lsint firstOrder;
  $identifier$ ?@lstring firstKey; <sorting_order> ?firstOrder;
  keys += !firstKey !firstOrder;
  repeat while
    @lsint nextOrder;
    $,$; $identifier$ ?@lstring nextKey; <sorting_order> ?nextOrder;
    keys += !nextKey !nextOrder;
  end repeat;

  if variableType == [@goilTemplateType listType] then
    #log keys;
    @goilTemplateFieldMapList variable := [variableValue mMapListValue];
    quickSort !?variable !0 ![variable length]-1 !keys;
    variableValue := [@goilTemplateValue new !0L !"" !variable ![@goilTemplateFieldMap emptyMap]];
    #log variable;
    [!?ioTemplateVariableMap setMTypeForKey !variableType ![variableName string]];
    [!?ioTemplateVariableMap setMValueForKey !variableValue ![variableName string]];
  else
    error variableName: "list type expected";
  end if;
end rule;

#---------------------------------------------------------------------------*

rule <variable>
  ?@goilTemplateVariableMap inTemplateVariableMap
  !@lstringlist path
:
  path := [@lstringlist emptyList];
  $identifier$ ?@lstring variableName;
  path += !variableName;
  @goilTemplateValue variableValue;
  @goilTemplateType variableType;
  [inTemplateVariableMap searchKey !variableName ?variableType ?variableValue];
  @goilTemplateFieldMap structValue := [variableValue mStructValue];
  repeat
  while
    if variableType != [@goilTemplateType structType] then
      error here: [variableName string]." is not a struct";
    end if;
    $::$; $identifier$ ?variableName;
    path += !variableName;
    [structValue searchKey !variableName ?variableType ?* ?* ?* ?structValue];
  end repeat;
end rule;

#---------------------------------------------------------------------------*

end syntax;
