semantics systemConfig :

import "implementation_types.gSemantics";

import "goil_types_root.gSemantics";
import "template_invocation.gSemantics";
import "goil_options.gOption";

method @object_t set ??@lstring name ?!@TfieldMap unused result
:
  error here: "Attribute: ".name.", Internal error";
end method;

# build a template struct
override method @structAttribute set ??@lstring name ?!@TfieldMap result:
  @TfieldMap subAttrs := [subAttributes fieldMap];
  addLStringValue !?subAttrs !"NAME" !structName;
  addStructValue !?result !name !subAttrs;
#  if [subAttrs count] > 0 then
#    foreach subAttrs do
#      [!?result insertKey !lkey !mType !mValue];
#    end foreach;
#  end if;
end method;

# build a template boolean
# the name of the attribute in the system configuration is the same
# the content of the attribute (if it exists) is a struct with the same
# name suffixed by _S
override method @boolAttribute set ??@lstring name ?!@TfieldMap result:
  addBoolValue !?result !name !value;
  @TfieldMap subAttrs := [subAttributes fieldMap];
  if [subAttrs count] > 0 then
    @lstring structName := [@lstring new ![name string]."_S" ![name location]];
    addStructValue !?result !structName !subAttrs;
  end if;
end method;

# build a template enum
# the name of the attribute in the system configuration is the same
# the content of the attribute (if it exists) is a struct with the same
# name suffixed by _S
override method @enumAttribute set ??@lstring name ?!@TfieldMap result:
  addStringValue !?result !name !value;
  @TfieldMap subAttrs := [subAttributes fieldMap];
  if [subAttrs count] > 0 then
    @lstring structName := [@lstring new ![name string]."_S" ![name location]];
    addStructValue !?result !structName !subAttrs;
  end if;
end method;

override method @stringAttribute set ??@lstring name ?!@TfieldMap result:
  addStringValue !?result !name !value;
end method;

override method @string_class set ??@lstring name ?!@TfieldMap result:
  addStringValue !?result !name !value;
end method;

override method @multipleAttribute set ??@lstring name ?!@TfieldMap result:
  @TfieldMapList multiple [emptyList];
  foreach items do
    @TfieldMap multipleItem [emptyMap];
    cast item:
    when == @structAttribute aStruct do
      addLStringValue !?multipleItem !"NAME" ![aStruct structName];
      @TfieldMap subAttrs := [[aStruct subAttributes] fieldMap];
      if [subAttrs count] > 0 then
        foreach subAttrs do
          [!?multipleItem insertKey !lkey !mType !mValue];
        end foreach;
      end if;
    else
      [item set ![@lstring new !"VALUE" ![item location]] !?multipleItem];
    end cast;
    multiple += !multipleItem;
  end foreach;
  addListValue !?result !name !multiple;
end method;

override method @uint32_class set ??@lstring name ?!@TfieldMap result:
  addUnsignedValue !?result !name ![value uint64];
end method;

override method @sint32_class set ??@lstring name ?!@TfieldMap result:
  addSignedValue !?result !name ![value sint64];
end method;

override method @uint64_class set ??@lstring name ?!@TfieldMap result:
  addUnsignedValue !?result !name !value;
end method;

override method @sint64_class set ??@lstring name ?!@TfieldMap result:
  addSignedValue !?result !name !value;
end method;

override method @float_class set ??@lstring name ?!@TfieldMap result:
  addFloatValue !?result !name !value;
end method;

override method @auto set ??@lstring name ?!@TfieldMap result:
  addEnumValue !?result !name !"_auto_";
end method;

reader @objectAttributes fieldMap
  ->@TfieldMap result
:
  result := [@TfieldMap emptyMap];
  foreach objectParams do
    [value set !lkey !?result];
  end foreach;
end reader;

reader @applicationDefinition templateData
  ??@implementation imp
  ->@TfieldMap cfg
:
  cfg := [@TfieldMap emptyMap];

#  log objects;
  #
  # First setup the general configuration data
  #
  addStringValue !?cfg !lstringWith[!"OILFILENAME"] ![[@string stringWithSourceFilePath] lastPathComponent];
  addLStringValue !?cfg !"CPUNAME" !name;
  addLStringValue !?cfg !"CPUDESCRIPTION" !cpuDescription;
  addLStringValue !?cfg !"OILVERSION" !version;
  addLStringValue !?cfg !"OILDESCRIPTION" !versionDescription;
  addStringValue !?cfg !lstringWith[!"TIMESTAMP"] ![@string stringWithCurrentDateTime];
  addStringValue !?cfg !lstringWith[!"PROJECT"] ![projectName[] lastPathComponent];
  addStringValue !?cfg !lstringWith[!"TARGET"] ![option goil_options.target_platform value];
  addStringValue !?cfg !lstringWith[!"TEMPLATEPATH"] ![option goil_options.template_dir value];
  addStringValue !?cfg !lstringWith[!"ARCH"] !arch[];
  addStringValue !?cfg !lstringWith[!"CHIP"] !chip[];
  addStringValue !?cfg !lstringWith[!"BOARD"] !board[];
  # Other options of goil
  addBoolValue !?cfg !lstringWith[!"LOGFILE"] ![option goil_options.generate_log value];

  foreach objects do
#    message [lkey string]."\n";
    # Check if the object is multiple or not. If not, attributes
    # are stored in a struct otherwise instances are stored in a map.
    @implementationObject implementationObject;
    [[imp imp] get !lkey ?implementationObject];
    if [[implementationObject multiple] bool] then
#      message "*** multiple\n";
      @TfieldMapList objs [emptyList];
      foreach [objectsOfKind objects] do
        @TfieldMap attrs := [attributes fieldMap];
        objs += !attrs;
      end foreach;
      addListValue !?cfg !lkey !objs;
    else
#      message "*** single\n";
      if [[objectsOfKind objects] count] == 1 then
        @TfieldMap attrs [emptyMap];
        foreach [objectsOfKind objects] do
          attrs := [attributes fieldMap];
        end foreach;
        addStructValue !?cfg !lkey !attrs;
      end if;
    end if;
  end foreach;
#  log cfg;
end reader;

end semantics;