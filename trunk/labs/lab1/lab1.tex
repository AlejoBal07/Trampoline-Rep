\documentclass[11pt]{article}
\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
\geometry{a4paper}                   % ... or a4paper or a5paper or ... 
%\geometry{landscape}                % Activate for for rotated page geometry
%\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}

\usepackage{hyperref}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{underscore}
\usepackage{parskip}
\usepackage[nosolutionfiles]{answers}

\newcommand{\normaltilde}{{\raise.17ex\hbox{$\scriptstyle\mathtt{\sim}$}}}
\newcommand{\unixcl}[1]{\texttt{\fcolorbox{black}{gray!20}{#1}}}

\Newassociation{sol}{Solution}{ans}
\newtheorem{ex}{Question}


\title{Lab \#1\\$\star$\\Getting started with OSEK/VDX\\\large{
Understanding fixed priority scheduling}}
\author{}
%\date{}                                           % Activate to display a given date or no date

\begin{document}
\maketitle

{\bf Note:} All the software and documents are stored at \url{http://www.irccyn.ec-nantes.fr/~bechenne/trampoline}

\section{Goal}

The goal of this lab is to become familiar with OSEK/VDX applications development process and with Trampoline and to understand how fixed priority scheduling works. We will see some Hook Routines too and Events. Trampoline is a Free Software implementation of the OSEK/VDX specification. Trampoline includes an OIL compiler which allows, starting from an OIL description, to generate OS level data structures of the application. In addition to the OIL description, the developer must provide the C sources of tasks and ISRs of the application. Trampoline runs on Unix (and on many other hardware platforms) and we will use it on this platform. If you have not installed Trampoline yet, get the Trampoline Package and read the install document.

The lab1, is located in the \unixcl{trampoline/labs/lab1} directory.

\section{Basic tasks}

Go into the lab1 directory. There are 2 files:

\begin{description}
\item[lab1.oil] the OIL description of the lab1 application
\item[lab1.c] the C source for the lab1 task and hook routines
\end{description}

Edit the lab1.oil and look at the \texttt{TRAMPOLINE_BASE_PATH} attribute (in OS $>$ BUILD attribute).  \texttt{TRAMPOLINE_BASE_PATH} is set to \texttt{"../.."}. If you move around the lab1 directory you will have to update this attribute.


lab1 is a very simple application with only 1 task called a_task. a_task starts automatically (\texttt{AUTOSTART = TRUE} in the OIL file). Look at the OIL file and the C source file.

To compile this application, go into the lab1 directory and type:\\
\unixcl{goil -t=posix --templates=../../goilv2/templates lab1.oil}

Goil templates are located in \texttt{trampoline/goilv2/templates}. The \texttt{-t} option gives the target system (here we generate the OS level data structures for the posix implementation of Trampoline). The OIL file gives the names of the C source files (with \texttt{APP_SRC} and the name of the executable file (with \texttt{APP_NAME}).

This generate a Makefile for the application (ie, roughly, a file that explain to the make build system what is needed to build the application). It has to be done only once. If you change something in the OIL file or in your C file, you do not need to rerun the goil compiler by hand because make will run it when needed. Then type:

\unixcl{make}

The application and Trampoline OS are compiled and linked together. To execute the application, type:

\unixcl{./elab1}

The following message should be displayed (it corresponds to the execution of task a_task).

\unixcl{I am a task, my id is 0}

\begin{ex}
The application hangs (does not exit). Why?
\end{ex}

\begin{ex}
Turn on the Pre-task hook, Post-task hook, Startup hook and Shutdown hook in the OIL file (\texttt{PRETASKHOOK = TRUE; POSTTASKHOOK = TRUE; STARTUPHOOK = TRUE;} and \texttt{SHUTDOWNHOOK = TRUE;} in OS object). Compile and execute. What is happening?
\end{ex}

\section{OS system calls and task launching}

\subsection{Task activation and scheduling}

The \texttt{ActivateTask()} system call allows to activate another task of the application. Hooks are kept on.

\begin{ex}
Add in the OIL file two other tasks: \texttt{task_0} (priority 1) and \texttt{task_1} (priority 8). Add the corresponding functions in the C source file. \texttt{task_0} prints ``I am task 0'' and \texttt{task_1} prints ``I am task 1''. Add in the \texttt{a_task} function after the existing \texttt{printf} the activation of \texttt{task_0} and \texttt{task_1}. Compile and execute. Why does \texttt{task_1} execute before \texttt{task_0} whereas it has been activated after?
\end{ex}

\subsection{Task chaining}

The \texttt{ChainTask()} system call allows to chain the execution of a task to another one. This is roughly the same thing as calling ActivateTask and TerminateTask.

\begin{ex}
Replace the call to \texttt{TerminateTask} by a \texttt{ChainTask(task_1)} at the end of task a task. What is happening?
\end{ex}

\begin{ex}
Chain to \texttt{task_0} instead of \texttt{task_1}. What is happening?
\end{ex}

\begin{ex}
Test the error code returned by ChainTask and correct your program to
handle the error.
\end{ex}

\section{Extended tasks and synchronization using events}

Unlike a basic task, an extended task may wait for an event. In the OIL file, set the priority of \texttt{task_0} to 8 and add 2 events \texttt{evt_0} and \texttt{evt_1}. \texttt{evt_0} is used by \texttt{task_0} and \texttt{evt_1} is used by \texttt{task_1}. \texttt{a_task} activates \texttt{task_0} and \texttt{task_1} then sets \texttt{evt_0} and \texttt{evt_1} and terminates. \texttt{task_0} and \texttt{task_1} wait for their event, clear it and terminate.

\begin{ex}
Write the corresponding application. Compile and execute the application. What is happening?
\end{ex}

\begin{ex}
Program an application conforming to the following requirements: The application has 2 tasks:
\texttt{server} priority 2, \texttt{t1} priority 1.

server is an infinite loop that activates \texttt{t1} and waits for event \texttt{evt_1}. \texttt{t1} prints ``I am t1'' and sets \texttt{evt_1} of \texttt{server}. Explain how it works.
\end{ex}

\begin{ex}
Extend the previous application by adding 2 tasks: \texttt{t2} and \texttt{t3} (priority 1 for both) and 2 events \texttt{evt_2} and \texttt{evt_3}. \texttt{server} activates \texttt{t1}, \texttt{t2} and \texttt{t3} and waits for one of the events. When one of the events is set, \texttt{server} activates the corresponding task again.
\end{ex}

\begin{ex}
Try many priority combinations for the tasks. Explain the behavior.
\end{ex}
\end{document}  