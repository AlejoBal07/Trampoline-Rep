semantics goil_types_root :

import "goil_basic_types.gSemantics" ;
import "goil_routines.gSemantics" ;

#import semantics goil_semantic_types in "goil_semantic_types.ggs" ;

map @objectKindMap {
  @identifierMap objectParams;
  insert put error message "%K is duplicated in %L";
  search get error message "%K does not exists";
  remove del error message "%K does not exists";
}

class @objectKind {
  @objectKindMap objects feature setter;
}

map @objectsMap {
  @objectKind objectsOfKind;
  insert put error message "%K is duplicated in %L";
  search get error message "%K does not exists";
  remove del error message "%K does not exists";
}

class @applicationDefinition {
  @lstring name feature setter;
  @objectsMap objects feature setter;
}

function osObject
  ??@objectsMap objects
  ->@identifierMap os
:
  @objectKind objectsForKind;
  [objects get !lstringWith[!"OS"] ?objectsForKind];
  @lstringlist names := [[objectsForKind objects] allKeyList];
  @lstring name;
  [names first ?name];
  [[objectsForKind objects] get !name ?os];
end function;

function objectForKindAndName
  ??@objectsMap objects
  ??@string kind
  ??@string name
  ->@identifierMap object
:
  if [objects hasKey !kind] then
    @objectKind kindObj;
    [objects get !lstringWith[!kind] ?kindObj];
    if [[kindObj objects] hasKey !name] then
      [[kindObj objects] get !lstringWith[!name] ?object];
    else
      object := [@identifierMap emptyMap];
    end if;
  else
    object := [@identifierMap emptyMap];
  end if;
end function;

routine setObjectForKindAndName
  ?!@objectsMap objects
  ??@string kind
  ??@string name
  ??@identifierMap object
:
  @lstring lkind := lstringWith[!kind];
  @lstring lname := lstringWith[!name];
  @objectKind kindObj := [@objectKind new ![@objectKindMap emptyMap]];
  if [objects hasKey !kind] then
    [!?objects del !lkind ?kindObj];
  end if;
  @objectKindMap kindMap := [kindObj objects];
  if [kindMap hasKey !name] then
    [!?kindMap del !lname ?*];
  end if;
  [!?kindMap put !lname !object];
  [!?kindObj setObjects !kindMap];
  [!?objects put !lkind !kindObj];
end routine;

function objectsForKind
  ??@objectsMap objects
  ??@string kind
  ->@objectKind result
:
  if [objects hasKey !kind] then
    [objects get !lstringWith[!kind] ?result];
  else
    result := [@objectKind new ![@objectKindMap emptyMap]];
  end if;
end function;
  
function listInOS
  ??@objectsMap objects
  ??@string attributeName
  ->@identifierList items
:
  @object_t itemsContainer;
  @identifierMap os := osObject[!objects];
  [os get !lstringWith[!attributeName] ?itemsContainer];
  items := multipleAttributeOrError[!itemsContainer !attributeName];
end function;

function boolInOS
  ??@objectsMap objects
  ??@string attributeName
  ->@boolAttribute bool
:
  @object_t boolContainer;
  @identifierMap os := osObject[!objects];
  [os get !lstringWith[!attributeName] ?boolContainer];
  cast boolContainer:
  when == @boolAttribute boolAttr do
    bool := boolAttr;
  else
    bool := [@boolAttribute new ![boolContainer location] !false ![@identifierMap emptyMap]];
    error [boolContainer location]: "Internal error, ".attributeName." has a wrong datatype";
  end cast;
end function;

#
routine setSTRINGAttributeIfVoid
  ?!@identifierMap object
  ??@string name
  ??@location location
  ??@string value
:
  if not [object hasKey !name] then
    [!?object put !lstringWith[!name] ![@string_class new !location !value]];
  end if;
end routine;
  
routine setUINT32AttributeIfVoid
  ?!@identifierMap object
  ??@string name
  ??@location location
  ??@uint value
:
  if not [object hasKey !name] then
    [!?object put !lstringWith[!name] ![@uint32_class new !location !value]];
  end if;
end routine;

routine setENUMAttributeIfVoid
  ?!@identifierMap object
  ??@string name
  ??@location location
  ??@string value
  ??@identifierMap subAttributes
:
  if not [object hasKey !name] then
    [!?object put !lstringWith[!name] ![@enumAttribute new !location !value !subAttributes]];
  end if;
end routine;

routine setMULTIPLEAttributeIfVoid
  ?!@identifierMap object
  ??@string name
  ??@location location
  ??@identifierList value
:
  if not [object hasKey !name] then
    [!?object put !lstringWith[!name] ![@multipleAttribute new !location !value]];
  end if;
end routine;

end semantics ;