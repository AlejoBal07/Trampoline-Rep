#
# @file implementation_parser.ggs
#
# @section descr File description
#
# parser for implementation definition.
#
# @section copyright Copyright
#
# Goil OIL compiler. Part of the Trampoline Project
#
# Trampoline is copyright (c) IRCCyN 2005+
# Copyright ESEO for function and data structures documentation
# Trampoline is protected by the French intellectual property law.
#
# Goil is distributed under the GNU Public Licence v2
#
# @section infos File informations
#
# $Date$
# $Rev$
# $Author$
# $URL$
#/

syntax implementation_parser("goil_lexique.gLexique"):

import "goil_lexique.gLexique";
import "implementation_types.gSemantics";
import "goil_routines.gSemantics";
import "goil_options.gOptions";

nonterminal <implementation_definition> ?!@implementation implementation;
nonterminal <implementation_objects> ?!@implementation implementation;
nonterminal <implementation_type> !@lstring attributeName !@impType type;

nonterminal <with_auto> !@bool withAuto;
nonterminal <int_or_float> !@object_t num ??@dataType type;
nonterminal <set_followup> ?!@numberList numbers ??@dataType type;
nonterminal <range> !@attributeRange range ??@dataType rangeType;
nonterminal <range_content> !@attributeRange range ??@dataType rangeType;
nonterminal <number_options> !@lstring name !@impType options ??@dataType type;
nonterminal <type_options> !@lstring name !@impType options ??@dataType type;
nonterminal <boolean_options> !@lstring name !@impType options;
nonterminal <string_options> !@lstring name !@impType options;
nonterminal <enum_item> ?!@enumValues items;
nonterminal <enum_options> !@lstring name !@impType options;
nonterminal <multiple> !@bool multiple;
nonterminal <identifier_or_attribute> !@lstring name;
nonterminal <identifier_or_enum_value> !@lstring name;

#
# External rules
#
nonterminal <description> !@lstring desc ;
nonterminal <boolean> !@lbool val;
nonterminal <sign> !@bool signed;

rule <implementation_definition>
  ?!@implementation implementation
:
  $IMPLEMENTATION$; $idf$ ?@lstring implementationName; ${$;
  repeat
  while <implementation_objects> !?implementation; $;$;
  end repeat;
  $}$; $;$;
end rule;

#routine addToImplementation
#  ?!@implementation implementation
#  ??@implementationObject object
#  ??@lstring objectKind
#:
#  @implementationObject previousObject;
#  @implementationMap imp := [implementation imp];
#  if [implementation hasKey ![objectKind string]] then
#    [!?imp del !objectKind ?previousObject];
#  else
#    previousObject := [@implementationObject emptyMap];
#  end if;
#  foreach object do
#    if [previousObject hasKey ![lkey string]] then
#      [!?previousObject del !lkey ?*];
#    end if;
#    [!?previousObject put !lkey !type];
#  end foreach;
#  [!?imp put !objectKind !previousObject];
#  [!?implementation setImp !imp];
#end routine;

rule <implementation_objects>
  ?!@implementation implementation
:
  @implementationObject object; 
  @implementationObjectMap objectAttributes;
  @lstring objectName;
  @lbool multiple;
  @lbool oldMultiple;
  @bool objectKnown := false;
  @implementationMap imp := [implementation imp];
  
  $idf$ ?objectName;
  
  if [implementation hasKey ![objectName string]] then
    objectKnown := true;
    [!?imp del !objectName ?object];
    oldMultiple := [object multiple];
    objectAttributes := [object attributes];
  else
    object := [@implementationObject new ![@lbool new !false !here] ![@implementationObjectMap emptyMap]];
    oldMultiple := [@lbool new !false !here];
    objectAttributes := [@implementationObjectMap emptyMap];
  end if;
  
  select
   # object may have multiple instances
    $[$; $]$; multiple := [@lbool new !true !here]; 
  or
    multiple := [@lbool new !false !here];
  end select;
  
  if objectKnown then
    if [multiple bool] != [oldMultiple bool] then
      if [option goil_options.warnMultiple value] then
        warning multiple:"Object multiple redefinition";
        warning oldMultiple:"was defined here";
      end if;
      multiple := oldMultiple;
    end if;
  end if;
  
  <implementation_list> !?objectAttributes;
  
  [!?object setMultiple !multiple];
  [!?object setAttributes !objectAttributes];
  
  [!?imp put !objectName !object];
  [!?implementation setImp !imp];
#  addToImplementation !?implementation !object !objectName;
end rule;

#
# Checks every value of the new enum is in the old enum
#
function checkEnums
  ??@impEnumType previousEnum
  ??@impEnumType newEnum
  ->@bool inside
:
  @stringset newValues := [[newEnum valuesMap] allKeys];
  @stringset previousValues := [[previousEnum valuesMap] allKeys];
  inside := (newValues & previousValues) == newValues;
  if not inside then
    error [newEnum location]: "ENUM is not within previous enum declaration";
    error [previousEnum location]: "previous ENUM declaration was here";
  end if;
end function;

#
# Checks new range is within the previous one
#
function checkRanged
  ??@impRangedType previousRanged
  ??@impRangedType newRanged
  ->@bool inside
:
  [[previousRanged setOrRange] enclose ?inside ![newRanged setOrRange]];
  if not inside then
    error [newRanged location]: "new range or set is not within previous range or set declaration";
    error [previousRanged location]: "previous range or set declaration was here";
  end if;
end function;

function checkNewTypeWithinPreviousType
  ??@lstring name
  ??@impType previousType
  ??@impType newType
  ->@bool result
:
  result := false;
  if [newType type] != [previousType type] then
    error [newType location]: [name string]." should be a ".[[previousType type] oilType];
    error [previousType location]: [name string]." was previouly defined here";
    result := false;
  else
    cast previousType:
    when == @impEnumType previousEnum do
      cast newType:
      when == @impEnumType newEnum do
        result := checkEnums[!previousEnum !newEnum];
      else end cast;
    when == @impRangedType previousRanged do
      cast newType:
      when == @impRangedType newRanged do
        result := checkRanged[!previousRanged !newRanged];
      else end cast;
    else end cast;          
  end if;
end function;

rule <implementation_list>
  ?!@implementationObjectMap objectAttributes
:
  ${$;
  repeat
  while
    @lstring attributeName;
    @impType type;
    <implementation_type> ?attributeName ?type;
    if [objectAttributes hasKey ![attributeName string]] then
      @impType previousType;
      [objectAttributes get !attributeName ?previousType];
      if checkNewTypeWithinPreviousType[!attributeName !previousType !type] then
        [!?objectAttributes del !attributeName ?*];
        [!?objectAttributes put !attributeName !type];
      end if;
    else  
      [!?objectAttributes put !attributeName !type];
    end if;
    $;$;
  end repeat;
  $}$;
end rule;

rule <implementation_type>
  !@lstring attributeName
  !@impType type
:
  select
    $UINT32$; <number_options> ?attributeName ?type ![@dataType uint32Number];
  or
    $INT32$;  <number_options> ?attributeName ?type ![@dataType sint32Number];
  or
    $UINT64$; <number_options> ?attributeName ?type ![@dataType uint64Number];
  or
    $INT64$; <number_options> ?attributeName ?type ![@dataType sint64Number];
  or
    $FLOAT$; <number_options> ?attributeName ?type ![@dataType floatNumber];
  or
    $ENUM$; <enum_options> ?attributeName ?type;
  or
    $BOOLEAN$; <boolean_options> ?attributeName ?type;
  or
    $STRING$; <string_options> ?attributeName ?type;
  or
    $IDENTIFIER$;  <type_options> ?attributeName ?type ![@dataType identifier];
  or
    @lstring typeName; $idf$ ?typeName; <objref_option> ?attributeName ?type !typeName;
  end select;
end rule;

rule <objref_option>
  !@lstring name
  !@impType options
  ?@lstring ref
:
  if [[ref string] rightSubString!5] != "_TYPE" then
    error here: "an object reference must end with _TYPE";
  else
    ref := [@lstring new ![ref leftSubString ![ref length] - 5] ![ref location]];
  end if;
  <identifier_or_attribute> ?name;
  @bool multiple;
  <multiple> ?multiple;
  @lstring description;
  <description> ?description;
  options := [@refType new !here ![@dataType objectType] !name !multiple !description !ref];  
end rule;
  

rule <string_options>
  !@lstring name
  !@impType options
:
  @bool withAuto;
  <with_auto> ?withAuto;
  <identifier_or_attribute> ?name;
  @bool multiple;
  <multiple> ?multiple;
  @object_t defaultValue;
  select
    @lstring stringValue;
    $=$; $string$ ?stringValue;
    defaultValue := [@string_class new ![stringValue location] ![stringValue string]];
  or
    defaultValue:= [@void new !here];
  end select;
  @lstring description;
  <description> ?description;
  options := [@impAutoDefaultType new !here ![@dataType string] !name !multiple !description !withAuto !defaultValue];
end rule;

rule <boolean_options>
  !@lstring name
  !@impType options
:
  @bool withAuto;
  <with_auto> ?withAuto;
  @implementationObjectMap trueSubAttributes [emptyMap];
  @implementationObjectMap falseSubAttributes [emptyMap];
  select
    $[$;
    $TRUE$;
    select 
      <implementation_list> !?trueSubAttributes;
    or
      trueSubAttributes := [@implementationObjectMap emptyMap];
    end select;
    $,$;
    $FALSE$;
    select 
      <implementation_list> !?falseSubAttributes;
    or
      falseSubAttributes := [@implementationObjectMap emptyMap];
    end select;
    $]$;
  or end select;
  <identifier_or_attribute> ?name;
  @bool multiple;
  <multiple> ?multiple;
  @object_t defaultValue;
  select
    @lbool boolValue;
    $=$; <boolean> ?boolValue;
    defaultValue := [@bool_t new ![boolValue location] ![boolValue bool]];
  or
    defaultValue:= [@void new !here];
  end select;
  @lstring description;
  <description> ?description;
  options := [@impBoolType new !here ![@dataType boolean] !name !multiple !description !withAuto !defaultValue !trueSubAttributes !falseSubAttributes];
end rule;

rule <enum_item>
  ?!@enumValues items
:
  @lstring enumItem;
  @implementationObjectMap subAttributes [emptyMap];
  <identifier_or_enum_value> ?enumItem;
  select
    <implementation_list> !?subAttributes;
  or end select;
  [!?items put !enumItem !subAttributes];
end rule;

rule <enum_options>
  !@lstring name
  !@impType options
:
  @bool withAuto;
  <with_auto> ?withAuto;
  @enumValues items [emptyMap];
  $[$;
  <enum_item> !?items;
  repeat
  while
    $,$; <enum_item> !?items;
  end repeat;
  $]$;
  <identifier_or_attribute> ?name;
  @bool multiple;
  <multiple> ?multiple;
  @object_t defaultValue := [@void new !here];
  select
    $=$;
    select
      @lstring stringValue;
      $idf$ ?stringValue;
      defaultValue := [@string_class new ![stringValue location] ![stringValue string]];
    or
      $AUTO$;
      defaultValue := [@auto new !here];
    or
      $NO_DEFAULT$;
    end select;
  or end select;
  @lstring description;
  <description> ?description;
  options := [@impEnumType new !here ![@dataType enumeration] !name !multiple !description !withAuto !defaultValue !items];
  verifyEnum !options;
end rule;

rule <number_options>
  !@lstring name
  !@impType options
  ??@dataType type
:
  @bool withAuto;
  <with_auto> ?withAuto;
  @attributeRange range;
  <range> ?range !type;
  <identifier_or_attribute> ?name;
  @bool multiple;
  <multiple> ?multiple;
  @object_t defaultValue;
  select
    $=$;
    select
      <int_or_float> ?defaultValue !type;
    or
      $NO_DEFAULT$; defaultValue := [@void new !here];
    or
      $AUTO$; defaultValue := [@auto new !here];
    end select;
  or
    defaultValue := [@void new !here];
  end select;
  @lstring description;
  <description> ?description;
  options := [@impRangedType new !here !type !name !multiple !description !withAuto !defaultValue !range];
end rule;

rule <type_options>
  !@lstring name
  !@impType options
  ??@dataType type
:
  <identifier_or_attribute> ?name;
  @bool multiple;
  <multiple> ?multiple;
  @lstring description;
  <description> ?description;
  options := [@impType new !here !type !name !multiple !description];
end rule;

rule <with_auto>
  !@bool withAuto
:
  select
    $WITH_AUTO$; withAuto := true;
  or
    withAuto := false;
  end select;
end rule;

function buildRange
  ??@dataType type
  ??@object_t start
  ??@object_t stop
  ->@attributeRange range
:
  if    type == [@dataType uint32Number] then
    range := [@uint32AttributeMinMax new !here !uint32OrError[!start!"UINT32 Range start"] !uint32OrError[!stop!"UINT32 Range stop"]];
  elsif type == [@dataType sint32Number] then
    range := [@sint32AttributeMinMax new !here !sint32OrError[!start!"SINT32 Range start"] !sint32OrError[!stop!"SINT32 Range stop"]];
  elsif type == [@dataType uint64Number] then
    range := [@uint64AttributeMinMax new !here !uint64OrError[!start!"UINT64 Range start"] !uint64OrError[!stop!"UINT64 Range stop"]];
  elsif type == [@dataType sint64Number] then
    range := [@sint64AttributeMinMax new !here !sint64OrError[!start!"SINT64 Range start"] !sint64OrError[!stop!"SINT64 Range stop"]];
  elsif type == [@dataType floatNumber] then
    range := [@floatAttributeMinMax new !here !floatOrError[!start!"FLOAT Range start"] !floatOrError[!stop!"FLOAT Range stop"]];
  else
    error here: "internal. Unknown number type": range;
  end if; 
end function;

rule <int_or_float>
  !@object_t num
  ??@dataType type
:
  @bool signed;
  <sign> ?signed;
  select
    @luint64 number;
    $uint_number$ ?number; 
    num := checkAndGetIntegerNumber[!type !number !signed];
  or
    @ldouble number;
    $float_number$ ?number;
    num := checkAndGetFloatNumber[!type !number !signed];
  end select;  
end rule;

rule <set_followup>
  ?!@numberList numbers
  ??@dataType type
:
  repeat
  while
    $,$;
    @object_t num;
    <int_or_float> ?num !type;
    numbers += !here !num;
  end repeat;
end rule;

rule <range_content>
  !@attributeRange range
  ??@dataType type
:
  @object_t start := [@void new !here];
  @object_t stop := [@void new !here];
  @bool signed;
  <sign> ?signed;
  select
    @luint64 number;
    $set_start_uint_number$ ?number;
    start := checkAndGetIntegerNumber[!type !number !signed];
    <int_or_float> ?stop !type;
    range := buildRange[!type !start !stop];
  or
    @luint64 number;
    $uint_number$ ?number;
    start := checkAndGetIntegerNumber[!type !number !signed];
    select
      $..$; <int_or_float> ?stop !type;
      range := buildRange[!type !start !stop];
    or
      @numberList numbers := [@numberList listWithValue !here !start];
      <set_followup> !?numbers !type;
      range := attributeRangeWithNumberList[!numbers !type];
    end select;
  or
    @ldouble number;
    $float_number$ ?number;
    start := checkAndGetFloatNumber[!type !number !signed];
    select
      $..$; <int_or_float> ?stop !type;
      range := buildRange[!type !start !stop];
    or
      @numberList numbers := [@numberList listWithValue !here !start];
      <set_followup> !?numbers !type;
      range := attributeRangeWithNumberList[!numbers !type];
    end select;
  end select;
end rule;

rule <range>
  !@attributeRange range
  ??@dataType rangeType
:
  @dataType start;
  @dataType finish;
  select
    $[$; <range_content> ?range !rangeType; $]$;
  or
    range := [@noRange new !here];
  end select;
end rule;

rule <multiple>
  !@bool multi
:
  select
    $[$ ; $]$ ;
    multi := true;
  or
    multi := false;
  end select ;
end rule ;

rule <identifier_or_attribute>
  !@lstring name
:
  $idf$ ?name ;
end rule;

rule <identifier_or_enum_value>
  !@lstring name
:
#  select $EXTENDED$;           name := [@lstring new !"EXTENDED" !here];
#  or     $STANDARD$;           name := [@lstring new !"STANDARD" !here];
#  or 
      $idf$ ?name ;
#  end select;
end rule;

end syntax;