\chapter{Tracing the execution}

\section*{Introduction}

The code of Trampoline RTOS embeds a tracing subsystem that can be activated at
system configuration time.
This toolkit sends a stream of events describing the execution of the
application to a target specific backend.
The resulting data can then be exploited to compute statistics on some
performance figures of the system (such as execution times, jitters, etc.)
and/or to feed a visualization tool.
Please notice that, in the current implementation, the tracing toolkit has a small, albeit non null, overhead so
the system from which traces are computed is not exactly the same than the
system without traces.

\section{Traced events}

Events that can be traced during an execution are given below.
Each event is described by its name and a set of attributes.
These attributes are made available by the kernel to the platform specific
backend (see section~\ref{sec:trace:targetbackend} below).

\begin{description}
  \item[PROC\_CHANGE\_STATE]: state of a process (task or ISR) is changed.
    \begin{itemize}
      \item \texttt{proc_id}: identifier of the process.
      \item \texttt{target_state}: new state of the proc. %TODO: list states
    \end{itemize}

  \item[RES\_CHANGE\_STATE]: state of a resource is changed.
    \begin{itemize}
      \item \texttt{res_id}: identifier of the resource.
      \item \texttt{target_state}: new state of the resource. %TODO: list states
    \end{itemize}

  \item[EVENT_SET]: a process sets one or more event to another process.
    \begin{itemize}
      \item \texttt{proc_id}: owner of the events.
      \item \texttt{ev_id}: list of events that have been set.
    \end{itemize}

  \item[EVENT_RESET]: a process resets a subset of its events
    \begin{itemize}
      \item \texttt{ev_id}: list of events that have been reset.
    \end{itemize}

  \item[TIMEOBJ\_CHANGE\_STATE]: state of a timeobj (alarm, schedule table
    expiry point) is changed.
    \begin{itemize}
      \item \texttt{timeobj_id}: identifier of the timeobj.
      \item \texttt{target_state}: new state of the timeobj.
    \end{itemize}

  \item[TIMEOBJ\_EXPIRE]: a timeobj expires.
    \begin{itemize}
      \item \texttt{alarm_id}: identifier of the timeobj.
    \end{itemize}

\end{description}

Notice that each event contains the minimal information that is needed
to rebuild the whole state of the system.
Hence, the running task is never used as an attribute because it can be deduced
by analysing the sequence of \textbf{PROC\_CHANGE\_STATE} events.

\section{Using the tracing subsystem}

Activation of tracing is done at system configuration time through the OIL file.
A boolean attribute \texttt{TRACE} is defined in the \texttt{OS} object. It has
several subattributes has shown in the code below:

\begin{lstlisting}[language=OIL]
TRACE = TRUE {
    FORMAT = bin;
    PROC = TRUE;
    RESOURCE = TRUE;
    ALARM = TRUE;
    EVENT = TRUE;
};
\end{lstlisting}

\begin{description}
  \item[FORMAT] specifies the output format of the trace. Currently, the
    following values are accepted: \texttt{txt}, \texttt{bin}, and
    \texttt{json}. They are not all supported by targets.

  \item[PROC] controls the tracing of event \texttt{PROC\_CHANGE\_STATE};

  \item[RESOURCE] controls the tracing of event \texttt{RES\_CHANGE\_STATE};

  \item[ALARM] controls the tracing of events \texttt{TIMEOBJ\_CHANGE\_STATE}
    and \texttt{TIMEOBJ\_EXPIRE};

  \item[EVENT]  controls the tracing of events \texttt{EVENT\_SET}
    and \texttt{EVENT\_RESET};
\end{description}

\section{Implementation}
The implementation is split in 2 parts:
\begin{itemize}
	\item the \emph{generic} part is a set of macro in the \texttt{os/} kernel files to captures trace events. The file \texttt{os/tpl_trace.h} list all the specific functions that should be implemented.
	\item the \emph{target specific} part in \lstinline{machine/.../tpl_trace.c} implements the trace back-end. 
\end{itemize}

\subsection{Implementing target specific backends}
\label{sec:trace:targetbackend}

The backend consists in a set of 7 functions that should be implemented in the target to store events, and communicate them to an host computer for analysis. Prototypes are in the \texttt{os/tpl_trace.h} are each function is related to a trace event. For instance, the following function will be called by the kernel internal files (\emph{in kernel mode!}) each time a proc (task/isr) state is updated.

\begin{lstlisting}
/**
* trace the execution of a task or ISR
* This function should be implemented in the machine dependant trace backend.
*
*/
FUNC(void, OS_CODE) tpl_trace_proc_change_state(
    CONST(tpl_proc_id,AUTOMATIC) proc_id,
    CONST(tpl_proc_state,AUTOMATIC) target_state);
\end{lstlisting}

A new file is now generated by goil \texttt{tpl_static_info.oil} that lists the objects defined in the oil file. This file can be combined with the trace to deal with the name of an object instead of its internal id.

\subsubsection{Posix target}
The posix target is the simplest one, as there is no problem to get back the trace. The trace can be save either in \texttt{json} mode only. 

A python script is provided (\texttt{readTrace.py}) by goil. It reads both the trace and and the \texttt{tpl_static_info.oil}, to retrieve trace with names instead of ids.

%\subsubsection{MSP430}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
