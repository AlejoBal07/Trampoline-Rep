/**
 * @file tpl_invoque.S
 *
 * @section descr File description
 *
 * System call user level invoque API.
 *
 * @warning this file is generated by gen_invoque.sh based on the 
 * tpl_os_service_ids.h header file.
 *
 * @section copyright Copyright
 *
 * Trampoline OS
 *
 * Trampoline is copyright (c) IRCCyN 2005+
 * Copyright ESEO for function and data structures documentation and ARM port
 * Trampoline is protected by the French intellectual property law.
 *
 * This software is distributed under the Lesser GNU Public Licence
 *
 * @section infos File informations
 *
 * $$Date$$
 * $$Rev$$
 * $$Author$$
 * $$URL$$
 */
#include "tpl_os_application_def.h"
#include "tpl_service_ids.h"

#if WITH_SYSTEM_CALL == NO
#error "This file should not be part of your project since WITH_SYSTEM_CALL is not defined"
#endif


#if WITH_MEMMAP == NO

#endif /* WITH_MEMMAP == NO */

#define API_START_SEC_CODE
#include "tpl_as_memmap.h"

	.syntax unified
	.thumb
.equ ISR_NUMBER_MASK, 0x000001FF


 /*============================================================================
  * Service GetActiveApplicationMode
  */
.global GetActiveApplicationMode
.type   GetActiveApplicationMode, %function
GetActiveApplicationMode:
    /*-------------------------------------------------------------------------
     * Check the ISR_NUMBER field of the PSR
     * If 0 we are in thread mode and the system call is done by a svc
     * If not 0 we are in handler mode and the system call is done by
     * a function call
     */
    mrs  r3,IPSR
    cmp  r3,#0
    bne  GetActiveApplicationMode_direct_call
    /*-------------------------------------------------------------------------
     * We are in thread mode so we set r3 to the identifier of the service
     * and we do a svc
     */
    movs r3,#OSServiceId_GetActiveApplicationMode
    svc  #OSServiceId_GetActiveApplicationMode
    /*-------------------------------------------------------------------------
     * return from the service wrapper
     */
    bx   lr
GetActiveApplicationMode_direct_call:
    /*-------------------------------------------------------------------------
     * We are in handler mode so we do a simple function call
     */
    push {lr}
    bl   tpl_get_active_application_mode_service
    /*-------------------------------------------------------------------------
     * return from the service wrapper
     */
    pop  {pc}

 /*============================================================================
  * Service StartOS
  */
.global tpl_start_os
.type   tpl_start_os, %function
tpl_start_os:
    /*-------------------------------------------------------------------------
     * Check the ISR_NUMBER field of the PSR
     * If 0 we are in thread mode and the system call is done by a svc
     * If not 0 we are in handler mode and the system call is done by
     * a function call
     */
    mrs  r3,IPSR
    cmp  r3,#0
    bne  StartOS_direct_call
    /*-------------------------------------------------------------------------
     * We are in thread mode so we set r3 to the identifier of the service
     * and we do a svc
     */
    movs r3,#OSServiceId_StartOS
    svc  #OSServiceId_StartOS
    /*-------------------------------------------------------------------------
     * return from the service wrapper
     */
    bx   lr
StartOS_direct_call:
    /*-------------------------------------------------------------------------
     * We are in handler mode so we do a simple function call
     */
    push {lr}
    bl   tpl_start_os_service
    /*-------------------------------------------------------------------------
     * return from the service wrapper
     */
    pop  {pc}

 /*============================================================================
  * Service ShutdownOS
  */
.global ShutdownOS
.type   ShutdownOS, %function
ShutdownOS:
    /*-------------------------------------------------------------------------
     * Check the ISR_NUMBER field of the PSR
     * If 0 we are in thread mode and the system call is done by a svc
     * If not 0 we are in handler mode and the system call is done by
     * a function call
     */
    mrs  r3,IPSR
    cmp  r3,#0
    bne  ShutdownOS_direct_call
    /*-------------------------------------------------------------------------
     * We are in thread mode so we set r3 to the identifier of the service
     * and we do a svc
     */
    movs r3,#OSServiceId_ShutdownOS
    svc  #OSServiceId_ShutdownOS
    /*-------------------------------------------------------------------------
     * return from the service wrapper
     */
    bx   lr
ShutdownOS_direct_call:
    /*-------------------------------------------------------------------------
     * We are in handler mode so we do a simple function call
     */
    push {lr}
    bl   tpl_shutdown_os_service
    /*-------------------------------------------------------------------------
     * return from the service wrapper
     */
    pop  {pc}

 /*============================================================================
  * Service EnableAllInterrupts
  */
.global EnableAllInterrupts
.type   EnableAllInterrupts, %function
EnableAllInterrupts:
    /*-------------------------------------------------------------------------
     * Check the ISR_NUMBER field of the PSR
     * If 0 we are in thread mode and the system call is done by a svc
     * If not 0 we are in handler mode and the system call is done by
     * a function call
     */
    mrs  r3,IPSR
    cmp  r3,#0
    bne  EnableAllInterrupts_direct_call
    /*-------------------------------------------------------------------------
     * We are in thread mode so we set r3 to the identifier of the service
     * and we do a svc
     */
    movs r3,#OSServiceId_EnableAllInterrupts
    svc  #OSServiceId_EnableAllInterrupts
    /*-------------------------------------------------------------------------
     * return from the service wrapper
     */
    bx   lr
EnableAllInterrupts_direct_call:
    /*-------------------------------------------------------------------------
     * We are in handler mode so we do a simple function call
     */
    cpsid i   /* set PRIMASK */
    push {lr}
    bl   tpl_enable_all_interrupts_service
    /*-------------------------------------------------------------------------
     * return from the service wrapper
     */
    cpsie i   /* clear PRIMASK */
    pop  {pc}

 /*============================================================================
  * Service DisableAllInterrupts
  */
.global DisableAllInterrupts
.type   DisableAllInterrupts, %function
DisableAllInterrupts:
    /*-------------------------------------------------------------------------
     * Check the ISR_NUMBER field of the PSR
     * If 0 we are in thread mode and the system call is done by a svc
     * If not 0 we are in handler mode and the system call is done by
     * a function call
     */
    mrs  r3,IPSR
    cmp  r3,#0
    bne  DisableAllInterrupts_direct_call
    /*-------------------------------------------------------------------------
     * We are in thread mode so we set r3 to the identifier of the service
     * and we do a svc
     */
    movs r3,#OSServiceId_DisableAllInterrupts
    svc  #OSServiceId_DisableAllInterrupts
    /*-------------------------------------------------------------------------
     * return from the service wrapper
     */
    bx   lr
DisableAllInterrupts_direct_call:
    /*-------------------------------------------------------------------------
     * We are in handler mode so we do a simple function call
     */
    cpsid i   /* set PRIMASK */
    push {lr}
    bl   tpl_disable_all_interrupts_service
    /*-------------------------------------------------------------------------
     * return from the service wrapper
     */
    cpsie i   /* clear PRIMASK */
    pop  {pc}

 /*============================================================================
  * Service ResumeAllInterrupts
  */
.global ResumeAllInterrupts
.type   ResumeAllInterrupts, %function
ResumeAllInterrupts:
    /*-------------------------------------------------------------------------
     * Check the ISR_NUMBER field of the PSR
     * If 0 we are in thread mode and the system call is done by a svc
     * If not 0 we are in handler mode and the system call is done by
     * a function call
     */
    mrs  r3,IPSR
    cmp  r3,#0
    bne  ResumeAllInterrupts_direct_call
    /*-------------------------------------------------------------------------
     * We are in thread mode so we set r3 to the identifier of the service
     * and we do a svc
     */
    movs r3,#OSServiceId_ResumeAllInterrupts
    svc  #OSServiceId_ResumeAllInterrupts
    /*-------------------------------------------------------------------------
     * return from the service wrapper
     */
    bx   lr
ResumeAllInterrupts_direct_call:
    /*-------------------------------------------------------------------------
     * We are in handler mode so we do a simple function call
     */
    cpsid i   /* set PRIMASK */
    push {lr}
    bl   tpl_resume_all_interrupts_service
    /*-------------------------------------------------------------------------
     * return from the service wrapper
     */
    cpsie i   /* clear PRIMASK */
    pop  {pc}

 /*============================================================================
  * Service SuspendAllInterrupts
  */
.global SuspendAllInterrupts
.type   SuspendAllInterrupts, %function
SuspendAllInterrupts:
    /*-------------------------------------------------------------------------
     * Check the ISR_NUMBER field of the PSR
     * If 0 we are in thread mode and the system call is done by a svc
     * If not 0 we are in handler mode and the system call is done by
     * a function call
     */
    mrs  r3,IPSR
    cmp  r3,#0
    bne  SuspendAllInterrupts_direct_call
    /*-------------------------------------------------------------------------
     * We are in thread mode so we set r3 to the identifier of the service
     * and we do a svc
     */
    movs r3,#OSServiceId_SuspendAllInterrupts
    svc  #OSServiceId_SuspendAllInterrupts
    /*-------------------------------------------------------------------------
     * return from the service wrapper
     */
    bx   lr
SuspendAllInterrupts_direct_call:
    /*-------------------------------------------------------------------------
     * We are in handler mode so we do a simple function call
     */
    cpsid i   /* set PRIMASK */
    push {lr}
    bl   tpl_suspend_all_interrupts_service
    /*-------------------------------------------------------------------------
     * return from the service wrapper
     */
    cpsie i   /* clear PRIMASK */
    pop  {pc}

 /*============================================================================
  * Service ResumeOSInterrupts
  */
.global ResumeOSInterrupts
.type   ResumeOSInterrupts, %function
ResumeOSInterrupts:
    /*-------------------------------------------------------------------------
     * Check the ISR_NUMBER field of the PSR
     * If 0 we are in thread mode and the system call is done by a svc
     * If not 0 we are in handler mode and the system call is done by
     * a function call
     */
    mrs  r3,IPSR
    cmp  r3,#0
    bne  ResumeOSInterrupts_direct_call
    /*-------------------------------------------------------------------------
     * We are in thread mode so we set r3 to the identifier of the service
     * and we do a svc
     */
    movs r3,#OSServiceId_ResumeOSInterrupts
    svc  #OSServiceId_ResumeOSInterrupts
    /*-------------------------------------------------------------------------
     * return from the service wrapper
     */
    bx   lr
ResumeOSInterrupts_direct_call:
    /*-------------------------------------------------------------------------
     * We are in handler mode so we do a simple function call
     */
    cpsid i   /* set PRIMASK */
    push {lr}
    bl   tpl_resume_os_interrupts_service
    /*-------------------------------------------------------------------------
     * return from the service wrapper
     */
    cpsie i   /* clear PRIMASK */
    pop  {pc}

 /*============================================================================
  * Service SuspendOSInterrupts
  */
.global SuspendOSInterrupts
.type   SuspendOSInterrupts, %function
SuspendOSInterrupts:
    /*-------------------------------------------------------------------------
     * Check the ISR_NUMBER field of the PSR
     * If 0 we are in thread mode and the system call is done by a svc
     * If not 0 we are in handler mode and the system call is done by
     * a function call
     */
    mrs  r3,IPSR
    cmp  r3,#0
    bne  SuspendOSInterrupts_direct_call
    /*-------------------------------------------------------------------------
     * We are in thread mode so we set r3 to the identifier of the service
     * and we do a svc
     */
    movs r3,#OSServiceId_SuspendOSInterrupts
    svc  #OSServiceId_SuspendOSInterrupts
    /*-------------------------------------------------------------------------
     * return from the service wrapper
     */
    bx   lr
SuspendOSInterrupts_direct_call:
    /*-------------------------------------------------------------------------
     * We are in handler mode so we do a simple function call
     */
    cpsid i   /* set PRIMASK */
    push {lr}
    bl   tpl_suspend_os_interrupts_service
    /*-------------------------------------------------------------------------
     * return from the service wrapper
     */
    cpsie i   /* clear PRIMASK */
    pop  {pc}

 /*============================================================================
  * Service CallTerminateISR2
  */
.global CallTerminateISR2
.type   CallTerminateISR2, %function
CallTerminateISR2:
    /*-------------------------------------------------------------------------
     * Check the ISR_NUMBER field of the PSR
     * If 0 we are in thread mode and the system call is done by a svc
     * If not 0 we are in handler mode and the system call is done by
     * a function call
     */
    mrs  r3,IPSR
    cmp  r3,#0
    bne  CallTerminateISR2_direct_call
    /*-------------------------------------------------------------------------
     * We are in thread mode so we set r3 to the identifier of the service
     * and we do a svc
     */
    movs r3,#OSServiceId_CallTerminateISR2
    svc  #OSServiceId_CallTerminateISR2
    /*-------------------------------------------------------------------------
     * return from the service wrapper
     */
    bx   lr
CallTerminateISR2_direct_call:
    /*-------------------------------------------------------------------------
     * We are in handler mode so we do a simple function call
     */
    cpsid i   /* set PRIMASK */
    push {lr}
    bl   tpl_call_terminate_isr2_service
    /*-------------------------------------------------------------------------
     * return from the service wrapper
     */
    cpsie i   /* clear PRIMASK */
    pop  {pc}

 /*============================================================================
  * Service GetResource
  */
.global GetResource
.type   GetResource, %function
GetResource:
    /*-------------------------------------------------------------------------
     * Check the ISR_NUMBER field of the PSR
     * If 0 we are in thread mode and the system call is done by a svc
     * If not 0 we are in handler mode and the system call is done by
     * a function call
     */
    mrs  r3,IPSR
    cmp  r3,#0
    bne  GetResource_direct_call
    /*-------------------------------------------------------------------------
     * We are in thread mode so we set r3 to the identifier of the service
     * and we do a svc
     */
    movs r3,#OSServiceId_GetResource
    svc  #OSServiceId_GetResource
    /*-------------------------------------------------------------------------
     * return from the service wrapper
     */
    bx   lr
GetResource_direct_call:
    /*-------------------------------------------------------------------------
     * We are in handler mode so we do a simple function call
     */
    push {lr}
    bl   tpl_get_resource_service
    /*-------------------------------------------------------------------------
     * return from the service wrapper
     */
    pop  {pc}

 /*============================================================================
  * Service ReleaseResource
  */
.global ReleaseResource
.type   ReleaseResource, %function
ReleaseResource:
    /*-------------------------------------------------------------------------
     * Check the ISR_NUMBER field of the PSR
     * If 0 we are in thread mode and the system call is done by a svc
     * If not 0 we are in handler mode and the system call is done by
     * a function call
     */
    mrs  r3,IPSR
    cmp  r3,#0
    bne  ReleaseResource_direct_call
    /*-------------------------------------------------------------------------
     * We are in thread mode so we set r3 to the identifier of the service
     * and we do a svc
     */
    movs r3,#OSServiceId_ReleaseResource
    svc  #OSServiceId_ReleaseResource
    /*-------------------------------------------------------------------------
     * return from the service wrapper
     */
    bx   lr
ReleaseResource_direct_call:
    /*-------------------------------------------------------------------------
     * We are in handler mode so we do a simple function call
     */
    push {lr}
    bl   tpl_release_resource_service
    /*-------------------------------------------------------------------------
     * return from the service wrapper
     */
    pop  {pc}


#define API_STOP_SEC_CODE
#include "tpl_as_memmap.h"


/* End of file tpl_invoque.S */

