/**
 * @file tpl_irq_handlers.S
 *
 * @section descr File description
 *
 * Generated from application checkpoint
 * Automatically generated by goil on Wed May 12 23:14:32 2021
 * from root OIL file fft_lea.oil
 *
 * @section infos File informations
 *
 */

#include "tpl_assembler.h"
#include "tpl_asm_definitions.h"
#include "tpl_kern_stack.h"

.extern tpl_kern
.extern tpl_kern_stack

#define OS_START_SEC_CODE
#include "tpl_as_memmap.h"

/*=============================================================================
 * After en interrupt on a CPUX, the process stack is as follow
 *
 *    +----+--------------+
 *  0 | PC |      SR      | + 0
 *    +----+--------------+
 *  1 |         PC        | + 2
 *    +-------------------+
 *
 */


/*=============================================================================
 * IRQ Handler for COUNTER with source vector TIMER3_A0_VECTOR
 ******************************************************************************/

.global tpl_primary_irq_handler_TIMER3_A0_VECTOR
.type   tpl_primary_irq_handler_TIMER3_A0_VECTOR, %function

/*-----------------------------------------------------------------------------
 */
tpl_primary_irq_handler_TIMER3_A0_VECTOR:

/*-----------------------------------------------------------------------------
 * -1- Before doing anything we have to save the volatile registers, which
 * are r11 (r11 is not volatile in the MSPGCC ABI but is volatile in GCC
 * compiler for MSP ABI. Anyway, in order to limit variabilility, r11 is 
 * saved for both ABIs) to r15, because they will not be saved when we will
 * call the underlying C function.
 */
  pushm.w   #5, r15  /* Push r11, r12, r13, r14 and r15 */
/*-----------------------------------------------------------------------------
 * -2- Switch to the kernel stack.
 */
  mov       r1, r11                          /* Copy the PSP in r11        */
  mov       #tpl_kern_stack + TPL_KERNEL_STACK_SIZE, r1 /* On kernel stack */
  push      r11                              /* Save PSP to kernel stack   */
/*-----------------------------------------------------------------------------
 * -3- Init the NEED_SWITCH/SAVE in tpl_kern.
 */
  mov       #tpl_kern, r11
  mov.b     #NO_NEED_SWITCH_NOR_SCHEDULE, TPL_KERN_OFFSET_NEED_SWITCH(r11)
  mov.b     #NO_NEED_SWITCH_NOR_SCHEDULE, TPL_KERN_OFFSET_NEED_SCHEDULE(r11)
/*-----------------------------------------------------------------------------
 * -4- Call the underlying C function.
 */
  call      #tpl_tick_TIMER3_A0_VECTOR
/*-----------------------------------------------------------------------------
 * -5- Switch back to the process stack
 */
tpl_direct_irq_handler_exit_TIMER3_A0_VECTOR:
  mov       r1, r13 /* get a copy of the KSP to restore it later        */
  add       #2, r13 /* and forget the pushed PSP (not useful anymore).  */
  pop       r1      /* get the saved process stack pointer back         */
/*-----------------------------------------------------------------------------
 * -6- Check the context switch condition in tpl_kern.
 */
  mov       #tpl_kern, r11
  tst.b     TPL_KERN_OFFSET_NEED_SWITCH(r11)
  jz        tpl_TIMER3_A0_VECTOR_no_context_switch
/*-----------------------------------------------------------------------------
 * -7- Save the rest of the context.
 */ 
  pushm.w   #7, r10  /* Push r4 to r10 */
/*-----------------------------------------------------------------------------
 * -8- Now the stack pointer is saved in the dedicated location.
 */  
  mov       &tpl_kern, r11 /* Get the s_running slot of tpl_kern in r11 */
  mov       @r11, r11      /* Get the pointer to the context (SP alone) */
  mov       r1, @r11       /* Save the stack pointer                    */
/*-----------------------------------------------------------------------------
 * -9- Call tpl_run_elected with argument 1 (aka save) after switching back
 * to the kernel stack.
 */
  mov       r13, r1        /* Switch back to the kernel stack           */
  mov       #1, REG_RETARG
  call      #tpl_run_elected
/*-----------------------------------------------------------------------------
 * -10- tpl_run_elected has copied the elected process slot of tpl_kern to the
 * running slot. We load the stack pointer of the new running process.
 */
  mov       &tpl_kern, r11 /* Get the s_running slot of tpl_kern in r11 */
  mov       @r11, r11      /* Get the pointer to the context (SP alone) */
  mov       @r11, r1       /* Get the stack pointer                     */
/*-----------------------------------------------------------------------------
 * -11- Now, the context of the new running process is loaded. All registers
 * are popped.
 */
  popm.w    #12,r15        /* Pop r4 to r15  */
  reti
/*-----------------------------------------------------------------------------
 * -12- We get here from stage 6. Restore the volatile registers and return
 * from the interrupt handler.
 */
tpl_TIMER3_A0_VECTOR_no_context_switch:
  popm.w    #5, r15
  reti
/*-----------------------------------------------------------------------------
*/


#define OS_STOP_SEC_CODE
#include "tpl_as_memmap.h"

/* End of file tpl_irq_handlers.S */
