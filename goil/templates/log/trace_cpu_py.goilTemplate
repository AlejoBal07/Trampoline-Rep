#! /usr/bin/python3
# -*- coding: UTF-8 -*-
import time
import json
import jsonpath
import os
import argparse
import sys
import textwrap

if __name__ == '__main__':

    #read trace_cpu_README.md in the same diectory

    parser = argparse.ArgumentParser(description='get information from trace.josn and tpl_static_infor.json and calculate the CPU and time of each task',
    formatter_class=argparse.RawDescriptionHelpFormatter, epilog=textwrap.dedent(
    '''\
    ----------------------------------------------------------------
## trace_cpu.py is used for printing the information of CPU usage
    {0} This script uses jsonpath module of python3, please download it with following command:
    
    {0} $.pip3 install jsonpath  

    # File Directory
        Two files are required to run this script : 'trace.json' and 'tpl_static_info.json'
    
        'trace.json' should be in the same file directory as this script.
        'tpl_static_info.json' should be in the subfolder (automatically generated by goil) under this path.
        the name of subfolder is the same as the .oil file.
    ----------------------------------------------------------------
## Run example
    {0}                #(default) for getting cpu usage during the whole process
    {0} -o             #read 2 json file, output cpu usage during the whole process and tasks that exceed their deadlines	
    {0} -s 2000        #read 2 json file, output cpu usage during the whole process and segmented cpu usage at 1000 ms intervals (the time interval is 1000ms by default)

    '''.format(sys.argv[0])))

    parser.add_argument("-o", "--timeout", type=str, nargs='?',help='For getting cpu usage during the whole process and informantion of tasks that exceed their deadlines',const=True,default=False)
    parser.add_argument("-s",'--timeinterval',  type=int,nargs='?',dest='accumulate', action='append',help='For getting cpu usage during the whole process and show segmented cpu usage at 1000 ms intervals (the time interval is 1000ms by default)',)    
    args = parser.parse_args()

    #get the path of tpl_static_info.json
    current_path = os.path.abspath(__file__)#get the path of this script 
    father_path = os.path.abspath(os.path.dirname(current_path) + os.path.sep + ".")
    os.chdir(father_path)#switch path to father_path


    #get the name of file which tpye is .oil
    further_path=[] 
    for root, dirs, files in os.walk(father_path):
        for file in files:
            if os.path.splitext(file)[1] == '.oil':
                further_path=os.path.splitext(file)[0]

    #path of tpl_static_info.json
    path_static=father_path+'/'+further_path+'/tpl_static_info.json'


# ---------------------get information from tql_static_infro.json----------------------------------------------
    tpl_static=open(path_static,'r')
    json_static=json.load(tpl_static)
    task = jsonpath.jsonpath(json_static["task"],"$..NAME")#names of all tasks  
    task_autostart = jsonpath.jsonpath(json_static["alarm"],"$..AUTOSTART")
    task_alarm_cycletime = jsonpath.jsonpath(json_static,"$..CYCLETIME")#list of CYCLETIME in alarm
    task_alarm =jsonpath.jsonpath(json_static["alarm"],"$..TASK")#list of task names in alarm
    task_isr = jsonpath.jsonpath(json_static["isr"],"$..NAME")#get list of task in isr-----------------generally task_isr is nothing
    if task == False :
        print("here is no task")
    elif task_isr == True:
        task=task+task_isr
    
    nb_task=len(task)
    len_alarm=len(task_alarm)
    task_cycletime=(['NULL']*(nb_task))
    s = 0# position de task_alarm_cycletime
    #match the task name to the cycletime
    for i in range(len_alarm) :
        if task_autostart[i]=='true' :
            for j in range(nb_task):
                if task[j]==task_alarm[i] :
                    task_cycletime[j]=task_alarm_cycletime[s] 
                    s=s+1

# --------------------get information from trace.json----------------------------------------------------------
    path_trace=father_path+'/trace.json'
    trace=open(path_trace,'r')
    json_trace=json.load(trace) #the process
    nb_proc=len(json_trace) #number of process
    #initialization
    nb_i = 0

    time_tache_start=(['NULL']*(nb_task+1))
    time_tache_end=([int(json_trace[0]["ts"])]*(nb_task+1))
    interval_time = 1000 #time interval is 1000ms by default
    time_tmp = ([0]*(nb_task+1)) 
    time_inter = ([0]*(nb_task+1)) 
    
    time_start=int(json_trace[0]["ts"] )# start time of process
    nb_tache=0
    task_no_overrun = False
    time_flag = int(json_trace[0]["ts"])
    tmp = (['NULL']*(nb_task+1)) 
    time=([0]*(nb_task+1))
# five state of task
    # supended 0
    # ready 1
    # running 2
    # waiting 3
    # ready_and_new 5

# calculate if there are tasks beyond their deadline
    if args.timeout==True :
        for nb_i in range(nb_proc) :  
            if (json_trace[nb_i]["type"]=="proc"):
                proc_id = int(json_trace[nb_i]["proc_id"])
                if proc_id < nb_task:
                    if (int(json_trace[nb_i]["target_state"])==1 or int(json_trace[nb_i]["target_state"])==5):

                        time_tache_start[proc_id] =int(json_trace[nb_i]["ts"])

                    if (int(json_trace[nb_i]["target_state"])==0):#int(json_trace[nb_i]["target_state"])==3 or 

                        if (int(json_trace[nb_i]["target_state"])==0):
                            if time_tache_start[proc_id]=='NULL' :
                                time_tache_start[proc_id] =int(json_trace[nb_i]["ts"])
                            time_tache_end[proc_id]=int(json_trace[nb_i]["ts"])

                            if task_cycletime[proc_id]!='NULL' :
                                if  int(task_cycletime[proc_id])<time_tache_end[proc_id]-time_tache_start[proc_id]:
                                    if task_no_overrun == False :
                                        print("===============================================================================")
                                        print("Here are tasks beyond their deadline : ")
                                        task_no_overrun=True
                                    nb_tache=nb_tache+1
                                    print('\%-10.10s' \% ('Task '+str(nb_tache)),end='')
                                    print('\%-25.25s' \% (' : '+str(task[proc_id])),end='')
                                    print('\%-20.20s' \% ('Cycletime : '+ str(task_cycletime[proc_id])),end='')
                                    print('\%-20.20s' \% ('Start time: '+str(time_tache_start[proc_id])),end='')
                                    print('\%-20.20s' \% ('End time: '+str(time_tache_end[proc_id])),end='')
                                    print('\%-20.20s' \% ('Duration: '+str(time_tache_end[proc_id]-time_tache_start[proc_id])),end='')
                                    print('\%-20.20s' \% ('Overrun :'+str(time_tache_end[proc_id]-time_tache_start[proc_id]-task_cycletime[proc_id])))
        if task_no_overrun == False :
            print("===============================================================================")
            print('No task beyond his deadline :')
        print("===============================================================================")
    
    running=False      
#calculate and show segmented cpu usage at intervals chosen (the time interval is 1000ms by default)
    for nb_i in range(nb_proc) :
        time[nb_task]=int(json_trace[nb_i]["ts"])#recording ts of number nb_i task
        if (json_trace[nb_i]["type"]=="proc"):
            proc_id = int(json_trace[nb_i]["proc_id"])
            if proc_id < nb_task:

                if (int(json_trace[nb_i]["target_state"])==2):
                    tmp[proc_id] =int(json_trace[nb_i]["ts"])
                    time_tache_start[proc_id] =int(json_trace[nb_i]["ts"])

                    running=True
                if (int(json_trace[nb_i]["target_state"])==3 or int(json_trace[nb_i]["target_state"])==0):
                    if tmp[proc_id]=='NULL' :
                        tmp[proc_id]=int(json_trace[nb_i]["ts"])
                    time[proc_id]=time[proc_id]+ int(json_trace[nb_i]["ts"])-tmp[proc_id]
                    running=False
        if args.accumulate :
            if args.accumulate[0] != None :
                interval_time=int(args.accumulate[0])             
            if int(json_trace[nb_i]["ts"])-time_flag >= interval_time or nb_i==nb_proc-1:  #real time greater that inverval_time or it is the last process

                if running == True :
                    time[proc_id]=time[proc_id]+ int(json_trace[nb_i]["ts"])-tmp[proc_id]
                    tmp[proc_id] = int(json_trace[nb_i]["ts"])
                print("-------------------------------------------------------------------------------")
                print('TIME FROM '+str(time_flag)+'ms'+' TO '+str(json_trace[nb_i]["ts"])+'ms')
                print('\%-30.30s' \% 'NAME OF TASK',end=''),
                print('\%-30.30s' \% 'TIME : ',end='')
                print('\%-20.20s' \% 'CPU USAGE')       
                time_flag = int(json_trace[nb_i]["ts"])
                proc_i_tmp = 0
                for proc_i_tmp in range(nb_task+1) :
                    time_inter[proc_i_tmp]=time[proc_i_tmp]-time_tmp[proc_i_tmp]                
                    time_tmp[proc_i_tmp]=time[proc_i_tmp]
                proc_i_tmp = 0
                for proc_i_tmp in range(nb_task) :
                    print('\%-30.30s' \% str(task[proc_i_tmp]),end="")
                    #print('\%-15.15s' \% "time : ",end="")
                    print('\%-30.30s' \% (str(time_inter[proc_i_tmp])+'ms'),end="")
                    print('\%-10.6s' \% str((float(time_inter[proc_i_tmp])/float((time_inter[nb_task])+0.1))*100)+'\%')
                proc_i_tmp = 0
            if nb_i == nb_proc-1 :#the ending time of process
                time[nb_task]=int(json_trace[nb_i]["ts"])
    task_i=0
# the CPU USAGE of whole process
    print("===============================================================================")
    print('FOR WHOLE PROCESS : TIME FROM '+str(time_start)+'ms'+' TO '+str(time[nb_task])+'ms')
    print('\%-30.30s' \% 'NAME OF TASK',end='')
    print('\%-30.30s' \% 'TIME : ',end='')
    print('\%-20.20s' \% 'CPU USAGE')
    for task_i in range(nb_task):
        print('\%-30.30s' \% str(task[task_i]),end="")
        #print('\%-15.15s' \% "time : ",end="")
        print('\%-30.30s' \% (str(time[task_i])+'ms'),end="")
        print('\%-10.6s' \% str((float(time[task_i])/float(time[nb_task]))*100)+'\%')
    print("===============================================================================")