/**
 * @file % ! FILENAME %
 *
 * @section desc File description
 *
 * Time enforcement data structure generated from application % !CPUNAME %
 * Automatically generated by goil on % !TIMESTAMP %
 * from root OIL file % !OILFILENAME %
 *
 * @section copyright Copyright
 *
 * Trampoline OS
 *
 * Trampoline is copyright (c)
 * CNRS, University of Nantes, Ecole Centrale de Nantes
 * Trampoline is protected by the French intellectual property law.
 *
 * This software is distributed under the GNU Public Licence V2.
 * Check the LICENSE file in the root directory of Trampoline
 *
 */

%

let timerMap := [TIMER mapBy: "NAME"]

# Output variables
# first gather all used variables
let varSet := @! !

if exists OS::STRATEGY::ACTION then
  foreach action in OS::STRATEGY::ACTION do
    if exists action::VALUE_S::BEFORE::VAR then
      foreach var in action::VALUE_S::BEFORE::VAR do
        [!varSet add: var::NAME]
      end foreach
    end if
    if exists action::VALUE_S::AFTER::VAR then
      foreach var in action::VALUE_S::BEFORE::VAR do
        [!varSet add: var::NAME]
      end foreach
    end if
    if exists action::VALUE_S::WHEN then
      foreach when in action::VALUE_S::WHEN do
        if exists when::MARKING then
          foreach mark in when::MARKING do
            if exists mark::VALUE_S::VAR then
              [!varSet add: mark::VALUE_S::VAR]
            end if
          end foreach
        end if
      end foreach
    end if
  end foreach
end if

foreach var in varSet do
%
STATIC VAR(uint32, OS_VAR) % !OS::STRATEGY::NAME %_% !var % = 0;%
end foreach

# Output the TIMERs

%

typedef struct {
  tpl_time_obj          *alarm;
  tpl_tick              time;
  tpl_application_mode  mode;
} TimerType;

FUNC(void, OS_CODE) tpl_start_timer(TimerType *timer)
{
   if (timer->alarm->state != ALARM_ACTIVE) {
     timer->alarm->alarm_time = timer->time;
     timer->alarm->cycle_time = 0;
     tpl_insert_time_obj(alarm);
   }
}
%

if exists TIMER then
  foreach tim in TIMER do

%

TimerType timer_% !tim::NAME % = { timer_%  !tim::NAME %_alarm, % !tim::TIME % };

/*
 * Callback for timer % !tim::NAME %
 */
FUNC(void, OS_CODE) % !tim::NAME %_callback()
{%
    # output the call to the functions implementing the WHEN
    if exists OS::STRATEGY::ACTION then
      foreach action in OS::STRATEGY::ACTION do
        if exists action::VALUE_S::WHEN then
          foreach when in action::VALUE_S::WHEN do
            if exists when::MARKING then
              foreach mark in when::MARKING do
                if mark::VALUE == "TIMER" then
                  if mark::VALUE_S::TIMER == tim::NAME then
          %
  tpl_% !OS::STRATEGY::NAME %_action_% !action::VALUE %_% !action::VALUE_S::ALARM %_when_% !when::NAME  %();%
                  end if
                end if
              end foreach
            end if
          end foreach
        end if
      end foreach
    end if%
}
%
  end foreach
end if

%
FUNC(void, OS_CODE) tpl_init_strategy_timer(
  CONST(tpl_application_mode, AUTOMATIC) mode)
{%

if exists TIMER then
  foreach tim in TIMER do
    if tim::AUTOSTART then
%
  if (mode & (%
  
      foreach am in tim::AUTOSTART_S::APPMODE do
        %(1 << % !am::VALUE %)%
      between % | %
      end foreach
      %)) {
    tpl_start_timers(&timer_% !tim::NAME %);
  }%
    end if
  end foreach
end if

%
}
%

foreach action in exists OS::STRATEGY::ACTION default ( @( ) ) do
  let actionName := action::VALUE
  if    actionName == "ALARMDELAY" then let actionName += "_" + action::VALUE_S::ALARM
  elsif actionName == "EXECDELAY" then let actionName += "_" + action::VALUE_S::TASK
  end if
  foreach when in exists action::VALUE_S::WHEN default ( @( ) ) do
%
FUNC(tpl_bool, OS_CODE) tpl_% !OS::STRATEGY::NAME %_action_% !actionName %_when_% !when::NAME  %()
{
}
%
  end foreach
end foreach