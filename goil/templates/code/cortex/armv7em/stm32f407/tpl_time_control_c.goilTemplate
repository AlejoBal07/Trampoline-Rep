/**
 * @file % ! FILENAME %
 *
 * @section desc File description
 *
 * Time enforcement data structure generated from application % !CPUNAME %
 * Automatically generated by goil on % !TIMESTAMP %
 * from root OIL file % !OILFILENAME %
 *
 * @section copyright Copyright
 *
 * Trampoline OS
 *
 * Trampoline is copyright (c)
 * CNRS, University of Nantes, Ecole Centrale de Nantes
 * Trampoline is protected by the French intellectual property law.
 *
 * This software is distributed under the GNU Public Licence V2.
 * Check the LICENSE file in the root directory of Trampoline
 *
 */

#include "tpl_os_kernel.h"
#include "tpl_app_define.h"
#include "tpl_os_alarm_kernel.h"
#include "tpl_os.h"
#include "tpl_dow.h"

#define OS_START_SEC_VAR_32BIT
#include "tpl_memmap.h"
extern volatile VAR(uint32, OS_VAR) tpl_time_counter;
#define OS_STOP_SEC_VAR_32BIT
#include "tpl_memmap.h"

%

let timerMap := [TIMER mapBy: "NAME"]
let alarmMap := [ALARMS mapBy: "NAME"]


# Gather the references to task in ALARMDELAY or EXECDELAY action marking
let taskSet := @! !
foreach action in exists OS::STRATEGY::ACTION default (@()) do
  foreach when in exists action::VALUE_S::WHEN default (@()) do
    foreach mark in exists when::MARKING default (@()) do
      if mark::VALUE == "TASK" then
        let taskSet += mark::VALUE_S::TASK
      end if
    end foreach
  end foreach
end foreach

# Output extern declarations of task descriptors referenced in ALARMDELAY actions marking
foreach task in taskSet do
%
extern VAR(tpl_proc, OS_VAR) % !task %_task_desc;%
end foreach

# Output variables
# first gather all used variables
let varSet := @! !
let clockSet := @! !

if exists OS::STRATEGY::ACTION then
  foreach action in OS::STRATEGY::ACTION do
    foreach var in exists action::VALUE_S::BEFORE::VAR default (@()) do
      [!varSet add: var::NAME]
    end foreach
    if exists action::VALUE_S::BEFORE::CLOCK then
      [!clockSet add: action::VALUE_S::BEFORE::CLOCK]
    end if
    if exists action::VALUE_S::RUNNING_FIRST::CLOCK then
      [!clockSet add: action::VALUE_S::RUNNING_FIRST::CLOCK]
    end if
    if exists action::VALUE_S::AFTER::VAR then
      foreach var in action::VALUE_S::BEFORE::VAR do
        [!varSet add: var::NAME]
      end foreach
    end if
    if exists action::VALUE_S::WHEN then
      foreach when in action::VALUE_S::WHEN do
        if exists when::MARKING then
          foreach mark in when::MARKING do
            if exists mark::VALUE_S::VAR then
              [!varSet add: mark::VALUE_S::VAR]
            end if
          end foreach
        end if
      end foreach
    end if
  end foreach
end if

foreach var in varSet do
%
STATIC VAR(uint32, OS_VAR) % !OS::STRATEGY::NAME %_var_% !var % = 0;%
end foreach

foreach clock in clockSet do
%
STATIC VAR(uint32, OS_VAR) % !OS::STRATEGY::NAME %_clock_% !clock % = 0;%
end foreach

foreach action in exists OS::STRATEGY::ACTION default ( @( ) ) do
  let actionName := action::VALUE
  if    actionName == "ALARMDELAY" then let actionName += "_" + action::VALUE_S::ALARM
  elsif actionName == "EXECDELAY" then let actionName += "_" + action::VALUE_S::TASK
  end if
  foreach when in exists action::VALUE_S::WHEN default ( @( ) ) do
%
FUNC(tpl_bool, OS_CODE) tpl_% !OS::STRATEGY::NAME %_action_% !actionName %_when_% !when::NAME %();
FUNC(void, OS_CODE) tpl_% !OS::STRATEGY::NAME %_process_% !actionName %_when_% !when::NAME %();%
  end foreach
end foreach


# Output the TIMERs

%

FUNC(tpl_bool, OS_CODE) tpl_start_alarm(
  CONSTP2VAR(tpl_time_obj, AUTOMATIC, OS_APPL_DATA) alarm,
  CONST(tpl_tick, AUTOMATIC) delay)
{
  if (alarm->state == ALARM_SLEEP) {
    CONSTP2VAR(tpl_counter, AUTOMATIC, OS_APPL_DATA) cnt = alarm->stat_part->counter;
    VAR(tpl_tick, AUTOMATIC) date = cnt->current_date + delay;
    if (date > cnt->max_allowed_value)
    {
        date -= (cnt->max_allowed_value + 1);
    }
    alarm->date = date;
    alarm->cycle = 0 ;
    alarm->state = ALARM_ACTIVE;
    tpl_insert_time_obj(alarm);
    return TRUE;
  }
  else {
    return FALSE;
  }
}

FUNC(void, OS_CODE) tpl_stop_alarm(
  CONSTP2VAR(tpl_time_obj, AUTOMATIC, OS_APPL_DATA) alarm)
{
  if (alarm->state == ALARM_ACTIVE)
  {
    tpl_remove_time_obj(alarm);
    alarm->state = ALARM_SLEEP;
  }
}

typedef struct {
  tpl_time_obj                                *alarm;
  tpl_tick                                    time;
  enum { TIMER_OFF, TIMER_ON, TIMER_EXPIRED } state;
} TimerType;

FUNC(void, OS_CODE) tpl_start_timer(TimerType *timer)
{
  CONSTP2VAR(tpl_time_obj, AUTOMATIC, OS_APPL_DATA) alarm = timer->alarm;

  if (tpl_start_alarm(alarm, timer->time)) {
    timer->state = TIMER_ON;
  }
}
%

if exists TIMER then
  foreach tim in TIMER do
%
extern TimerType timer_% !tim::NAME %;

/*
 * Callback for timer % !tim::NAME %
 */
FUNC(void, OS_CODE) timer_% !tim::NAME %_callback()
{
  timer_% !tim::NAME %.state = TIMER_EXPIRED;%
    # Look in the strategy to find cases that use the timer
    foreach action in exists OS::STRATEGY::ACTION default (@()) do
      let actionName := action::VALUE
      if    actionName == "ALARMDELAY" then let actionName += "_" + action::VALUE_S::ALARM
      elsif actionName == "EXECDELAY" then let actionName += "_" + action::VALUE_S::TASK
      end if
      if action::VALUE == "ALARMDELAY" then
        foreach when in action::VALUE_S::WHEN do
          foreach mark in exists when::MARKING default (@()) do
            if mark::VALUE == "TIMER" then
              if mark::VALUE_S::TIMER == tim::NAME & mark::VALUE_S::STATE == "EXPIRED" then%
  if (tpl_% !OS::STRATEGY::NAME %_action_% !actionName %_when_% !when::NAME  %())
  {
    tpl_% !OS::STRATEGY::NAME %_process_% !actionName %_when_% !when::NAME %();
  }%
              end if
            end if
          end foreach
        end foreach
      end if
    end foreach
%
}

/*
 * Timer alarm timer_% !tim::NAME %_alarm
 */
#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

CONST(tpl_callback_action, OS_CONST) timer_% !tim::NAME %_alarm_action = {
  {
    /* action function    */  tpl_action_callback
  },
  /* callback function  */  timer_% !tim::NAME %_callback
};

CONST(tpl_alarm_static, OS_CONST) timer_% !tim::NAME %_alarm_static = {
  {
    /* pointer to counter           */  &SystemCounter_counter_desc,
    /* pointer to the expiration    */  tpl_raise_alarm
#if (WITH_TRACE == YES)
    /* id of the alarm for tracing  */  , -1
#endif
#if WITH_OSAPPLICATION == YES
    /* OS application id            */  , 
#endif
  },
  /* action of the alarm  */  (tpl_action *)&timer_% !tim::NAME %_alarm_action
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

VAR(tpl_time_obj, OS_VAR) timer_% !tim::NAME %_alarm_alarm_desc = {
    /* pointer to the static part   */  (tpl_time_obj_static *)&timer_% !tim::NAME %_alarm_static,
    /* next alarm                   */  NULL,
    /* prev alarm                   */  NULL,
    /* cycle                        */  0,
    /* date                         */  0,
    /* State of the alarm           */  ALARM_SLEEP};

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"


TimerType timer_% !tim::NAME % = { &timer_%  !tim::NAME %_alarm_alarm_desc, % !tim::TIME %, TIMER_OFF };%
  end foreach
end if

#
# output callback of ALARMDELAY actions 
#
foreach action in exists OS::STRATEGY::ACTION default ( @() ) do
  let actionName := action::VALUE
  if    actionName == "ALARMDELAY" then let actionName += "_" + action::VALUE_S::ALARM
  elsif actionName == "EXECDELAY" then let actionName += "_" + action::VALUE_S::TASK
  end if
  if action::VALUE == "ALARMDELAY" then
    #
    # output callback of ALARMDELAY actions 
    #
    if exists action::VALUE_S::ALARM then%
/*
 * Callback for alarm % !action::VALUE_S::ALARM %
 */
FUNC(void, OS_CODE) % !OS::STRATEGY::NAME %_% !action::VALUE_S::ALARM %_callback()
{
  /* BEFORE statement */%
      # BEFORE setup
      if exists action::VALUE_S::BEFORE::CLOCK then%
  % !OS::STRATEGY::NAME %_clock_% !action::VALUE_S::BEFORE::CLOCK % = tpl_time_counter;%
      end if
      foreach var in exists action::VALUE_S::BEFORE::VAR default (@()) do%
  % !OS::STRATEGY::NAME %_var_% !var::NAME % = % !var::VALUE %;%
      end foreach
      # WHEN evaluation and DO execution
      foreach when in exists action::VALUE_S::WHEN default (@()) do
%
  if (tpl_% !OS::STRATEGY::NAME %_action_% !actionName %_when_% !when::NAME  %())
  {
    tpl_% !OS::STRATEGY::NAME %_process_% !actionName %_when_% !when::NAME %();
  }%
      end foreach
%
}

/*
 * Delayed callback for alarm delayed_% !action::VALUE_S::ALARM %
 */
FUNC(void, OS_CODE) delayed_% !action::VALUE_S::ALARM %_callback()
{
  /* for delayed alarms, the action is done here */%
      foreach when in exists action::VALUE_S::WHEN default (@()) do
        if when::DO == "WAITUNTIL" then 
          let act := alarmMap[action::VALUE_S::ALARM]::ACTION
          let act_s := alarmMap[action::VALUE_S::ALARM]::ACTION_S
          if act == "ACTIVATETASK" then %
  tpl_activate_task(% !act_s::TASK %);%
          elsif act == "SETEVENT" then %
  tpl_set_event(% !act_s::TASK %, % !act_s::EVENT %);%
          end if%
  /* AFTER statement */%
          foreach var in exists action::VALUE_S::AFTER::VAR default (@()) do%
  % !OS::STRATEGY::NAME %_var_% !var::NAME % = % !var::VALUE %;%
          end foreach
        end if 
      end foreach
%
}

/*
 * Delayed alarm delayed_% !action::VALUE_S::ALARM %
 */
#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

CONST(tpl_callback_action, OS_CONST) delayed_% !action::VALUE_S::ALARM %_action = {
  {
    /* action function    */  tpl_action_callback
  },
  /* callback function  */  delayed_% !action::VALUE_S::ALARM %_callback
};

CONST(tpl_alarm_static, OS_CONST) delayed_% !action::VALUE_S::ALARM %_static = {
  {
    /* pointer to counter           */  &SystemCounter_counter_desc,
    /* pointer to the expiration    */  tpl_raise_alarm
#if (WITH_TRACE == YES)
    /* id of the alarm for tracing  */  , -1
#endif
#if WITH_OSAPPLICATION == YES
    /* OS application id            */  , 
#endif
  },
  /* action of the alarm  */  (tpl_action *)&delayed_% !action::VALUE_S::ALARM %_action
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

VAR(tpl_time_obj, OS_VAR) delayed_% !action::VALUE_S::ALARM %_alarm_desc = {
    /* pointer to the static part   */  (tpl_time_obj_static *)&delayed_% !action::VALUE_S::ALARM %_static,
    /* next alarm                   */  NULL,
    /* prev alarm                   */  NULL,
    /* cycle                        */  0,
    /* date                         */  0,
    /* State of the alarm           */  ALARM_SLEEP};

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

%
    end if
  elsif action::VALUE == "EXECDELAY" then
    # Output the strategy function called in TerminateTask service wrapper
  end if
end foreach

foreach action in exists OS::STRATEGY::ACTION default ( @( ) ) do
  let actionName := action::VALUE
  if    actionName == "ALARMDELAY" then let actionName += "_" + action::VALUE_S::ALARM
  elsif actionName == "EXECDELAY" then let actionName += "_" + action::VALUE_S::TASK
  end if
  foreach when in exists action::VALUE_S::WHEN default ( @( ) ) do
%
FUNC(tpl_bool, OS_CODE) tpl_% !OS::STRATEGY::NAME %_action_% !actionName %_when_% !when::NAME %()
{
  return %
    if exists when::MARKING then
    %
    (%
      foreach mark in exists when::MARKING default ( @( ) ) do
        if    mark::VALUE == "VAR" then   
          %(% !OS::STRATEGY::NAME %_var_% !mark::VALUE_S::VAR % == % !mark::VALUE_S::VALUE %)% 
        elsif mark::VALUE == "TASK" then
          %(% !mark::VALUE_S::TASK %_task_desc.state % 
          if exists mark::VALUE_S::STATE then %== % !mark::VALUE_S::STATE % || % !mark::VALUE_S::TASK %_task_desc.activate_count > 1)%
          elsif exists mark::VALUE_S::NOTSTATE then %!= % !mark::VALUE_S::NOTSTATE %)%
          end if
        elsif mark::VALUE == "TIMER" then
          %(timer_% !mark::VALUE_S::TIMER %.alarm->state == TIMER_% !mark::VALUE_S::STATE %)%
        end if
      between % &&
     %
      end foreach
      %);%
    else 
      %FALSE;%
    end if
%
}

%
    if action::VALUE == "ALARMDELAY" then
%
FUNC(void, OS_CODE) tpl_% !OS::STRATEGY::NAME %_process_% !actionName %_when_% !when::NAME %()
{
  /* DO = % !when::DO % */%
      if when::DO == "IMMEDIATELY" then
        let act := alarmMap[action::VALUE_S::ALARM]::ACTION
        let act_s := alarmMap[action::VALUE_S::ALARM]::ACTION_S
        if act == "ACTIVATETASK" then %
  tpl_activate_task(% !act_s::TASK %);%
        elsif act == "SETEVENT" then %
  tpl_set_event(% !act_s::TASK %, % !act_s::EVENT %);%
        end if
        foreach var in exists action::VALUE_S::AFTER::VAR default (@()) do%
  % !OS::STRATEGY::NAME %_var_% !var::NAME % = % !var::VALUE %;%
        end foreach
  # kill the delayed alarm if any
  %
  tpl_stop_alarm(&delayed_% !action::VALUE_S::ALARM %_alarm_desc);%
      elsif when::DO == "WAITUNTIL" then
        let clock := OS::STRATEGY::NAME + "_clock_" + when::DO_S::CLOCK
%
  CONST(uint32, AUTOMATIC) elapsed = (tpl_time_counter >= % !clock %) ?
    tpl_time_counter - % !clock % :
    tpl_time_counter + (% !max32bitsUnsignedInt() %UL - % !clock %) + 1;
  if (elapsed < % !when::DO_S::VALUE %)
  {
    tpl_stop_alarm(&delayed_% !action::VALUE_S::ALARM %_alarm_desc);
    tpl_start_alarm(&delayed_% !action::VALUE_S::ALARM %_alarm_desc, % !when::DO_S::VALUE % - elapsed);
  }
  else if (elapsed == % !when::DO_S::VALUE %)
  {%
        let act := alarmMap[action::VALUE_S::ALARM]::ACTION
        let act_s := alarmMap[action::VALUE_S::ALARM]::ACTION_S
        if act == "ACTIVATETASK" then %
    tpl_activate_task(% !act_s::TASK %);%
        elsif act == "SETEVENT" then %
    tpl_set_event(% !act_s::TASK %, % !act_s::EVENT %);%
        end if
        foreach var in exists action::VALUE_S::AFTER::VAR default (@()) do%
    % !OS::STRATEGY::NAME %_var_% !var::NAME % = % !var::VALUE %;%
        end foreach%
  }
  else
  {
    DOW_DO(printf("Strategy error : \%s \%s\\n", __FILE__, __LINE__);)
  }%      
      end if%
}
%
    end if
  end foreach
end foreach

%
/*
 * To be called in StartOS
 */
FUNC(void, OS_CODE) tpl_init_strategy_timer(
  CONST(tpl_application_mode, AUTOMATIC) mode)
{%

if exists TIMER then
  foreach tim in TIMER do
    if tim::AUTOSTART then
%
  if (mode & (%
  
      foreach am in tim::AUTOSTART_S::APPMODE do
        %(1 << % !am::VALUE %)%
      between % | %
      end foreach
      %))
  {
    tpl_start_timer(&timer_% !tim::NAME %);
  }%
    end if
  end foreach
end if

%
}

/*
 * Function to be called when a task is activated and goes to state
 * READY_AND_NEW
 */
FUNC(void, OS_CODE) tpl_task_state_ready_and_new(CONST(tpl_task_id, AUTOMATIC) task_id)
{%
foreach task in taskSet
before %
  if %
do %(task_id == % !task %)
  {%
  foreach action in exists OS::STRATEGY::ACTION default (@()) do
    let actionName := action::VALUE
    if    actionName == "ALARMDELAY" then let actionName += "_" + action::VALUE_S::ALARM
    elsif actionName == "EXECDELAY" then let actionName += "_" + action::VALUE_S::TASK
    end if
    if action::VALUE == "ALARMDELAY" then
      foreach when in exists action::VALUE_S::WHEN default (@()) do
        foreach mark in exists when::MARKING default (@()) do
          if mark::VALUE == "TASK" then
            if mark::VALUE_S::TASK == task & mark::VALUE_S::STATE == "READY_AND_NEW" then
%
    if (tpl_% !OS::STRATEGY::NAME %_action_% !actionName %_when_% !when::NAME  %())
    {
      tpl_% !OS::STRATEGY::NAME %_process_% !actionName %_when_% !when::NAME %();
    }%
            end if
          end if
        end foreach
      end foreach
    end if
  end foreach%
  }%
between%
  else if %
end foreach
%
}


/*
 * Function to be called when a task goes to state RUNNING
 */
FUNC(void, OS_CODE) tpl_task_state_running(CONST(tpl_task_id, AUTOMATIC) task_id)
{%
foreach task in taskSet
before %
  if %
do %(task_id == % !task %)
  {%
  foreach action in exists OS::STRATEGY::ACTION default (@()) do
    let actionName := action::VALUE
    if    actionName == "ALARMDELAY" then let actionName += "_" + action::VALUE_S::ALARM
    elsif actionName == "EXECDELAY" then let actionName += "_" + action::VALUE_S::TASK
    end if
    if action::VALUE == "ALARMDELAY" then
      foreach when in exists action::VALUE_S::WHEN default (@()) do
        foreach mark in exists when::MARKING default (@()) do
          if mark::VALUE == "TASK" then
            if mark::VALUE_S::TASK == task & mark::VALUE_S::STATE == "RUNNING" then
%
    if (tpl_% !OS::STRATEGY::NAME %_action_% !actionName %_when_% !when::NAME  %())
    {
      tpl_% !OS::STRATEGY::NAME %_process_% !actionName %_when_% !when::NAME %();
    }%
            end if
          end if
        end foreach
      end foreach
    end if
  end foreach%
  }%
between%
  else if %
end foreach
%
}


/*
 * Function to be called when a task goes to state SUSPENDED
 */
FUNC(void, OS_CODE) tpl_task_state_suspended(CONST(tpl_task_id, AUTOMATIC) task_id)
{%
foreach task in taskSet
before %
  if %
do %(task_id == % !task %)
  {%
  foreach action in exists OS::STRATEGY::ACTION default (@()) do
    let actionName := action::VALUE
    if    actionName == "ALARMDELAY" then let actionName += "_" + action::VALUE_S::ALARM
    elsif actionName == "EXECDELAY" then let actionName += "_" + action::VALUE_S::TASK
    end if
    if action::VALUE == "ALARMDELAY" then
      foreach when in exists action::VALUE_S::WHEN default (@()) do
        foreach mark in exists when::MARKING default (@()) do
          if mark::VALUE == "TASK" then
            if mark::VALUE_S::TASK == task & mark::VALUE_S::STATE == "SUSPENDED" then
%
    if (tpl_% !OS::STRATEGY::NAME %_action_% !actionName %_when_% !when::NAME  %())
    {
      tpl_% !OS::STRATEGY::NAME %_process_% !actionName %_when_% !when::NAME %();
    }%
            end if
          end if
        end foreach
      end foreach
    end if
  end foreach%
  }%
between%
  else if %
end foreach
%
}

/*
 * Function to be called in the TerminateTask wrapper
 */
FUNC(void, OS_CODE) tpl_delay_task_if_needed()
{%
foreach action in exists OS::STRATEGY::ACTION default (@()) do
  if action::VALUE == "EXECDELAY" then %
  if (tpl_kern.running_id == % !action::VALUE_S::TASK %)
  {
    while (1) {%
    let actionName := action::VALUE + "_" + action::VALUE_S::TASK
    # Get action for DO == IMMEDIATELY
    let whenImmediately := @()
    let whenUntil := @()
    foreach when in exists action::VALUE_S::WHEN default (@()) do
      if when::DO == "IMMEDIATELY" then
        let whenImmediately += when
      elsif when::DO == "WAITUNTIL" then
        let whenUntil += when
      end if
    end foreach
    foreach when in whenImmediately
    before%
      if (%
    do
      %tpl_% !OS::STRATEGY::NAME %_action_% !actionName %_when_% !when::NAME  %()%
    between % ||
          %
    after %)
      {
        break;
      }%
    end foreach
    foreach when in whenUntil do
      let clock := OS::STRATEGY::NAME + "_clock_" + when::DO_S::CLOCK
%
      if (tpl_% !OS::STRATEGY::NAME %_action_% !actionName %_when_% !when::NAME  %())
      {
        CONST(uint32, AUTOMATIC) elapsed = (tpl_time_counter >= % !clock %) ?
          tpl_time_counter - % !clock % :
          tpl_time_counter + (% !max32bitsUnsignedInt() %UL - % !clock %) + 1;
        if (elapsed >= % !when::DO_S::VALUE %)
        {
          break;
        }
      }%
    end foreach%
    }
  }%
  end if
end foreach
%
}

/*
 * Function to be called when a task goes
 * in the RUNNING state for the first time.
 */
FUNC(void, OS_CODE) tpl_task_state_running_first_time(CONST(tpl_task_id, AUTOMATIC) task_id)
{%
let clockInitActions := @()
foreach action in exists OS::STRATEGY::ACTION default (@()) do
  if action::VALUE == "EXECDELAY" then
    let clockInitActions += action
  end if
end foreach
foreach action in clockInitActions 
  before %
  if (task_id == %
  do 
    !action::VALUE_S::TASK %)
  {
    %
    ! OS::STRATEGY::NAME + "_clock_" + action::VALUE_S::RUNNING_FIRST::CLOCK% = tpl_time_counter;    
  }%
  between %
  else if (task_id == %
end foreach%
}

