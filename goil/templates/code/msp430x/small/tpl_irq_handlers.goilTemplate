%
#------------------------------------------------------------------------------*
# Target specific initializations
# build IRQ handlers
#

let objForIRQ := @[ ]

# Map ISR into objForIRQ
foreach isr in ISR do
  let key := isr::SOURCE
  if not exists objForIRQ[key] then
    let isr::KIND := "ISR"
    let objForIRQ[key] := isr
  else
    error isr::SOURCE : "Interrupt source already used"
  end if
end foreach


# Map COUNTER into objForIRQ
foreach cnt in COUNTER do
  let key := cnt::SOURCE
  if not exists objForIRQ[key] then
    let cnt::KIND := "COUNTER"
    let objForIRQ[key] := cnt
  else
    error cnt::SOURCE : "Interrupt source already used"
  end if
end foreach

# Build the list of IRQ handlers to call
let irqStageList := @( )

# Build a list of virtual objects (sources of interrupts) each of them holding values :
# handlerSource, handlerName, handlerAck, generatePrimaryIrq
foreach obj in objForIRQ do
  let anIrq := @{ }
  let anIrq::handlerSource := KEY
  let anIrq::handlerName := obj::NAME
  let anIrq::generatePrimaryIrq := true
  let anIrq::isACounter := false
  let anIrq::identifier := -1
  if obj::KIND == "ISR" then
    if obj::CATEGORY == 1 then
      let anIrq::generatePrimaryIrq := false
      let anIrq::function := obj::NAME + "_function"
    else # category 2
      let anIrq::function := obj::NAME + "_function"
      # get the id 
      foreach proc in PROCESSES do
        if proc::NAME == anIrq::handlerName then
          let anIrq::identifier := INDEX
        end if
      end foreach
    end if
  elsif obj::KIND == "COUNTER" then
    let anIrq::function := "tpl_tick_" + KEY
    let anIrq::isACounter := true
  end if
  let irqStageList += anIrq 
end foreach

#------------------------------------------------------------------------------*
%/**
 * @file tpl_irq_handlers.% !EXTENSIONIRQHANDLERS %
 *
 * @section descr File description
 *
 * Generated from application % !CPUNAME %
 * Automatically generated by goil on % !TIMESTAMP %
 * from root OIL file % !OILFILENAME %
 *
 * @section infos File informations
 *
 */

#include "tpl_assembler.h"
#include "tpl_asm_definitions.h"
#include "tpl_kern_stack.h"

.extern tpl_kern
.extern tpl_kern_stack

#define OS_START_SEC_CODE
#include "tpl_as_memmap.h"

/*=============================================================================
 * After en interrupt on a CPUX, the process stack is as follow
 *
 *    +----+--------------+
 *  0 | PC |      SR      | + 0
 *    +----+--------------+
 *  1 |         PC        | + 2
 *    +-------------------+
 *
 */
%

foreach irq in irqStageList
  before
%
%
  do
    let handlerSource := irq::handlerSource
    let handlerName := irq::handlerName
    let handlerIRQ := irq::function
    let handlerIsACounter := irq::isACounter
    let isr2Id := irq::identifier
    if irq::generatePrimaryIrq then
%
/*=============================================================================
 * IRQ Handler for IRQ % !handlerName % with source vector % !handlerSource %
 ******************************************************************************/
%
      template primary_irq_handler_body
    else
      template direct_irq_handler_body
    end if
  after
%
%
end foreach

%
#define OS_STOP_SEC_CODE
#include "tpl_as_memmap.h"

/* End of file tpl_irq_handlers.% !EXTENSIONIRQHANDLERS % */
