/* Interrupt table vector */
#include "tpl_compiler.h"
#include "tpl_os.h"
#include "tpl_os_interrupt_kernel.h"
#include "tpl_machine.h"
%

#------------------------------------------------------------------------------*
# Target specific initializations
# build the maps for IRQ
#
# On MSP430 only one Counter or ISR may be connected to an interrupt vector
#
let objForIRQ := @[ ]

# Map ISR into objForIRQ
foreach isr in ISR do
  let key := isr::SOURCE
  if not exists objForIRQ[key] then
    let isr::KIND := "ISR"
    let objForIRQ[key] := isr
  else
    error isr::SOURCE : "Interrupt source already used"
  end if
end foreach


# Map COUNTER into objForIRQ
foreach cnt in COUNTER do
  let key := cnt::SOURCE
  if not exists objForIRQ[key] then
    let cnt::KIND := "COUNTER"
    let objForIRQ[key] := cnt
  else
    error cnt::SOURCE : "Interrupt source already used"
  end if
end foreach


# Map ISR2s to an index for tpl_isr_stat_table
let index := 0
let mapOfISR2 := @[ ]
foreach isr in ISRS2 do
  let key := isr::SOURCE
  let isr::INDEX := index
  let mapOfISR2[key] := isr
  let index := index + 1
end foreach

#------------------------------------------------------------------------------*
%
/* External handlers */
%
display INTERRUPT
foreach int in INTERRUPT do
  # Reach the declared interrupt in INTERRUPT 
  if exists objForIRQ[int::NAME] then
    let handlerIsEmpty := false
    foreach obj in objForIRQ do
      if KEY == int::NAME then
        # We have found an interrupts to call
        # check whether we have an ISR or a COUNTER
        if obj::KIND == "ISR" then
          if obj::CATEGORY == 1 then %
extern FUNC(void, OS_CODE) % !KEY %_Handler(P2CONST(void, OS_APPL_DATA, AUTOMATIC));%
          else
            if obj::CATEGORY == 2 then %
extern FUNC(void, OS_CODE) tpl_primary_irq_handler_% !KEY %(P2CONST(void, OS_APPL_DATA, AUTOMATIC));%
            else %
#error unknown CATEGORY % !obj::CATEGORY
            end if
          end if
        else # this is a counter
%
extern FUNC(void, OS_CODE) tpl_primary_irq_handler_% !KEY %(P2CONST(void, OS_APPL_DATA, AUTOMATIC));%
        end if
      end if
    end foreach
  end if
end foreach
%

/* Interrupt table vector */
%
loop ENTRY
  from INTERRUPT_VECTOR_SPEC::ORIGIN
  to INTERRUPT_VECTOR_SPEC::ORIGIN + (INTERRUPT_VECTOR_SPEC::SIZE - 1) * 2
  step 2
  before
%
__attribute__ ((section(".isr_vector"))) CONST(tpl_it_handler, AUTOMATIC) tpl_it_vectors[% !INTERRUPT_VECTOR_SPEC::SIZE %] = {
%
  do
    foreach int in INTERRUPT do
      if int::ADDRESS == ENTRY then
      end if
    end foreach
end loop
#    let handlerIsEmpty := true
#    foreach int in INTERRUPT do
#      # Reach the declared interrupt in INTERRUPT 
#      if ENTRY == int::VECT then
#        if exists objForIRQ[int::NAME] then
#          let handlerIsEmpty := false
#          foreach objList in objForIRQ do
#            if KEY == int::NAME then
#              # We have found the list of interrupts to call
#              # How many ISR do we have for this SOURCE ?
#              if [objList length] == 1 then
#                let obj := [objList first]
#                # check whether we have an ISR or a COUNTER
#                if obj::KIND == "ISR" then
#                  if obj::CATEGORY == 1 then
#                    %(tpl_it_handler)% !KEY %_Handler%
#                  else
#                    if obj::CATEGORY == 2 then
#                      %(tpl_it_handler)tpl_primary_irq_handler_% !KEY
#                    else
#                      %#error unknown CATEGORY % !obj::CATEGORY
#                    end if
#                  end if
#                else # this is a counter
#                  %(tpl_it_handler)tpl_primary_irq_handler_% !KEY
#                end if
#              else
#                # check if we have only ISR1
#                let onlyISR1 := true
#                foreach obj in objList do
#                  if ( (obj::KIND == "ISR" & obj::CATEGORY == 2) |
#                       (obj::KIND == "COUNTER") ) then
#                    let onlyISR1 := false
#                  end if
#                end foreach
#                if onlyISR1 == true then
#                  %(tpl_it_handler)% !KEY %_Handler%
#                else
#                  %(tpl_it_handler)tpl_primary_irq_handler_% !KEY
#                end if
#              end if
#            end if
#          end foreach
#        else
#          if int::EXCEPTION then
#            let handlerIsEmpty := false
#            if int::VECTOR_TYPE == "HANDLER" then
#              if int::VECTOR_TYPE_S::NAME != "NONE" then
#                %(tpl_it_handler)% !int::VECTOR_TYPE_S::NAME
#              else
#                %(tpl_it_handler)tpl_null_it%
#              end if
#            else
#              if int::VECTOR_TYPE == "REFERENCE" then
#                %(tpl_it_handler)% !int::VECTOR_TYPE_S::NAME
#              end if
#            end if
#          end if
#        end if
#      end if
#    end foreach
#    if handlerIsEmpty then
#      %(tpl_it_handler)tpl_null_it%
#    end if
##    % }%
#  between %,
#%
#  after
#%
#};
#%
#end loop
%
%


# vim:ft=goil_templates
