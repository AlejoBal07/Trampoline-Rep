/**
 * @file % !FILENAME %
 *
 * @section desc File description
 *
 * OS data structure generated from application % !CPUNAME %
 * Automatically generated by goil on % !TIMESTAMP %
 * from root OIL file % !OILFILENAME%
 *
 * @section copyright Copyright
 *
 * Trampoline OS
 *
 * Trampoline is copyright (c) IRCCyN 2005-2007
 * Trampoline is protected by the French intellectual property law.
 *
 * This software is distributed under the Lesser GNU Public Licence
 *
 * @section infos File informations
 *
 * $Date$
 * $Rev$
 * $Author$
 * $URL$
 */
%
if OS::SEQUENCING then 
%
#include <stdbool.h>
#include <stdint.h>

#include "tpl_os_internal_types.h"
#include "tpl_sequence_kernel.h"
#include "tpl_os_definitions.h"


#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
%

#------------------------------------------------------------------------------*
let listTask := @[]
foreach proc in PROCESSES do
  if proc::KIND == "Task" then
   let key := proc::NAME
   let listTask[key] := INDEX
  end if
end foreach

let listState := @[]
foreach state in STATE do
  let key := state::NAME
  let listState[key] := state::VALUE
end foreach

let listAlarm := @[]
foreach al in ALARM do
  let key := al::NAME
  let listAlarm[key] := INDEX
end foreach
#------------------------------------------------------------------------------*

foreach transition in TRANSITION do
  if exists transition::TASK then
    let task_count := [transition::TASK length]
    foreach task in transition::TASK 
    before 
%
const uint8 % !transition::NAME%_task[% !task_count%] = {
%
    do
!listTask[task::VALUE]  % /* id of task */%
    between
    %, 
%
    after 
    %
};%
    end foreach
  end if
  
  if exists transition::ALARM then
   let alarm_count := [transition::ALARM length]
   foreach alarm in transition::ALARM
   before
%

const tpl_sequence_alarm % !transition::NAME%_alarm[% !alarm_count%] = {
%
  do
  foreach al in ALARM do
   if alarm::VALUE == al::NAME then
%{%!listAlarm[alarm::VALUE]   %    /* id alarm */
,%!al::ALARMTIME          %    /* alarm time */
,%!al::CYCLETIME          %    /* cycle time */
,%!al::NB_ACTIVATION      %    /* number of acitvation of alarm */
}%
   end if 
  end foreach
  between
  %,
%
  after
  %
};
%
   end foreach
  end if
end foreach

foreach transition in TRANSITION 
  do
  %
VAR(tpl_sequence, OS_VAR) sequence_% !transition::NAME% = {
  .energy = % !transition::ENERGY%
, .next_state = % !listState[transition::TO_STATE]%
, .current_state = % !listState[transition::FROM_STATE]%
%
if exists transition::TASK then
%, .nb_task = % ![transition::TASK length]%     
, .seqTaskTab = % !transition::NAME%_task
%
else
%, .nb_task = 0     
, .seqTaskTab = NULL
%
end if
if exists transition::ALARM then
%, .nb_alarm = % ![transition::ALARM length]%
, .seqAlarmTab = % !transition::NAME%_alarm
%
else
%, .nb_alarm = 0
, .seqAlarmTab = NULL
%
end if

let mask := 255
if exists transition::TASK then
foreach task in transition::TASK do
let mask := mask -(1<<listTask[task::VALUE])
end foreach
end if
if exists transition::ALARM then
foreach alarm in transition::ALARM do
let mask := mask -(1<<(listAlarm[alarm::VALUE] + [listTask length]))
end foreach
end if
%, .mask_seq_terminate = %![mask hexString]%
, .vec_seq_terminate = 0xFF
};
%
end foreach
#foreach transition in TRANSITION do
#    %
#VAR(tpl_sequence, OS_VAR) sequence_% !transition::NAME% = {
#  .energy = % ! transition::ENERGY%
#, .next_state = % !listState[transition::TO_STATE]%
#, .current_state = % !listState[transition::FROM_STATE]%
#, .nb_task = % !task_count%
#%
#let mask := 255
#foreach task in transition::TASK do
# let mask := mask - (1<<listTask[task::VALUE])
#end foreach
#%, .mask_seq_terminate = % ![mask hexString]%
#, .vec_seq_terminate = 0xFF
#, .seqTaskTab = % !transition::NAME%_task
#};
#
#%
#  end if
#end foreach
%
#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"


#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

CONSTP2VAR(tpl_sequence, AUTOMATIC, OS_APPL_DATA)
tpl_sequence_table[TRANSITION_COUNT] = {
%
foreach transition in TRANSITION do
  %  &sequence_% !transition::NAME%,
%
end foreach
%
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/**
 * @internal
 *
 * tpl_kern_seq gather informations on the current sequence and
 * the previous one
 */
VAR(tpl_kern_seq_state, OS_VAR) tpl_kern_seq =
{
  NULL,                      /* no running sequence   */
  NULL,                      /* no elected sequence   */
  TRUE,                      /* schedule needed at start */
  0,                         /* current state is STATE with value 0 */
};

#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

P2VAR(tpl_sequence, TYPEDEF, OS_VAR) tpl_ready_sequence_list[2];

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
%
end if