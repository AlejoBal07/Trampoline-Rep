/**
 * @file % !FILENAME %
 *
 * @section desc File description
 *
 * OS data structure generated from application % !CPUNAME %
 * Automatically generated by goil on % !TIMESTAMP %
 * from root OIL file % !OILFILENAME%
 *
 * @section copyright Copyright
 *
 * Trampoline OS
 *
 * Trampoline is copyright (c) IRCCyN 2005-2007
 * Trampoline is protected by the French intellectual property law.
 *
 * This software is distributed under the Lesser GNU Public Licence
 *
 * @section infos File informations
 *
 * $Date$
 * $Rev$
 * $Author$
 * $URL$
 */
%
if OS::SEQUENCING then 
%
#include <stdbool.h>
#include <stdint.h>

#include "tpl_os_internal_types.h"
#include "tpl_sequence_kernel.h"
#include "tpl_os_definitions.h"


#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
%

#------------------------------------------------------------------------------*
let listTask := @[]
foreach proc in PROCESSES do
  if proc::KIND == "Task" then
   let key := proc::NAME
   let listTask[key] := INDEX
  end if
end foreach

let listState := @[]
foreach state in STATE do
  let key := state::NAME
  let listState[key] := state::VALUE
end foreach

let listAlarm := @[]
foreach al in ALARM do
  let key := al::NAME
  let listAlarm[key] := INDEX
end foreach
#------------------------------------------------------------------------------*

foreach transition in TRANSITION do
  if exists transition::TASK then
    let task_count := [transition::TASK length]
    foreach task in transition::TASK 
    before 
%const uint8 % !transition::NAME%_task[% !task_count%] = {
%
    do
!listTask[task::VALUE]
    between
    %, 
%
    after 
    %
};%
    end foreach
#  if exists transition::TASK then
#    let task_count := [transition::TASK length]
#    display task_count
#  end if
#  if exists transition::ALARM then
#    let al_count := [transition::ALARM length]
#    display al_count
#  end if
    %
VAR(tpl_sequence, OS_VAR) sequence_% !transition::NAME% = {
  .energy = % ! transition::ENERGY%
, .next_state = % !listState[transition::TO_STATE]%
, .current_state = % !listState[transition::FROM_STATE]%
, .nb_task = % !task_count%
%
let mask := 255
foreach task in transition::TASK do
 let mask := mask - (1<<listTask[task::VALUE])
end foreach
%, .mask_seq_terminate = % ![mask hexString]%
, .vec_seq_terminate = 0xFF
, .seqTaskTab = % !transition::NAME%_task
};

%
  end if
end foreach
%
#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"


#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

CONSTP2VAR(tpl_sequence, AUTOMATIC, OS_APPL_DATA)
tpl_sequence_table[TRANSITION_COUNT] = {
%
foreach transition in TRANSITION do
  %  &sequence_% !transition::NAME%,
%
end foreach
%
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/**
 * @internal
 *
 * tpl_kern_seq gather informations on the current sequence and
 * the previous one
 */
VAR(tpl_kern_seq_state, OS_VAR) tpl_kern_seq =
{
  NULL,                      /* no running sequence   */
  NULL,                      /* no elected sequence   */
  TRUE,                      /* schedule needed at start */
  0,                         /* current state is STATE with value 0 */
};

#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

P2VAR(tpl_sequence, TYPEDEF, OS_VAR) tpl_ready_sequence_list[2];

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
%
end if